// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: flyteidl/core/resource.proto

#ifndef PROTOBUF_INCLUDED_flyteidl_2fcore_2fresource_2eproto
#define PROTOBUF_INCLUDED_flyteidl_2fcore_2fresource_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_flyteidl_2fcore_2fresource_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_flyteidl_2fcore_2fresource_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[7]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_flyteidl_2fcore_2fresource_2eproto();
namespace flyteidl {
namespace core {
class ClusterSpec;
class ClusterSpecDefaultTypeInternal;
extern ClusterSpecDefaultTypeInternal _ClusterSpec_default_instance_;
class HeadGroupSpec;
class HeadGroupSpecDefaultTypeInternal;
extern HeadGroupSpecDefaultTypeInternal _HeadGroupSpec_default_instance_;
class HeadGroupSpec_RayStartParamsEntry_DoNotUse;
class HeadGroupSpec_RayStartParamsEntry_DoNotUseDefaultTypeInternal;
extern HeadGroupSpec_RayStartParamsEntry_DoNotUseDefaultTypeInternal _HeadGroupSpec_RayStartParamsEntry_DoNotUse_default_instance_;
class RayCluster;
class RayClusterDefaultTypeInternal;
extern RayClusterDefaultTypeInternal _RayCluster_default_instance_;
class Resource;
class ResourceDefaultTypeInternal;
extern ResourceDefaultTypeInternal _Resource_default_instance_;
class WorkerGroupSpec;
class WorkerGroupSpecDefaultTypeInternal;
extern WorkerGroupSpecDefaultTypeInternal _WorkerGroupSpec_default_instance_;
class WorkerGroupSpec_RayStartParamsEntry_DoNotUse;
class WorkerGroupSpec_RayStartParamsEntry_DoNotUseDefaultTypeInternal;
extern WorkerGroupSpec_RayStartParamsEntry_DoNotUseDefaultTypeInternal _WorkerGroupSpec_RayStartParamsEntry_DoNotUse_default_instance_;
}  // namespace core
}  // namespace flyteidl
namespace google {
namespace protobuf {
template<> ::flyteidl::core::ClusterSpec* Arena::CreateMaybeMessage<::flyteidl::core::ClusterSpec>(Arena*);
template<> ::flyteidl::core::HeadGroupSpec* Arena::CreateMaybeMessage<::flyteidl::core::HeadGroupSpec>(Arena*);
template<> ::flyteidl::core::HeadGroupSpec_RayStartParamsEntry_DoNotUse* Arena::CreateMaybeMessage<::flyteidl::core::HeadGroupSpec_RayStartParamsEntry_DoNotUse>(Arena*);
template<> ::flyteidl::core::RayCluster* Arena::CreateMaybeMessage<::flyteidl::core::RayCluster>(Arena*);
template<> ::flyteidl::core::Resource* Arena::CreateMaybeMessage<::flyteidl::core::Resource>(Arena*);
template<> ::flyteidl::core::WorkerGroupSpec* Arena::CreateMaybeMessage<::flyteidl::core::WorkerGroupSpec>(Arena*);
template<> ::flyteidl::core::WorkerGroupSpec_RayStartParamsEntry_DoNotUse* Arena::CreateMaybeMessage<::flyteidl::core::WorkerGroupSpec_RayStartParamsEntry_DoNotUse>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace flyteidl {
namespace core {

enum RayCluster_Environment {
  RayCluster_Environment_DEV = 0,
  RayCluster_Environment_TESTING = 1,
  RayCluster_Environment_STAGING = 2,
  RayCluster_Environment_PRODUCTION = 3,
  RayCluster_Environment_RayCluster_Environment_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  RayCluster_Environment_RayCluster_Environment_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool RayCluster_Environment_IsValid(int value);
const RayCluster_Environment RayCluster_Environment_Environment_MIN = RayCluster_Environment_DEV;
const RayCluster_Environment RayCluster_Environment_Environment_MAX = RayCluster_Environment_PRODUCTION;
const int RayCluster_Environment_Environment_ARRAYSIZE = RayCluster_Environment_Environment_MAX + 1;

const ::google::protobuf::EnumDescriptor* RayCluster_Environment_descriptor();
inline const ::std::string& RayCluster_Environment_Name(RayCluster_Environment value) {
  return ::google::protobuf::internal::NameOfEnum(
    RayCluster_Environment_descriptor(), value);
}
inline bool RayCluster_Environment_Parse(
    const ::std::string& name, RayCluster_Environment* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RayCluster_Environment>(
    RayCluster_Environment_descriptor(), name, value);
}
// ===================================================================

class Resource final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.Resource) */ {
 public:
  Resource();
  virtual ~Resource();

  Resource(const Resource& from);

  inline Resource& operator=(const Resource& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Resource(Resource&& from) noexcept
    : Resource() {
    *this = ::std::move(from);
  }

  inline Resource& operator=(Resource&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Resource& default_instance();

  enum ValueCase {
    kRay = 1,
    VALUE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Resource* internal_default_instance() {
    return reinterpret_cast<const Resource*>(
               &_Resource_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Resource* other);
  friend void swap(Resource& a, Resource& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Resource* New() const final {
    return CreateMaybeMessage<Resource>(nullptr);
  }

  Resource* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Resource>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Resource& from);
  void MergeFrom(const Resource& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Resource* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .flyteidl.core.RayCluster ray = 1;
  bool has_ray() const;
  void clear_ray();
  static const int kRayFieldNumber = 1;
  const ::flyteidl::core::RayCluster& ray() const;
  ::flyteidl::core::RayCluster* release_ray();
  ::flyteidl::core::RayCluster* mutable_ray();
  void set_allocated_ray(::flyteidl::core::RayCluster* ray);

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:flyteidl.core.Resource)
 private:
  class HasBitSetters;
  void set_has_ray();

  inline bool has_value() const;
  inline void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union ValueUnion {
    ValueUnion() {}
    ::flyteidl::core::RayCluster* ray_;
  } value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_flyteidl_2fcore_2fresource_2eproto;
};
// -------------------------------------------------------------------

class RayCluster final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.RayCluster) */ {
 public:
  RayCluster();
  virtual ~RayCluster();

  RayCluster(const RayCluster& from);

  inline RayCluster& operator=(const RayCluster& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RayCluster(RayCluster&& from) noexcept
    : RayCluster() {
    *this = ::std::move(from);
  }

  inline RayCluster& operator=(RayCluster&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RayCluster& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RayCluster* internal_default_instance() {
    return reinterpret_cast<const RayCluster*>(
               &_RayCluster_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(RayCluster* other);
  friend void swap(RayCluster& a, RayCluster& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RayCluster* New() const final {
    return CreateMaybeMessage<RayCluster>(nullptr);
  }

  RayCluster* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RayCluster>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RayCluster& from);
  void MergeFrom(const RayCluster& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RayCluster* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RayCluster_Environment Environment;
  static const Environment DEV =
    RayCluster_Environment_DEV;
  static const Environment TESTING =
    RayCluster_Environment_TESTING;
  static const Environment STAGING =
    RayCluster_Environment_STAGING;
  static const Environment PRODUCTION =
    RayCluster_Environment_PRODUCTION;
  static inline bool Environment_IsValid(int value) {
    return RayCluster_Environment_IsValid(value);
  }
  static const Environment Environment_MIN =
    RayCluster_Environment_Environment_MIN;
  static const Environment Environment_MAX =
    RayCluster_Environment_Environment_MAX;
  static const int Environment_ARRAYSIZE =
    RayCluster_Environment_Environment_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Environment_descriptor() {
    return RayCluster_Environment_descriptor();
  }
  static inline const ::std::string& Environment_Name(Environment value) {
    return RayCluster_Environment_Name(value);
  }
  static inline bool Environment_Parse(const ::std::string& name,
      Environment* value) {
    return RayCluster_Environment_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string namespace = 2;
  void clear_namespace_();
  static const int kNamespaceFieldNumber = 2;
  const ::std::string& namespace_() const;
  void set_namespace_(const ::std::string& value);
  #if LANG_CXX11
  void set_namespace_(::std::string&& value);
  #endif
  void set_namespace_(const char* value);
  void set_namespace_(const char* value, size_t size);
  ::std::string* mutable_namespace_();
  ::std::string* release_namespace_();
  void set_allocated_namespace_(::std::string* namespace_);

  // string user = 3;
  void clear_user();
  static const int kUserFieldNumber = 3;
  const ::std::string& user() const;
  void set_user(const ::std::string& value);
  #if LANG_CXX11
  void set_user(::std::string&& value);
  #endif
  void set_user(const char* value);
  void set_user(const char* value, size_t size);
  ::std::string* mutable_user();
  ::std::string* release_user();
  void set_allocated_user(::std::string* user);

  // string version = 4;
  void clear_version();
  static const int kVersionFieldNumber = 4;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // string cluster_state = 9;
  void clear_cluster_state();
  static const int kClusterStateFieldNumber = 9;
  const ::std::string& cluster_state() const;
  void set_cluster_state(const ::std::string& value);
  #if LANG_CXX11
  void set_cluster_state(::std::string&& value);
  #endif
  void set_cluster_state(const char* value);
  void set_cluster_state(const char* value, size_t size);
  ::std::string* mutable_cluster_state();
  ::std::string* release_cluster_state();
  void set_allocated_cluster_state(::std::string* cluster_state);

  // .flyteidl.core.ClusterSpec cluster_spec = 6;
  bool has_cluster_spec() const;
  void clear_cluster_spec();
  static const int kClusterSpecFieldNumber = 6;
  const ::flyteidl::core::ClusterSpec& cluster_spec() const;
  ::flyteidl::core::ClusterSpec* release_cluster_spec();
  ::flyteidl::core::ClusterSpec* mutable_cluster_spec();
  void set_allocated_cluster_spec(::flyteidl::core::ClusterSpec* cluster_spec);

  // .google.protobuf.Timestamp created_at = 7;
  bool has_created_at() const;
  void clear_created_at();
  static const int kCreatedAtFieldNumber = 7;
  const ::google::protobuf::Timestamp& created_at() const;
  ::google::protobuf::Timestamp* release_created_at();
  ::google::protobuf::Timestamp* mutable_created_at();
  void set_allocated_created_at(::google::protobuf::Timestamp* created_at);

  // .google.protobuf.Timestamp deleted_at = 8;
  bool has_deleted_at() const;
  void clear_deleted_at();
  static const int kDeletedAtFieldNumber = 8;
  const ::google::protobuf::Timestamp& deleted_at() const;
  ::google::protobuf::Timestamp* release_deleted_at();
  ::google::protobuf::Timestamp* mutable_deleted_at();
  void set_allocated_deleted_at(::google::protobuf::Timestamp* deleted_at);

  // .flyteidl.core.RayCluster.Environment environment = 5;
  void clear_environment();
  static const int kEnvironmentFieldNumber = 5;
  ::flyteidl::core::RayCluster_Environment environment() const;
  void set_environment(::flyteidl::core::RayCluster_Environment value);

  // @@protoc_insertion_point(class_scope:flyteidl.core.RayCluster)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr namespace__;
  ::google::protobuf::internal::ArenaStringPtr user_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr cluster_state_;
  ::flyteidl::core::ClusterSpec* cluster_spec_;
  ::google::protobuf::Timestamp* created_at_;
  ::google::protobuf::Timestamp* deleted_at_;
  int environment_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2fresource_2eproto;
};
// -------------------------------------------------------------------

class ClusterSpec final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.ClusterSpec) */ {
 public:
  ClusterSpec();
  virtual ~ClusterSpec();

  ClusterSpec(const ClusterSpec& from);

  inline ClusterSpec& operator=(const ClusterSpec& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClusterSpec(ClusterSpec&& from) noexcept
    : ClusterSpec() {
    *this = ::std::move(from);
  }

  inline ClusterSpec& operator=(ClusterSpec&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ClusterSpec& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClusterSpec* internal_default_instance() {
    return reinterpret_cast<const ClusterSpec*>(
               &_ClusterSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(ClusterSpec* other);
  friend void swap(ClusterSpec& a, ClusterSpec& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClusterSpec* New() const final {
    return CreateMaybeMessage<ClusterSpec>(nullptr);
  }

  ClusterSpec* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClusterSpec>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClusterSpec& from);
  void MergeFrom(const ClusterSpec& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClusterSpec* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .flyteidl.core.WorkerGroupSpec worker_group_sepc = 2;
  int worker_group_sepc_size() const;
  void clear_worker_group_sepc();
  static const int kWorkerGroupSepcFieldNumber = 2;
  ::flyteidl::core::WorkerGroupSpec* mutable_worker_group_sepc(int index);
  ::google::protobuf::RepeatedPtrField< ::flyteidl::core::WorkerGroupSpec >*
      mutable_worker_group_sepc();
  const ::flyteidl::core::WorkerGroupSpec& worker_group_sepc(int index) const;
  ::flyteidl::core::WorkerGroupSpec* add_worker_group_sepc();
  const ::google::protobuf::RepeatedPtrField< ::flyteidl::core::WorkerGroupSpec >&
      worker_group_sepc() const;

  // .flyteidl.core.HeadGroupSpec head_group_spec = 1;
  bool has_head_group_spec() const;
  void clear_head_group_spec();
  static const int kHeadGroupSpecFieldNumber = 1;
  const ::flyteidl::core::HeadGroupSpec& head_group_spec() const;
  ::flyteidl::core::HeadGroupSpec* release_head_group_spec();
  ::flyteidl::core::HeadGroupSpec* mutable_head_group_spec();
  void set_allocated_head_group_spec(::flyteidl::core::HeadGroupSpec* head_group_spec);

  // @@protoc_insertion_point(class_scope:flyteidl.core.ClusterSpec)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::flyteidl::core::WorkerGroupSpec > worker_group_sepc_;
  ::flyteidl::core::HeadGroupSpec* head_group_spec_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2fresource_2eproto;
};
// -------------------------------------------------------------------

class HeadGroupSpec_RayStartParamsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<HeadGroupSpec_RayStartParamsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
static bool _ParseMap(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  typedef ::google::protobuf::internal::MapEntry<HeadGroupSpec_RayStartParamsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  HeadGroupSpec_RayStartParamsEntry_DoNotUse();
  HeadGroupSpec_RayStartParamsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const HeadGroupSpec_RayStartParamsEntry_DoNotUse& other);
  static const HeadGroupSpec_RayStartParamsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const HeadGroupSpec_RayStartParamsEntry_DoNotUse*>(&_HeadGroupSpec_RayStartParamsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class HeadGroupSpec final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.HeadGroupSpec) */ {
 public:
  HeadGroupSpec();
  virtual ~HeadGroupSpec();

  HeadGroupSpec(const HeadGroupSpec& from);

  inline HeadGroupSpec& operator=(const HeadGroupSpec& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HeadGroupSpec(HeadGroupSpec&& from) noexcept
    : HeadGroupSpec() {
    *this = ::std::move(from);
  }

  inline HeadGroupSpec& operator=(HeadGroupSpec&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const HeadGroupSpec& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HeadGroupSpec* internal_default_instance() {
    return reinterpret_cast<const HeadGroupSpec*>(
               &_HeadGroupSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(HeadGroupSpec* other);
  friend void swap(HeadGroupSpec& a, HeadGroupSpec& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HeadGroupSpec* New() const final {
    return CreateMaybeMessage<HeadGroupSpec>(nullptr);
  }

  HeadGroupSpec* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HeadGroupSpec>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HeadGroupSpec& from);
  void MergeFrom(const HeadGroupSpec& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeadGroupSpec* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, string> ray_start_params = 4;
  int ray_start_params_size() const;
  void clear_ray_start_params();
  static const int kRayStartParamsFieldNumber = 4;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      ray_start_params() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_ray_start_params();

  // string compute_template = 1;
  void clear_compute_template();
  static const int kComputeTemplateFieldNumber = 1;
  const ::std::string& compute_template() const;
  void set_compute_template(const ::std::string& value);
  #if LANG_CXX11
  void set_compute_template(::std::string&& value);
  #endif
  void set_compute_template(const char* value);
  void set_compute_template(const char* value, size_t size);
  ::std::string* mutable_compute_template();
  ::std::string* release_compute_template();
  void set_allocated_compute_template(::std::string* compute_template);

  // string image = 2;
  void clear_image();
  static const int kImageFieldNumber = 2;
  const ::std::string& image() const;
  void set_image(const ::std::string& value);
  #if LANG_CXX11
  void set_image(::std::string&& value);
  #endif
  void set_image(const char* value);
  void set_image(const char* value, size_t size);
  ::std::string* mutable_image();
  ::std::string* release_image();
  void set_allocated_image(::std::string* image);

  // string service_type = 3;
  void clear_service_type();
  static const int kServiceTypeFieldNumber = 3;
  const ::std::string& service_type() const;
  void set_service_type(const ::std::string& value);
  #if LANG_CXX11
  void set_service_type(::std::string&& value);
  #endif
  void set_service_type(const char* value);
  void set_service_type(const char* value, size_t size);
  ::std::string* mutable_service_type();
  ::std::string* release_service_type();
  void set_allocated_service_type(::std::string* service_type);

  // @@protoc_insertion_point(class_scope:flyteidl.core.HeadGroupSpec)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      HeadGroupSpec_RayStartParamsEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > ray_start_params_;
  ::google::protobuf::internal::ArenaStringPtr compute_template_;
  ::google::protobuf::internal::ArenaStringPtr image_;
  ::google::protobuf::internal::ArenaStringPtr service_type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2fresource_2eproto;
};
// -------------------------------------------------------------------

class WorkerGroupSpec_RayStartParamsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<WorkerGroupSpec_RayStartParamsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
static bool _ParseMap(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  typedef ::google::protobuf::internal::MapEntry<WorkerGroupSpec_RayStartParamsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  WorkerGroupSpec_RayStartParamsEntry_DoNotUse();
  WorkerGroupSpec_RayStartParamsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const WorkerGroupSpec_RayStartParamsEntry_DoNotUse& other);
  static const WorkerGroupSpec_RayStartParamsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const WorkerGroupSpec_RayStartParamsEntry_DoNotUse*>(&_WorkerGroupSpec_RayStartParamsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class WorkerGroupSpec final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.WorkerGroupSpec) */ {
 public:
  WorkerGroupSpec();
  virtual ~WorkerGroupSpec();

  WorkerGroupSpec(const WorkerGroupSpec& from);

  inline WorkerGroupSpec& operator=(const WorkerGroupSpec& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WorkerGroupSpec(WorkerGroupSpec&& from) noexcept
    : WorkerGroupSpec() {
    *this = ::std::move(from);
  }

  inline WorkerGroupSpec& operator=(WorkerGroupSpec&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const WorkerGroupSpec& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WorkerGroupSpec* internal_default_instance() {
    return reinterpret_cast<const WorkerGroupSpec*>(
               &_WorkerGroupSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(WorkerGroupSpec* other);
  friend void swap(WorkerGroupSpec& a, WorkerGroupSpec& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WorkerGroupSpec* New() const final {
    return CreateMaybeMessage<WorkerGroupSpec>(nullptr);
  }

  WorkerGroupSpec* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WorkerGroupSpec>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WorkerGroupSpec& from);
  void MergeFrom(const WorkerGroupSpec& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkerGroupSpec* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, string> ray_start_params = 7;
  int ray_start_params_size() const;
  void clear_ray_start_params();
  static const int kRayStartParamsFieldNumber = 7;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      ray_start_params() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_ray_start_params();

  // string group_name = 1;
  void clear_group_name();
  static const int kGroupNameFieldNumber = 1;
  const ::std::string& group_name() const;
  void set_group_name(const ::std::string& value);
  #if LANG_CXX11
  void set_group_name(::std::string&& value);
  #endif
  void set_group_name(const char* value);
  void set_group_name(const char* value, size_t size);
  ::std::string* mutable_group_name();
  ::std::string* release_group_name();
  void set_allocated_group_name(::std::string* group_name);

  // string compute_template = 2;
  void clear_compute_template();
  static const int kComputeTemplateFieldNumber = 2;
  const ::std::string& compute_template() const;
  void set_compute_template(const ::std::string& value);
  #if LANG_CXX11
  void set_compute_template(::std::string&& value);
  #endif
  void set_compute_template(const char* value);
  void set_compute_template(const char* value, size_t size);
  ::std::string* mutable_compute_template();
  ::std::string* release_compute_template();
  void set_allocated_compute_template(::std::string* compute_template);

  // string image = 3;
  void clear_image();
  static const int kImageFieldNumber = 3;
  const ::std::string& image() const;
  void set_image(const ::std::string& value);
  #if LANG_CXX11
  void set_image(::std::string&& value);
  #endif
  void set_image(const char* value);
  void set_image(const char* value, size_t size);
  ::std::string* mutable_image();
  ::std::string* release_image();
  void set_allocated_image(::std::string* image);

  // int32 replicas = 4;
  void clear_replicas();
  static const int kReplicasFieldNumber = 4;
  ::google::protobuf::int32 replicas() const;
  void set_replicas(::google::protobuf::int32 value);

  // int32 min_replicas = 5;
  void clear_min_replicas();
  static const int kMinReplicasFieldNumber = 5;
  ::google::protobuf::int32 min_replicas() const;
  void set_min_replicas(::google::protobuf::int32 value);

  // int32 max_replicas = 6;
  void clear_max_replicas();
  static const int kMaxReplicasFieldNumber = 6;
  ::google::protobuf::int32 max_replicas() const;
  void set_max_replicas(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:flyteidl.core.WorkerGroupSpec)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      WorkerGroupSpec_RayStartParamsEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > ray_start_params_;
  ::google::protobuf::internal::ArenaStringPtr group_name_;
  ::google::protobuf::internal::ArenaStringPtr compute_template_;
  ::google::protobuf::internal::ArenaStringPtr image_;
  ::google::protobuf::int32 replicas_;
  ::google::protobuf::int32 min_replicas_;
  ::google::protobuf::int32 max_replicas_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2fresource_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Resource

// .flyteidl.core.RayCluster ray = 1;
inline bool Resource::has_ray() const {
  return value_case() == kRay;
}
inline void Resource::set_has_ray() {
  _oneof_case_[0] = kRay;
}
inline void Resource::clear_ray() {
  if (has_ray()) {
    delete value_.ray_;
    clear_has_value();
  }
}
inline ::flyteidl::core::RayCluster* Resource::release_ray() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Resource.ray)
  if (has_ray()) {
    clear_has_value();
      ::flyteidl::core::RayCluster* temp = value_.ray_;
    value_.ray_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::core::RayCluster& Resource::ray() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Resource.ray)
  return has_ray()
      ? *value_.ray_
      : *reinterpret_cast< ::flyteidl::core::RayCluster*>(&::flyteidl::core::_RayCluster_default_instance_);
}
inline ::flyteidl::core::RayCluster* Resource::mutable_ray() {
  if (!has_ray()) {
    clear_value();
    set_has_ray();
    value_.ray_ = CreateMaybeMessage< ::flyteidl::core::RayCluster >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Resource.ray)
  return value_.ray_;
}

inline bool Resource::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void Resource::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline Resource::ValueCase Resource::value_case() const {
  return Resource::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// RayCluster

// string name = 1;
inline void RayCluster::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RayCluster::name() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.RayCluster.name)
  return name_.GetNoArena();
}
inline void RayCluster::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.RayCluster.name)
}
#if LANG_CXX11
inline void RayCluster::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.RayCluster.name)
}
#endif
inline void RayCluster::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.RayCluster.name)
}
inline void RayCluster::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.RayCluster.name)
}
inline ::std::string* RayCluster::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.RayCluster.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RayCluster::release_name() {
  // @@protoc_insertion_point(field_release:flyteidl.core.RayCluster.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RayCluster::set_allocated_name(::std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.RayCluster.name)
}

// string namespace = 2;
inline void RayCluster::clear_namespace_() {
  namespace__.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RayCluster::namespace_() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.RayCluster.namespace)
  return namespace__.GetNoArena();
}
inline void RayCluster::set_namespace_(const ::std::string& value) {
  
  namespace__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.RayCluster.namespace)
}
#if LANG_CXX11
inline void RayCluster::set_namespace_(::std::string&& value) {
  
  namespace__.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.RayCluster.namespace)
}
#endif
inline void RayCluster::set_namespace_(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  namespace__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.RayCluster.namespace)
}
inline void RayCluster::set_namespace_(const char* value, size_t size) {
  
  namespace__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.RayCluster.namespace)
}
inline ::std::string* RayCluster::mutable_namespace_() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.RayCluster.namespace)
  return namespace__.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RayCluster::release_namespace_() {
  // @@protoc_insertion_point(field_release:flyteidl.core.RayCluster.namespace)
  
  return namespace__.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RayCluster::set_allocated_namespace_(::std::string* namespace_) {
  if (namespace_ != nullptr) {
    
  } else {
    
  }
  namespace__.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), namespace_);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.RayCluster.namespace)
}

// string user = 3;
inline void RayCluster::clear_user() {
  user_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RayCluster::user() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.RayCluster.user)
  return user_.GetNoArena();
}
inline void RayCluster::set_user(const ::std::string& value) {
  
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.RayCluster.user)
}
#if LANG_CXX11
inline void RayCluster::set_user(::std::string&& value) {
  
  user_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.RayCluster.user)
}
#endif
inline void RayCluster::set_user(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.RayCluster.user)
}
inline void RayCluster::set_user(const char* value, size_t size) {
  
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.RayCluster.user)
}
inline ::std::string* RayCluster::mutable_user() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.RayCluster.user)
  return user_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RayCluster::release_user() {
  // @@protoc_insertion_point(field_release:flyteidl.core.RayCluster.user)
  
  return user_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RayCluster::set_allocated_user(::std::string* user) {
  if (user != nullptr) {
    
  } else {
    
  }
  user_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.RayCluster.user)
}

// string version = 4;
inline void RayCluster::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RayCluster::version() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.RayCluster.version)
  return version_.GetNoArena();
}
inline void RayCluster::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.RayCluster.version)
}
#if LANG_CXX11
inline void RayCluster::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.RayCluster.version)
}
#endif
inline void RayCluster::set_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.RayCluster.version)
}
inline void RayCluster::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.RayCluster.version)
}
inline ::std::string* RayCluster::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.RayCluster.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RayCluster::release_version() {
  // @@protoc_insertion_point(field_release:flyteidl.core.RayCluster.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RayCluster::set_allocated_version(::std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.RayCluster.version)
}

// .flyteidl.core.RayCluster.Environment environment = 5;
inline void RayCluster::clear_environment() {
  environment_ = 0;
}
inline ::flyteidl::core::RayCluster_Environment RayCluster::environment() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.RayCluster.environment)
  return static_cast< ::flyteidl::core::RayCluster_Environment >(environment_);
}
inline void RayCluster::set_environment(::flyteidl::core::RayCluster_Environment value) {
  
  environment_ = value;
  // @@protoc_insertion_point(field_set:flyteidl.core.RayCluster.environment)
}

// .flyteidl.core.ClusterSpec cluster_spec = 6;
inline bool RayCluster::has_cluster_spec() const {
  return this != internal_default_instance() && cluster_spec_ != nullptr;
}
inline void RayCluster::clear_cluster_spec() {
  if (GetArenaNoVirtual() == nullptr && cluster_spec_ != nullptr) {
    delete cluster_spec_;
  }
  cluster_spec_ = nullptr;
}
inline const ::flyteidl::core::ClusterSpec& RayCluster::cluster_spec() const {
  const ::flyteidl::core::ClusterSpec* p = cluster_spec_;
  // @@protoc_insertion_point(field_get:flyteidl.core.RayCluster.cluster_spec)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::ClusterSpec*>(
      &::flyteidl::core::_ClusterSpec_default_instance_);
}
inline ::flyteidl::core::ClusterSpec* RayCluster::release_cluster_spec() {
  // @@protoc_insertion_point(field_release:flyteidl.core.RayCluster.cluster_spec)
  
  ::flyteidl::core::ClusterSpec* temp = cluster_spec_;
  cluster_spec_ = nullptr;
  return temp;
}
inline ::flyteidl::core::ClusterSpec* RayCluster::mutable_cluster_spec() {
  
  if (cluster_spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::ClusterSpec>(GetArenaNoVirtual());
    cluster_spec_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.RayCluster.cluster_spec)
  return cluster_spec_;
}
inline void RayCluster::set_allocated_cluster_spec(::flyteidl::core::ClusterSpec* cluster_spec) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete cluster_spec_;
  }
  if (cluster_spec) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      cluster_spec = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, cluster_spec, submessage_arena);
    }
    
  } else {
    
  }
  cluster_spec_ = cluster_spec;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.RayCluster.cluster_spec)
}

// .google.protobuf.Timestamp created_at = 7;
inline bool RayCluster::has_created_at() const {
  return this != internal_default_instance() && created_at_ != nullptr;
}
inline const ::google::protobuf::Timestamp& RayCluster::created_at() const {
  const ::google::protobuf::Timestamp* p = created_at_;
  // @@protoc_insertion_point(field_get:flyteidl.core.RayCluster.created_at)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* RayCluster::release_created_at() {
  // @@protoc_insertion_point(field_release:flyteidl.core.RayCluster.created_at)
  
  ::google::protobuf::Timestamp* temp = created_at_;
  created_at_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* RayCluster::mutable_created_at() {
  
  if (created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaNoVirtual());
    created_at_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.RayCluster.created_at)
  return created_at_;
}
inline void RayCluster::set_allocated_created_at(::google::protobuf::Timestamp* created_at) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(created_at_);
  }
  if (created_at) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(created_at)->GetArena();
    if (message_arena != submessage_arena) {
      created_at = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, created_at, submessage_arena);
    }
    
  } else {
    
  }
  created_at_ = created_at;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.RayCluster.created_at)
}

// .google.protobuf.Timestamp deleted_at = 8;
inline bool RayCluster::has_deleted_at() const {
  return this != internal_default_instance() && deleted_at_ != nullptr;
}
inline const ::google::protobuf::Timestamp& RayCluster::deleted_at() const {
  const ::google::protobuf::Timestamp* p = deleted_at_;
  // @@protoc_insertion_point(field_get:flyteidl.core.RayCluster.deleted_at)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* RayCluster::release_deleted_at() {
  // @@protoc_insertion_point(field_release:flyteidl.core.RayCluster.deleted_at)
  
  ::google::protobuf::Timestamp* temp = deleted_at_;
  deleted_at_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* RayCluster::mutable_deleted_at() {
  
  if (deleted_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaNoVirtual());
    deleted_at_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.RayCluster.deleted_at)
  return deleted_at_;
}
inline void RayCluster::set_allocated_deleted_at(::google::protobuf::Timestamp* deleted_at) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(deleted_at_);
  }
  if (deleted_at) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(deleted_at)->GetArena();
    if (message_arena != submessage_arena) {
      deleted_at = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, deleted_at, submessage_arena);
    }
    
  } else {
    
  }
  deleted_at_ = deleted_at;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.RayCluster.deleted_at)
}

// string cluster_state = 9;
inline void RayCluster::clear_cluster_state() {
  cluster_state_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RayCluster::cluster_state() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.RayCluster.cluster_state)
  return cluster_state_.GetNoArena();
}
inline void RayCluster::set_cluster_state(const ::std::string& value) {
  
  cluster_state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.RayCluster.cluster_state)
}
#if LANG_CXX11
inline void RayCluster::set_cluster_state(::std::string&& value) {
  
  cluster_state_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.RayCluster.cluster_state)
}
#endif
inline void RayCluster::set_cluster_state(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  cluster_state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.RayCluster.cluster_state)
}
inline void RayCluster::set_cluster_state(const char* value, size_t size) {
  
  cluster_state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.RayCluster.cluster_state)
}
inline ::std::string* RayCluster::mutable_cluster_state() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.RayCluster.cluster_state)
  return cluster_state_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RayCluster::release_cluster_state() {
  // @@protoc_insertion_point(field_release:flyteidl.core.RayCluster.cluster_state)
  
  return cluster_state_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RayCluster::set_allocated_cluster_state(::std::string* cluster_state) {
  if (cluster_state != nullptr) {
    
  } else {
    
  }
  cluster_state_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cluster_state);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.RayCluster.cluster_state)
}

// -------------------------------------------------------------------

// ClusterSpec

// .flyteidl.core.HeadGroupSpec head_group_spec = 1;
inline bool ClusterSpec::has_head_group_spec() const {
  return this != internal_default_instance() && head_group_spec_ != nullptr;
}
inline void ClusterSpec::clear_head_group_spec() {
  if (GetArenaNoVirtual() == nullptr && head_group_spec_ != nullptr) {
    delete head_group_spec_;
  }
  head_group_spec_ = nullptr;
}
inline const ::flyteidl::core::HeadGroupSpec& ClusterSpec::head_group_spec() const {
  const ::flyteidl::core::HeadGroupSpec* p = head_group_spec_;
  // @@protoc_insertion_point(field_get:flyteidl.core.ClusterSpec.head_group_spec)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::HeadGroupSpec*>(
      &::flyteidl::core::_HeadGroupSpec_default_instance_);
}
inline ::flyteidl::core::HeadGroupSpec* ClusterSpec::release_head_group_spec() {
  // @@protoc_insertion_point(field_release:flyteidl.core.ClusterSpec.head_group_spec)
  
  ::flyteidl::core::HeadGroupSpec* temp = head_group_spec_;
  head_group_spec_ = nullptr;
  return temp;
}
inline ::flyteidl::core::HeadGroupSpec* ClusterSpec::mutable_head_group_spec() {
  
  if (head_group_spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::HeadGroupSpec>(GetArenaNoVirtual());
    head_group_spec_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.ClusterSpec.head_group_spec)
  return head_group_spec_;
}
inline void ClusterSpec::set_allocated_head_group_spec(::flyteidl::core::HeadGroupSpec* head_group_spec) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete head_group_spec_;
  }
  if (head_group_spec) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      head_group_spec = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, head_group_spec, submessage_arena);
    }
    
  } else {
    
  }
  head_group_spec_ = head_group_spec;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.ClusterSpec.head_group_spec)
}

// repeated .flyteidl.core.WorkerGroupSpec worker_group_sepc = 2;
inline int ClusterSpec::worker_group_sepc_size() const {
  return worker_group_sepc_.size();
}
inline void ClusterSpec::clear_worker_group_sepc() {
  worker_group_sepc_.Clear();
}
inline ::flyteidl::core::WorkerGroupSpec* ClusterSpec::mutable_worker_group_sepc(int index) {
  // @@protoc_insertion_point(field_mutable:flyteidl.core.ClusterSpec.worker_group_sepc)
  return worker_group_sepc_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::flyteidl::core::WorkerGroupSpec >*
ClusterSpec::mutable_worker_group_sepc() {
  // @@protoc_insertion_point(field_mutable_list:flyteidl.core.ClusterSpec.worker_group_sepc)
  return &worker_group_sepc_;
}
inline const ::flyteidl::core::WorkerGroupSpec& ClusterSpec::worker_group_sepc(int index) const {
  // @@protoc_insertion_point(field_get:flyteidl.core.ClusterSpec.worker_group_sepc)
  return worker_group_sepc_.Get(index);
}
inline ::flyteidl::core::WorkerGroupSpec* ClusterSpec::add_worker_group_sepc() {
  // @@protoc_insertion_point(field_add:flyteidl.core.ClusterSpec.worker_group_sepc)
  return worker_group_sepc_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::flyteidl::core::WorkerGroupSpec >&
ClusterSpec::worker_group_sepc() const {
  // @@protoc_insertion_point(field_list:flyteidl.core.ClusterSpec.worker_group_sepc)
  return worker_group_sepc_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// HeadGroupSpec

// string compute_template = 1;
inline void HeadGroupSpec::clear_compute_template() {
  compute_template_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HeadGroupSpec::compute_template() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.HeadGroupSpec.compute_template)
  return compute_template_.GetNoArena();
}
inline void HeadGroupSpec::set_compute_template(const ::std::string& value) {
  
  compute_template_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.HeadGroupSpec.compute_template)
}
#if LANG_CXX11
inline void HeadGroupSpec::set_compute_template(::std::string&& value) {
  
  compute_template_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.HeadGroupSpec.compute_template)
}
#endif
inline void HeadGroupSpec::set_compute_template(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  compute_template_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.HeadGroupSpec.compute_template)
}
inline void HeadGroupSpec::set_compute_template(const char* value, size_t size) {
  
  compute_template_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.HeadGroupSpec.compute_template)
}
inline ::std::string* HeadGroupSpec::mutable_compute_template() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.HeadGroupSpec.compute_template)
  return compute_template_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HeadGroupSpec::release_compute_template() {
  // @@protoc_insertion_point(field_release:flyteidl.core.HeadGroupSpec.compute_template)
  
  return compute_template_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HeadGroupSpec::set_allocated_compute_template(::std::string* compute_template) {
  if (compute_template != nullptr) {
    
  } else {
    
  }
  compute_template_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), compute_template);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.HeadGroupSpec.compute_template)
}

// string image = 2;
inline void HeadGroupSpec::clear_image() {
  image_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HeadGroupSpec::image() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.HeadGroupSpec.image)
  return image_.GetNoArena();
}
inline void HeadGroupSpec::set_image(const ::std::string& value) {
  
  image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.HeadGroupSpec.image)
}
#if LANG_CXX11
inline void HeadGroupSpec::set_image(::std::string&& value) {
  
  image_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.HeadGroupSpec.image)
}
#endif
inline void HeadGroupSpec::set_image(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.HeadGroupSpec.image)
}
inline void HeadGroupSpec::set_image(const char* value, size_t size) {
  
  image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.HeadGroupSpec.image)
}
inline ::std::string* HeadGroupSpec::mutable_image() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.HeadGroupSpec.image)
  return image_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HeadGroupSpec::release_image() {
  // @@protoc_insertion_point(field_release:flyteidl.core.HeadGroupSpec.image)
  
  return image_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HeadGroupSpec::set_allocated_image(::std::string* image) {
  if (image != nullptr) {
    
  } else {
    
  }
  image_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), image);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.HeadGroupSpec.image)
}

// string service_type = 3;
inline void HeadGroupSpec::clear_service_type() {
  service_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HeadGroupSpec::service_type() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.HeadGroupSpec.service_type)
  return service_type_.GetNoArena();
}
inline void HeadGroupSpec::set_service_type(const ::std::string& value) {
  
  service_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.HeadGroupSpec.service_type)
}
#if LANG_CXX11
inline void HeadGroupSpec::set_service_type(::std::string&& value) {
  
  service_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.HeadGroupSpec.service_type)
}
#endif
inline void HeadGroupSpec::set_service_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  service_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.HeadGroupSpec.service_type)
}
inline void HeadGroupSpec::set_service_type(const char* value, size_t size) {
  
  service_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.HeadGroupSpec.service_type)
}
inline ::std::string* HeadGroupSpec::mutable_service_type() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.HeadGroupSpec.service_type)
  return service_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HeadGroupSpec::release_service_type() {
  // @@protoc_insertion_point(field_release:flyteidl.core.HeadGroupSpec.service_type)
  
  return service_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HeadGroupSpec::set_allocated_service_type(::std::string* service_type) {
  if (service_type != nullptr) {
    
  } else {
    
  }
  service_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), service_type);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.HeadGroupSpec.service_type)
}

// map<string, string> ray_start_params = 4;
inline int HeadGroupSpec::ray_start_params_size() const {
  return ray_start_params_.size();
}
inline void HeadGroupSpec::clear_ray_start_params() {
  ray_start_params_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
HeadGroupSpec::ray_start_params() const {
  // @@protoc_insertion_point(field_map:flyteidl.core.HeadGroupSpec.ray_start_params)
  return ray_start_params_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
HeadGroupSpec::mutable_ray_start_params() {
  // @@protoc_insertion_point(field_mutable_map:flyteidl.core.HeadGroupSpec.ray_start_params)
  return ray_start_params_.MutableMap();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// WorkerGroupSpec

// string group_name = 1;
inline void WorkerGroupSpec::clear_group_name() {
  group_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WorkerGroupSpec::group_name() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.WorkerGroupSpec.group_name)
  return group_name_.GetNoArena();
}
inline void WorkerGroupSpec::set_group_name(const ::std::string& value) {
  
  group_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.WorkerGroupSpec.group_name)
}
#if LANG_CXX11
inline void WorkerGroupSpec::set_group_name(::std::string&& value) {
  
  group_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.WorkerGroupSpec.group_name)
}
#endif
inline void WorkerGroupSpec::set_group_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  group_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.WorkerGroupSpec.group_name)
}
inline void WorkerGroupSpec::set_group_name(const char* value, size_t size) {
  
  group_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.WorkerGroupSpec.group_name)
}
inline ::std::string* WorkerGroupSpec::mutable_group_name() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.WorkerGroupSpec.group_name)
  return group_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WorkerGroupSpec::release_group_name() {
  // @@protoc_insertion_point(field_release:flyteidl.core.WorkerGroupSpec.group_name)
  
  return group_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WorkerGroupSpec::set_allocated_group_name(::std::string* group_name) {
  if (group_name != nullptr) {
    
  } else {
    
  }
  group_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), group_name);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.WorkerGroupSpec.group_name)
}

// string compute_template = 2;
inline void WorkerGroupSpec::clear_compute_template() {
  compute_template_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WorkerGroupSpec::compute_template() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.WorkerGroupSpec.compute_template)
  return compute_template_.GetNoArena();
}
inline void WorkerGroupSpec::set_compute_template(const ::std::string& value) {
  
  compute_template_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.WorkerGroupSpec.compute_template)
}
#if LANG_CXX11
inline void WorkerGroupSpec::set_compute_template(::std::string&& value) {
  
  compute_template_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.WorkerGroupSpec.compute_template)
}
#endif
inline void WorkerGroupSpec::set_compute_template(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  compute_template_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.WorkerGroupSpec.compute_template)
}
inline void WorkerGroupSpec::set_compute_template(const char* value, size_t size) {
  
  compute_template_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.WorkerGroupSpec.compute_template)
}
inline ::std::string* WorkerGroupSpec::mutable_compute_template() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.WorkerGroupSpec.compute_template)
  return compute_template_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WorkerGroupSpec::release_compute_template() {
  // @@protoc_insertion_point(field_release:flyteidl.core.WorkerGroupSpec.compute_template)
  
  return compute_template_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WorkerGroupSpec::set_allocated_compute_template(::std::string* compute_template) {
  if (compute_template != nullptr) {
    
  } else {
    
  }
  compute_template_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), compute_template);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.WorkerGroupSpec.compute_template)
}

// string image = 3;
inline void WorkerGroupSpec::clear_image() {
  image_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WorkerGroupSpec::image() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.WorkerGroupSpec.image)
  return image_.GetNoArena();
}
inline void WorkerGroupSpec::set_image(const ::std::string& value) {
  
  image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.WorkerGroupSpec.image)
}
#if LANG_CXX11
inline void WorkerGroupSpec::set_image(::std::string&& value) {
  
  image_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.WorkerGroupSpec.image)
}
#endif
inline void WorkerGroupSpec::set_image(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.WorkerGroupSpec.image)
}
inline void WorkerGroupSpec::set_image(const char* value, size_t size) {
  
  image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.WorkerGroupSpec.image)
}
inline ::std::string* WorkerGroupSpec::mutable_image() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.WorkerGroupSpec.image)
  return image_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WorkerGroupSpec::release_image() {
  // @@protoc_insertion_point(field_release:flyteidl.core.WorkerGroupSpec.image)
  
  return image_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WorkerGroupSpec::set_allocated_image(::std::string* image) {
  if (image != nullptr) {
    
  } else {
    
  }
  image_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), image);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.WorkerGroupSpec.image)
}

// int32 replicas = 4;
inline void WorkerGroupSpec::clear_replicas() {
  replicas_ = 0;
}
inline ::google::protobuf::int32 WorkerGroupSpec::replicas() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.WorkerGroupSpec.replicas)
  return replicas_;
}
inline void WorkerGroupSpec::set_replicas(::google::protobuf::int32 value) {
  
  replicas_ = value;
  // @@protoc_insertion_point(field_set:flyteidl.core.WorkerGroupSpec.replicas)
}

// int32 min_replicas = 5;
inline void WorkerGroupSpec::clear_min_replicas() {
  min_replicas_ = 0;
}
inline ::google::protobuf::int32 WorkerGroupSpec::min_replicas() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.WorkerGroupSpec.min_replicas)
  return min_replicas_;
}
inline void WorkerGroupSpec::set_min_replicas(::google::protobuf::int32 value) {
  
  min_replicas_ = value;
  // @@protoc_insertion_point(field_set:flyteidl.core.WorkerGroupSpec.min_replicas)
}

// int32 max_replicas = 6;
inline void WorkerGroupSpec::clear_max_replicas() {
  max_replicas_ = 0;
}
inline ::google::protobuf::int32 WorkerGroupSpec::max_replicas() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.WorkerGroupSpec.max_replicas)
  return max_replicas_;
}
inline void WorkerGroupSpec::set_max_replicas(::google::protobuf::int32 value) {
  
  max_replicas_ = value;
  // @@protoc_insertion_point(field_set:flyteidl.core.WorkerGroupSpec.max_replicas)
}

// map<string, string> ray_start_params = 7;
inline int WorkerGroupSpec::ray_start_params_size() const {
  return ray_start_params_.size();
}
inline void WorkerGroupSpec::clear_ray_start_params() {
  ray_start_params_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
WorkerGroupSpec::ray_start_params() const {
  // @@protoc_insertion_point(field_map:flyteidl.core.WorkerGroupSpec.ray_start_params)
  return ray_start_params_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
WorkerGroupSpec::mutable_ray_start_params() {
  // @@protoc_insertion_point(field_mutable_map:flyteidl.core.WorkerGroupSpec.ray_start_params)
  return ray_start_params_.MutableMap();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace core
}  // namespace flyteidl

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::flyteidl::core::RayCluster_Environment> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::flyteidl::core::RayCluster_Environment>() {
  return ::flyteidl::core::RayCluster_Environment_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_flyteidl_2fcore_2fresource_2eproto
