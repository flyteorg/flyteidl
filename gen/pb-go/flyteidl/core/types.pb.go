// Code generated by protoc-gen-go. DO NOT EDIT.
// source: flyteidl/core/types.proto

package core

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	_struct "github.com/golang/protobuf/ptypes/struct"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Define a set of simple types.
type SimpleType int32

const (
	SimpleType_NONE     SimpleType = 0
	SimpleType_INTEGER  SimpleType = 1
	SimpleType_FLOAT    SimpleType = 2
	SimpleType_STRING   SimpleType = 3
	SimpleType_BOOLEAN  SimpleType = 4
	SimpleType_DATETIME SimpleType = 5
	SimpleType_DURATION SimpleType = 6
	SimpleType_BINARY   SimpleType = 7
	SimpleType_ERROR    SimpleType = 8
	SimpleType_STRUCT   SimpleType = 9
)

var SimpleType_name = map[int32]string{
	0: "NONE",
	1: "INTEGER",
	2: "FLOAT",
	3: "STRING",
	4: "BOOLEAN",
	5: "DATETIME",
	6: "DURATION",
	7: "BINARY",
	8: "ERROR",
	9: "STRUCT",
}

var SimpleType_value = map[string]int32{
	"NONE":     0,
	"INTEGER":  1,
	"FLOAT":    2,
	"STRING":   3,
	"BOOLEAN":  4,
	"DATETIME": 5,
	"DURATION": 6,
	"BINARY":   7,
	"ERROR":    8,
	"STRUCT":   9,
}

func (x SimpleType) String() string {
	return proto.EnumName(SimpleType_name, int32(x))
}

func (SimpleType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_51e8add38f4caaed, []int{0}
}

type SchemaType_SchemaColumn_SchemaColumnType int32

const (
	SchemaType_SchemaColumn_INTEGER  SchemaType_SchemaColumn_SchemaColumnType = 0
	SchemaType_SchemaColumn_FLOAT    SchemaType_SchemaColumn_SchemaColumnType = 1
	SchemaType_SchemaColumn_STRING   SchemaType_SchemaColumn_SchemaColumnType = 2
	SchemaType_SchemaColumn_BOOLEAN  SchemaType_SchemaColumn_SchemaColumnType = 3
	SchemaType_SchemaColumn_DATETIME SchemaType_SchemaColumn_SchemaColumnType = 4
	SchemaType_SchemaColumn_DURATION SchemaType_SchemaColumn_SchemaColumnType = 5
)

var SchemaType_SchemaColumn_SchemaColumnType_name = map[int32]string{
	0: "INTEGER",
	1: "FLOAT",
	2: "STRING",
	3: "BOOLEAN",
	4: "DATETIME",
	5: "DURATION",
}

var SchemaType_SchemaColumn_SchemaColumnType_value = map[string]int32{
	"INTEGER":  0,
	"FLOAT":    1,
	"STRING":   2,
	"BOOLEAN":  3,
	"DATETIME": 4,
	"DURATION": 5,
}

func (x SchemaType_SchemaColumn_SchemaColumnType) String() string {
	return proto.EnumName(SchemaType_SchemaColumn_SchemaColumnType_name, int32(x))
}

func (SchemaType_SchemaColumn_SchemaColumnType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_51e8add38f4caaed, []int{0, 0, 0}
}

type BlobType_BlobDimensionality int32

const (
	BlobType_SINGLE    BlobType_BlobDimensionality = 0
	BlobType_MULTIPART BlobType_BlobDimensionality = 1
)

var BlobType_BlobDimensionality_name = map[int32]string{
	0: "SINGLE",
	1: "MULTIPART",
}

var BlobType_BlobDimensionality_value = map[string]int32{
	"SINGLE":    0,
	"MULTIPART": 1,
}

func (x BlobType_BlobDimensionality) String() string {
	return proto.EnumName(BlobType_BlobDimensionality_name, int32(x))
}

func (BlobType_BlobDimensionality) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_51e8add38f4caaed, []int{1, 0}
}

// Defines schema columns and types to strongly type-validate schemas interoperability.
type SchemaType struct {
	// A list of ordered columns this schema comprises of.
	Columns              []*SchemaType_SchemaColumn `protobuf:"bytes,3,rep,name=columns,proto3" json:"columns,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *SchemaType) Reset()         { *m = SchemaType{} }
func (m *SchemaType) String() string { return proto.CompactTextString(m) }
func (*SchemaType) ProtoMessage()    {}
func (*SchemaType) Descriptor() ([]byte, []int) {
	return fileDescriptor_51e8add38f4caaed, []int{0}
}

func (m *SchemaType) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SchemaType.Unmarshal(m, b)
}
func (m *SchemaType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SchemaType.Marshal(b, m, deterministic)
}
func (m *SchemaType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchemaType.Merge(m, src)
}
func (m *SchemaType) XXX_Size() int {
	return xxx_messageInfo_SchemaType.Size(m)
}
func (m *SchemaType) XXX_DiscardUnknown() {
	xxx_messageInfo_SchemaType.DiscardUnknown(m)
}

var xxx_messageInfo_SchemaType proto.InternalMessageInfo

func (m *SchemaType) GetColumns() []*SchemaType_SchemaColumn {
	if m != nil {
		return m.Columns
	}
	return nil
}

type SchemaType_SchemaColumn struct {
	// A unique name -within the schema type- for the column
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The column type. This allows a limited set of types currently.
	Type                 SchemaType_SchemaColumn_SchemaColumnType `protobuf:"varint,2,opt,name=type,proto3,enum=flyteidl.core.SchemaType_SchemaColumn_SchemaColumnType" json:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                 `json:"-"`
	XXX_unrecognized     []byte                                   `json:"-"`
	XXX_sizecache        int32                                    `json:"-"`
}

func (m *SchemaType_SchemaColumn) Reset()         { *m = SchemaType_SchemaColumn{} }
func (m *SchemaType_SchemaColumn) String() string { return proto.CompactTextString(m) }
func (*SchemaType_SchemaColumn) ProtoMessage()    {}
func (*SchemaType_SchemaColumn) Descriptor() ([]byte, []int) {
	return fileDescriptor_51e8add38f4caaed, []int{0, 0}
}

func (m *SchemaType_SchemaColumn) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SchemaType_SchemaColumn.Unmarshal(m, b)
}
func (m *SchemaType_SchemaColumn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SchemaType_SchemaColumn.Marshal(b, m, deterministic)
}
func (m *SchemaType_SchemaColumn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchemaType_SchemaColumn.Merge(m, src)
}
func (m *SchemaType_SchemaColumn) XXX_Size() int {
	return xxx_messageInfo_SchemaType_SchemaColumn.Size(m)
}
func (m *SchemaType_SchemaColumn) XXX_DiscardUnknown() {
	xxx_messageInfo_SchemaType_SchemaColumn.DiscardUnknown(m)
}

var xxx_messageInfo_SchemaType_SchemaColumn proto.InternalMessageInfo

func (m *SchemaType_SchemaColumn) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SchemaType_SchemaColumn) GetType() SchemaType_SchemaColumn_SchemaColumnType {
	if m != nil {
		return m.Type
	}
	return SchemaType_SchemaColumn_INTEGER
}

// Defines type behavior for blob objects
type BlobType struct {
	// Format can be a free form string understood by SDK/UI etc like
	// csv, parquet etc
	Format               string                      `protobuf:"bytes,1,opt,name=format,proto3" json:"format,omitempty"`
	Dimensionality       BlobType_BlobDimensionality `protobuf:"varint,2,opt,name=dimensionality,proto3,enum=flyteidl.core.BlobType_BlobDimensionality" json:"dimensionality,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *BlobType) Reset()         { *m = BlobType{} }
func (m *BlobType) String() string { return proto.CompactTextString(m) }
func (*BlobType) ProtoMessage()    {}
func (*BlobType) Descriptor() ([]byte, []int) {
	return fileDescriptor_51e8add38f4caaed, []int{1}
}

func (m *BlobType) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BlobType.Unmarshal(m, b)
}
func (m *BlobType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BlobType.Marshal(b, m, deterministic)
}
func (m *BlobType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlobType.Merge(m, src)
}
func (m *BlobType) XXX_Size() int {
	return xxx_messageInfo_BlobType.Size(m)
}
func (m *BlobType) XXX_DiscardUnknown() {
	xxx_messageInfo_BlobType.DiscardUnknown(m)
}

var xxx_messageInfo_BlobType proto.InternalMessageInfo

func (m *BlobType) GetFormat() string {
	if m != nil {
		return m.Format
	}
	return ""
}

func (m *BlobType) GetDimensionality() BlobType_BlobDimensionality {
	if m != nil {
		return m.Dimensionality
	}
	return BlobType_SINGLE
}

// Enables declaring enum types, with predefined string values
// For len(values) > 0, the first value in the ordered list is regarded as the default value. If you wish
// To provide no defaults, make the first value as undefined.
type EnumType struct {
	// Predefined set of enum values.
	Values               []string `protobuf:"bytes,1,rep,name=values,proto3" json:"values,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EnumType) Reset()         { *m = EnumType{} }
func (m *EnumType) String() string { return proto.CompactTextString(m) }
func (*EnumType) ProtoMessage()    {}
func (*EnumType) Descriptor() ([]byte, []int) {
	return fileDescriptor_51e8add38f4caaed, []int{2}
}

func (m *EnumType) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EnumType.Unmarshal(m, b)
}
func (m *EnumType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EnumType.Marshal(b, m, deterministic)
}
func (m *EnumType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnumType.Merge(m, src)
}
func (m *EnumType) XXX_Size() int {
	return xxx_messageInfo_EnumType.Size(m)
}
func (m *EnumType) XXX_DiscardUnknown() {
	xxx_messageInfo_EnumType.DiscardUnknown(m)
}

var xxx_messageInfo_EnumType proto.InternalMessageInfo

func (m *EnumType) GetValues() []string {
	if m != nil {
		return m.Values
	}
	return nil
}

// Defines a tagged union type, also known as a variant (and formally as the sum type).
//
// A sum type S is defined by a sequence of types (A, B, C, ...) (each tagged by its numerical position in the sequence)
// A value of type S is constructed from a value of any of the variant types. The specific choice of type is recorded by
// storing the varaint's tag (position in the sequence) with the literal value and can be examined in runtime.
//
// Type S is typically written as
// S := A | B | C | ...
// or as
// S := Apple A | Banana B | Cantaloupe C | ...
// if the tags are assigned some name (here arbitrarily chosen to be fruit).
//
// If the tags are ommitted, this implementation resolves ambiguities by choosing the earliest compatible variant type
// For example, a value of type `List (A | B) | List (B | C)` is constructed from a value of type `List B` by using
// the tag for the `List (A | B)` variant since it occurs before `List (B | C)` even though they are both compatible
// When converting from IDL back to the native implementation, the tag should not be relied upon to retrieve the correct output type
// because a value of type `A | B` with tag 0 must be compatible with type `B | A` despite the tag pointing to the wrong variant.
//
// Notably, a nullable (optional) type is a sum type between some type X and the singleton type representing a null-value:
// Optional X := X | Null
//
// Python's `typing.Union` is an example of a union type with no runtime representation.
// It allows ambiguous sum types such as `typing.Union[int, int]` and `Union[list[Union[a, b]], list[Union[b, c]]]`
// since the ambiguity does not influence whether the types are compatible in any way.
// When converting to IDL, runtime values of type-erased unions use the first-compatible rule.
//
// C++'s `std::variant` is an example of a tagged union where the tag is implicit in the order of the types.
// When converting to IDL, runtime values of implicitly-tagged unions should use the index of the variant as the tag.
//
// Haskell's sum types, as well as Rust's and Swift's "enum" types are examples of tagged union types where the tag is explicitly named.
// When converting to IDL, runtime values of explicitly-tagged unions should use the index of the variant as the tag.
// This means that IDL values do not follow language semantics in case the variants are rearranged as IDL values will no longer have the correct tag.
// ^ Haskell example: `Nothing` will have tag `1` for `Maybe a = Just a | Nothing` and tag `0` for `Maybe a = Nothing | Just a`
//                    the tags are incompatible despite the values being compatible by Haskell rules.
//
// See also: https://en.wikipedia.org/wiki/Tagged_union
type UnionType struct {
	// Predefined set of LiteralTypes in union.
	Variants             []*LiteralType `protobuf:"bytes,1,rep,name=variants,proto3" json:"variants,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *UnionType) Reset()         { *m = UnionType{} }
func (m *UnionType) String() string { return proto.CompactTextString(m) }
func (*UnionType) ProtoMessage()    {}
func (*UnionType) Descriptor() ([]byte, []int) {
	return fileDescriptor_51e8add38f4caaed, []int{3}
}

func (m *UnionType) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UnionType.Unmarshal(m, b)
}
func (m *UnionType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UnionType.Marshal(b, m, deterministic)
}
func (m *UnionType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnionType.Merge(m, src)
}
func (m *UnionType) XXX_Size() int {
	return xxx_messageInfo_UnionType.Size(m)
}
func (m *UnionType) XXX_DiscardUnknown() {
	xxx_messageInfo_UnionType.DiscardUnknown(m)
}

var xxx_messageInfo_UnionType proto.InternalMessageInfo

func (m *UnionType) GetVariants() []*LiteralType {
	if m != nil {
		return m.Variants
	}
	return nil
}

// Defines a strong type to allow type checking between interfaces.
type LiteralType struct {
	// Types that are valid to be assigned to Type:
	//	*LiteralType_Simple
	//	*LiteralType_Schema
	//	*LiteralType_CollectionType
	//	*LiteralType_MapValueType
	//	*LiteralType_Blob
	//	*LiteralType_EnumType
	//	*LiteralType_UnionType
	Type isLiteralType_Type `protobuf_oneof:"type"`
	// This field contains type metadata that is descriptive of the type, but is NOT considered in type-checking.  This might be used by
	// consumers to identify special behavior or display extended information for the type.
	Metadata             *_struct.Struct `protobuf:"bytes,6,opt,name=metadata,proto3" json:"metadata,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *LiteralType) Reset()         { *m = LiteralType{} }
func (m *LiteralType) String() string { return proto.CompactTextString(m) }
func (*LiteralType) ProtoMessage()    {}
func (*LiteralType) Descriptor() ([]byte, []int) {
	return fileDescriptor_51e8add38f4caaed, []int{4}
}

func (m *LiteralType) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LiteralType.Unmarshal(m, b)
}
func (m *LiteralType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LiteralType.Marshal(b, m, deterministic)
}
func (m *LiteralType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LiteralType.Merge(m, src)
}
func (m *LiteralType) XXX_Size() int {
	return xxx_messageInfo_LiteralType.Size(m)
}
func (m *LiteralType) XXX_DiscardUnknown() {
	xxx_messageInfo_LiteralType.DiscardUnknown(m)
}

var xxx_messageInfo_LiteralType proto.InternalMessageInfo

type isLiteralType_Type interface {
	isLiteralType_Type()
}

type LiteralType_Simple struct {
	Simple SimpleType `protobuf:"varint,1,opt,name=simple,proto3,enum=flyteidl.core.SimpleType,oneof"`
}

type LiteralType_Schema struct {
	Schema *SchemaType `protobuf:"bytes,2,opt,name=schema,proto3,oneof"`
}

type LiteralType_CollectionType struct {
	CollectionType *LiteralType `protobuf:"bytes,3,opt,name=collection_type,json=collectionType,proto3,oneof"`
}

type LiteralType_MapValueType struct {
	MapValueType *LiteralType `protobuf:"bytes,4,opt,name=map_value_type,json=mapValueType,proto3,oneof"`
}

type LiteralType_Blob struct {
	Blob *BlobType `protobuf:"bytes,5,opt,name=blob,proto3,oneof"`
}

type LiteralType_EnumType struct {
	EnumType *EnumType `protobuf:"bytes,7,opt,name=enum_type,json=enumType,proto3,oneof"`
}

type LiteralType_UnionType struct {
	UnionType *UnionType `protobuf:"bytes,8,opt,name=union_type,json=unionType,proto3,oneof"`
}

func (*LiteralType_Simple) isLiteralType_Type() {}

func (*LiteralType_Schema) isLiteralType_Type() {}

func (*LiteralType_CollectionType) isLiteralType_Type() {}

func (*LiteralType_MapValueType) isLiteralType_Type() {}

func (*LiteralType_Blob) isLiteralType_Type() {}

func (*LiteralType_EnumType) isLiteralType_Type() {}

func (*LiteralType_UnionType) isLiteralType_Type() {}

func (m *LiteralType) GetType() isLiteralType_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *LiteralType) GetSimple() SimpleType {
	if x, ok := m.GetType().(*LiteralType_Simple); ok {
		return x.Simple
	}
	return SimpleType_NONE
}

func (m *LiteralType) GetSchema() *SchemaType {
	if x, ok := m.GetType().(*LiteralType_Schema); ok {
		return x.Schema
	}
	return nil
}

func (m *LiteralType) GetCollectionType() *LiteralType {
	if x, ok := m.GetType().(*LiteralType_CollectionType); ok {
		return x.CollectionType
	}
	return nil
}

func (m *LiteralType) GetMapValueType() *LiteralType {
	if x, ok := m.GetType().(*LiteralType_MapValueType); ok {
		return x.MapValueType
	}
	return nil
}

func (m *LiteralType) GetBlob() *BlobType {
	if x, ok := m.GetType().(*LiteralType_Blob); ok {
		return x.Blob
	}
	return nil
}

func (m *LiteralType) GetEnumType() *EnumType {
	if x, ok := m.GetType().(*LiteralType_EnumType); ok {
		return x.EnumType
	}
	return nil
}

func (m *LiteralType) GetUnionType() *UnionType {
	if x, ok := m.GetType().(*LiteralType_UnionType); ok {
		return x.UnionType
	}
	return nil
}

func (m *LiteralType) GetMetadata() *_struct.Struct {
	if m != nil {
		return m.Metadata
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*LiteralType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*LiteralType_Simple)(nil),
		(*LiteralType_Schema)(nil),
		(*LiteralType_CollectionType)(nil),
		(*LiteralType_MapValueType)(nil),
		(*LiteralType_Blob)(nil),
		(*LiteralType_EnumType)(nil),
		(*LiteralType_UnionType)(nil),
	}
}

// A reference to an output produced by a node. The type can be retrieved -and validated- from
// the underlying interface of the node.
type OutputReference struct {
	// Node id must exist at the graph layer.
	NodeId string `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	// Variable name must refer to an output variable for the node.
	Var                  string   `protobuf:"bytes,2,opt,name=var,proto3" json:"var,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OutputReference) Reset()         { *m = OutputReference{} }
func (m *OutputReference) String() string { return proto.CompactTextString(m) }
func (*OutputReference) ProtoMessage()    {}
func (*OutputReference) Descriptor() ([]byte, []int) {
	return fileDescriptor_51e8add38f4caaed, []int{5}
}

func (m *OutputReference) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_OutputReference.Unmarshal(m, b)
}
func (m *OutputReference) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_OutputReference.Marshal(b, m, deterministic)
}
func (m *OutputReference) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OutputReference.Merge(m, src)
}
func (m *OutputReference) XXX_Size() int {
	return xxx_messageInfo_OutputReference.Size(m)
}
func (m *OutputReference) XXX_DiscardUnknown() {
	xxx_messageInfo_OutputReference.DiscardUnknown(m)
}

var xxx_messageInfo_OutputReference proto.InternalMessageInfo

func (m *OutputReference) GetNodeId() string {
	if m != nil {
		return m.NodeId
	}
	return ""
}

func (m *OutputReference) GetVar() string {
	if m != nil {
		return m.Var
	}
	return ""
}

// Represents an error thrown from a node.
type Error struct {
	// The node id that threw the error.
	FailedNodeId string `protobuf:"bytes,1,opt,name=failed_node_id,json=failedNodeId,proto3" json:"failed_node_id,omitempty"`
	// Error message thrown.
	Message              string   `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Error) Reset()         { *m = Error{} }
func (m *Error) String() string { return proto.CompactTextString(m) }
func (*Error) ProtoMessage()    {}
func (*Error) Descriptor() ([]byte, []int) {
	return fileDescriptor_51e8add38f4caaed, []int{6}
}

func (m *Error) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Error.Unmarshal(m, b)
}
func (m *Error) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Error.Marshal(b, m, deterministic)
}
func (m *Error) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Error.Merge(m, src)
}
func (m *Error) XXX_Size() int {
	return xxx_messageInfo_Error.Size(m)
}
func (m *Error) XXX_DiscardUnknown() {
	xxx_messageInfo_Error.DiscardUnknown(m)
}

var xxx_messageInfo_Error proto.InternalMessageInfo

func (m *Error) GetFailedNodeId() string {
	if m != nil {
		return m.FailedNodeId
	}
	return ""
}

func (m *Error) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func init() {
	proto.RegisterEnum("flyteidl.core.SimpleType", SimpleType_name, SimpleType_value)
	proto.RegisterEnum("flyteidl.core.SchemaType_SchemaColumn_SchemaColumnType", SchemaType_SchemaColumn_SchemaColumnType_name, SchemaType_SchemaColumn_SchemaColumnType_value)
	proto.RegisterEnum("flyteidl.core.BlobType_BlobDimensionality", BlobType_BlobDimensionality_name, BlobType_BlobDimensionality_value)
	proto.RegisterType((*SchemaType)(nil), "flyteidl.core.SchemaType")
	proto.RegisterType((*SchemaType_SchemaColumn)(nil), "flyteidl.core.SchemaType.SchemaColumn")
	proto.RegisterType((*BlobType)(nil), "flyteidl.core.BlobType")
	proto.RegisterType((*EnumType)(nil), "flyteidl.core.EnumType")
	proto.RegisterType((*UnionType)(nil), "flyteidl.core.UnionType")
	proto.RegisterType((*LiteralType)(nil), "flyteidl.core.LiteralType")
	proto.RegisterType((*OutputReference)(nil), "flyteidl.core.OutputReference")
	proto.RegisterType((*Error)(nil), "flyteidl.core.Error")
}

func init() { proto.RegisterFile("flyteidl/core/types.proto", fileDescriptor_51e8add38f4caaed) }

var fileDescriptor_51e8add38f4caaed = []byte{
	// 730 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x54, 0xdb, 0x6a, 0xdb, 0x48,
	0x18, 0xb6, 0x2c, 0x1f, 0xa4, 0xdf, 0x8e, 0x23, 0xe6, 0x62, 0xa3, 0x84, 0xbd, 0x30, 0x62, 0x59,
	0x42, 0x20, 0x16, 0x38, 0x4b, 0x96, 0x85, 0xbd, 0xa8, 0x9d, 0xa8, 0xb6, 0xa8, 0x23, 0x97, 0x89,
	0x5c, 0x68, 0x6f, 0xcc, 0x58, 0x1e, 0x3b, 0x02, 0x49, 0x23, 0x74, 0x08, 0xf8, 0x05, 0xfa, 0x1e,
	0xbd, 0xea, 0xeb, 0xf4, 0x15, 0xfa, 0x26, 0x45, 0x23, 0xc9, 0xa7, 0xb4, 0x25, 0x77, 0xf3, 0xeb,
	0xff, 0xbe, 0x4f, 0xff, 0x19, 0xce, 0x57, 0xde, 0x26, 0xa1, 0xee, 0xd2, 0xd3, 0x1d, 0x16, 0x51,
	0x3d, 0xd9, 0x84, 0x34, 0xee, 0x85, 0x11, 0x4b, 0x18, 0x3a, 0x29, 0x5d, 0xbd, 0xcc, 0x75, 0xf1,
	0xe7, 0x9a, 0xb1, 0xb5, 0x47, 0x75, 0xee, 0x5c, 0xa4, 0x2b, 0x3d, 0x4e, 0xa2, 0xd4, 0x49, 0x72,
	0xb0, 0xf6, 0xa5, 0x0a, 0xf0, 0xe8, 0x3c, 0x51, 0x9f, 0xd8, 0x9b, 0x90, 0xa2, 0x37, 0xd0, 0x74,
	0x98, 0x97, 0xfa, 0x41, 0xac, 0x8a, 0x5d, 0xf1, 0xb2, 0xd5, 0xff, 0xbb, 0x77, 0xa0, 0xd6, 0xdb,
	0x61, 0x8b, 0xe7, 0x1d, 0x87, 0xe3, 0x92, 0x76, 0xf1, 0x4d, 0x80, 0xf6, 0xbe, 0x07, 0x21, 0xa8,
	0x05, 0xc4, 0xa7, 0xaa, 0xd0, 0x15, 0x2e, 0x65, 0xcc, 0xdf, 0xe8, 0x1d, 0xd4, 0xb2, 0x88, 0xd5,
	0x6a, 0x57, 0xb8, 0xec, 0xf4, 0xff, 0x7d, 0xdd, 0x3f, 0x0e, 0x8c, 0xcc, 0x8b, 0xb9, 0x88, 0x36,
	0x07, 0xe5, 0xd8, 0x83, 0x5a, 0xd0, 0x34, 0x2d, 0xdb, 0x18, 0x19, 0x58, 0xa9, 0x20, 0x19, 0xea,
	0x6f, 0x27, 0xd3, 0x81, 0xad, 0x08, 0x08, 0xa0, 0xf1, 0x68, 0x63, 0xd3, 0x1a, 0x29, 0xd5, 0x0c,
	0x33, 0x9c, 0x4e, 0x27, 0xc6, 0xc0, 0x52, 0x44, 0xd4, 0x06, 0xe9, 0x7e, 0x60, 0x1b, 0xb6, 0xf9,
	0x60, 0x28, 0x35, 0x6e, 0xcd, 0xf0, 0xc0, 0x36, 0xa7, 0x96, 0x52, 0xd7, 0xbe, 0x0a, 0x20, 0x0d,
	0x3d, 0xb6, 0xe0, 0xca, 0x7f, 0x40, 0x63, 0xc5, 0x22, 0x9f, 0x24, 0x45, 0x42, 0x85, 0x85, 0x30,
	0x74, 0x96, 0xae, 0x4f, 0x83, 0xd8, 0x65, 0x01, 0xf1, 0xdc, 0x64, 0x53, 0x24, 0x77, 0x75, 0x94,
	0x5c, 0x29, 0xc4, 0x1f, 0xf7, 0x07, 0x0c, 0x7c, 0xa4, 0xa0, 0xe9, 0x80, 0x5e, 0xa2, 0x78, 0x0e,
	0xa6, 0x35, 0x9a, 0x18, 0x4a, 0x05, 0x9d, 0x80, 0xfc, 0x30, 0x9b, 0xd8, 0xe6, 0xfb, 0x01, 0xb6,
	0x15, 0x41, 0xd3, 0x40, 0x32, 0x82, 0xd4, 0x2f, 0x03, 0x7d, 0x26, 0x5e, 0x4a, 0x63, 0x55, 0xe8,
	0x8a, 0x59, 0xa0, 0xb9, 0xa5, 0xdd, 0x81, 0x3c, 0x0b, 0x5c, 0x96, 0xd7, 0xe9, 0x16, 0xa4, 0x67,
	0x12, 0xb9, 0x24, 0x48, 0x72, 0x58, 0xab, 0x7f, 0x71, 0x14, 0xef, 0xc4, 0x4d, 0x68, 0x44, 0x3c,
	0x5e, 0xef, 0x2d, 0x56, 0xfb, 0x2e, 0x42, 0x6b, 0xcf, 0x83, 0x6e, 0xa0, 0x11, 0xbb, 0x7e, 0xe8,
	0xe5, 0x6d, 0xee, 0xf4, 0xcf, 0x8f, 0x5b, 0xca, 0x9d, 0x19, 0x74, 0x5c, 0xc1, 0x05, 0x94, 0x93,
	0x78, 0xe3, 0x78, 0xa9, 0x5a, 0x2f, 0x49, 0xdb, 0x39, 0xe0, 0x24, 0x6e, 0x21, 0x03, 0x4e, 0x1d,
	0xe6, 0x79, 0xd4, 0x49, 0x5c, 0x16, 0xcc, 0xf9, 0x14, 0x89, 0x9c, 0xfd, 0x9b, 0xc0, 0xc7, 0x15,
	0xdc, 0xd9, 0x91, 0x78, 0xc0, 0x43, 0xe8, 0xf8, 0x24, 0x9c, 0xf3, 0x9a, 0xe4, 0x2a, 0xb5, 0x57,
	0xa8, 0xb4, 0x7d, 0x12, 0x7e, 0xc8, 0x28, 0x5c, 0xe3, 0x1a, 0x6a, 0x0b, 0x8f, 0x2d, 0xd4, 0x3a,
	0x67, 0x9e, 0xfd, 0xa2, 0xd1, 0xe3, 0x0a, 0xe6, 0x30, 0x74, 0x0b, 0x32, 0x0d, 0x52, 0x3f, 0xff,
	0x5b, 0xf3, 0xa7, 0x9c, 0xb2, 0x79, 0xe3, 0x0a, 0x96, 0x68, 0xd9, 0xc8, 0xff, 0x00, 0xd2, 0x60,
	0x9b, 0xac, 0xc4, 0x89, 0xea, 0x11, 0x71, 0xdb, 0xd1, 0x71, 0x05, 0xcb, 0xe9, 0xb6, 0xbd, 0x37,
	0x20, 0xf9, 0x34, 0x21, 0x4b, 0x92, 0x10, 0xb5, 0x51, 0xfc, 0x31, 0x3f, 0x07, 0xbd, 0xf2, 0x1c,
	0xf4, 0x1e, 0xf9, 0x39, 0xc0, 0x5b, 0xe0, 0xb0, 0x91, 0x2f, 0xa7, 0xf6, 0x3f, 0x9c, 0x4e, 0xd3,
	0x24, 0x4c, 0x13, 0x4c, 0x57, 0x34, 0xa2, 0x81, 0x43, 0xd1, 0x19, 0x34, 0x03, 0xb6, 0xa4, 0x73,
	0x77, 0x59, 0x4e, 0x7f, 0x66, 0x9a, 0x4b, 0xa4, 0x80, 0xf8, 0x4c, 0x22, 0xde, 0x47, 0x19, 0x67,
	0x4f, 0x6d, 0x04, 0x75, 0x23, 0x8a, 0x58, 0x84, 0xfe, 0x82, 0xce, 0x8a, 0xb8, 0x1e, 0x5d, 0xce,
	0x0f, 0xa9, 0xed, 0xfc, 0xab, 0x95, 0x0b, 0xa8, 0xd0, 0xf4, 0x69, 0x1c, 0x93, 0x35, 0x2d, 0x44,
	0x4a, 0xf3, 0xea, 0xb3, 0x00, 0xb0, 0x1b, 0x1f, 0x24, 0x41, 0xcd, 0x9a, 0x5a, 0xd9, 0xec, 0xef,
	0xed, 0xb8, 0xb0, 0xdb, 0xf1, 0xea, 0xde, 0x8e, 0x8b, 0xfb, 0x3b, 0x5e, 0x3b, 0xd8, 0xf1, 0xfa,
	0xc1, 0x8e, 0x37, 0x32, 0xd2, 0xd0, 0xb4, 0x06, 0xf8, 0xa3, 0xd2, 0xcc, 0xb4, 0x0c, 0x8c, 0xa7,
	0x58, 0x91, 0x0a, 0xad, 0xd9, 0x9d, 0xad, 0xc8, 0xc3, 0xdb, 0x4f, 0xff, 0xac, 0xdd, 0xe4, 0x29,
	0x5d, 0xf4, 0x1c, 0xe6, 0xeb, 0xbc, 0xfe, 0x2c, 0x5a, 0xeb, 0xdb, 0x43, 0xbc, 0xa6, 0x81, 0x1e,
	0x2e, 0xae, 0xd7, 0x4c, 0x3f, 0xb8, 0xcd, 0x8b, 0x06, 0x2f, 0xf5, 0xcd, 0x8f, 0x00, 0x00, 0x00,
	0xff, 0xff, 0x71, 0x5d, 0x2e, 0x2e, 0xb3, 0x05, 0x00, 0x00,
}
