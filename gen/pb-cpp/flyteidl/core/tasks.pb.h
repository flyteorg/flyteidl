// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: flyteidl/core/tasks.proto

#ifndef PROTOBUF_INCLUDED_flyteidl_2fcore_2ftasks_2eproto
#define PROTOBUF_INCLUDED_flyteidl_2fcore_2ftasks_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "flyteidl/core/identifier.pb.h"
#include "flyteidl/core/interface.pb.h"
#include "flyteidl/core/literals.pb.h"
#include <google/protobuf/duration.pb.h>
#include <google/protobuf/struct.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_flyteidl_2fcore_2ftasks_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_flyteidl_2fcore_2ftasks_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[9]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_flyteidl_2fcore_2ftasks_2eproto();
namespace flyteidl {
namespace core {
class Container;
class ContainerDefaultTypeInternal;
extern ContainerDefaultTypeInternal _Container_default_instance_;
class ContainerPort;
class ContainerPortDefaultTypeInternal;
extern ContainerPortDefaultTypeInternal _ContainerPort_default_instance_;
class DataLoadingConfig;
class DataLoadingConfigDefaultTypeInternal;
extern DataLoadingConfigDefaultTypeInternal _DataLoadingConfig_default_instance_;
class IOStrategy;
class IOStrategyDefaultTypeInternal;
extern IOStrategyDefaultTypeInternal _IOStrategy_default_instance_;
class Resources;
class ResourcesDefaultTypeInternal;
extern ResourcesDefaultTypeInternal _Resources_default_instance_;
class Resources_ResourceEntry;
class Resources_ResourceEntryDefaultTypeInternal;
extern Resources_ResourceEntryDefaultTypeInternal _Resources_ResourceEntry_default_instance_;
class RuntimeMetadata;
class RuntimeMetadataDefaultTypeInternal;
extern RuntimeMetadataDefaultTypeInternal _RuntimeMetadata_default_instance_;
class TaskMetadata;
class TaskMetadataDefaultTypeInternal;
extern TaskMetadataDefaultTypeInternal _TaskMetadata_default_instance_;
class TaskTemplate;
class TaskTemplateDefaultTypeInternal;
extern TaskTemplateDefaultTypeInternal _TaskTemplate_default_instance_;
}  // namespace core
}  // namespace flyteidl
namespace google {
namespace protobuf {
template<> ::flyteidl::core::Container* Arena::CreateMaybeMessage<::flyteidl::core::Container>(Arena*);
template<> ::flyteidl::core::ContainerPort* Arena::CreateMaybeMessage<::flyteidl::core::ContainerPort>(Arena*);
template<> ::flyteidl::core::DataLoadingConfig* Arena::CreateMaybeMessage<::flyteidl::core::DataLoadingConfig>(Arena*);
template<> ::flyteidl::core::IOStrategy* Arena::CreateMaybeMessage<::flyteidl::core::IOStrategy>(Arena*);
template<> ::flyteidl::core::Resources* Arena::CreateMaybeMessage<::flyteidl::core::Resources>(Arena*);
template<> ::flyteidl::core::Resources_ResourceEntry* Arena::CreateMaybeMessage<::flyteidl::core::Resources_ResourceEntry>(Arena*);
template<> ::flyteidl::core::RuntimeMetadata* Arena::CreateMaybeMessage<::flyteidl::core::RuntimeMetadata>(Arena*);
template<> ::flyteidl::core::TaskMetadata* Arena::CreateMaybeMessage<::flyteidl::core::TaskMetadata>(Arena*);
template<> ::flyteidl::core::TaskTemplate* Arena::CreateMaybeMessage<::flyteidl::core::TaskTemplate>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace flyteidl {
namespace core {

enum Resources_ResourceName {
  Resources_ResourceName_UNKNOWN = 0,
  Resources_ResourceName_CPU = 1,
  Resources_ResourceName_GPU = 2,
  Resources_ResourceName_MEMORY = 3,
  Resources_ResourceName_STORAGE = 4,
  Resources_ResourceName_Resources_ResourceName_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  Resources_ResourceName_Resources_ResourceName_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool Resources_ResourceName_IsValid(int value);
const Resources_ResourceName Resources_ResourceName_ResourceName_MIN = Resources_ResourceName_UNKNOWN;
const Resources_ResourceName Resources_ResourceName_ResourceName_MAX = Resources_ResourceName_STORAGE;
const int Resources_ResourceName_ResourceName_ARRAYSIZE = Resources_ResourceName_ResourceName_MAX + 1;

const ::google::protobuf::EnumDescriptor* Resources_ResourceName_descriptor();
inline const ::std::string& Resources_ResourceName_Name(Resources_ResourceName value) {
  return ::google::protobuf::internal::NameOfEnum(
    Resources_ResourceName_descriptor(), value);
}
inline bool Resources_ResourceName_Parse(
    const ::std::string& name, Resources_ResourceName* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Resources_ResourceName>(
    Resources_ResourceName_descriptor(), name, value);
}
enum RuntimeMetadata_RuntimeType {
  RuntimeMetadata_RuntimeType_OTHER = 0,
  RuntimeMetadata_RuntimeType_FLYTE_SDK = 1,
  RuntimeMetadata_RuntimeType_RuntimeMetadata_RuntimeType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  RuntimeMetadata_RuntimeType_RuntimeMetadata_RuntimeType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool RuntimeMetadata_RuntimeType_IsValid(int value);
const RuntimeMetadata_RuntimeType RuntimeMetadata_RuntimeType_RuntimeType_MIN = RuntimeMetadata_RuntimeType_OTHER;
const RuntimeMetadata_RuntimeType RuntimeMetadata_RuntimeType_RuntimeType_MAX = RuntimeMetadata_RuntimeType_FLYTE_SDK;
const int RuntimeMetadata_RuntimeType_RuntimeType_ARRAYSIZE = RuntimeMetadata_RuntimeType_RuntimeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RuntimeMetadata_RuntimeType_descriptor();
inline const ::std::string& RuntimeMetadata_RuntimeType_Name(RuntimeMetadata_RuntimeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RuntimeMetadata_RuntimeType_descriptor(), value);
}
inline bool RuntimeMetadata_RuntimeType_Parse(
    const ::std::string& name, RuntimeMetadata_RuntimeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RuntimeMetadata_RuntimeType>(
    RuntimeMetadata_RuntimeType_descriptor(), name, value);
}
enum IOStrategy_DownloadMode {
  IOStrategy_DownloadMode_DOWNLOAD_EAGER = 0,
  IOStrategy_DownloadMode_DOWNLOAD_STREAM = 1,
  IOStrategy_DownloadMode_DO_NOT_DOWNLOAD = 2,
  IOStrategy_DownloadMode_IOStrategy_DownloadMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  IOStrategy_DownloadMode_IOStrategy_DownloadMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool IOStrategy_DownloadMode_IsValid(int value);
const IOStrategy_DownloadMode IOStrategy_DownloadMode_DownloadMode_MIN = IOStrategy_DownloadMode_DOWNLOAD_EAGER;
const IOStrategy_DownloadMode IOStrategy_DownloadMode_DownloadMode_MAX = IOStrategy_DownloadMode_DO_NOT_DOWNLOAD;
const int IOStrategy_DownloadMode_DownloadMode_ARRAYSIZE = IOStrategy_DownloadMode_DownloadMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* IOStrategy_DownloadMode_descriptor();
inline const ::std::string& IOStrategy_DownloadMode_Name(IOStrategy_DownloadMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    IOStrategy_DownloadMode_descriptor(), value);
}
inline bool IOStrategy_DownloadMode_Parse(
    const ::std::string& name, IOStrategy_DownloadMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<IOStrategy_DownloadMode>(
    IOStrategy_DownloadMode_descriptor(), name, value);
}
enum IOStrategy_UploadMode {
  IOStrategy_UploadMode_UPLOAD_ON_EXIT = 0,
  IOStrategy_UploadMode_UPLOAD_EAGER = 1,
  IOStrategy_UploadMode_DO_NOT_UPLOAD = 2,
  IOStrategy_UploadMode_IOStrategy_UploadMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  IOStrategy_UploadMode_IOStrategy_UploadMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool IOStrategy_UploadMode_IsValid(int value);
const IOStrategy_UploadMode IOStrategy_UploadMode_UploadMode_MIN = IOStrategy_UploadMode_UPLOAD_ON_EXIT;
const IOStrategy_UploadMode IOStrategy_UploadMode_UploadMode_MAX = IOStrategy_UploadMode_DO_NOT_UPLOAD;
const int IOStrategy_UploadMode_UploadMode_ARRAYSIZE = IOStrategy_UploadMode_UploadMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* IOStrategy_UploadMode_descriptor();
inline const ::std::string& IOStrategy_UploadMode_Name(IOStrategy_UploadMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    IOStrategy_UploadMode_descriptor(), value);
}
inline bool IOStrategy_UploadMode_Parse(
    const ::std::string& name, IOStrategy_UploadMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<IOStrategy_UploadMode>(
    IOStrategy_UploadMode_descriptor(), name, value);
}
enum DataLoadingConfig_LiteralMapFormat {
  DataLoadingConfig_LiteralMapFormat_JSON = 0,
  DataLoadingConfig_LiteralMapFormat_YAML = 1,
  DataLoadingConfig_LiteralMapFormat_PROTO = 2,
  DataLoadingConfig_LiteralMapFormat_DataLoadingConfig_LiteralMapFormat_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  DataLoadingConfig_LiteralMapFormat_DataLoadingConfig_LiteralMapFormat_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool DataLoadingConfig_LiteralMapFormat_IsValid(int value);
const DataLoadingConfig_LiteralMapFormat DataLoadingConfig_LiteralMapFormat_LiteralMapFormat_MIN = DataLoadingConfig_LiteralMapFormat_JSON;
const DataLoadingConfig_LiteralMapFormat DataLoadingConfig_LiteralMapFormat_LiteralMapFormat_MAX = DataLoadingConfig_LiteralMapFormat_PROTO;
const int DataLoadingConfig_LiteralMapFormat_LiteralMapFormat_ARRAYSIZE = DataLoadingConfig_LiteralMapFormat_LiteralMapFormat_MAX + 1;

const ::google::protobuf::EnumDescriptor* DataLoadingConfig_LiteralMapFormat_descriptor();
inline const ::std::string& DataLoadingConfig_LiteralMapFormat_Name(DataLoadingConfig_LiteralMapFormat value) {
  return ::google::protobuf::internal::NameOfEnum(
    DataLoadingConfig_LiteralMapFormat_descriptor(), value);
}
inline bool DataLoadingConfig_LiteralMapFormat_Parse(
    const ::std::string& name, DataLoadingConfig_LiteralMapFormat* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DataLoadingConfig_LiteralMapFormat>(
    DataLoadingConfig_LiteralMapFormat_descriptor(), name, value);
}
// ===================================================================

class Resources_ResourceEntry final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.Resources.ResourceEntry) */ {
 public:
  Resources_ResourceEntry();
  virtual ~Resources_ResourceEntry();

  Resources_ResourceEntry(const Resources_ResourceEntry& from);

  inline Resources_ResourceEntry& operator=(const Resources_ResourceEntry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Resources_ResourceEntry(Resources_ResourceEntry&& from) noexcept
    : Resources_ResourceEntry() {
    *this = ::std::move(from);
  }

  inline Resources_ResourceEntry& operator=(Resources_ResourceEntry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Resources_ResourceEntry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Resources_ResourceEntry* internal_default_instance() {
    return reinterpret_cast<const Resources_ResourceEntry*>(
               &_Resources_ResourceEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Resources_ResourceEntry* other);
  friend void swap(Resources_ResourceEntry& a, Resources_ResourceEntry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Resources_ResourceEntry* New() const final {
    return CreateMaybeMessage<Resources_ResourceEntry>(nullptr);
  }

  Resources_ResourceEntry* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Resources_ResourceEntry>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Resources_ResourceEntry& from);
  void MergeFrom(const Resources_ResourceEntry& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Resources_ResourceEntry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // .flyteidl.core.Resources.ResourceName name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  ::flyteidl::core::Resources_ResourceName name() const;
  void set_name(::flyteidl::core::Resources_ResourceName value);

  // @@protoc_insertion_point(class_scope:flyteidl.core.Resources.ResourceEntry)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  int name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2ftasks_2eproto;
};
// -------------------------------------------------------------------

class Resources final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.Resources) */ {
 public:
  Resources();
  virtual ~Resources();

  Resources(const Resources& from);

  inline Resources& operator=(const Resources& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Resources(Resources&& from) noexcept
    : Resources() {
    *this = ::std::move(from);
  }

  inline Resources& operator=(Resources&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Resources& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Resources* internal_default_instance() {
    return reinterpret_cast<const Resources*>(
               &_Resources_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Resources* other);
  friend void swap(Resources& a, Resources& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Resources* New() const final {
    return CreateMaybeMessage<Resources>(nullptr);
  }

  Resources* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Resources>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Resources& from);
  void MergeFrom(const Resources& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Resources* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Resources_ResourceEntry ResourceEntry;

  typedef Resources_ResourceName ResourceName;
  static const ResourceName UNKNOWN =
    Resources_ResourceName_UNKNOWN;
  static const ResourceName CPU =
    Resources_ResourceName_CPU;
  static const ResourceName GPU =
    Resources_ResourceName_GPU;
  static const ResourceName MEMORY =
    Resources_ResourceName_MEMORY;
  static const ResourceName STORAGE =
    Resources_ResourceName_STORAGE;
  static inline bool ResourceName_IsValid(int value) {
    return Resources_ResourceName_IsValid(value);
  }
  static const ResourceName ResourceName_MIN =
    Resources_ResourceName_ResourceName_MIN;
  static const ResourceName ResourceName_MAX =
    Resources_ResourceName_ResourceName_MAX;
  static const int ResourceName_ARRAYSIZE =
    Resources_ResourceName_ResourceName_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ResourceName_descriptor() {
    return Resources_ResourceName_descriptor();
  }
  static inline const ::std::string& ResourceName_Name(ResourceName value) {
    return Resources_ResourceName_Name(value);
  }
  static inline bool ResourceName_Parse(const ::std::string& name,
      ResourceName* value) {
    return Resources_ResourceName_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .flyteidl.core.Resources.ResourceEntry requests = 1;
  int requests_size() const;
  void clear_requests();
  static const int kRequestsFieldNumber = 1;
  ::flyteidl::core::Resources_ResourceEntry* mutable_requests(int index);
  ::google::protobuf::RepeatedPtrField< ::flyteidl::core::Resources_ResourceEntry >*
      mutable_requests();
  const ::flyteidl::core::Resources_ResourceEntry& requests(int index) const;
  ::flyteidl::core::Resources_ResourceEntry* add_requests();
  const ::google::protobuf::RepeatedPtrField< ::flyteidl::core::Resources_ResourceEntry >&
      requests() const;

  // repeated .flyteidl.core.Resources.ResourceEntry limits = 2;
  int limits_size() const;
  void clear_limits();
  static const int kLimitsFieldNumber = 2;
  ::flyteidl::core::Resources_ResourceEntry* mutable_limits(int index);
  ::google::protobuf::RepeatedPtrField< ::flyteidl::core::Resources_ResourceEntry >*
      mutable_limits();
  const ::flyteidl::core::Resources_ResourceEntry& limits(int index) const;
  ::flyteidl::core::Resources_ResourceEntry* add_limits();
  const ::google::protobuf::RepeatedPtrField< ::flyteidl::core::Resources_ResourceEntry >&
      limits() const;

  // @@protoc_insertion_point(class_scope:flyteidl.core.Resources)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::flyteidl::core::Resources_ResourceEntry > requests_;
  ::google::protobuf::RepeatedPtrField< ::flyteidl::core::Resources_ResourceEntry > limits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2ftasks_2eproto;
};
// -------------------------------------------------------------------

class RuntimeMetadata final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.RuntimeMetadata) */ {
 public:
  RuntimeMetadata();
  virtual ~RuntimeMetadata();

  RuntimeMetadata(const RuntimeMetadata& from);

  inline RuntimeMetadata& operator=(const RuntimeMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RuntimeMetadata(RuntimeMetadata&& from) noexcept
    : RuntimeMetadata() {
    *this = ::std::move(from);
  }

  inline RuntimeMetadata& operator=(RuntimeMetadata&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RuntimeMetadata& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RuntimeMetadata* internal_default_instance() {
    return reinterpret_cast<const RuntimeMetadata*>(
               &_RuntimeMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(RuntimeMetadata* other);
  friend void swap(RuntimeMetadata& a, RuntimeMetadata& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RuntimeMetadata* New() const final {
    return CreateMaybeMessage<RuntimeMetadata>(nullptr);
  }

  RuntimeMetadata* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RuntimeMetadata>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RuntimeMetadata& from);
  void MergeFrom(const RuntimeMetadata& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RuntimeMetadata* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RuntimeMetadata_RuntimeType RuntimeType;
  static const RuntimeType OTHER =
    RuntimeMetadata_RuntimeType_OTHER;
  static const RuntimeType FLYTE_SDK =
    RuntimeMetadata_RuntimeType_FLYTE_SDK;
  static inline bool RuntimeType_IsValid(int value) {
    return RuntimeMetadata_RuntimeType_IsValid(value);
  }
  static const RuntimeType RuntimeType_MIN =
    RuntimeMetadata_RuntimeType_RuntimeType_MIN;
  static const RuntimeType RuntimeType_MAX =
    RuntimeMetadata_RuntimeType_RuntimeType_MAX;
  static const int RuntimeType_ARRAYSIZE =
    RuntimeMetadata_RuntimeType_RuntimeType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RuntimeType_descriptor() {
    return RuntimeMetadata_RuntimeType_descriptor();
  }
  static inline const ::std::string& RuntimeType_Name(RuntimeType value) {
    return RuntimeMetadata_RuntimeType_Name(value);
  }
  static inline bool RuntimeType_Parse(const ::std::string& name,
      RuntimeType* value) {
    return RuntimeMetadata_RuntimeType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string version = 2;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // string flavor = 3;
  void clear_flavor();
  static const int kFlavorFieldNumber = 3;
  const ::std::string& flavor() const;
  void set_flavor(const ::std::string& value);
  #if LANG_CXX11
  void set_flavor(::std::string&& value);
  #endif
  void set_flavor(const char* value);
  void set_flavor(const char* value, size_t size);
  ::std::string* mutable_flavor();
  ::std::string* release_flavor();
  void set_allocated_flavor(::std::string* flavor);

  // .flyteidl.core.RuntimeMetadata.RuntimeType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::flyteidl::core::RuntimeMetadata_RuntimeType type() const;
  void set_type(::flyteidl::core::RuntimeMetadata_RuntimeType value);

  // @@protoc_insertion_point(class_scope:flyteidl.core.RuntimeMetadata)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr flavor_;
  int type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2ftasks_2eproto;
};
// -------------------------------------------------------------------

class TaskMetadata final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.TaskMetadata) */ {
 public:
  TaskMetadata();
  virtual ~TaskMetadata();

  TaskMetadata(const TaskMetadata& from);

  inline TaskMetadata& operator=(const TaskMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TaskMetadata(TaskMetadata&& from) noexcept
    : TaskMetadata() {
    *this = ::std::move(from);
  }

  inline TaskMetadata& operator=(TaskMetadata&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TaskMetadata& default_instance();

  enum InterruptibleValueCase {
    kInterruptible = 8,
    INTERRUPTIBLE_VALUE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TaskMetadata* internal_default_instance() {
    return reinterpret_cast<const TaskMetadata*>(
               &_TaskMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(TaskMetadata* other);
  friend void swap(TaskMetadata& a, TaskMetadata& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TaskMetadata* New() const final {
    return CreateMaybeMessage<TaskMetadata>(nullptr);
  }

  TaskMetadata* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TaskMetadata>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TaskMetadata& from);
  void MergeFrom(const TaskMetadata& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskMetadata* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string discovery_version = 6;
  void clear_discovery_version();
  static const int kDiscoveryVersionFieldNumber = 6;
  const ::std::string& discovery_version() const;
  void set_discovery_version(const ::std::string& value);
  #if LANG_CXX11
  void set_discovery_version(::std::string&& value);
  #endif
  void set_discovery_version(const char* value);
  void set_discovery_version(const char* value, size_t size);
  ::std::string* mutable_discovery_version();
  ::std::string* release_discovery_version();
  void set_allocated_discovery_version(::std::string* discovery_version);

  // string deprecated_error_message = 7;
  void clear_deprecated_error_message();
  static const int kDeprecatedErrorMessageFieldNumber = 7;
  const ::std::string& deprecated_error_message() const;
  void set_deprecated_error_message(const ::std::string& value);
  #if LANG_CXX11
  void set_deprecated_error_message(::std::string&& value);
  #endif
  void set_deprecated_error_message(const char* value);
  void set_deprecated_error_message(const char* value, size_t size);
  ::std::string* mutable_deprecated_error_message();
  ::std::string* release_deprecated_error_message();
  void set_allocated_deprecated_error_message(::std::string* deprecated_error_message);

  // .flyteidl.core.RuntimeMetadata runtime = 2;
  bool has_runtime() const;
  void clear_runtime();
  static const int kRuntimeFieldNumber = 2;
  const ::flyteidl::core::RuntimeMetadata& runtime() const;
  ::flyteidl::core::RuntimeMetadata* release_runtime();
  ::flyteidl::core::RuntimeMetadata* mutable_runtime();
  void set_allocated_runtime(::flyteidl::core::RuntimeMetadata* runtime);

  // .google.protobuf.Duration timeout = 4;
  bool has_timeout() const;
  void clear_timeout();
  static const int kTimeoutFieldNumber = 4;
  const ::google::protobuf::Duration& timeout() const;
  ::google::protobuf::Duration* release_timeout();
  ::google::protobuf::Duration* mutable_timeout();
  void set_allocated_timeout(::google::protobuf::Duration* timeout);

  // .flyteidl.core.RetryStrategy retries = 5;
  bool has_retries() const;
  void clear_retries();
  static const int kRetriesFieldNumber = 5;
  const ::flyteidl::core::RetryStrategy& retries() const;
  ::flyteidl::core::RetryStrategy* release_retries();
  ::flyteidl::core::RetryStrategy* mutable_retries();
  void set_allocated_retries(::flyteidl::core::RetryStrategy* retries);

  // bool discoverable = 1;
  void clear_discoverable();
  static const int kDiscoverableFieldNumber = 1;
  bool discoverable() const;
  void set_discoverable(bool value);

  // bool interruptible = 8;
  private:
  bool has_interruptible() const;
  public:
  void clear_interruptible();
  static const int kInterruptibleFieldNumber = 8;
  bool interruptible() const;
  void set_interruptible(bool value);

  void clear_interruptible_value();
  InterruptibleValueCase interruptible_value_case() const;
  // @@protoc_insertion_point(class_scope:flyteidl.core.TaskMetadata)
 private:
  class HasBitSetters;
  void set_has_interruptible();

  inline bool has_interruptible_value() const;
  inline void clear_has_interruptible_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr discovery_version_;
  ::google::protobuf::internal::ArenaStringPtr deprecated_error_message_;
  ::flyteidl::core::RuntimeMetadata* runtime_;
  ::google::protobuf::Duration* timeout_;
  ::flyteidl::core::RetryStrategy* retries_;
  bool discoverable_;
  union InterruptibleValueUnion {
    InterruptibleValueUnion() {}
    bool interruptible_;
  } interruptible_value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_flyteidl_2fcore_2ftasks_2eproto;
};
// -------------------------------------------------------------------

class TaskTemplate final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.TaskTemplate) */ {
 public:
  TaskTemplate();
  virtual ~TaskTemplate();

  TaskTemplate(const TaskTemplate& from);

  inline TaskTemplate& operator=(const TaskTemplate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TaskTemplate(TaskTemplate&& from) noexcept
    : TaskTemplate() {
    *this = ::std::move(from);
  }

  inline TaskTemplate& operator=(TaskTemplate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TaskTemplate& default_instance();

  enum TargetCase {
    kContainer = 6,
    TARGET_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TaskTemplate* internal_default_instance() {
    return reinterpret_cast<const TaskTemplate*>(
               &_TaskTemplate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(TaskTemplate* other);
  friend void swap(TaskTemplate& a, TaskTemplate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TaskTemplate* New() const final {
    return CreateMaybeMessage<TaskTemplate>(nullptr);
  }

  TaskTemplate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TaskTemplate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TaskTemplate& from);
  void MergeFrom(const TaskTemplate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskTemplate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // .flyteidl.core.Identifier id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::flyteidl::core::Identifier& id() const;
  ::flyteidl::core::Identifier* release_id();
  ::flyteidl::core::Identifier* mutable_id();
  void set_allocated_id(::flyteidl::core::Identifier* id);

  // .flyteidl.core.TaskMetadata metadata = 3;
  bool has_metadata() const;
  void clear_metadata();
  static const int kMetadataFieldNumber = 3;
  const ::flyteidl::core::TaskMetadata& metadata() const;
  ::flyteidl::core::TaskMetadata* release_metadata();
  ::flyteidl::core::TaskMetadata* mutable_metadata();
  void set_allocated_metadata(::flyteidl::core::TaskMetadata* metadata);

  // .flyteidl.core.TypedInterface interface = 4;
  bool has_interface() const;
  void clear_interface();
  static const int kInterfaceFieldNumber = 4;
  const ::flyteidl::core::TypedInterface& interface() const;
  ::flyteidl::core::TypedInterface* release_interface();
  ::flyteidl::core::TypedInterface* mutable_interface();
  void set_allocated_interface(::flyteidl::core::TypedInterface* interface);

  // .google.protobuf.Struct custom = 5;
  bool has_custom() const;
  void clear_custom();
  static const int kCustomFieldNumber = 5;
  const ::google::protobuf::Struct& custom() const;
  ::google::protobuf::Struct* release_custom();
  ::google::protobuf::Struct* mutable_custom();
  void set_allocated_custom(::google::protobuf::Struct* custom);

  // .flyteidl.core.Container container = 6;
  bool has_container() const;
  void clear_container();
  static const int kContainerFieldNumber = 6;
  const ::flyteidl::core::Container& container() const;
  ::flyteidl::core::Container* release_container();
  ::flyteidl::core::Container* mutable_container();
  void set_allocated_container(::flyteidl::core::Container* container);

  void clear_target();
  TargetCase target_case() const;
  // @@protoc_insertion_point(class_scope:flyteidl.core.TaskTemplate)
 private:
  class HasBitSetters;
  void set_has_container();

  inline bool has_target() const;
  inline void clear_has_target();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::flyteidl::core::Identifier* id_;
  ::flyteidl::core::TaskMetadata* metadata_;
  ::flyteidl::core::TypedInterface* interface_;
  ::google::protobuf::Struct* custom_;
  union TargetUnion {
    TargetUnion() {}
    ::flyteidl::core::Container* container_;
  } target_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_flyteidl_2fcore_2ftasks_2eproto;
};
// -------------------------------------------------------------------

class ContainerPort final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.ContainerPort) */ {
 public:
  ContainerPort();
  virtual ~ContainerPort();

  ContainerPort(const ContainerPort& from);

  inline ContainerPort& operator=(const ContainerPort& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ContainerPort(ContainerPort&& from) noexcept
    : ContainerPort() {
    *this = ::std::move(from);
  }

  inline ContainerPort& operator=(ContainerPort&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ContainerPort& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ContainerPort* internal_default_instance() {
    return reinterpret_cast<const ContainerPort*>(
               &_ContainerPort_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(ContainerPort* other);
  friend void swap(ContainerPort& a, ContainerPort& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ContainerPort* New() const final {
    return CreateMaybeMessage<ContainerPort>(nullptr);
  }

  ContainerPort* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ContainerPort>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ContainerPort& from);
  void MergeFrom(const ContainerPort& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContainerPort* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 container_port = 1;
  void clear_container_port();
  static const int kContainerPortFieldNumber = 1;
  ::google::protobuf::uint32 container_port() const;
  void set_container_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:flyteidl.core.ContainerPort)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 container_port_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2ftasks_2eproto;
};
// -------------------------------------------------------------------

class Container final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.Container) */ {
 public:
  Container();
  virtual ~Container();

  Container(const Container& from);

  inline Container& operator=(const Container& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Container(Container&& from) noexcept
    : Container() {
    *this = ::std::move(from);
  }

  inline Container& operator=(Container&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Container& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Container* internal_default_instance() {
    return reinterpret_cast<const Container*>(
               &_Container_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Container* other);
  friend void swap(Container& a, Container& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Container* New() const final {
    return CreateMaybeMessage<Container>(nullptr);
  }

  Container* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Container>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Container& from);
  void MergeFrom(const Container& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Container* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string command = 2;
  int command_size() const;
  void clear_command();
  static const int kCommandFieldNumber = 2;
  const ::std::string& command(int index) const;
  ::std::string* mutable_command(int index);
  void set_command(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_command(int index, ::std::string&& value);
  #endif
  void set_command(int index, const char* value);
  void set_command(int index, const char* value, size_t size);
  ::std::string* add_command();
  void add_command(const ::std::string& value);
  #if LANG_CXX11
  void add_command(::std::string&& value);
  #endif
  void add_command(const char* value);
  void add_command(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& command() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_command();

  // repeated string args = 3;
  int args_size() const;
  void clear_args();
  static const int kArgsFieldNumber = 3;
  const ::std::string& args(int index) const;
  ::std::string* mutable_args(int index);
  void set_args(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_args(int index, ::std::string&& value);
  #endif
  void set_args(int index, const char* value);
  void set_args(int index, const char* value, size_t size);
  ::std::string* add_args();
  void add_args(const ::std::string& value);
  #if LANG_CXX11
  void add_args(::std::string&& value);
  #endif
  void add_args(const char* value);
  void add_args(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& args() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_args();

  // repeated .flyteidl.core.KeyValuePair env = 5;
  int env_size() const;
  void clear_env();
  static const int kEnvFieldNumber = 5;
  ::flyteidl::core::KeyValuePair* mutable_env(int index);
  ::google::protobuf::RepeatedPtrField< ::flyteidl::core::KeyValuePair >*
      mutable_env();
  const ::flyteidl::core::KeyValuePair& env(int index) const;
  ::flyteidl::core::KeyValuePair* add_env();
  const ::google::protobuf::RepeatedPtrField< ::flyteidl::core::KeyValuePair >&
      env() const;

  // repeated .flyteidl.core.KeyValuePair config = 6;
  int config_size() const;
  void clear_config();
  static const int kConfigFieldNumber = 6;
  ::flyteidl::core::KeyValuePair* mutable_config(int index);
  ::google::protobuf::RepeatedPtrField< ::flyteidl::core::KeyValuePair >*
      mutable_config();
  const ::flyteidl::core::KeyValuePair& config(int index) const;
  ::flyteidl::core::KeyValuePair* add_config();
  const ::google::protobuf::RepeatedPtrField< ::flyteidl::core::KeyValuePair >&
      config() const;

  // repeated .flyteidl.core.ContainerPort ports = 7;
  int ports_size() const;
  void clear_ports();
  static const int kPortsFieldNumber = 7;
  ::flyteidl::core::ContainerPort* mutable_ports(int index);
  ::google::protobuf::RepeatedPtrField< ::flyteidl::core::ContainerPort >*
      mutable_ports();
  const ::flyteidl::core::ContainerPort& ports(int index) const;
  ::flyteidl::core::ContainerPort* add_ports();
  const ::google::protobuf::RepeatedPtrField< ::flyteidl::core::ContainerPort >&
      ports() const;

  // string image = 1;
  void clear_image();
  static const int kImageFieldNumber = 1;
  const ::std::string& image() const;
  void set_image(const ::std::string& value);
  #if LANG_CXX11
  void set_image(::std::string&& value);
  #endif
  void set_image(const char* value);
  void set_image(const char* value, size_t size);
  ::std::string* mutable_image();
  ::std::string* release_image();
  void set_allocated_image(::std::string* image);

  // .flyteidl.core.Resources resources = 4;
  bool has_resources() const;
  void clear_resources();
  static const int kResourcesFieldNumber = 4;
  const ::flyteidl::core::Resources& resources() const;
  ::flyteidl::core::Resources* release_resources();
  ::flyteidl::core::Resources* mutable_resources();
  void set_allocated_resources(::flyteidl::core::Resources* resources);

  // .flyteidl.core.DataLoadingConfig data_config = 9;
  bool has_data_config() const;
  void clear_data_config();
  static const int kDataConfigFieldNumber = 9;
  const ::flyteidl::core::DataLoadingConfig& data_config() const;
  ::flyteidl::core::DataLoadingConfig* release_data_config();
  ::flyteidl::core::DataLoadingConfig* mutable_data_config();
  void set_allocated_data_config(::flyteidl::core::DataLoadingConfig* data_config);

  // @@protoc_insertion_point(class_scope:flyteidl.core.Container)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField<::std::string> command_;
  ::google::protobuf::RepeatedPtrField<::std::string> args_;
  ::google::protobuf::RepeatedPtrField< ::flyteidl::core::KeyValuePair > env_;
  ::google::protobuf::RepeatedPtrField< ::flyteidl::core::KeyValuePair > config_;
  ::google::protobuf::RepeatedPtrField< ::flyteidl::core::ContainerPort > ports_;
  ::google::protobuf::internal::ArenaStringPtr image_;
  ::flyteidl::core::Resources* resources_;
  ::flyteidl::core::DataLoadingConfig* data_config_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2ftasks_2eproto;
};
// -------------------------------------------------------------------

class IOStrategy final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.IOStrategy) */ {
 public:
  IOStrategy();
  virtual ~IOStrategy();

  IOStrategy(const IOStrategy& from);

  inline IOStrategy& operator=(const IOStrategy& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IOStrategy(IOStrategy&& from) noexcept
    : IOStrategy() {
    *this = ::std::move(from);
  }

  inline IOStrategy& operator=(IOStrategy&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const IOStrategy& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IOStrategy* internal_default_instance() {
    return reinterpret_cast<const IOStrategy*>(
               &_IOStrategy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(IOStrategy* other);
  friend void swap(IOStrategy& a, IOStrategy& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IOStrategy* New() const final {
    return CreateMaybeMessage<IOStrategy>(nullptr);
  }

  IOStrategy* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IOStrategy>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const IOStrategy& from);
  void MergeFrom(const IOStrategy& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IOStrategy* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef IOStrategy_DownloadMode DownloadMode;
  static const DownloadMode DOWNLOAD_EAGER =
    IOStrategy_DownloadMode_DOWNLOAD_EAGER;
  static const DownloadMode DOWNLOAD_STREAM =
    IOStrategy_DownloadMode_DOWNLOAD_STREAM;
  static const DownloadMode DO_NOT_DOWNLOAD =
    IOStrategy_DownloadMode_DO_NOT_DOWNLOAD;
  static inline bool DownloadMode_IsValid(int value) {
    return IOStrategy_DownloadMode_IsValid(value);
  }
  static const DownloadMode DownloadMode_MIN =
    IOStrategy_DownloadMode_DownloadMode_MIN;
  static const DownloadMode DownloadMode_MAX =
    IOStrategy_DownloadMode_DownloadMode_MAX;
  static const int DownloadMode_ARRAYSIZE =
    IOStrategy_DownloadMode_DownloadMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DownloadMode_descriptor() {
    return IOStrategy_DownloadMode_descriptor();
  }
  static inline const ::std::string& DownloadMode_Name(DownloadMode value) {
    return IOStrategy_DownloadMode_Name(value);
  }
  static inline bool DownloadMode_Parse(const ::std::string& name,
      DownloadMode* value) {
    return IOStrategy_DownloadMode_Parse(name, value);
  }

  typedef IOStrategy_UploadMode UploadMode;
  static const UploadMode UPLOAD_ON_EXIT =
    IOStrategy_UploadMode_UPLOAD_ON_EXIT;
  static const UploadMode UPLOAD_EAGER =
    IOStrategy_UploadMode_UPLOAD_EAGER;
  static const UploadMode DO_NOT_UPLOAD =
    IOStrategy_UploadMode_DO_NOT_UPLOAD;
  static inline bool UploadMode_IsValid(int value) {
    return IOStrategy_UploadMode_IsValid(value);
  }
  static const UploadMode UploadMode_MIN =
    IOStrategy_UploadMode_UploadMode_MIN;
  static const UploadMode UploadMode_MAX =
    IOStrategy_UploadMode_UploadMode_MAX;
  static const int UploadMode_ARRAYSIZE =
    IOStrategy_UploadMode_UploadMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  UploadMode_descriptor() {
    return IOStrategy_UploadMode_descriptor();
  }
  static inline const ::std::string& UploadMode_Name(UploadMode value) {
    return IOStrategy_UploadMode_Name(value);
  }
  static inline bool UploadMode_Parse(const ::std::string& name,
      UploadMode* value) {
    return IOStrategy_UploadMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .flyteidl.core.IOStrategy.DownloadMode download_mode = 1;
  void clear_download_mode();
  static const int kDownloadModeFieldNumber = 1;
  ::flyteidl::core::IOStrategy_DownloadMode download_mode() const;
  void set_download_mode(::flyteidl::core::IOStrategy_DownloadMode value);

  // .flyteidl.core.IOStrategy.UploadMode upload_mode = 2;
  void clear_upload_mode();
  static const int kUploadModeFieldNumber = 2;
  ::flyteidl::core::IOStrategy_UploadMode upload_mode() const;
  void set_upload_mode(::flyteidl::core::IOStrategy_UploadMode value);

  // @@protoc_insertion_point(class_scope:flyteidl.core.IOStrategy)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int download_mode_;
  int upload_mode_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2ftasks_2eproto;
};
// -------------------------------------------------------------------

class DataLoadingConfig final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.DataLoadingConfig) */ {
 public:
  DataLoadingConfig();
  virtual ~DataLoadingConfig();

  DataLoadingConfig(const DataLoadingConfig& from);

  inline DataLoadingConfig& operator=(const DataLoadingConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DataLoadingConfig(DataLoadingConfig&& from) noexcept
    : DataLoadingConfig() {
    *this = ::std::move(from);
  }

  inline DataLoadingConfig& operator=(DataLoadingConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const DataLoadingConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DataLoadingConfig* internal_default_instance() {
    return reinterpret_cast<const DataLoadingConfig*>(
               &_DataLoadingConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(DataLoadingConfig* other);
  friend void swap(DataLoadingConfig& a, DataLoadingConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DataLoadingConfig* New() const final {
    return CreateMaybeMessage<DataLoadingConfig>(nullptr);
  }

  DataLoadingConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DataLoadingConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DataLoadingConfig& from);
  void MergeFrom(const DataLoadingConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataLoadingConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DataLoadingConfig_LiteralMapFormat LiteralMapFormat;
  static const LiteralMapFormat JSON =
    DataLoadingConfig_LiteralMapFormat_JSON;
  static const LiteralMapFormat YAML =
    DataLoadingConfig_LiteralMapFormat_YAML;
  static const LiteralMapFormat PROTO =
    DataLoadingConfig_LiteralMapFormat_PROTO;
  static inline bool LiteralMapFormat_IsValid(int value) {
    return DataLoadingConfig_LiteralMapFormat_IsValid(value);
  }
  static const LiteralMapFormat LiteralMapFormat_MIN =
    DataLoadingConfig_LiteralMapFormat_LiteralMapFormat_MIN;
  static const LiteralMapFormat LiteralMapFormat_MAX =
    DataLoadingConfig_LiteralMapFormat_LiteralMapFormat_MAX;
  static const int LiteralMapFormat_ARRAYSIZE =
    DataLoadingConfig_LiteralMapFormat_LiteralMapFormat_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LiteralMapFormat_descriptor() {
    return DataLoadingConfig_LiteralMapFormat_descriptor();
  }
  static inline const ::std::string& LiteralMapFormat_Name(LiteralMapFormat value) {
    return DataLoadingConfig_LiteralMapFormat_Name(value);
  }
  static inline bool LiteralMapFormat_Parse(const ::std::string& name,
      LiteralMapFormat* value) {
    return DataLoadingConfig_LiteralMapFormat_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string input_path = 2;
  void clear_input_path();
  static const int kInputPathFieldNumber = 2;
  const ::std::string& input_path() const;
  void set_input_path(const ::std::string& value);
  #if LANG_CXX11
  void set_input_path(::std::string&& value);
  #endif
  void set_input_path(const char* value);
  void set_input_path(const char* value, size_t size);
  ::std::string* mutable_input_path();
  ::std::string* release_input_path();
  void set_allocated_input_path(::std::string* input_path);

  // string output_path = 3;
  void clear_output_path();
  static const int kOutputPathFieldNumber = 3;
  const ::std::string& output_path() const;
  void set_output_path(const ::std::string& value);
  #if LANG_CXX11
  void set_output_path(::std::string&& value);
  #endif
  void set_output_path(const char* value);
  void set_output_path(const char* value, size_t size);
  ::std::string* mutable_output_path();
  ::std::string* release_output_path();
  void set_allocated_output_path(::std::string* output_path);

  // .flyteidl.core.IOStrategy io_strategy = 5;
  bool has_io_strategy() const;
  void clear_io_strategy();
  static const int kIoStrategyFieldNumber = 5;
  const ::flyteidl::core::IOStrategy& io_strategy() const;
  ::flyteidl::core::IOStrategy* release_io_strategy();
  ::flyteidl::core::IOStrategy* mutable_io_strategy();
  void set_allocated_io_strategy(::flyteidl::core::IOStrategy* io_strategy);

  // bool enabled = 1;
  void clear_enabled();
  static const int kEnabledFieldNumber = 1;
  bool enabled() const;
  void set_enabled(bool value);

  // .flyteidl.core.DataLoadingConfig.LiteralMapFormat format = 4;
  void clear_format();
  static const int kFormatFieldNumber = 4;
  ::flyteidl::core::DataLoadingConfig_LiteralMapFormat format() const;
  void set_format(::flyteidl::core::DataLoadingConfig_LiteralMapFormat value);

  // @@protoc_insertion_point(class_scope:flyteidl.core.DataLoadingConfig)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr input_path_;
  ::google::protobuf::internal::ArenaStringPtr output_path_;
  ::flyteidl::core::IOStrategy* io_strategy_;
  bool enabled_;
  int format_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2ftasks_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Resources_ResourceEntry

// .flyteidl.core.Resources.ResourceName name = 1;
inline void Resources_ResourceEntry::clear_name() {
  name_ = 0;
}
inline ::flyteidl::core::Resources_ResourceName Resources_ResourceEntry::name() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Resources.ResourceEntry.name)
  return static_cast< ::flyteidl::core::Resources_ResourceName >(name_);
}
inline void Resources_ResourceEntry::set_name(::flyteidl::core::Resources_ResourceName value) {
  
  name_ = value;
  // @@protoc_insertion_point(field_set:flyteidl.core.Resources.ResourceEntry.name)
}

// string value = 2;
inline void Resources_ResourceEntry::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Resources_ResourceEntry::value() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Resources.ResourceEntry.value)
  return value_.GetNoArena();
}
inline void Resources_ResourceEntry::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.Resources.ResourceEntry.value)
}
#if LANG_CXX11
inline void Resources_ResourceEntry::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.Resources.ResourceEntry.value)
}
#endif
inline void Resources_ResourceEntry::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.Resources.ResourceEntry.value)
}
inline void Resources_ResourceEntry::set_value(const char* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.Resources.ResourceEntry.value)
}
inline ::std::string* Resources_ResourceEntry::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Resources.ResourceEntry.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Resources_ResourceEntry::release_value() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Resources.ResourceEntry.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Resources_ResourceEntry::set_allocated_value(::std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.Resources.ResourceEntry.value)
}

// -------------------------------------------------------------------

// Resources

// repeated .flyteidl.core.Resources.ResourceEntry requests = 1;
inline int Resources::requests_size() const {
  return requests_.size();
}
inline void Resources::clear_requests() {
  requests_.Clear();
}
inline ::flyteidl::core::Resources_ResourceEntry* Resources::mutable_requests(int index) {
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Resources.requests)
  return requests_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::flyteidl::core::Resources_ResourceEntry >*
Resources::mutable_requests() {
  // @@protoc_insertion_point(field_mutable_list:flyteidl.core.Resources.requests)
  return &requests_;
}
inline const ::flyteidl::core::Resources_ResourceEntry& Resources::requests(int index) const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Resources.requests)
  return requests_.Get(index);
}
inline ::flyteidl::core::Resources_ResourceEntry* Resources::add_requests() {
  // @@protoc_insertion_point(field_add:flyteidl.core.Resources.requests)
  return requests_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::flyteidl::core::Resources_ResourceEntry >&
Resources::requests() const {
  // @@protoc_insertion_point(field_list:flyteidl.core.Resources.requests)
  return requests_;
}

// repeated .flyteidl.core.Resources.ResourceEntry limits = 2;
inline int Resources::limits_size() const {
  return limits_.size();
}
inline void Resources::clear_limits() {
  limits_.Clear();
}
inline ::flyteidl::core::Resources_ResourceEntry* Resources::mutable_limits(int index) {
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Resources.limits)
  return limits_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::flyteidl::core::Resources_ResourceEntry >*
Resources::mutable_limits() {
  // @@protoc_insertion_point(field_mutable_list:flyteidl.core.Resources.limits)
  return &limits_;
}
inline const ::flyteidl::core::Resources_ResourceEntry& Resources::limits(int index) const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Resources.limits)
  return limits_.Get(index);
}
inline ::flyteidl::core::Resources_ResourceEntry* Resources::add_limits() {
  // @@protoc_insertion_point(field_add:flyteidl.core.Resources.limits)
  return limits_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::flyteidl::core::Resources_ResourceEntry >&
Resources::limits() const {
  // @@protoc_insertion_point(field_list:flyteidl.core.Resources.limits)
  return limits_;
}

// -------------------------------------------------------------------

// RuntimeMetadata

// .flyteidl.core.RuntimeMetadata.RuntimeType type = 1;
inline void RuntimeMetadata::clear_type() {
  type_ = 0;
}
inline ::flyteidl::core::RuntimeMetadata_RuntimeType RuntimeMetadata::type() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.RuntimeMetadata.type)
  return static_cast< ::flyteidl::core::RuntimeMetadata_RuntimeType >(type_);
}
inline void RuntimeMetadata::set_type(::flyteidl::core::RuntimeMetadata_RuntimeType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:flyteidl.core.RuntimeMetadata.type)
}

// string version = 2;
inline void RuntimeMetadata::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RuntimeMetadata::version() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.RuntimeMetadata.version)
  return version_.GetNoArena();
}
inline void RuntimeMetadata::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.RuntimeMetadata.version)
}
#if LANG_CXX11
inline void RuntimeMetadata::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.RuntimeMetadata.version)
}
#endif
inline void RuntimeMetadata::set_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.RuntimeMetadata.version)
}
inline void RuntimeMetadata::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.RuntimeMetadata.version)
}
inline ::std::string* RuntimeMetadata::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.RuntimeMetadata.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RuntimeMetadata::release_version() {
  // @@protoc_insertion_point(field_release:flyteidl.core.RuntimeMetadata.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RuntimeMetadata::set_allocated_version(::std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.RuntimeMetadata.version)
}

// string flavor = 3;
inline void RuntimeMetadata::clear_flavor() {
  flavor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RuntimeMetadata::flavor() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.RuntimeMetadata.flavor)
  return flavor_.GetNoArena();
}
inline void RuntimeMetadata::set_flavor(const ::std::string& value) {
  
  flavor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.RuntimeMetadata.flavor)
}
#if LANG_CXX11
inline void RuntimeMetadata::set_flavor(::std::string&& value) {
  
  flavor_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.RuntimeMetadata.flavor)
}
#endif
inline void RuntimeMetadata::set_flavor(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  flavor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.RuntimeMetadata.flavor)
}
inline void RuntimeMetadata::set_flavor(const char* value, size_t size) {
  
  flavor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.RuntimeMetadata.flavor)
}
inline ::std::string* RuntimeMetadata::mutable_flavor() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.RuntimeMetadata.flavor)
  return flavor_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RuntimeMetadata::release_flavor() {
  // @@protoc_insertion_point(field_release:flyteidl.core.RuntimeMetadata.flavor)
  
  return flavor_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RuntimeMetadata::set_allocated_flavor(::std::string* flavor) {
  if (flavor != nullptr) {
    
  } else {
    
  }
  flavor_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), flavor);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.RuntimeMetadata.flavor)
}

// -------------------------------------------------------------------

// TaskMetadata

// bool discoverable = 1;
inline void TaskMetadata::clear_discoverable() {
  discoverable_ = false;
}
inline bool TaskMetadata::discoverable() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.TaskMetadata.discoverable)
  return discoverable_;
}
inline void TaskMetadata::set_discoverable(bool value) {
  
  discoverable_ = value;
  // @@protoc_insertion_point(field_set:flyteidl.core.TaskMetadata.discoverable)
}

// .flyteidl.core.RuntimeMetadata runtime = 2;
inline bool TaskMetadata::has_runtime() const {
  return this != internal_default_instance() && runtime_ != nullptr;
}
inline void TaskMetadata::clear_runtime() {
  if (GetArenaNoVirtual() == nullptr && runtime_ != nullptr) {
    delete runtime_;
  }
  runtime_ = nullptr;
}
inline const ::flyteidl::core::RuntimeMetadata& TaskMetadata::runtime() const {
  const ::flyteidl::core::RuntimeMetadata* p = runtime_;
  // @@protoc_insertion_point(field_get:flyteidl.core.TaskMetadata.runtime)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::RuntimeMetadata*>(
      &::flyteidl::core::_RuntimeMetadata_default_instance_);
}
inline ::flyteidl::core::RuntimeMetadata* TaskMetadata::release_runtime() {
  // @@protoc_insertion_point(field_release:flyteidl.core.TaskMetadata.runtime)
  
  ::flyteidl::core::RuntimeMetadata* temp = runtime_;
  runtime_ = nullptr;
  return temp;
}
inline ::flyteidl::core::RuntimeMetadata* TaskMetadata::mutable_runtime() {
  
  if (runtime_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::RuntimeMetadata>(GetArenaNoVirtual());
    runtime_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.TaskMetadata.runtime)
  return runtime_;
}
inline void TaskMetadata::set_allocated_runtime(::flyteidl::core::RuntimeMetadata* runtime) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete runtime_;
  }
  if (runtime) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      runtime = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, runtime, submessage_arena);
    }
    
  } else {
    
  }
  runtime_ = runtime;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.TaskMetadata.runtime)
}

// .google.protobuf.Duration timeout = 4;
inline bool TaskMetadata::has_timeout() const {
  return this != internal_default_instance() && timeout_ != nullptr;
}
inline const ::google::protobuf::Duration& TaskMetadata::timeout() const {
  const ::google::protobuf::Duration* p = timeout_;
  // @@protoc_insertion_point(field_get:flyteidl.core.TaskMetadata.timeout)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::Duration*>(
      &::google::protobuf::_Duration_default_instance_);
}
inline ::google::protobuf::Duration* TaskMetadata::release_timeout() {
  // @@protoc_insertion_point(field_release:flyteidl.core.TaskMetadata.timeout)
  
  ::google::protobuf::Duration* temp = timeout_;
  timeout_ = nullptr;
  return temp;
}
inline ::google::protobuf::Duration* TaskMetadata::mutable_timeout() {
  
  if (timeout_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Duration>(GetArenaNoVirtual());
    timeout_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.TaskMetadata.timeout)
  return timeout_;
}
inline void TaskMetadata::set_allocated_timeout(::google::protobuf::Duration* timeout) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(timeout_);
  }
  if (timeout) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(timeout)->GetArena();
    if (message_arena != submessage_arena) {
      timeout = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, timeout, submessage_arena);
    }
    
  } else {
    
  }
  timeout_ = timeout;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.TaskMetadata.timeout)
}

// .flyteidl.core.RetryStrategy retries = 5;
inline bool TaskMetadata::has_retries() const {
  return this != internal_default_instance() && retries_ != nullptr;
}
inline const ::flyteidl::core::RetryStrategy& TaskMetadata::retries() const {
  const ::flyteidl::core::RetryStrategy* p = retries_;
  // @@protoc_insertion_point(field_get:flyteidl.core.TaskMetadata.retries)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::RetryStrategy*>(
      &::flyteidl::core::_RetryStrategy_default_instance_);
}
inline ::flyteidl::core::RetryStrategy* TaskMetadata::release_retries() {
  // @@protoc_insertion_point(field_release:flyteidl.core.TaskMetadata.retries)
  
  ::flyteidl::core::RetryStrategy* temp = retries_;
  retries_ = nullptr;
  return temp;
}
inline ::flyteidl::core::RetryStrategy* TaskMetadata::mutable_retries() {
  
  if (retries_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::RetryStrategy>(GetArenaNoVirtual());
    retries_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.TaskMetadata.retries)
  return retries_;
}
inline void TaskMetadata::set_allocated_retries(::flyteidl::core::RetryStrategy* retries) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(retries_);
  }
  if (retries) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      retries = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, retries, submessage_arena);
    }
    
  } else {
    
  }
  retries_ = retries;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.TaskMetadata.retries)
}

// string discovery_version = 6;
inline void TaskMetadata::clear_discovery_version() {
  discovery_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TaskMetadata::discovery_version() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.TaskMetadata.discovery_version)
  return discovery_version_.GetNoArena();
}
inline void TaskMetadata::set_discovery_version(const ::std::string& value) {
  
  discovery_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.TaskMetadata.discovery_version)
}
#if LANG_CXX11
inline void TaskMetadata::set_discovery_version(::std::string&& value) {
  
  discovery_version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.TaskMetadata.discovery_version)
}
#endif
inline void TaskMetadata::set_discovery_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  discovery_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.TaskMetadata.discovery_version)
}
inline void TaskMetadata::set_discovery_version(const char* value, size_t size) {
  
  discovery_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.TaskMetadata.discovery_version)
}
inline ::std::string* TaskMetadata::mutable_discovery_version() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.TaskMetadata.discovery_version)
  return discovery_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TaskMetadata::release_discovery_version() {
  // @@protoc_insertion_point(field_release:flyteidl.core.TaskMetadata.discovery_version)
  
  return discovery_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TaskMetadata::set_allocated_discovery_version(::std::string* discovery_version) {
  if (discovery_version != nullptr) {
    
  } else {
    
  }
  discovery_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), discovery_version);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.TaskMetadata.discovery_version)
}

// string deprecated_error_message = 7;
inline void TaskMetadata::clear_deprecated_error_message() {
  deprecated_error_message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TaskMetadata::deprecated_error_message() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.TaskMetadata.deprecated_error_message)
  return deprecated_error_message_.GetNoArena();
}
inline void TaskMetadata::set_deprecated_error_message(const ::std::string& value) {
  
  deprecated_error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.TaskMetadata.deprecated_error_message)
}
#if LANG_CXX11
inline void TaskMetadata::set_deprecated_error_message(::std::string&& value) {
  
  deprecated_error_message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.TaskMetadata.deprecated_error_message)
}
#endif
inline void TaskMetadata::set_deprecated_error_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  deprecated_error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.TaskMetadata.deprecated_error_message)
}
inline void TaskMetadata::set_deprecated_error_message(const char* value, size_t size) {
  
  deprecated_error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.TaskMetadata.deprecated_error_message)
}
inline ::std::string* TaskMetadata::mutable_deprecated_error_message() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.TaskMetadata.deprecated_error_message)
  return deprecated_error_message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TaskMetadata::release_deprecated_error_message() {
  // @@protoc_insertion_point(field_release:flyteidl.core.TaskMetadata.deprecated_error_message)
  
  return deprecated_error_message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TaskMetadata::set_allocated_deprecated_error_message(::std::string* deprecated_error_message) {
  if (deprecated_error_message != nullptr) {
    
  } else {
    
  }
  deprecated_error_message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), deprecated_error_message);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.TaskMetadata.deprecated_error_message)
}

// bool interruptible = 8;
inline bool TaskMetadata::has_interruptible() const {
  return interruptible_value_case() == kInterruptible;
}
inline void TaskMetadata::set_has_interruptible() {
  _oneof_case_[0] = kInterruptible;
}
inline void TaskMetadata::clear_interruptible() {
  if (has_interruptible()) {
    interruptible_value_.interruptible_ = false;
    clear_has_interruptible_value();
  }
}
inline bool TaskMetadata::interruptible() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.TaskMetadata.interruptible)
  if (has_interruptible()) {
    return interruptible_value_.interruptible_;
  }
  return false;
}
inline void TaskMetadata::set_interruptible(bool value) {
  if (!has_interruptible()) {
    clear_interruptible_value();
    set_has_interruptible();
  }
  interruptible_value_.interruptible_ = value;
  // @@protoc_insertion_point(field_set:flyteidl.core.TaskMetadata.interruptible)
}

inline bool TaskMetadata::has_interruptible_value() const {
  return interruptible_value_case() != INTERRUPTIBLE_VALUE_NOT_SET;
}
inline void TaskMetadata::clear_has_interruptible_value() {
  _oneof_case_[0] = INTERRUPTIBLE_VALUE_NOT_SET;
}
inline TaskMetadata::InterruptibleValueCase TaskMetadata::interruptible_value_case() const {
  return TaskMetadata::InterruptibleValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// TaskTemplate

// .flyteidl.core.Identifier id = 1;
inline bool TaskTemplate::has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline const ::flyteidl::core::Identifier& TaskTemplate::id() const {
  const ::flyteidl::core::Identifier* p = id_;
  // @@protoc_insertion_point(field_get:flyteidl.core.TaskTemplate.id)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::Identifier*>(
      &::flyteidl::core::_Identifier_default_instance_);
}
inline ::flyteidl::core::Identifier* TaskTemplate::release_id() {
  // @@protoc_insertion_point(field_release:flyteidl.core.TaskTemplate.id)
  
  ::flyteidl::core::Identifier* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::flyteidl::core::Identifier* TaskTemplate::mutable_id() {
  
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::Identifier>(GetArenaNoVirtual());
    id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.TaskTemplate.id)
  return id_;
}
inline void TaskTemplate::set_allocated_id(::flyteidl::core::Identifier* id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(id_);
  }
  if (id) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.TaskTemplate.id)
}

// string type = 2;
inline void TaskTemplate::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TaskTemplate::type() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.TaskTemplate.type)
  return type_.GetNoArena();
}
inline void TaskTemplate::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.TaskTemplate.type)
}
#if LANG_CXX11
inline void TaskTemplate::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.TaskTemplate.type)
}
#endif
inline void TaskTemplate::set_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.TaskTemplate.type)
}
inline void TaskTemplate::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.TaskTemplate.type)
}
inline ::std::string* TaskTemplate::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.TaskTemplate.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TaskTemplate::release_type() {
  // @@protoc_insertion_point(field_release:flyteidl.core.TaskTemplate.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TaskTemplate::set_allocated_type(::std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.TaskTemplate.type)
}

// .flyteidl.core.TaskMetadata metadata = 3;
inline bool TaskTemplate::has_metadata() const {
  return this != internal_default_instance() && metadata_ != nullptr;
}
inline void TaskTemplate::clear_metadata() {
  if (GetArenaNoVirtual() == nullptr && metadata_ != nullptr) {
    delete metadata_;
  }
  metadata_ = nullptr;
}
inline const ::flyteidl::core::TaskMetadata& TaskTemplate::metadata() const {
  const ::flyteidl::core::TaskMetadata* p = metadata_;
  // @@protoc_insertion_point(field_get:flyteidl.core.TaskTemplate.metadata)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::TaskMetadata*>(
      &::flyteidl::core::_TaskMetadata_default_instance_);
}
inline ::flyteidl::core::TaskMetadata* TaskTemplate::release_metadata() {
  // @@protoc_insertion_point(field_release:flyteidl.core.TaskTemplate.metadata)
  
  ::flyteidl::core::TaskMetadata* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::flyteidl::core::TaskMetadata* TaskTemplate::mutable_metadata() {
  
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::TaskMetadata>(GetArenaNoVirtual());
    metadata_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.TaskTemplate.metadata)
  return metadata_;
}
inline void TaskTemplate::set_allocated_metadata(::flyteidl::core::TaskMetadata* metadata) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete metadata_;
  }
  if (metadata) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      metadata = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.TaskTemplate.metadata)
}

// .flyteidl.core.TypedInterface interface = 4;
inline bool TaskTemplate::has_interface() const {
  return this != internal_default_instance() && interface_ != nullptr;
}
inline const ::flyteidl::core::TypedInterface& TaskTemplate::interface() const {
  const ::flyteidl::core::TypedInterface* p = interface_;
  // @@protoc_insertion_point(field_get:flyteidl.core.TaskTemplate.interface)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::TypedInterface*>(
      &::flyteidl::core::_TypedInterface_default_instance_);
}
inline ::flyteidl::core::TypedInterface* TaskTemplate::release_interface() {
  // @@protoc_insertion_point(field_release:flyteidl.core.TaskTemplate.interface)
  
  ::flyteidl::core::TypedInterface* temp = interface_;
  interface_ = nullptr;
  return temp;
}
inline ::flyteidl::core::TypedInterface* TaskTemplate::mutable_interface() {
  
  if (interface_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::TypedInterface>(GetArenaNoVirtual());
    interface_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.TaskTemplate.interface)
  return interface_;
}
inline void TaskTemplate::set_allocated_interface(::flyteidl::core::TypedInterface* interface) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(interface_);
  }
  if (interface) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      interface = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, interface, submessage_arena);
    }
    
  } else {
    
  }
  interface_ = interface;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.TaskTemplate.interface)
}

// .google.protobuf.Struct custom = 5;
inline bool TaskTemplate::has_custom() const {
  return this != internal_default_instance() && custom_ != nullptr;
}
inline const ::google::protobuf::Struct& TaskTemplate::custom() const {
  const ::google::protobuf::Struct* p = custom_;
  // @@protoc_insertion_point(field_get:flyteidl.core.TaskTemplate.custom)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::Struct*>(
      &::google::protobuf::_Struct_default_instance_);
}
inline ::google::protobuf::Struct* TaskTemplate::release_custom() {
  // @@protoc_insertion_point(field_release:flyteidl.core.TaskTemplate.custom)
  
  ::google::protobuf::Struct* temp = custom_;
  custom_ = nullptr;
  return temp;
}
inline ::google::protobuf::Struct* TaskTemplate::mutable_custom() {
  
  if (custom_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Struct>(GetArenaNoVirtual());
    custom_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.TaskTemplate.custom)
  return custom_;
}
inline void TaskTemplate::set_allocated_custom(::google::protobuf::Struct* custom) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(custom_);
  }
  if (custom) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(custom)->GetArena();
    if (message_arena != submessage_arena) {
      custom = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, custom, submessage_arena);
    }
    
  } else {
    
  }
  custom_ = custom;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.TaskTemplate.custom)
}

// .flyteidl.core.Container container = 6;
inline bool TaskTemplate::has_container() const {
  return target_case() == kContainer;
}
inline void TaskTemplate::set_has_container() {
  _oneof_case_[0] = kContainer;
}
inline void TaskTemplate::clear_container() {
  if (has_container()) {
    delete target_.container_;
    clear_has_target();
  }
}
inline ::flyteidl::core::Container* TaskTemplate::release_container() {
  // @@protoc_insertion_point(field_release:flyteidl.core.TaskTemplate.container)
  if (has_container()) {
    clear_has_target();
      ::flyteidl::core::Container* temp = target_.container_;
    target_.container_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::core::Container& TaskTemplate::container() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.TaskTemplate.container)
  return has_container()
      ? *target_.container_
      : *reinterpret_cast< ::flyteidl::core::Container*>(&::flyteidl::core::_Container_default_instance_);
}
inline ::flyteidl::core::Container* TaskTemplate::mutable_container() {
  if (!has_container()) {
    clear_target();
    set_has_container();
    target_.container_ = CreateMaybeMessage< ::flyteidl::core::Container >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.TaskTemplate.container)
  return target_.container_;
}

inline bool TaskTemplate::has_target() const {
  return target_case() != TARGET_NOT_SET;
}
inline void TaskTemplate::clear_has_target() {
  _oneof_case_[0] = TARGET_NOT_SET;
}
inline TaskTemplate::TargetCase TaskTemplate::target_case() const {
  return TaskTemplate::TargetCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ContainerPort

// uint32 container_port = 1;
inline void ContainerPort::clear_container_port() {
  container_port_ = 0u;
}
inline ::google::protobuf::uint32 ContainerPort::container_port() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.ContainerPort.container_port)
  return container_port_;
}
inline void ContainerPort::set_container_port(::google::protobuf::uint32 value) {
  
  container_port_ = value;
  // @@protoc_insertion_point(field_set:flyteidl.core.ContainerPort.container_port)
}

// -------------------------------------------------------------------

// Container

// string image = 1;
inline void Container::clear_image() {
  image_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Container::image() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Container.image)
  return image_.GetNoArena();
}
inline void Container::set_image(const ::std::string& value) {
  
  image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.Container.image)
}
#if LANG_CXX11
inline void Container::set_image(::std::string&& value) {
  
  image_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.Container.image)
}
#endif
inline void Container::set_image(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.Container.image)
}
inline void Container::set_image(const char* value, size_t size) {
  
  image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.Container.image)
}
inline ::std::string* Container::mutable_image() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Container.image)
  return image_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Container::release_image() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Container.image)
  
  return image_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Container::set_allocated_image(::std::string* image) {
  if (image != nullptr) {
    
  } else {
    
  }
  image_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), image);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.Container.image)
}

// repeated string command = 2;
inline int Container::command_size() const {
  return command_.size();
}
inline void Container::clear_command() {
  command_.Clear();
}
inline const ::std::string& Container::command(int index) const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Container.command)
  return command_.Get(index);
}
inline ::std::string* Container::mutable_command(int index) {
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Container.command)
  return command_.Mutable(index);
}
inline void Container::set_command(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:flyteidl.core.Container.command)
  command_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Container::set_command(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:flyteidl.core.Container.command)
  command_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Container::set_command(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  command_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:flyteidl.core.Container.command)
}
inline void Container::set_command(int index, const char* value, size_t size) {
  command_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.Container.command)
}
inline ::std::string* Container::add_command() {
  // @@protoc_insertion_point(field_add_mutable:flyteidl.core.Container.command)
  return command_.Add();
}
inline void Container::add_command(const ::std::string& value) {
  command_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:flyteidl.core.Container.command)
}
#if LANG_CXX11
inline void Container::add_command(::std::string&& value) {
  command_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:flyteidl.core.Container.command)
}
#endif
inline void Container::add_command(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  command_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:flyteidl.core.Container.command)
}
inline void Container::add_command(const char* value, size_t size) {
  command_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:flyteidl.core.Container.command)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
Container::command() const {
  // @@protoc_insertion_point(field_list:flyteidl.core.Container.command)
  return command_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
Container::mutable_command() {
  // @@protoc_insertion_point(field_mutable_list:flyteidl.core.Container.command)
  return &command_;
}

// repeated string args = 3;
inline int Container::args_size() const {
  return args_.size();
}
inline void Container::clear_args() {
  args_.Clear();
}
inline const ::std::string& Container::args(int index) const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Container.args)
  return args_.Get(index);
}
inline ::std::string* Container::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Container.args)
  return args_.Mutable(index);
}
inline void Container::set_args(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:flyteidl.core.Container.args)
  args_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Container::set_args(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:flyteidl.core.Container.args)
  args_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Container::set_args(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  args_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:flyteidl.core.Container.args)
}
inline void Container::set_args(int index, const char* value, size_t size) {
  args_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.Container.args)
}
inline ::std::string* Container::add_args() {
  // @@protoc_insertion_point(field_add_mutable:flyteidl.core.Container.args)
  return args_.Add();
}
inline void Container::add_args(const ::std::string& value) {
  args_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:flyteidl.core.Container.args)
}
#if LANG_CXX11
inline void Container::add_args(::std::string&& value) {
  args_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:flyteidl.core.Container.args)
}
#endif
inline void Container::add_args(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  args_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:flyteidl.core.Container.args)
}
inline void Container::add_args(const char* value, size_t size) {
  args_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:flyteidl.core.Container.args)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
Container::args() const {
  // @@protoc_insertion_point(field_list:flyteidl.core.Container.args)
  return args_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
Container::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:flyteidl.core.Container.args)
  return &args_;
}

// .flyteidl.core.Resources resources = 4;
inline bool Container::has_resources() const {
  return this != internal_default_instance() && resources_ != nullptr;
}
inline void Container::clear_resources() {
  if (GetArenaNoVirtual() == nullptr && resources_ != nullptr) {
    delete resources_;
  }
  resources_ = nullptr;
}
inline const ::flyteidl::core::Resources& Container::resources() const {
  const ::flyteidl::core::Resources* p = resources_;
  // @@protoc_insertion_point(field_get:flyteidl.core.Container.resources)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::Resources*>(
      &::flyteidl::core::_Resources_default_instance_);
}
inline ::flyteidl::core::Resources* Container::release_resources() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Container.resources)
  
  ::flyteidl::core::Resources* temp = resources_;
  resources_ = nullptr;
  return temp;
}
inline ::flyteidl::core::Resources* Container::mutable_resources() {
  
  if (resources_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::Resources>(GetArenaNoVirtual());
    resources_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Container.resources)
  return resources_;
}
inline void Container::set_allocated_resources(::flyteidl::core::Resources* resources) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete resources_;
  }
  if (resources) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      resources = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, resources, submessage_arena);
    }
    
  } else {
    
  }
  resources_ = resources;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.Container.resources)
}

// repeated .flyteidl.core.KeyValuePair env = 5;
inline int Container::env_size() const {
  return env_.size();
}
inline ::flyteidl::core::KeyValuePair* Container::mutable_env(int index) {
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Container.env)
  return env_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::flyteidl::core::KeyValuePair >*
Container::mutable_env() {
  // @@protoc_insertion_point(field_mutable_list:flyteidl.core.Container.env)
  return &env_;
}
inline const ::flyteidl::core::KeyValuePair& Container::env(int index) const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Container.env)
  return env_.Get(index);
}
inline ::flyteidl::core::KeyValuePair* Container::add_env() {
  // @@protoc_insertion_point(field_add:flyteidl.core.Container.env)
  return env_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::flyteidl::core::KeyValuePair >&
Container::env() const {
  // @@protoc_insertion_point(field_list:flyteidl.core.Container.env)
  return env_;
}

// repeated .flyteidl.core.KeyValuePair config = 6;
inline int Container::config_size() const {
  return config_.size();
}
inline ::flyteidl::core::KeyValuePair* Container::mutable_config(int index) {
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Container.config)
  return config_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::flyteidl::core::KeyValuePair >*
Container::mutable_config() {
  // @@protoc_insertion_point(field_mutable_list:flyteidl.core.Container.config)
  return &config_;
}
inline const ::flyteidl::core::KeyValuePair& Container::config(int index) const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Container.config)
  return config_.Get(index);
}
inline ::flyteidl::core::KeyValuePair* Container::add_config() {
  // @@protoc_insertion_point(field_add:flyteidl.core.Container.config)
  return config_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::flyteidl::core::KeyValuePair >&
Container::config() const {
  // @@protoc_insertion_point(field_list:flyteidl.core.Container.config)
  return config_;
}

// repeated .flyteidl.core.ContainerPort ports = 7;
inline int Container::ports_size() const {
  return ports_.size();
}
inline void Container::clear_ports() {
  ports_.Clear();
}
inline ::flyteidl::core::ContainerPort* Container::mutable_ports(int index) {
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Container.ports)
  return ports_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::flyteidl::core::ContainerPort >*
Container::mutable_ports() {
  // @@protoc_insertion_point(field_mutable_list:flyteidl.core.Container.ports)
  return &ports_;
}
inline const ::flyteidl::core::ContainerPort& Container::ports(int index) const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Container.ports)
  return ports_.Get(index);
}
inline ::flyteidl::core::ContainerPort* Container::add_ports() {
  // @@protoc_insertion_point(field_add:flyteidl.core.Container.ports)
  return ports_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::flyteidl::core::ContainerPort >&
Container::ports() const {
  // @@protoc_insertion_point(field_list:flyteidl.core.Container.ports)
  return ports_;
}

// .flyteidl.core.DataLoadingConfig data_config = 9;
inline bool Container::has_data_config() const {
  return this != internal_default_instance() && data_config_ != nullptr;
}
inline void Container::clear_data_config() {
  if (GetArenaNoVirtual() == nullptr && data_config_ != nullptr) {
    delete data_config_;
  }
  data_config_ = nullptr;
}
inline const ::flyteidl::core::DataLoadingConfig& Container::data_config() const {
  const ::flyteidl::core::DataLoadingConfig* p = data_config_;
  // @@protoc_insertion_point(field_get:flyteidl.core.Container.data_config)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::DataLoadingConfig*>(
      &::flyteidl::core::_DataLoadingConfig_default_instance_);
}
inline ::flyteidl::core::DataLoadingConfig* Container::release_data_config() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Container.data_config)
  
  ::flyteidl::core::DataLoadingConfig* temp = data_config_;
  data_config_ = nullptr;
  return temp;
}
inline ::flyteidl::core::DataLoadingConfig* Container::mutable_data_config() {
  
  if (data_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::DataLoadingConfig>(GetArenaNoVirtual());
    data_config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Container.data_config)
  return data_config_;
}
inline void Container::set_allocated_data_config(::flyteidl::core::DataLoadingConfig* data_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete data_config_;
  }
  if (data_config) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      data_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, data_config, submessage_arena);
    }
    
  } else {
    
  }
  data_config_ = data_config;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.Container.data_config)
}

// -------------------------------------------------------------------

// IOStrategy

// .flyteidl.core.IOStrategy.DownloadMode download_mode = 1;
inline void IOStrategy::clear_download_mode() {
  download_mode_ = 0;
}
inline ::flyteidl::core::IOStrategy_DownloadMode IOStrategy::download_mode() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.IOStrategy.download_mode)
  return static_cast< ::flyteidl::core::IOStrategy_DownloadMode >(download_mode_);
}
inline void IOStrategy::set_download_mode(::flyteidl::core::IOStrategy_DownloadMode value) {
  
  download_mode_ = value;
  // @@protoc_insertion_point(field_set:flyteidl.core.IOStrategy.download_mode)
}

// .flyteidl.core.IOStrategy.UploadMode upload_mode = 2;
inline void IOStrategy::clear_upload_mode() {
  upload_mode_ = 0;
}
inline ::flyteidl::core::IOStrategy_UploadMode IOStrategy::upload_mode() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.IOStrategy.upload_mode)
  return static_cast< ::flyteidl::core::IOStrategy_UploadMode >(upload_mode_);
}
inline void IOStrategy::set_upload_mode(::flyteidl::core::IOStrategy_UploadMode value) {
  
  upload_mode_ = value;
  // @@protoc_insertion_point(field_set:flyteidl.core.IOStrategy.upload_mode)
}

// -------------------------------------------------------------------

// DataLoadingConfig

// bool enabled = 1;
inline void DataLoadingConfig::clear_enabled() {
  enabled_ = false;
}
inline bool DataLoadingConfig::enabled() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.DataLoadingConfig.enabled)
  return enabled_;
}
inline void DataLoadingConfig::set_enabled(bool value) {
  
  enabled_ = value;
  // @@protoc_insertion_point(field_set:flyteidl.core.DataLoadingConfig.enabled)
}

// string input_path = 2;
inline void DataLoadingConfig::clear_input_path() {
  input_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DataLoadingConfig::input_path() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.DataLoadingConfig.input_path)
  return input_path_.GetNoArena();
}
inline void DataLoadingConfig::set_input_path(const ::std::string& value) {
  
  input_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.DataLoadingConfig.input_path)
}
#if LANG_CXX11
inline void DataLoadingConfig::set_input_path(::std::string&& value) {
  
  input_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.DataLoadingConfig.input_path)
}
#endif
inline void DataLoadingConfig::set_input_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  input_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.DataLoadingConfig.input_path)
}
inline void DataLoadingConfig::set_input_path(const char* value, size_t size) {
  
  input_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.DataLoadingConfig.input_path)
}
inline ::std::string* DataLoadingConfig::mutable_input_path() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.DataLoadingConfig.input_path)
  return input_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DataLoadingConfig::release_input_path() {
  // @@protoc_insertion_point(field_release:flyteidl.core.DataLoadingConfig.input_path)
  
  return input_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DataLoadingConfig::set_allocated_input_path(::std::string* input_path) {
  if (input_path != nullptr) {
    
  } else {
    
  }
  input_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), input_path);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.DataLoadingConfig.input_path)
}

// string output_path = 3;
inline void DataLoadingConfig::clear_output_path() {
  output_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DataLoadingConfig::output_path() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.DataLoadingConfig.output_path)
  return output_path_.GetNoArena();
}
inline void DataLoadingConfig::set_output_path(const ::std::string& value) {
  
  output_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.DataLoadingConfig.output_path)
}
#if LANG_CXX11
inline void DataLoadingConfig::set_output_path(::std::string&& value) {
  
  output_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.DataLoadingConfig.output_path)
}
#endif
inline void DataLoadingConfig::set_output_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  output_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.DataLoadingConfig.output_path)
}
inline void DataLoadingConfig::set_output_path(const char* value, size_t size) {
  
  output_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.DataLoadingConfig.output_path)
}
inline ::std::string* DataLoadingConfig::mutable_output_path() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.DataLoadingConfig.output_path)
  return output_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DataLoadingConfig::release_output_path() {
  // @@protoc_insertion_point(field_release:flyteidl.core.DataLoadingConfig.output_path)
  
  return output_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DataLoadingConfig::set_allocated_output_path(::std::string* output_path) {
  if (output_path != nullptr) {
    
  } else {
    
  }
  output_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), output_path);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.DataLoadingConfig.output_path)
}

// .flyteidl.core.DataLoadingConfig.LiteralMapFormat format = 4;
inline void DataLoadingConfig::clear_format() {
  format_ = 0;
}
inline ::flyteidl::core::DataLoadingConfig_LiteralMapFormat DataLoadingConfig::format() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.DataLoadingConfig.format)
  return static_cast< ::flyteidl::core::DataLoadingConfig_LiteralMapFormat >(format_);
}
inline void DataLoadingConfig::set_format(::flyteidl::core::DataLoadingConfig_LiteralMapFormat value) {
  
  format_ = value;
  // @@protoc_insertion_point(field_set:flyteidl.core.DataLoadingConfig.format)
}

// .flyteidl.core.IOStrategy io_strategy = 5;
inline bool DataLoadingConfig::has_io_strategy() const {
  return this != internal_default_instance() && io_strategy_ != nullptr;
}
inline void DataLoadingConfig::clear_io_strategy() {
  if (GetArenaNoVirtual() == nullptr && io_strategy_ != nullptr) {
    delete io_strategy_;
  }
  io_strategy_ = nullptr;
}
inline const ::flyteidl::core::IOStrategy& DataLoadingConfig::io_strategy() const {
  const ::flyteidl::core::IOStrategy* p = io_strategy_;
  // @@protoc_insertion_point(field_get:flyteidl.core.DataLoadingConfig.io_strategy)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::IOStrategy*>(
      &::flyteidl::core::_IOStrategy_default_instance_);
}
inline ::flyteidl::core::IOStrategy* DataLoadingConfig::release_io_strategy() {
  // @@protoc_insertion_point(field_release:flyteidl.core.DataLoadingConfig.io_strategy)
  
  ::flyteidl::core::IOStrategy* temp = io_strategy_;
  io_strategy_ = nullptr;
  return temp;
}
inline ::flyteidl::core::IOStrategy* DataLoadingConfig::mutable_io_strategy() {
  
  if (io_strategy_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::IOStrategy>(GetArenaNoVirtual());
    io_strategy_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.DataLoadingConfig.io_strategy)
  return io_strategy_;
}
inline void DataLoadingConfig::set_allocated_io_strategy(::flyteidl::core::IOStrategy* io_strategy) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete io_strategy_;
  }
  if (io_strategy) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      io_strategy = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, io_strategy, submessage_arena);
    }
    
  } else {
    
  }
  io_strategy_ = io_strategy;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.DataLoadingConfig.io_strategy)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace core
}  // namespace flyteidl

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::flyteidl::core::Resources_ResourceName> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::flyteidl::core::Resources_ResourceName>() {
  return ::flyteidl::core::Resources_ResourceName_descriptor();
}
template <> struct is_proto_enum< ::flyteidl::core::RuntimeMetadata_RuntimeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::flyteidl::core::RuntimeMetadata_RuntimeType>() {
  return ::flyteidl::core::RuntimeMetadata_RuntimeType_descriptor();
}
template <> struct is_proto_enum< ::flyteidl::core::IOStrategy_DownloadMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::flyteidl::core::IOStrategy_DownloadMode>() {
  return ::flyteidl::core::IOStrategy_DownloadMode_descriptor();
}
template <> struct is_proto_enum< ::flyteidl::core::IOStrategy_UploadMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::flyteidl::core::IOStrategy_UploadMode>() {
  return ::flyteidl::core::IOStrategy_UploadMode_descriptor();
}
template <> struct is_proto_enum< ::flyteidl::core::DataLoadingConfig_LiteralMapFormat> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::flyteidl::core::DataLoadingConfig_LiteralMapFormat>() {
  return ::flyteidl::core::DataLoadingConfig_LiteralMapFormat_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_flyteidl_2fcore_2ftasks_2eproto
