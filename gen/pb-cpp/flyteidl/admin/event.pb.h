// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: flyteidl/admin/event.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_flyteidl_2fadmin_2fevent_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_flyteidl_2fadmin_2fevent_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "flyteidl/event/event.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_flyteidl_2fadmin_2fevent_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_flyteidl_2fadmin_2fevent_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[9]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_flyteidl_2fadmin_2fevent_2eproto;
namespace flyteidl {
namespace admin {
class EventErrorAlreadyInTerminalState;
struct EventErrorAlreadyInTerminalStateDefaultTypeInternal;
extern EventErrorAlreadyInTerminalStateDefaultTypeInternal _EventErrorAlreadyInTerminalState_default_instance_;
class EventErrorIncompatibleCluster;
struct EventErrorIncompatibleClusterDefaultTypeInternal;
extern EventErrorIncompatibleClusterDefaultTypeInternal _EventErrorIncompatibleCluster_default_instance_;
class EventFailureReason;
struct EventFailureReasonDefaultTypeInternal;
extern EventFailureReasonDefaultTypeInternal _EventFailureReason_default_instance_;
class NodeExecutionEventRequest;
struct NodeExecutionEventRequestDefaultTypeInternal;
extern NodeExecutionEventRequestDefaultTypeInternal _NodeExecutionEventRequest_default_instance_;
class NodeExecutionEventResponse;
struct NodeExecutionEventResponseDefaultTypeInternal;
extern NodeExecutionEventResponseDefaultTypeInternal _NodeExecutionEventResponse_default_instance_;
class TaskExecutionEventRequest;
struct TaskExecutionEventRequestDefaultTypeInternal;
extern TaskExecutionEventRequestDefaultTypeInternal _TaskExecutionEventRequest_default_instance_;
class TaskExecutionEventResponse;
struct TaskExecutionEventResponseDefaultTypeInternal;
extern TaskExecutionEventResponseDefaultTypeInternal _TaskExecutionEventResponse_default_instance_;
class WorkflowExecutionEventRequest;
struct WorkflowExecutionEventRequestDefaultTypeInternal;
extern WorkflowExecutionEventRequestDefaultTypeInternal _WorkflowExecutionEventRequest_default_instance_;
class WorkflowExecutionEventResponse;
struct WorkflowExecutionEventResponseDefaultTypeInternal;
extern WorkflowExecutionEventResponseDefaultTypeInternal _WorkflowExecutionEventResponse_default_instance_;
}  // namespace admin
}  // namespace flyteidl
PROTOBUF_NAMESPACE_OPEN
template<> ::flyteidl::admin::EventErrorAlreadyInTerminalState* Arena::CreateMaybeMessage<::flyteidl::admin::EventErrorAlreadyInTerminalState>(Arena*);
template<> ::flyteidl::admin::EventErrorIncompatibleCluster* Arena::CreateMaybeMessage<::flyteidl::admin::EventErrorIncompatibleCluster>(Arena*);
template<> ::flyteidl::admin::EventFailureReason* Arena::CreateMaybeMessage<::flyteidl::admin::EventFailureReason>(Arena*);
template<> ::flyteidl::admin::NodeExecutionEventRequest* Arena::CreateMaybeMessage<::flyteidl::admin::NodeExecutionEventRequest>(Arena*);
template<> ::flyteidl::admin::NodeExecutionEventResponse* Arena::CreateMaybeMessage<::flyteidl::admin::NodeExecutionEventResponse>(Arena*);
template<> ::flyteidl::admin::TaskExecutionEventRequest* Arena::CreateMaybeMessage<::flyteidl::admin::TaskExecutionEventRequest>(Arena*);
template<> ::flyteidl::admin::TaskExecutionEventResponse* Arena::CreateMaybeMessage<::flyteidl::admin::TaskExecutionEventResponse>(Arena*);
template<> ::flyteidl::admin::WorkflowExecutionEventRequest* Arena::CreateMaybeMessage<::flyteidl::admin::WorkflowExecutionEventRequest>(Arena*);
template<> ::flyteidl::admin::WorkflowExecutionEventResponse* Arena::CreateMaybeMessage<::flyteidl::admin::WorkflowExecutionEventResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace flyteidl {
namespace admin {

// ===================================================================

class EventErrorAlreadyInTerminalState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.admin.EventErrorAlreadyInTerminalState) */ {
 public:
  inline EventErrorAlreadyInTerminalState() : EventErrorAlreadyInTerminalState(nullptr) {}
  ~EventErrorAlreadyInTerminalState() override;
  explicit constexpr EventErrorAlreadyInTerminalState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventErrorAlreadyInTerminalState(const EventErrorAlreadyInTerminalState& from);
  EventErrorAlreadyInTerminalState(EventErrorAlreadyInTerminalState&& from) noexcept
    : EventErrorAlreadyInTerminalState() {
    *this = ::std::move(from);
  }

  inline EventErrorAlreadyInTerminalState& operator=(const EventErrorAlreadyInTerminalState& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventErrorAlreadyInTerminalState& operator=(EventErrorAlreadyInTerminalState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventErrorAlreadyInTerminalState& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventErrorAlreadyInTerminalState* internal_default_instance() {
    return reinterpret_cast<const EventErrorAlreadyInTerminalState*>(
               &_EventErrorAlreadyInTerminalState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(EventErrorAlreadyInTerminalState& a, EventErrorAlreadyInTerminalState& b) {
    a.Swap(&b);
  }
  inline void Swap(EventErrorAlreadyInTerminalState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventErrorAlreadyInTerminalState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventErrorAlreadyInTerminalState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventErrorAlreadyInTerminalState>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventErrorAlreadyInTerminalState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.admin.EventErrorAlreadyInTerminalState";
  }
  protected:
  explicit EventErrorAlreadyInTerminalState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCurrentPhaseFieldNumber = 1,
  };
  // string current_phase = 1 [json_name = "currentPhase"];
  void clear_current_phase();
  const std::string& current_phase() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_current_phase(ArgT0&& arg0, ArgT... args);
  std::string* mutable_current_phase();
  PROTOBUF_NODISCARD std::string* release_current_phase();
  void set_allocated_current_phase(std::string* current_phase);
  private:
  const std::string& _internal_current_phase() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_current_phase(const std::string& value);
  std::string* _internal_mutable_current_phase();
  public:

  // @@protoc_insertion_point(class_scope:flyteidl.admin.EventErrorAlreadyInTerminalState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr current_phase_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fadmin_2fevent_2eproto;
};
// -------------------------------------------------------------------

class EventErrorIncompatibleCluster final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.admin.EventErrorIncompatibleCluster) */ {
 public:
  inline EventErrorIncompatibleCluster() : EventErrorIncompatibleCluster(nullptr) {}
  ~EventErrorIncompatibleCluster() override;
  explicit constexpr EventErrorIncompatibleCluster(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventErrorIncompatibleCluster(const EventErrorIncompatibleCluster& from);
  EventErrorIncompatibleCluster(EventErrorIncompatibleCluster&& from) noexcept
    : EventErrorIncompatibleCluster() {
    *this = ::std::move(from);
  }

  inline EventErrorIncompatibleCluster& operator=(const EventErrorIncompatibleCluster& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventErrorIncompatibleCluster& operator=(EventErrorIncompatibleCluster&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventErrorIncompatibleCluster& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventErrorIncompatibleCluster* internal_default_instance() {
    return reinterpret_cast<const EventErrorIncompatibleCluster*>(
               &_EventErrorIncompatibleCluster_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(EventErrorIncompatibleCluster& a, EventErrorIncompatibleCluster& b) {
    a.Swap(&b);
  }
  inline void Swap(EventErrorIncompatibleCluster* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventErrorIncompatibleCluster* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventErrorIncompatibleCluster* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventErrorIncompatibleCluster>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventErrorIncompatibleCluster* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.admin.EventErrorIncompatibleCluster";
  }
  protected:
  explicit EventErrorIncompatibleCluster(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClusterFieldNumber = 1,
  };
  // string cluster = 1 [json_name = "cluster"];
  void clear_cluster();
  const std::string& cluster() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cluster(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cluster();
  PROTOBUF_NODISCARD std::string* release_cluster();
  void set_allocated_cluster(std::string* cluster);
  private:
  const std::string& _internal_cluster() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cluster(const std::string& value);
  std::string* _internal_mutable_cluster();
  public:

  // @@protoc_insertion_point(class_scope:flyteidl.admin.EventErrorIncompatibleCluster)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cluster_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fadmin_2fevent_2eproto;
};
// -------------------------------------------------------------------

class EventFailureReason final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.admin.EventFailureReason) */ {
 public:
  inline EventFailureReason() : EventFailureReason(nullptr) {}
  ~EventFailureReason() override;
  explicit constexpr EventFailureReason(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventFailureReason(const EventFailureReason& from);
  EventFailureReason(EventFailureReason&& from) noexcept
    : EventFailureReason() {
    *this = ::std::move(from);
  }

  inline EventFailureReason& operator=(const EventFailureReason& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventFailureReason& operator=(EventFailureReason&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventFailureReason& default_instance() {
    return *internal_default_instance();
  }
  enum ReasonCase {
    kAlreadyInTerminalState = 1,
    kIncompatibleCluster = 2,
    REASON_NOT_SET = 0,
  };

  static inline const EventFailureReason* internal_default_instance() {
    return reinterpret_cast<const EventFailureReason*>(
               &_EventFailureReason_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(EventFailureReason& a, EventFailureReason& b) {
    a.Swap(&b);
  }
  inline void Swap(EventFailureReason* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventFailureReason* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventFailureReason* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventFailureReason>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventFailureReason* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.admin.EventFailureReason";
  }
  protected:
  explicit EventFailureReason(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAlreadyInTerminalStateFieldNumber = 1,
    kIncompatibleClusterFieldNumber = 2,
  };
  // .flyteidl.admin.EventErrorAlreadyInTerminalState already_in_terminal_state = 1 [json_name = "alreadyInTerminalState"];
  bool has_already_in_terminal_state() const;
  private:
  bool _internal_has_already_in_terminal_state() const;
  public:
  void clear_already_in_terminal_state();
  const ::flyteidl::admin::EventErrorAlreadyInTerminalState& already_in_terminal_state() const;
  PROTOBUF_NODISCARD ::flyteidl::admin::EventErrorAlreadyInTerminalState* release_already_in_terminal_state();
  ::flyteidl::admin::EventErrorAlreadyInTerminalState* mutable_already_in_terminal_state();
  void set_allocated_already_in_terminal_state(::flyteidl::admin::EventErrorAlreadyInTerminalState* already_in_terminal_state);
  private:
  const ::flyteidl::admin::EventErrorAlreadyInTerminalState& _internal_already_in_terminal_state() const;
  ::flyteidl::admin::EventErrorAlreadyInTerminalState* _internal_mutable_already_in_terminal_state();
  public:
  void unsafe_arena_set_allocated_already_in_terminal_state(
      ::flyteidl::admin::EventErrorAlreadyInTerminalState* already_in_terminal_state);
  ::flyteidl::admin::EventErrorAlreadyInTerminalState* unsafe_arena_release_already_in_terminal_state();

  // .flyteidl.admin.EventErrorIncompatibleCluster incompatible_cluster = 2 [json_name = "incompatibleCluster"];
  bool has_incompatible_cluster() const;
  private:
  bool _internal_has_incompatible_cluster() const;
  public:
  void clear_incompatible_cluster();
  const ::flyteidl::admin::EventErrorIncompatibleCluster& incompatible_cluster() const;
  PROTOBUF_NODISCARD ::flyteidl::admin::EventErrorIncompatibleCluster* release_incompatible_cluster();
  ::flyteidl::admin::EventErrorIncompatibleCluster* mutable_incompatible_cluster();
  void set_allocated_incompatible_cluster(::flyteidl::admin::EventErrorIncompatibleCluster* incompatible_cluster);
  private:
  const ::flyteidl::admin::EventErrorIncompatibleCluster& _internal_incompatible_cluster() const;
  ::flyteidl::admin::EventErrorIncompatibleCluster* _internal_mutable_incompatible_cluster();
  public:
  void unsafe_arena_set_allocated_incompatible_cluster(
      ::flyteidl::admin::EventErrorIncompatibleCluster* incompatible_cluster);
  ::flyteidl::admin::EventErrorIncompatibleCluster* unsafe_arena_release_incompatible_cluster();

  void clear_reason();
  ReasonCase reason_case() const;
  // @@protoc_insertion_point(class_scope:flyteidl.admin.EventFailureReason)
 private:
  class _Internal;
  void set_has_already_in_terminal_state();
  void set_has_incompatible_cluster();

  inline bool has_reason() const;
  inline void clear_has_reason();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ReasonUnion {
    constexpr ReasonUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::flyteidl::admin::EventErrorAlreadyInTerminalState* already_in_terminal_state_;
    ::flyteidl::admin::EventErrorIncompatibleCluster* incompatible_cluster_;
  } reason_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_flyteidl_2fadmin_2fevent_2eproto;
};
// -------------------------------------------------------------------

class WorkflowExecutionEventRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.admin.WorkflowExecutionEventRequest) */ {
 public:
  inline WorkflowExecutionEventRequest() : WorkflowExecutionEventRequest(nullptr) {}
  ~WorkflowExecutionEventRequest() override;
  explicit constexpr WorkflowExecutionEventRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WorkflowExecutionEventRequest(const WorkflowExecutionEventRequest& from);
  WorkflowExecutionEventRequest(WorkflowExecutionEventRequest&& from) noexcept
    : WorkflowExecutionEventRequest() {
    *this = ::std::move(from);
  }

  inline WorkflowExecutionEventRequest& operator=(const WorkflowExecutionEventRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkflowExecutionEventRequest& operator=(WorkflowExecutionEventRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkflowExecutionEventRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorkflowExecutionEventRequest* internal_default_instance() {
    return reinterpret_cast<const WorkflowExecutionEventRequest*>(
               &_WorkflowExecutionEventRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(WorkflowExecutionEventRequest& a, WorkflowExecutionEventRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkflowExecutionEventRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkflowExecutionEventRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorkflowExecutionEventRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WorkflowExecutionEventRequest>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkflowExecutionEventRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.admin.WorkflowExecutionEventRequest";
  }
  protected:
  explicit WorkflowExecutionEventRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestIdFieldNumber = 1,
    kEventFieldNumber = 2,
  };
  // string request_id = 1 [json_name = "requestId"];
  void clear_request_id();
  const std::string& request_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_request_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_request_id();
  PROTOBUF_NODISCARD std::string* release_request_id();
  void set_allocated_request_id(std::string* request_id);
  private:
  const std::string& _internal_request_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_id(const std::string& value);
  std::string* _internal_mutable_request_id();
  public:

  // .flyteidl.event.WorkflowExecutionEvent event = 2 [json_name = "event"];
  bool has_event() const;
  private:
  bool _internal_has_event() const;
  public:
  void clear_event();
  const ::flyteidl::event::WorkflowExecutionEvent& event() const;
  PROTOBUF_NODISCARD ::flyteidl::event::WorkflowExecutionEvent* release_event();
  ::flyteidl::event::WorkflowExecutionEvent* mutable_event();
  void set_allocated_event(::flyteidl::event::WorkflowExecutionEvent* event);
  private:
  const ::flyteidl::event::WorkflowExecutionEvent& _internal_event() const;
  ::flyteidl::event::WorkflowExecutionEvent* _internal_mutable_event();
  public:
  void unsafe_arena_set_allocated_event(
      ::flyteidl::event::WorkflowExecutionEvent* event);
  ::flyteidl::event::WorkflowExecutionEvent* unsafe_arena_release_event();

  // @@protoc_insertion_point(class_scope:flyteidl.admin.WorkflowExecutionEventRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_id_;
  ::flyteidl::event::WorkflowExecutionEvent* event_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fadmin_2fevent_2eproto;
};
// -------------------------------------------------------------------

class WorkflowExecutionEventResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:flyteidl.admin.WorkflowExecutionEventResponse) */ {
 public:
  inline WorkflowExecutionEventResponse() : WorkflowExecutionEventResponse(nullptr) {}
  explicit constexpr WorkflowExecutionEventResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WorkflowExecutionEventResponse(const WorkflowExecutionEventResponse& from);
  WorkflowExecutionEventResponse(WorkflowExecutionEventResponse&& from) noexcept
    : WorkflowExecutionEventResponse() {
    *this = ::std::move(from);
  }

  inline WorkflowExecutionEventResponse& operator=(const WorkflowExecutionEventResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkflowExecutionEventResponse& operator=(WorkflowExecutionEventResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkflowExecutionEventResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorkflowExecutionEventResponse* internal_default_instance() {
    return reinterpret_cast<const WorkflowExecutionEventResponse*>(
               &_WorkflowExecutionEventResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(WorkflowExecutionEventResponse& a, WorkflowExecutionEventResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkflowExecutionEventResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkflowExecutionEventResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorkflowExecutionEventResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WorkflowExecutionEventResponse>(arena);
  }

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.admin.WorkflowExecutionEventResponse";
  }
  protected:
  explicit WorkflowExecutionEventResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:flyteidl.admin.WorkflowExecutionEventResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fadmin_2fevent_2eproto;
};
// -------------------------------------------------------------------

class NodeExecutionEventRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.admin.NodeExecutionEventRequest) */ {
 public:
  inline NodeExecutionEventRequest() : NodeExecutionEventRequest(nullptr) {}
  ~NodeExecutionEventRequest() override;
  explicit constexpr NodeExecutionEventRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NodeExecutionEventRequest(const NodeExecutionEventRequest& from);
  NodeExecutionEventRequest(NodeExecutionEventRequest&& from) noexcept
    : NodeExecutionEventRequest() {
    *this = ::std::move(from);
  }

  inline NodeExecutionEventRequest& operator=(const NodeExecutionEventRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeExecutionEventRequest& operator=(NodeExecutionEventRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeExecutionEventRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeExecutionEventRequest* internal_default_instance() {
    return reinterpret_cast<const NodeExecutionEventRequest*>(
               &_NodeExecutionEventRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(NodeExecutionEventRequest& a, NodeExecutionEventRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeExecutionEventRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeExecutionEventRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeExecutionEventRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodeExecutionEventRequest>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeExecutionEventRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.admin.NodeExecutionEventRequest";
  }
  protected:
  explicit NodeExecutionEventRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestIdFieldNumber = 1,
    kEventFieldNumber = 2,
  };
  // string request_id = 1 [json_name = "requestId"];
  void clear_request_id();
  const std::string& request_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_request_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_request_id();
  PROTOBUF_NODISCARD std::string* release_request_id();
  void set_allocated_request_id(std::string* request_id);
  private:
  const std::string& _internal_request_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_id(const std::string& value);
  std::string* _internal_mutable_request_id();
  public:

  // .flyteidl.event.NodeExecutionEvent event = 2 [json_name = "event"];
  bool has_event() const;
  private:
  bool _internal_has_event() const;
  public:
  void clear_event();
  const ::flyteidl::event::NodeExecutionEvent& event() const;
  PROTOBUF_NODISCARD ::flyteidl::event::NodeExecutionEvent* release_event();
  ::flyteidl::event::NodeExecutionEvent* mutable_event();
  void set_allocated_event(::flyteidl::event::NodeExecutionEvent* event);
  private:
  const ::flyteidl::event::NodeExecutionEvent& _internal_event() const;
  ::flyteidl::event::NodeExecutionEvent* _internal_mutable_event();
  public:
  void unsafe_arena_set_allocated_event(
      ::flyteidl::event::NodeExecutionEvent* event);
  ::flyteidl::event::NodeExecutionEvent* unsafe_arena_release_event();

  // @@protoc_insertion_point(class_scope:flyteidl.admin.NodeExecutionEventRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_id_;
  ::flyteidl::event::NodeExecutionEvent* event_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fadmin_2fevent_2eproto;
};
// -------------------------------------------------------------------

class NodeExecutionEventResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:flyteidl.admin.NodeExecutionEventResponse) */ {
 public:
  inline NodeExecutionEventResponse() : NodeExecutionEventResponse(nullptr) {}
  explicit constexpr NodeExecutionEventResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NodeExecutionEventResponse(const NodeExecutionEventResponse& from);
  NodeExecutionEventResponse(NodeExecutionEventResponse&& from) noexcept
    : NodeExecutionEventResponse() {
    *this = ::std::move(from);
  }

  inline NodeExecutionEventResponse& operator=(const NodeExecutionEventResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeExecutionEventResponse& operator=(NodeExecutionEventResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeExecutionEventResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeExecutionEventResponse* internal_default_instance() {
    return reinterpret_cast<const NodeExecutionEventResponse*>(
               &_NodeExecutionEventResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(NodeExecutionEventResponse& a, NodeExecutionEventResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeExecutionEventResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeExecutionEventResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeExecutionEventResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodeExecutionEventResponse>(arena);
  }

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.admin.NodeExecutionEventResponse";
  }
  protected:
  explicit NodeExecutionEventResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:flyteidl.admin.NodeExecutionEventResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fadmin_2fevent_2eproto;
};
// -------------------------------------------------------------------

class TaskExecutionEventRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.admin.TaskExecutionEventRequest) */ {
 public:
  inline TaskExecutionEventRequest() : TaskExecutionEventRequest(nullptr) {}
  ~TaskExecutionEventRequest() override;
  explicit constexpr TaskExecutionEventRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TaskExecutionEventRequest(const TaskExecutionEventRequest& from);
  TaskExecutionEventRequest(TaskExecutionEventRequest&& from) noexcept
    : TaskExecutionEventRequest() {
    *this = ::std::move(from);
  }

  inline TaskExecutionEventRequest& operator=(const TaskExecutionEventRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskExecutionEventRequest& operator=(TaskExecutionEventRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskExecutionEventRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskExecutionEventRequest* internal_default_instance() {
    return reinterpret_cast<const TaskExecutionEventRequest*>(
               &_TaskExecutionEventRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(TaskExecutionEventRequest& a, TaskExecutionEventRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskExecutionEventRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskExecutionEventRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TaskExecutionEventRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TaskExecutionEventRequest>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskExecutionEventRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.admin.TaskExecutionEventRequest";
  }
  protected:
  explicit TaskExecutionEventRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestIdFieldNumber = 1,
    kEventFieldNumber = 2,
  };
  // string request_id = 1 [json_name = "requestId"];
  void clear_request_id();
  const std::string& request_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_request_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_request_id();
  PROTOBUF_NODISCARD std::string* release_request_id();
  void set_allocated_request_id(std::string* request_id);
  private:
  const std::string& _internal_request_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_id(const std::string& value);
  std::string* _internal_mutable_request_id();
  public:

  // .flyteidl.event.TaskExecutionEvent event = 2 [json_name = "event"];
  bool has_event() const;
  private:
  bool _internal_has_event() const;
  public:
  void clear_event();
  const ::flyteidl::event::TaskExecutionEvent& event() const;
  PROTOBUF_NODISCARD ::flyteidl::event::TaskExecutionEvent* release_event();
  ::flyteidl::event::TaskExecutionEvent* mutable_event();
  void set_allocated_event(::flyteidl::event::TaskExecutionEvent* event);
  private:
  const ::flyteidl::event::TaskExecutionEvent& _internal_event() const;
  ::flyteidl::event::TaskExecutionEvent* _internal_mutable_event();
  public:
  void unsafe_arena_set_allocated_event(
      ::flyteidl::event::TaskExecutionEvent* event);
  ::flyteidl::event::TaskExecutionEvent* unsafe_arena_release_event();

  // @@protoc_insertion_point(class_scope:flyteidl.admin.TaskExecutionEventRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_id_;
  ::flyteidl::event::TaskExecutionEvent* event_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fadmin_2fevent_2eproto;
};
// -------------------------------------------------------------------

class TaskExecutionEventResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:flyteidl.admin.TaskExecutionEventResponse) */ {
 public:
  inline TaskExecutionEventResponse() : TaskExecutionEventResponse(nullptr) {}
  explicit constexpr TaskExecutionEventResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TaskExecutionEventResponse(const TaskExecutionEventResponse& from);
  TaskExecutionEventResponse(TaskExecutionEventResponse&& from) noexcept
    : TaskExecutionEventResponse() {
    *this = ::std::move(from);
  }

  inline TaskExecutionEventResponse& operator=(const TaskExecutionEventResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskExecutionEventResponse& operator=(TaskExecutionEventResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskExecutionEventResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskExecutionEventResponse* internal_default_instance() {
    return reinterpret_cast<const TaskExecutionEventResponse*>(
               &_TaskExecutionEventResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(TaskExecutionEventResponse& a, TaskExecutionEventResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskExecutionEventResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskExecutionEventResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TaskExecutionEventResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TaskExecutionEventResponse>(arena);
  }

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.admin.TaskExecutionEventResponse";
  }
  protected:
  explicit TaskExecutionEventResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:flyteidl.admin.TaskExecutionEventResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fadmin_2fevent_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// EventErrorAlreadyInTerminalState

// string current_phase = 1 [json_name = "currentPhase"];
inline void EventErrorAlreadyInTerminalState::clear_current_phase() {
  current_phase_.ClearToEmpty();
}
inline const std::string& EventErrorAlreadyInTerminalState::current_phase() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.EventErrorAlreadyInTerminalState.current_phase)
  return _internal_current_phase();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EventErrorAlreadyInTerminalState::set_current_phase(ArgT0&& arg0, ArgT... args) {
 
 current_phase_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.admin.EventErrorAlreadyInTerminalState.current_phase)
}
inline std::string* EventErrorAlreadyInTerminalState::mutable_current_phase() {
  std::string* _s = _internal_mutable_current_phase();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.EventErrorAlreadyInTerminalState.current_phase)
  return _s;
}
inline const std::string& EventErrorAlreadyInTerminalState::_internal_current_phase() const {
  return current_phase_.Get();
}
inline void EventErrorAlreadyInTerminalState::_internal_set_current_phase(const std::string& value) {
  
  current_phase_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EventErrorAlreadyInTerminalState::_internal_mutable_current_phase() {
  
  return current_phase_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EventErrorAlreadyInTerminalState::release_current_phase() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.EventErrorAlreadyInTerminalState.current_phase)
  return current_phase_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EventErrorAlreadyInTerminalState::set_allocated_current_phase(std::string* current_phase) {
  if (current_phase != nullptr) {
    
  } else {
    
  }
  current_phase_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), current_phase,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (current_phase_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    current_phase_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.EventErrorAlreadyInTerminalState.current_phase)
}

// -------------------------------------------------------------------

// EventErrorIncompatibleCluster

// string cluster = 1 [json_name = "cluster"];
inline void EventErrorIncompatibleCluster::clear_cluster() {
  cluster_.ClearToEmpty();
}
inline const std::string& EventErrorIncompatibleCluster::cluster() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.EventErrorIncompatibleCluster.cluster)
  return _internal_cluster();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EventErrorIncompatibleCluster::set_cluster(ArgT0&& arg0, ArgT... args) {
 
 cluster_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.admin.EventErrorIncompatibleCluster.cluster)
}
inline std::string* EventErrorIncompatibleCluster::mutable_cluster() {
  std::string* _s = _internal_mutable_cluster();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.EventErrorIncompatibleCluster.cluster)
  return _s;
}
inline const std::string& EventErrorIncompatibleCluster::_internal_cluster() const {
  return cluster_.Get();
}
inline void EventErrorIncompatibleCluster::_internal_set_cluster(const std::string& value) {
  
  cluster_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EventErrorIncompatibleCluster::_internal_mutable_cluster() {
  
  return cluster_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EventErrorIncompatibleCluster::release_cluster() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.EventErrorIncompatibleCluster.cluster)
  return cluster_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EventErrorIncompatibleCluster::set_allocated_cluster(std::string* cluster) {
  if (cluster != nullptr) {
    
  } else {
    
  }
  cluster_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cluster,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (cluster_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    cluster_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.EventErrorIncompatibleCluster.cluster)
}

// -------------------------------------------------------------------

// EventFailureReason

// .flyteidl.admin.EventErrorAlreadyInTerminalState already_in_terminal_state = 1 [json_name = "alreadyInTerminalState"];
inline bool EventFailureReason::_internal_has_already_in_terminal_state() const {
  return reason_case() == kAlreadyInTerminalState;
}
inline bool EventFailureReason::has_already_in_terminal_state() const {
  return _internal_has_already_in_terminal_state();
}
inline void EventFailureReason::set_has_already_in_terminal_state() {
  _oneof_case_[0] = kAlreadyInTerminalState;
}
inline void EventFailureReason::clear_already_in_terminal_state() {
  if (_internal_has_already_in_terminal_state()) {
    if (GetArenaForAllocation() == nullptr) {
      delete reason_.already_in_terminal_state_;
    }
    clear_has_reason();
  }
}
inline ::flyteidl::admin::EventErrorAlreadyInTerminalState* EventFailureReason::release_already_in_terminal_state() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.EventFailureReason.already_in_terminal_state)
  if (_internal_has_already_in_terminal_state()) {
    clear_has_reason();
      ::flyteidl::admin::EventErrorAlreadyInTerminalState* temp = reason_.already_in_terminal_state_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    reason_.already_in_terminal_state_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::admin::EventErrorAlreadyInTerminalState& EventFailureReason::_internal_already_in_terminal_state() const {
  return _internal_has_already_in_terminal_state()
      ? *reason_.already_in_terminal_state_
      : reinterpret_cast< ::flyteidl::admin::EventErrorAlreadyInTerminalState&>(::flyteidl::admin::_EventErrorAlreadyInTerminalState_default_instance_);
}
inline const ::flyteidl::admin::EventErrorAlreadyInTerminalState& EventFailureReason::already_in_terminal_state() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.EventFailureReason.already_in_terminal_state)
  return _internal_already_in_terminal_state();
}
inline ::flyteidl::admin::EventErrorAlreadyInTerminalState* EventFailureReason::unsafe_arena_release_already_in_terminal_state() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flyteidl.admin.EventFailureReason.already_in_terminal_state)
  if (_internal_has_already_in_terminal_state()) {
    clear_has_reason();
    ::flyteidl::admin::EventErrorAlreadyInTerminalState* temp = reason_.already_in_terminal_state_;
    reason_.already_in_terminal_state_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventFailureReason::unsafe_arena_set_allocated_already_in_terminal_state(::flyteidl::admin::EventErrorAlreadyInTerminalState* already_in_terminal_state) {
  clear_reason();
  if (already_in_terminal_state) {
    set_has_already_in_terminal_state();
    reason_.already_in_terminal_state_ = already_in_terminal_state;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.EventFailureReason.already_in_terminal_state)
}
inline ::flyteidl::admin::EventErrorAlreadyInTerminalState* EventFailureReason::_internal_mutable_already_in_terminal_state() {
  if (!_internal_has_already_in_terminal_state()) {
    clear_reason();
    set_has_already_in_terminal_state();
    reason_.already_in_terminal_state_ = CreateMaybeMessage< ::flyteidl::admin::EventErrorAlreadyInTerminalState >(GetArenaForAllocation());
  }
  return reason_.already_in_terminal_state_;
}
inline ::flyteidl::admin::EventErrorAlreadyInTerminalState* EventFailureReason::mutable_already_in_terminal_state() {
  ::flyteidl::admin::EventErrorAlreadyInTerminalState* _msg = _internal_mutable_already_in_terminal_state();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.EventFailureReason.already_in_terminal_state)
  return _msg;
}

// .flyteidl.admin.EventErrorIncompatibleCluster incompatible_cluster = 2 [json_name = "incompatibleCluster"];
inline bool EventFailureReason::_internal_has_incompatible_cluster() const {
  return reason_case() == kIncompatibleCluster;
}
inline bool EventFailureReason::has_incompatible_cluster() const {
  return _internal_has_incompatible_cluster();
}
inline void EventFailureReason::set_has_incompatible_cluster() {
  _oneof_case_[0] = kIncompatibleCluster;
}
inline void EventFailureReason::clear_incompatible_cluster() {
  if (_internal_has_incompatible_cluster()) {
    if (GetArenaForAllocation() == nullptr) {
      delete reason_.incompatible_cluster_;
    }
    clear_has_reason();
  }
}
inline ::flyteidl::admin::EventErrorIncompatibleCluster* EventFailureReason::release_incompatible_cluster() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.EventFailureReason.incompatible_cluster)
  if (_internal_has_incompatible_cluster()) {
    clear_has_reason();
      ::flyteidl::admin::EventErrorIncompatibleCluster* temp = reason_.incompatible_cluster_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    reason_.incompatible_cluster_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::admin::EventErrorIncompatibleCluster& EventFailureReason::_internal_incompatible_cluster() const {
  return _internal_has_incompatible_cluster()
      ? *reason_.incompatible_cluster_
      : reinterpret_cast< ::flyteidl::admin::EventErrorIncompatibleCluster&>(::flyteidl::admin::_EventErrorIncompatibleCluster_default_instance_);
}
inline const ::flyteidl::admin::EventErrorIncompatibleCluster& EventFailureReason::incompatible_cluster() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.EventFailureReason.incompatible_cluster)
  return _internal_incompatible_cluster();
}
inline ::flyteidl::admin::EventErrorIncompatibleCluster* EventFailureReason::unsafe_arena_release_incompatible_cluster() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flyteidl.admin.EventFailureReason.incompatible_cluster)
  if (_internal_has_incompatible_cluster()) {
    clear_has_reason();
    ::flyteidl::admin::EventErrorIncompatibleCluster* temp = reason_.incompatible_cluster_;
    reason_.incompatible_cluster_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventFailureReason::unsafe_arena_set_allocated_incompatible_cluster(::flyteidl::admin::EventErrorIncompatibleCluster* incompatible_cluster) {
  clear_reason();
  if (incompatible_cluster) {
    set_has_incompatible_cluster();
    reason_.incompatible_cluster_ = incompatible_cluster;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.EventFailureReason.incompatible_cluster)
}
inline ::flyteidl::admin::EventErrorIncompatibleCluster* EventFailureReason::_internal_mutable_incompatible_cluster() {
  if (!_internal_has_incompatible_cluster()) {
    clear_reason();
    set_has_incompatible_cluster();
    reason_.incompatible_cluster_ = CreateMaybeMessage< ::flyteidl::admin::EventErrorIncompatibleCluster >(GetArenaForAllocation());
  }
  return reason_.incompatible_cluster_;
}
inline ::flyteidl::admin::EventErrorIncompatibleCluster* EventFailureReason::mutable_incompatible_cluster() {
  ::flyteidl::admin::EventErrorIncompatibleCluster* _msg = _internal_mutable_incompatible_cluster();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.EventFailureReason.incompatible_cluster)
  return _msg;
}

inline bool EventFailureReason::has_reason() const {
  return reason_case() != REASON_NOT_SET;
}
inline void EventFailureReason::clear_has_reason() {
  _oneof_case_[0] = REASON_NOT_SET;
}
inline EventFailureReason::ReasonCase EventFailureReason::reason_case() const {
  return EventFailureReason::ReasonCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// WorkflowExecutionEventRequest

// string request_id = 1 [json_name = "requestId"];
inline void WorkflowExecutionEventRequest::clear_request_id() {
  request_id_.ClearToEmpty();
}
inline const std::string& WorkflowExecutionEventRequest::request_id() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.WorkflowExecutionEventRequest.request_id)
  return _internal_request_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WorkflowExecutionEventRequest::set_request_id(ArgT0&& arg0, ArgT... args) {
 
 request_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.admin.WorkflowExecutionEventRequest.request_id)
}
inline std::string* WorkflowExecutionEventRequest::mutable_request_id() {
  std::string* _s = _internal_mutable_request_id();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.WorkflowExecutionEventRequest.request_id)
  return _s;
}
inline const std::string& WorkflowExecutionEventRequest::_internal_request_id() const {
  return request_id_.Get();
}
inline void WorkflowExecutionEventRequest::_internal_set_request_id(const std::string& value) {
  
  request_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WorkflowExecutionEventRequest::_internal_mutable_request_id() {
  
  return request_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WorkflowExecutionEventRequest::release_request_id() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.WorkflowExecutionEventRequest.request_id)
  return request_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WorkflowExecutionEventRequest::set_allocated_request_id(std::string* request_id) {
  if (request_id != nullptr) {
    
  } else {
    
  }
  request_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), request_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (request_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    request_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.WorkflowExecutionEventRequest.request_id)
}

// .flyteidl.event.WorkflowExecutionEvent event = 2 [json_name = "event"];
inline bool WorkflowExecutionEventRequest::_internal_has_event() const {
  return this != internal_default_instance() && event_ != nullptr;
}
inline bool WorkflowExecutionEventRequest::has_event() const {
  return _internal_has_event();
}
inline const ::flyteidl::event::WorkflowExecutionEvent& WorkflowExecutionEventRequest::_internal_event() const {
  const ::flyteidl::event::WorkflowExecutionEvent* p = event_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::event::WorkflowExecutionEvent&>(
      ::flyteidl::event::_WorkflowExecutionEvent_default_instance_);
}
inline const ::flyteidl::event::WorkflowExecutionEvent& WorkflowExecutionEventRequest::event() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.WorkflowExecutionEventRequest.event)
  return _internal_event();
}
inline void WorkflowExecutionEventRequest::unsafe_arena_set_allocated_event(
    ::flyteidl::event::WorkflowExecutionEvent* event) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(event_);
  }
  event_ = event;
  if (event) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.WorkflowExecutionEventRequest.event)
}
inline ::flyteidl::event::WorkflowExecutionEvent* WorkflowExecutionEventRequest::release_event() {
  
  ::flyteidl::event::WorkflowExecutionEvent* temp = event_;
  event_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::event::WorkflowExecutionEvent* WorkflowExecutionEventRequest::unsafe_arena_release_event() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.WorkflowExecutionEventRequest.event)
  
  ::flyteidl::event::WorkflowExecutionEvent* temp = event_;
  event_ = nullptr;
  return temp;
}
inline ::flyteidl::event::WorkflowExecutionEvent* WorkflowExecutionEventRequest::_internal_mutable_event() {
  
  if (event_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::event::WorkflowExecutionEvent>(GetArenaForAllocation());
    event_ = p;
  }
  return event_;
}
inline ::flyteidl::event::WorkflowExecutionEvent* WorkflowExecutionEventRequest::mutable_event() {
  ::flyteidl::event::WorkflowExecutionEvent* _msg = _internal_mutable_event();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.WorkflowExecutionEventRequest.event)
  return _msg;
}
inline void WorkflowExecutionEventRequest::set_allocated_event(::flyteidl::event::WorkflowExecutionEvent* event) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(event_);
  }
  if (event) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(event));
    if (message_arena != submessage_arena) {
      event = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, event, submessage_arena);
    }
    
  } else {
    
  }
  event_ = event;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.WorkflowExecutionEventRequest.event)
}

// -------------------------------------------------------------------

// WorkflowExecutionEventResponse

// -------------------------------------------------------------------

// NodeExecutionEventRequest

// string request_id = 1 [json_name = "requestId"];
inline void NodeExecutionEventRequest::clear_request_id() {
  request_id_.ClearToEmpty();
}
inline const std::string& NodeExecutionEventRequest::request_id() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NodeExecutionEventRequest.request_id)
  return _internal_request_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeExecutionEventRequest::set_request_id(ArgT0&& arg0, ArgT... args) {
 
 request_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.admin.NodeExecutionEventRequest.request_id)
}
inline std::string* NodeExecutionEventRequest::mutable_request_id() {
  std::string* _s = _internal_mutable_request_id();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.NodeExecutionEventRequest.request_id)
  return _s;
}
inline const std::string& NodeExecutionEventRequest::_internal_request_id() const {
  return request_id_.Get();
}
inline void NodeExecutionEventRequest::_internal_set_request_id(const std::string& value) {
  
  request_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NodeExecutionEventRequest::_internal_mutable_request_id() {
  
  return request_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NodeExecutionEventRequest::release_request_id() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.NodeExecutionEventRequest.request_id)
  return request_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NodeExecutionEventRequest::set_allocated_request_id(std::string* request_id) {
  if (request_id != nullptr) {
    
  } else {
    
  }
  request_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), request_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (request_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    request_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.NodeExecutionEventRequest.request_id)
}

// .flyteidl.event.NodeExecutionEvent event = 2 [json_name = "event"];
inline bool NodeExecutionEventRequest::_internal_has_event() const {
  return this != internal_default_instance() && event_ != nullptr;
}
inline bool NodeExecutionEventRequest::has_event() const {
  return _internal_has_event();
}
inline const ::flyteidl::event::NodeExecutionEvent& NodeExecutionEventRequest::_internal_event() const {
  const ::flyteidl::event::NodeExecutionEvent* p = event_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::event::NodeExecutionEvent&>(
      ::flyteidl::event::_NodeExecutionEvent_default_instance_);
}
inline const ::flyteidl::event::NodeExecutionEvent& NodeExecutionEventRequest::event() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NodeExecutionEventRequest.event)
  return _internal_event();
}
inline void NodeExecutionEventRequest::unsafe_arena_set_allocated_event(
    ::flyteidl::event::NodeExecutionEvent* event) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(event_);
  }
  event_ = event;
  if (event) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.NodeExecutionEventRequest.event)
}
inline ::flyteidl::event::NodeExecutionEvent* NodeExecutionEventRequest::release_event() {
  
  ::flyteidl::event::NodeExecutionEvent* temp = event_;
  event_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::event::NodeExecutionEvent* NodeExecutionEventRequest::unsafe_arena_release_event() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.NodeExecutionEventRequest.event)
  
  ::flyteidl::event::NodeExecutionEvent* temp = event_;
  event_ = nullptr;
  return temp;
}
inline ::flyteidl::event::NodeExecutionEvent* NodeExecutionEventRequest::_internal_mutable_event() {
  
  if (event_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::event::NodeExecutionEvent>(GetArenaForAllocation());
    event_ = p;
  }
  return event_;
}
inline ::flyteidl::event::NodeExecutionEvent* NodeExecutionEventRequest::mutable_event() {
  ::flyteidl::event::NodeExecutionEvent* _msg = _internal_mutable_event();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.NodeExecutionEventRequest.event)
  return _msg;
}
inline void NodeExecutionEventRequest::set_allocated_event(::flyteidl::event::NodeExecutionEvent* event) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(event_);
  }
  if (event) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(event));
    if (message_arena != submessage_arena) {
      event = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, event, submessage_arena);
    }
    
  } else {
    
  }
  event_ = event;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.NodeExecutionEventRequest.event)
}

// -------------------------------------------------------------------

// NodeExecutionEventResponse

// -------------------------------------------------------------------

// TaskExecutionEventRequest

// string request_id = 1 [json_name = "requestId"];
inline void TaskExecutionEventRequest::clear_request_id() {
  request_id_.ClearToEmpty();
}
inline const std::string& TaskExecutionEventRequest::request_id() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.TaskExecutionEventRequest.request_id)
  return _internal_request_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TaskExecutionEventRequest::set_request_id(ArgT0&& arg0, ArgT... args) {
 
 request_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.admin.TaskExecutionEventRequest.request_id)
}
inline std::string* TaskExecutionEventRequest::mutable_request_id() {
  std::string* _s = _internal_mutable_request_id();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.TaskExecutionEventRequest.request_id)
  return _s;
}
inline const std::string& TaskExecutionEventRequest::_internal_request_id() const {
  return request_id_.Get();
}
inline void TaskExecutionEventRequest::_internal_set_request_id(const std::string& value) {
  
  request_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TaskExecutionEventRequest::_internal_mutable_request_id() {
  
  return request_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TaskExecutionEventRequest::release_request_id() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.TaskExecutionEventRequest.request_id)
  return request_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TaskExecutionEventRequest::set_allocated_request_id(std::string* request_id) {
  if (request_id != nullptr) {
    
  } else {
    
  }
  request_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), request_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (request_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    request_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.TaskExecutionEventRequest.request_id)
}

// .flyteidl.event.TaskExecutionEvent event = 2 [json_name = "event"];
inline bool TaskExecutionEventRequest::_internal_has_event() const {
  return this != internal_default_instance() && event_ != nullptr;
}
inline bool TaskExecutionEventRequest::has_event() const {
  return _internal_has_event();
}
inline const ::flyteidl::event::TaskExecutionEvent& TaskExecutionEventRequest::_internal_event() const {
  const ::flyteidl::event::TaskExecutionEvent* p = event_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::event::TaskExecutionEvent&>(
      ::flyteidl::event::_TaskExecutionEvent_default_instance_);
}
inline const ::flyteidl::event::TaskExecutionEvent& TaskExecutionEventRequest::event() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.TaskExecutionEventRequest.event)
  return _internal_event();
}
inline void TaskExecutionEventRequest::unsafe_arena_set_allocated_event(
    ::flyteidl::event::TaskExecutionEvent* event) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(event_);
  }
  event_ = event;
  if (event) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.TaskExecutionEventRequest.event)
}
inline ::flyteidl::event::TaskExecutionEvent* TaskExecutionEventRequest::release_event() {
  
  ::flyteidl::event::TaskExecutionEvent* temp = event_;
  event_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::event::TaskExecutionEvent* TaskExecutionEventRequest::unsafe_arena_release_event() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.TaskExecutionEventRequest.event)
  
  ::flyteidl::event::TaskExecutionEvent* temp = event_;
  event_ = nullptr;
  return temp;
}
inline ::flyteidl::event::TaskExecutionEvent* TaskExecutionEventRequest::_internal_mutable_event() {
  
  if (event_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::event::TaskExecutionEvent>(GetArenaForAllocation());
    event_ = p;
  }
  return event_;
}
inline ::flyteidl::event::TaskExecutionEvent* TaskExecutionEventRequest::mutable_event() {
  ::flyteidl::event::TaskExecutionEvent* _msg = _internal_mutable_event();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.TaskExecutionEventRequest.event)
  return _msg;
}
inline void TaskExecutionEventRequest::set_allocated_event(::flyteidl::event::TaskExecutionEvent* event) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(event_);
  }
  if (event) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(event));
    if (message_arena != submessage_arena) {
      event = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, event, submessage_arena);
    }
    
  } else {
    
  }
  event_ = event;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.TaskExecutionEventRequest.event)
}

// -------------------------------------------------------------------

// TaskExecutionEventResponse

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace admin
}  // namespace flyteidl

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_flyteidl_2fadmin_2fevent_2eproto
