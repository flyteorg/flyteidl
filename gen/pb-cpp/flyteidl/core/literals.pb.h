// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: flyteidl/core/literals.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_flyteidl_2fcore_2fliterals_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_flyteidl_2fcore_2fliterals_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
#include <google/protobuf/duration.pb.h>
#include <google/protobuf/struct.pb.h>
#include "flyteidl/core/types.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_flyteidl_2fcore_2fliterals_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_flyteidl_2fcore_2fliterals_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[22]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_flyteidl_2fcore_2fliterals_2eproto;
namespace flyteidl {
namespace core {
class Binary;
struct BinaryDefaultTypeInternal;
extern BinaryDefaultTypeInternal _Binary_default_instance_;
class Binding;
struct BindingDefaultTypeInternal;
extern BindingDefaultTypeInternal _Binding_default_instance_;
class BindingData;
struct BindingDataDefaultTypeInternal;
extern BindingDataDefaultTypeInternal _BindingData_default_instance_;
class BindingDataCollection;
struct BindingDataCollectionDefaultTypeInternal;
extern BindingDataCollectionDefaultTypeInternal _BindingDataCollection_default_instance_;
class BindingDataMap;
struct BindingDataMapDefaultTypeInternal;
extern BindingDataMapDefaultTypeInternal _BindingDataMap_default_instance_;
class BindingDataMap_BindingsEntry_DoNotUse;
struct BindingDataMap_BindingsEntry_DoNotUseDefaultTypeInternal;
extern BindingDataMap_BindingsEntry_DoNotUseDefaultTypeInternal _BindingDataMap_BindingsEntry_DoNotUse_default_instance_;
class Blob;
struct BlobDefaultTypeInternal;
extern BlobDefaultTypeInternal _Blob_default_instance_;
class BlobMetadata;
struct BlobMetadataDefaultTypeInternal;
extern BlobMetadataDefaultTypeInternal _BlobMetadata_default_instance_;
class KeyValuePair;
struct KeyValuePairDefaultTypeInternal;
extern KeyValuePairDefaultTypeInternal _KeyValuePair_default_instance_;
class Literal;
struct LiteralDefaultTypeInternal;
extern LiteralDefaultTypeInternal _Literal_default_instance_;
class LiteralCollection;
struct LiteralCollectionDefaultTypeInternal;
extern LiteralCollectionDefaultTypeInternal _LiteralCollection_default_instance_;
class LiteralMap;
struct LiteralMapDefaultTypeInternal;
extern LiteralMapDefaultTypeInternal _LiteralMap_default_instance_;
class LiteralMap_LiteralsEntry_DoNotUse;
struct LiteralMap_LiteralsEntry_DoNotUseDefaultTypeInternal;
extern LiteralMap_LiteralsEntry_DoNotUseDefaultTypeInternal _LiteralMap_LiteralsEntry_DoNotUse_default_instance_;
class Primitive;
struct PrimitiveDefaultTypeInternal;
extern PrimitiveDefaultTypeInternal _Primitive_default_instance_;
class RetryStrategy;
struct RetryStrategyDefaultTypeInternal;
extern RetryStrategyDefaultTypeInternal _RetryStrategy_default_instance_;
class Scalar;
struct ScalarDefaultTypeInternal;
extern ScalarDefaultTypeInternal _Scalar_default_instance_;
class Schema;
struct SchemaDefaultTypeInternal;
extern SchemaDefaultTypeInternal _Schema_default_instance_;
class StructuredDataset;
struct StructuredDatasetDefaultTypeInternal;
extern StructuredDatasetDefaultTypeInternal _StructuredDataset_default_instance_;
class StructuredDatasetMetadata;
struct StructuredDatasetMetadataDefaultTypeInternal;
extern StructuredDatasetMetadataDefaultTypeInternal _StructuredDatasetMetadata_default_instance_;
class Union;
struct UnionDefaultTypeInternal;
extern UnionDefaultTypeInternal _Union_default_instance_;
class UnionInfo;
struct UnionInfoDefaultTypeInternal;
extern UnionInfoDefaultTypeInternal _UnionInfo_default_instance_;
class Void;
struct VoidDefaultTypeInternal;
extern VoidDefaultTypeInternal _Void_default_instance_;
}  // namespace core
}  // namespace flyteidl
PROTOBUF_NAMESPACE_OPEN
template<> ::flyteidl::core::Binary* Arena::CreateMaybeMessage<::flyteidl::core::Binary>(Arena*);
template<> ::flyteidl::core::Binding* Arena::CreateMaybeMessage<::flyteidl::core::Binding>(Arena*);
template<> ::flyteidl::core::BindingData* Arena::CreateMaybeMessage<::flyteidl::core::BindingData>(Arena*);
template<> ::flyteidl::core::BindingDataCollection* Arena::CreateMaybeMessage<::flyteidl::core::BindingDataCollection>(Arena*);
template<> ::flyteidl::core::BindingDataMap* Arena::CreateMaybeMessage<::flyteidl::core::BindingDataMap>(Arena*);
template<> ::flyteidl::core::BindingDataMap_BindingsEntry_DoNotUse* Arena::CreateMaybeMessage<::flyteidl::core::BindingDataMap_BindingsEntry_DoNotUse>(Arena*);
template<> ::flyteidl::core::Blob* Arena::CreateMaybeMessage<::flyteidl::core::Blob>(Arena*);
template<> ::flyteidl::core::BlobMetadata* Arena::CreateMaybeMessage<::flyteidl::core::BlobMetadata>(Arena*);
template<> ::flyteidl::core::KeyValuePair* Arena::CreateMaybeMessage<::flyteidl::core::KeyValuePair>(Arena*);
template<> ::flyteidl::core::Literal* Arena::CreateMaybeMessage<::flyteidl::core::Literal>(Arena*);
template<> ::flyteidl::core::LiteralCollection* Arena::CreateMaybeMessage<::flyteidl::core::LiteralCollection>(Arena*);
template<> ::flyteidl::core::LiteralMap* Arena::CreateMaybeMessage<::flyteidl::core::LiteralMap>(Arena*);
template<> ::flyteidl::core::LiteralMap_LiteralsEntry_DoNotUse* Arena::CreateMaybeMessage<::flyteidl::core::LiteralMap_LiteralsEntry_DoNotUse>(Arena*);
template<> ::flyteidl::core::Primitive* Arena::CreateMaybeMessage<::flyteidl::core::Primitive>(Arena*);
template<> ::flyteidl::core::RetryStrategy* Arena::CreateMaybeMessage<::flyteidl::core::RetryStrategy>(Arena*);
template<> ::flyteidl::core::Scalar* Arena::CreateMaybeMessage<::flyteidl::core::Scalar>(Arena*);
template<> ::flyteidl::core::Schema* Arena::CreateMaybeMessage<::flyteidl::core::Schema>(Arena*);
template<> ::flyteidl::core::StructuredDataset* Arena::CreateMaybeMessage<::flyteidl::core::StructuredDataset>(Arena*);
template<> ::flyteidl::core::StructuredDatasetMetadata* Arena::CreateMaybeMessage<::flyteidl::core::StructuredDatasetMetadata>(Arena*);
template<> ::flyteidl::core::Union* Arena::CreateMaybeMessage<::flyteidl::core::Union>(Arena*);
template<> ::flyteidl::core::UnionInfo* Arena::CreateMaybeMessage<::flyteidl::core::UnionInfo>(Arena*);
template<> ::flyteidl::core::Void* Arena::CreateMaybeMessage<::flyteidl::core::Void>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace flyteidl {
namespace core {

// ===================================================================

class Primitive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.Primitive) */ {
 public:
  inline Primitive() : Primitive(nullptr) {}
  ~Primitive() override;
  explicit constexpr Primitive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Primitive(const Primitive& from);
  Primitive(Primitive&& from) noexcept
    : Primitive() {
    *this = ::std::move(from);
  }

  inline Primitive& operator=(const Primitive& from) {
    CopyFrom(from);
    return *this;
  }
  inline Primitive& operator=(Primitive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Primitive& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kInteger = 1,
    kFloatValue = 2,
    kStringValue = 3,
    kBoolean = 4,
    kDatetime = 5,
    kDuration = 6,
    VALUE_NOT_SET = 0,
  };

  static inline const Primitive* internal_default_instance() {
    return reinterpret_cast<const Primitive*>(
               &_Primitive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Primitive& a, Primitive& b) {
    a.Swap(&b);
  }
  inline void Swap(Primitive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Primitive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Primitive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Primitive>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Primitive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.core.Primitive";
  }
  protected:
  explicit Primitive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIntegerFieldNumber = 1,
    kFloatValueFieldNumber = 2,
    kStringValueFieldNumber = 3,
    kBooleanFieldNumber = 4,
    kDatetimeFieldNumber = 5,
    kDurationFieldNumber = 6,
  };
  // int64 integer = 1 [json_name = "integer"];
  bool has_integer() const;
  private:
  bool _internal_has_integer() const;
  public:
  void clear_integer();
  int64_t integer() const;
  void set_integer(int64_t value);
  private:
  int64_t _internal_integer() const;
  void _internal_set_integer(int64_t value);
  public:

  // double float_value = 2 [json_name = "floatValue"];
  bool has_float_value() const;
  private:
  bool _internal_has_float_value() const;
  public:
  void clear_float_value();
  double float_value() const;
  void set_float_value(double value);
  private:
  double _internal_float_value() const;
  void _internal_set_float_value(double value);
  public:

  // string string_value = 3 [json_name = "stringValue"];
  bool has_string_value() const;
  private:
  bool _internal_has_string_value() const;
  public:
  void clear_string_value();
  const std::string& string_value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_string_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_string_value();
  PROTOBUF_NODISCARD std::string* release_string_value();
  void set_allocated_string_value(std::string* string_value);
  private:
  const std::string& _internal_string_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_string_value(const std::string& value);
  std::string* _internal_mutable_string_value();
  public:

  // bool boolean = 4 [json_name = "boolean"];
  bool has_boolean() const;
  private:
  bool _internal_has_boolean() const;
  public:
  void clear_boolean();
  bool boolean() const;
  void set_boolean(bool value);
  private:
  bool _internal_boolean() const;
  void _internal_set_boolean(bool value);
  public:

  // .google.protobuf.Timestamp datetime = 5 [json_name = "datetime"];
  bool has_datetime() const;
  private:
  bool _internal_has_datetime() const;
  public:
  void clear_datetime();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& datetime() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_datetime();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_datetime();
  void set_allocated_datetime(::PROTOBUF_NAMESPACE_ID::Timestamp* datetime);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_datetime() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_datetime();
  public:
  void unsafe_arena_set_allocated_datetime(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* datetime);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_datetime();

  // .google.protobuf.Duration duration = 6 [json_name = "duration"];
  bool has_duration() const;
  private:
  bool _internal_has_duration() const;
  public:
  void clear_duration();
  const ::PROTOBUF_NAMESPACE_ID::Duration& duration() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_duration();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_duration();
  void set_allocated_duration(::PROTOBUF_NAMESPACE_ID::Duration* duration);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_duration() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_duration();
  public:
  void unsafe_arena_set_allocated_duration(
      ::PROTOBUF_NAMESPACE_ID::Duration* duration);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_duration();

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:flyteidl.core.Primitive)
 private:
  class _Internal;
  void set_has_integer();
  void set_has_float_value();
  void set_has_string_value();
  void set_has_boolean();
  void set_has_datetime();
  void set_has_duration();

  inline bool has_value() const;
  inline void clear_has_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ValueUnion {
    constexpr ValueUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    int64_t integer_;
    double float_value_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr string_value_;
    bool boolean_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* datetime_;
    ::PROTOBUF_NAMESPACE_ID::Duration* duration_;
  } value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_flyteidl_2fcore_2fliterals_2eproto;
};
// -------------------------------------------------------------------

class Void final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:flyteidl.core.Void) */ {
 public:
  inline Void() : Void(nullptr) {}
  explicit constexpr Void(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Void(const Void& from);
  Void(Void&& from) noexcept
    : Void() {
    *this = ::std::move(from);
  }

  inline Void& operator=(const Void& from) {
    CopyFrom(from);
    return *this;
  }
  inline Void& operator=(Void&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Void& default_instance() {
    return *internal_default_instance();
  }
  static inline const Void* internal_default_instance() {
    return reinterpret_cast<const Void*>(
               &_Void_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Void& a, Void& b) {
    a.Swap(&b);
  }
  inline void Swap(Void* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Void* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Void* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Void>(arena);
  }

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.core.Void";
  }
  protected:
  explicit Void(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:flyteidl.core.Void)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2fliterals_2eproto;
};
// -------------------------------------------------------------------

class Blob final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.Blob) */ {
 public:
  inline Blob() : Blob(nullptr) {}
  ~Blob() override;
  explicit constexpr Blob(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Blob(const Blob& from);
  Blob(Blob&& from) noexcept
    : Blob() {
    *this = ::std::move(from);
  }

  inline Blob& operator=(const Blob& from) {
    CopyFrom(from);
    return *this;
  }
  inline Blob& operator=(Blob&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Blob& default_instance() {
    return *internal_default_instance();
  }
  static inline const Blob* internal_default_instance() {
    return reinterpret_cast<const Blob*>(
               &_Blob_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Blob& a, Blob& b) {
    a.Swap(&b);
  }
  inline void Swap(Blob* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Blob* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Blob* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Blob>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Blob* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.core.Blob";
  }
  protected:
  explicit Blob(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUriFieldNumber = 3,
    kMetadataFieldNumber = 1,
  };
  // string uri = 3 [json_name = "uri"];
  void clear_uri();
  const std::string& uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uri();
  PROTOBUF_NODISCARD std::string* release_uri();
  void set_allocated_uri(std::string* uri);
  private:
  const std::string& _internal_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri(const std::string& value);
  std::string* _internal_mutable_uri();
  public:

  // .flyteidl.core.BlobMetadata metadata = 1 [json_name = "metadata"];
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::flyteidl::core::BlobMetadata& metadata() const;
  PROTOBUF_NODISCARD ::flyteidl::core::BlobMetadata* release_metadata();
  ::flyteidl::core::BlobMetadata* mutable_metadata();
  void set_allocated_metadata(::flyteidl::core::BlobMetadata* metadata);
  private:
  const ::flyteidl::core::BlobMetadata& _internal_metadata() const;
  ::flyteidl::core::BlobMetadata* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::flyteidl::core::BlobMetadata* metadata);
  ::flyteidl::core::BlobMetadata* unsafe_arena_release_metadata();

  // @@protoc_insertion_point(class_scope:flyteidl.core.Blob)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
  ::flyteidl::core::BlobMetadata* metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2fliterals_2eproto;
};
// -------------------------------------------------------------------

class BlobMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.BlobMetadata) */ {
 public:
  inline BlobMetadata() : BlobMetadata(nullptr) {}
  ~BlobMetadata() override;
  explicit constexpr BlobMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlobMetadata(const BlobMetadata& from);
  BlobMetadata(BlobMetadata&& from) noexcept
    : BlobMetadata() {
    *this = ::std::move(from);
  }

  inline BlobMetadata& operator=(const BlobMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlobMetadata& operator=(BlobMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlobMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlobMetadata* internal_default_instance() {
    return reinterpret_cast<const BlobMetadata*>(
               &_BlobMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(BlobMetadata& a, BlobMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(BlobMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlobMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlobMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlobMetadata>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlobMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.core.BlobMetadata";
  }
  protected:
  explicit BlobMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
  };
  // .flyteidl.core.BlobType type = 1 [json_name = "type"];
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  const ::flyteidl::core::BlobType& type() const;
  PROTOBUF_NODISCARD ::flyteidl::core::BlobType* release_type();
  ::flyteidl::core::BlobType* mutable_type();
  void set_allocated_type(::flyteidl::core::BlobType* type);
  private:
  const ::flyteidl::core::BlobType& _internal_type() const;
  ::flyteidl::core::BlobType* _internal_mutable_type();
  public:
  void unsafe_arena_set_allocated_type(
      ::flyteidl::core::BlobType* type);
  ::flyteidl::core::BlobType* unsafe_arena_release_type();

  // @@protoc_insertion_point(class_scope:flyteidl.core.BlobMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::flyteidl::core::BlobType* type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2fliterals_2eproto;
};
// -------------------------------------------------------------------

class Binary final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.Binary) */ {
 public:
  inline Binary() : Binary(nullptr) {}
  ~Binary() override;
  explicit constexpr Binary(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Binary(const Binary& from);
  Binary(Binary&& from) noexcept
    : Binary() {
    *this = ::std::move(from);
  }

  inline Binary& operator=(const Binary& from) {
    CopyFrom(from);
    return *this;
  }
  inline Binary& operator=(Binary&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Binary& default_instance() {
    return *internal_default_instance();
  }
  static inline const Binary* internal_default_instance() {
    return reinterpret_cast<const Binary*>(
               &_Binary_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Binary& a, Binary& b) {
    a.Swap(&b);
  }
  inline void Swap(Binary* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Binary* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Binary* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Binary>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Binary* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.core.Binary";
  }
  protected:
  explicit Binary(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
    kTagFieldNumber = 2,
  };
  // bytes value = 1 [json_name = "value"];
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // string tag = 2 [json_name = "tag"];
  void clear_tag();
  const std::string& tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tag();
  PROTOBUF_NODISCARD std::string* release_tag();
  void set_allocated_tag(std::string* tag);
  private:
  const std::string& _internal_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tag(const std::string& value);
  std::string* _internal_mutable_tag();
  public:

  // @@protoc_insertion_point(class_scope:flyteidl.core.Binary)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2fliterals_2eproto;
};
// -------------------------------------------------------------------

class Schema final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.Schema) */ {
 public:
  inline Schema() : Schema(nullptr) {}
  ~Schema() override;
  explicit constexpr Schema(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Schema(const Schema& from);
  Schema(Schema&& from) noexcept
    : Schema() {
    *this = ::std::move(from);
  }

  inline Schema& operator=(const Schema& from) {
    CopyFrom(from);
    return *this;
  }
  inline Schema& operator=(Schema&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Schema& default_instance() {
    return *internal_default_instance();
  }
  static inline const Schema* internal_default_instance() {
    return reinterpret_cast<const Schema*>(
               &_Schema_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Schema& a, Schema& b) {
    a.Swap(&b);
  }
  inline void Swap(Schema* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Schema* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Schema* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Schema>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Schema* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.core.Schema";
  }
  protected:
  explicit Schema(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUriFieldNumber = 1,
    kTypeFieldNumber = 3,
  };
  // string uri = 1 [json_name = "uri"];
  void clear_uri();
  const std::string& uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uri();
  PROTOBUF_NODISCARD std::string* release_uri();
  void set_allocated_uri(std::string* uri);
  private:
  const std::string& _internal_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri(const std::string& value);
  std::string* _internal_mutable_uri();
  public:

  // .flyteidl.core.SchemaType type = 3 [json_name = "type"];
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  const ::flyteidl::core::SchemaType& type() const;
  PROTOBUF_NODISCARD ::flyteidl::core::SchemaType* release_type();
  ::flyteidl::core::SchemaType* mutable_type();
  void set_allocated_type(::flyteidl::core::SchemaType* type);
  private:
  const ::flyteidl::core::SchemaType& _internal_type() const;
  ::flyteidl::core::SchemaType* _internal_mutable_type();
  public:
  void unsafe_arena_set_allocated_type(
      ::flyteidl::core::SchemaType* type);
  ::flyteidl::core::SchemaType* unsafe_arena_release_type();

  // @@protoc_insertion_point(class_scope:flyteidl.core.Schema)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
  ::flyteidl::core::SchemaType* type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2fliterals_2eproto;
};
// -------------------------------------------------------------------

class Union final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.Union) */ {
 public:
  inline Union() : Union(nullptr) {}
  ~Union() override;
  explicit constexpr Union(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Union(const Union& from);
  Union(Union&& from) noexcept
    : Union() {
    *this = ::std::move(from);
  }

  inline Union& operator=(const Union& from) {
    CopyFrom(from);
    return *this;
  }
  inline Union& operator=(Union&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Union& default_instance() {
    return *internal_default_instance();
  }
  static inline const Union* internal_default_instance() {
    return reinterpret_cast<const Union*>(
               &_Union_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Union& a, Union& b) {
    a.Swap(&b);
  }
  inline void Swap(Union* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Union* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Union* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Union>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Union* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.core.Union";
  }
  protected:
  explicit Union(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // .flyteidl.core.Literal value = 1 [json_name = "value"];
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::flyteidl::core::Literal& value() const;
  PROTOBUF_NODISCARD ::flyteidl::core::Literal* release_value();
  ::flyteidl::core::Literal* mutable_value();
  void set_allocated_value(::flyteidl::core::Literal* value);
  private:
  const ::flyteidl::core::Literal& _internal_value() const;
  ::flyteidl::core::Literal* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::flyteidl::core::Literal* value);
  ::flyteidl::core::Literal* unsafe_arena_release_value();

  // .flyteidl.core.LiteralType type = 2 [json_name = "type"];
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  const ::flyteidl::core::LiteralType& type() const;
  PROTOBUF_NODISCARD ::flyteidl::core::LiteralType* release_type();
  ::flyteidl::core::LiteralType* mutable_type();
  void set_allocated_type(::flyteidl::core::LiteralType* type);
  private:
  const ::flyteidl::core::LiteralType& _internal_type() const;
  ::flyteidl::core::LiteralType* _internal_mutable_type();
  public:
  void unsafe_arena_set_allocated_type(
      ::flyteidl::core::LiteralType* type);
  ::flyteidl::core::LiteralType* unsafe_arena_release_type();

  // @@protoc_insertion_point(class_scope:flyteidl.core.Union)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::flyteidl::core::Literal* value_;
  ::flyteidl::core::LiteralType* type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2fliterals_2eproto;
};
// -------------------------------------------------------------------

class StructuredDatasetMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.StructuredDatasetMetadata) */ {
 public:
  inline StructuredDatasetMetadata() : StructuredDatasetMetadata(nullptr) {}
  ~StructuredDatasetMetadata() override;
  explicit constexpr StructuredDatasetMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StructuredDatasetMetadata(const StructuredDatasetMetadata& from);
  StructuredDatasetMetadata(StructuredDatasetMetadata&& from) noexcept
    : StructuredDatasetMetadata() {
    *this = ::std::move(from);
  }

  inline StructuredDatasetMetadata& operator=(const StructuredDatasetMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline StructuredDatasetMetadata& operator=(StructuredDatasetMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StructuredDatasetMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const StructuredDatasetMetadata* internal_default_instance() {
    return reinterpret_cast<const StructuredDatasetMetadata*>(
               &_StructuredDatasetMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(StructuredDatasetMetadata& a, StructuredDatasetMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(StructuredDatasetMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StructuredDatasetMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StructuredDatasetMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StructuredDatasetMetadata>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StructuredDatasetMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.core.StructuredDatasetMetadata";
  }
  protected:
  explicit StructuredDatasetMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStructuredDatasetTypeFieldNumber = 1,
  };
  // .flyteidl.core.StructuredDatasetType structured_dataset_type = 1 [json_name = "structuredDatasetType"];
  bool has_structured_dataset_type() const;
  private:
  bool _internal_has_structured_dataset_type() const;
  public:
  void clear_structured_dataset_type();
  const ::flyteidl::core::StructuredDatasetType& structured_dataset_type() const;
  PROTOBUF_NODISCARD ::flyteidl::core::StructuredDatasetType* release_structured_dataset_type();
  ::flyteidl::core::StructuredDatasetType* mutable_structured_dataset_type();
  void set_allocated_structured_dataset_type(::flyteidl::core::StructuredDatasetType* structured_dataset_type);
  private:
  const ::flyteidl::core::StructuredDatasetType& _internal_structured_dataset_type() const;
  ::flyteidl::core::StructuredDatasetType* _internal_mutable_structured_dataset_type();
  public:
  void unsafe_arena_set_allocated_structured_dataset_type(
      ::flyteidl::core::StructuredDatasetType* structured_dataset_type);
  ::flyteidl::core::StructuredDatasetType* unsafe_arena_release_structured_dataset_type();

  // @@protoc_insertion_point(class_scope:flyteidl.core.StructuredDatasetMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::flyteidl::core::StructuredDatasetType* structured_dataset_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2fliterals_2eproto;
};
// -------------------------------------------------------------------

class StructuredDataset final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.StructuredDataset) */ {
 public:
  inline StructuredDataset() : StructuredDataset(nullptr) {}
  ~StructuredDataset() override;
  explicit constexpr StructuredDataset(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StructuredDataset(const StructuredDataset& from);
  StructuredDataset(StructuredDataset&& from) noexcept
    : StructuredDataset() {
    *this = ::std::move(from);
  }

  inline StructuredDataset& operator=(const StructuredDataset& from) {
    CopyFrom(from);
    return *this;
  }
  inline StructuredDataset& operator=(StructuredDataset&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StructuredDataset& default_instance() {
    return *internal_default_instance();
  }
  static inline const StructuredDataset* internal_default_instance() {
    return reinterpret_cast<const StructuredDataset*>(
               &_StructuredDataset_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(StructuredDataset& a, StructuredDataset& b) {
    a.Swap(&b);
  }
  inline void Swap(StructuredDataset* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StructuredDataset* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StructuredDataset* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StructuredDataset>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StructuredDataset* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.core.StructuredDataset";
  }
  protected:
  explicit StructuredDataset(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUriFieldNumber = 1,
    kMetadataFieldNumber = 2,
  };
  // string uri = 1 [json_name = "uri"];
  void clear_uri();
  const std::string& uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uri();
  PROTOBUF_NODISCARD std::string* release_uri();
  void set_allocated_uri(std::string* uri);
  private:
  const std::string& _internal_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri(const std::string& value);
  std::string* _internal_mutable_uri();
  public:

  // .flyteidl.core.StructuredDatasetMetadata metadata = 2 [json_name = "metadata"];
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::flyteidl::core::StructuredDatasetMetadata& metadata() const;
  PROTOBUF_NODISCARD ::flyteidl::core::StructuredDatasetMetadata* release_metadata();
  ::flyteidl::core::StructuredDatasetMetadata* mutable_metadata();
  void set_allocated_metadata(::flyteidl::core::StructuredDatasetMetadata* metadata);
  private:
  const ::flyteidl::core::StructuredDatasetMetadata& _internal_metadata() const;
  ::flyteidl::core::StructuredDatasetMetadata* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::flyteidl::core::StructuredDatasetMetadata* metadata);
  ::flyteidl::core::StructuredDatasetMetadata* unsafe_arena_release_metadata();

  // @@protoc_insertion_point(class_scope:flyteidl.core.StructuredDataset)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
  ::flyteidl::core::StructuredDatasetMetadata* metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2fliterals_2eproto;
};
// -------------------------------------------------------------------

class Scalar final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.Scalar) */ {
 public:
  inline Scalar() : Scalar(nullptr) {}
  ~Scalar() override;
  explicit constexpr Scalar(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Scalar(const Scalar& from);
  Scalar(Scalar&& from) noexcept
    : Scalar() {
    *this = ::std::move(from);
  }

  inline Scalar& operator=(const Scalar& from) {
    CopyFrom(from);
    return *this;
  }
  inline Scalar& operator=(Scalar&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Scalar& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kPrimitive = 1,
    kBlob = 2,
    kBinary = 3,
    kSchema = 4,
    kNoneType = 5,
    kError = 6,
    kGeneric = 7,
    kStructuredDataset = 8,
    kUnion = 9,
    VALUE_NOT_SET = 0,
  };

  static inline const Scalar* internal_default_instance() {
    return reinterpret_cast<const Scalar*>(
               &_Scalar_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Scalar& a, Scalar& b) {
    a.Swap(&b);
  }
  inline void Swap(Scalar* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Scalar* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Scalar* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Scalar>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Scalar* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.core.Scalar";
  }
  protected:
  explicit Scalar(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPrimitiveFieldNumber = 1,
    kBlobFieldNumber = 2,
    kBinaryFieldNumber = 3,
    kSchemaFieldNumber = 4,
    kNoneTypeFieldNumber = 5,
    kErrorFieldNumber = 6,
    kGenericFieldNumber = 7,
    kStructuredDatasetFieldNumber = 8,
    kUnionFieldNumber = 9,
  };
  // .flyteidl.core.Primitive primitive = 1 [json_name = "primitive"];
  bool has_primitive() const;
  private:
  bool _internal_has_primitive() const;
  public:
  void clear_primitive();
  const ::flyteidl::core::Primitive& primitive() const;
  PROTOBUF_NODISCARD ::flyteidl::core::Primitive* release_primitive();
  ::flyteidl::core::Primitive* mutable_primitive();
  void set_allocated_primitive(::flyteidl::core::Primitive* primitive);
  private:
  const ::flyteidl::core::Primitive& _internal_primitive() const;
  ::flyteidl::core::Primitive* _internal_mutable_primitive();
  public:
  void unsafe_arena_set_allocated_primitive(
      ::flyteidl::core::Primitive* primitive);
  ::flyteidl::core::Primitive* unsafe_arena_release_primitive();

  // .flyteidl.core.Blob blob = 2 [json_name = "blob"];
  bool has_blob() const;
  private:
  bool _internal_has_blob() const;
  public:
  void clear_blob();
  const ::flyteidl::core::Blob& blob() const;
  PROTOBUF_NODISCARD ::flyteidl::core::Blob* release_blob();
  ::flyteidl::core::Blob* mutable_blob();
  void set_allocated_blob(::flyteidl::core::Blob* blob);
  private:
  const ::flyteidl::core::Blob& _internal_blob() const;
  ::flyteidl::core::Blob* _internal_mutable_blob();
  public:
  void unsafe_arena_set_allocated_blob(
      ::flyteidl::core::Blob* blob);
  ::flyteidl::core::Blob* unsafe_arena_release_blob();

  // .flyteidl.core.Binary binary = 3 [json_name = "binary"];
  bool has_binary() const;
  private:
  bool _internal_has_binary() const;
  public:
  void clear_binary();
  const ::flyteidl::core::Binary& binary() const;
  PROTOBUF_NODISCARD ::flyteidl::core::Binary* release_binary();
  ::flyteidl::core::Binary* mutable_binary();
  void set_allocated_binary(::flyteidl::core::Binary* binary);
  private:
  const ::flyteidl::core::Binary& _internal_binary() const;
  ::flyteidl::core::Binary* _internal_mutable_binary();
  public:
  void unsafe_arena_set_allocated_binary(
      ::flyteidl::core::Binary* binary);
  ::flyteidl::core::Binary* unsafe_arena_release_binary();

  // .flyteidl.core.Schema schema = 4 [json_name = "schema"];
  bool has_schema() const;
  private:
  bool _internal_has_schema() const;
  public:
  void clear_schema();
  const ::flyteidl::core::Schema& schema() const;
  PROTOBUF_NODISCARD ::flyteidl::core::Schema* release_schema();
  ::flyteidl::core::Schema* mutable_schema();
  void set_allocated_schema(::flyteidl::core::Schema* schema);
  private:
  const ::flyteidl::core::Schema& _internal_schema() const;
  ::flyteidl::core::Schema* _internal_mutable_schema();
  public:
  void unsafe_arena_set_allocated_schema(
      ::flyteidl::core::Schema* schema);
  ::flyteidl::core::Schema* unsafe_arena_release_schema();

  // .flyteidl.core.Void none_type = 5 [json_name = "noneType"];
  bool has_none_type() const;
  private:
  bool _internal_has_none_type() const;
  public:
  void clear_none_type();
  const ::flyteidl::core::Void& none_type() const;
  PROTOBUF_NODISCARD ::flyteidl::core::Void* release_none_type();
  ::flyteidl::core::Void* mutable_none_type();
  void set_allocated_none_type(::flyteidl::core::Void* none_type);
  private:
  const ::flyteidl::core::Void& _internal_none_type() const;
  ::flyteidl::core::Void* _internal_mutable_none_type();
  public:
  void unsafe_arena_set_allocated_none_type(
      ::flyteidl::core::Void* none_type);
  ::flyteidl::core::Void* unsafe_arena_release_none_type();

  // .flyteidl.core.Error error = 6 [json_name = "error"];
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::flyteidl::core::Error& error() const;
  PROTOBUF_NODISCARD ::flyteidl::core::Error* release_error();
  ::flyteidl::core::Error* mutable_error();
  void set_allocated_error(::flyteidl::core::Error* error);
  private:
  const ::flyteidl::core::Error& _internal_error() const;
  ::flyteidl::core::Error* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::flyteidl::core::Error* error);
  ::flyteidl::core::Error* unsafe_arena_release_error();

  // .google.protobuf.Struct generic = 7 [json_name = "generic"];
  bool has_generic() const;
  private:
  bool _internal_has_generic() const;
  public:
  void clear_generic();
  const ::PROTOBUF_NAMESPACE_ID::Struct& generic() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_generic();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_generic();
  void set_allocated_generic(::PROTOBUF_NAMESPACE_ID::Struct* generic);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_generic() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_generic();
  public:
  void unsafe_arena_set_allocated_generic(
      ::PROTOBUF_NAMESPACE_ID::Struct* generic);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_generic();

  // .flyteidl.core.StructuredDataset structured_dataset = 8 [json_name = "structuredDataset"];
  bool has_structured_dataset() const;
  private:
  bool _internal_has_structured_dataset() const;
  public:
  void clear_structured_dataset();
  const ::flyteidl::core::StructuredDataset& structured_dataset() const;
  PROTOBUF_NODISCARD ::flyteidl::core::StructuredDataset* release_structured_dataset();
  ::flyteidl::core::StructuredDataset* mutable_structured_dataset();
  void set_allocated_structured_dataset(::flyteidl::core::StructuredDataset* structured_dataset);
  private:
  const ::flyteidl::core::StructuredDataset& _internal_structured_dataset() const;
  ::flyteidl::core::StructuredDataset* _internal_mutable_structured_dataset();
  public:
  void unsafe_arena_set_allocated_structured_dataset(
      ::flyteidl::core::StructuredDataset* structured_dataset);
  ::flyteidl::core::StructuredDataset* unsafe_arena_release_structured_dataset();

  // .flyteidl.core.Union union = 9 [json_name = "union"];
  bool has_union_() const;
  private:
  bool _internal_has_union_() const;
  public:
  void clear_union_();
  const ::flyteidl::core::Union& union_() const;
  PROTOBUF_NODISCARD ::flyteidl::core::Union* release_union_();
  ::flyteidl::core::Union* mutable_union_();
  void set_allocated_union_(::flyteidl::core::Union* union_);
  private:
  const ::flyteidl::core::Union& _internal_union_() const;
  ::flyteidl::core::Union* _internal_mutable_union_();
  public:
  void unsafe_arena_set_allocated_union_(
      ::flyteidl::core::Union* union_);
  ::flyteidl::core::Union* unsafe_arena_release_union_();

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:flyteidl.core.Scalar)
 private:
  class _Internal;
  void set_has_primitive();
  void set_has_blob();
  void set_has_binary();
  void set_has_schema();
  void set_has_none_type();
  void set_has_error();
  void set_has_generic();
  void set_has_structured_dataset();
  void set_has_union_();

  inline bool has_value() const;
  inline void clear_has_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ValueUnion {
    constexpr ValueUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::flyteidl::core::Primitive* primitive_;
    ::flyteidl::core::Blob* blob_;
    ::flyteidl::core::Binary* binary_;
    ::flyteidl::core::Schema* schema_;
    ::flyteidl::core::Void* none_type_;
    ::flyteidl::core::Error* error_;
    ::PROTOBUF_NAMESPACE_ID::Struct* generic_;
    ::flyteidl::core::StructuredDataset* structured_dataset_;
    ::flyteidl::core::Union* union__;
  } value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_flyteidl_2fcore_2fliterals_2eproto;
};
// -------------------------------------------------------------------

class Literal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.Literal) */ {
 public:
  inline Literal() : Literal(nullptr) {}
  ~Literal() override;
  explicit constexpr Literal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Literal(const Literal& from);
  Literal(Literal&& from) noexcept
    : Literal() {
    *this = ::std::move(from);
  }

  inline Literal& operator=(const Literal& from) {
    CopyFrom(from);
    return *this;
  }
  inline Literal& operator=(Literal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Literal& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kScalar = 1,
    kCollection = 2,
    kMap = 3,
    VALUE_NOT_SET = 0,
  };

  static inline const Literal* internal_default_instance() {
    return reinterpret_cast<const Literal*>(
               &_Literal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Literal& a, Literal& b) {
    a.Swap(&b);
  }
  inline void Swap(Literal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Literal* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Literal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Literal>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Literal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.core.Literal";
  }
  protected:
  explicit Literal(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHashFieldNumber = 4,
    kScalarFieldNumber = 1,
    kCollectionFieldNumber = 2,
    kMapFieldNumber = 3,
  };
  // string hash = 4 [json_name = "hash"];
  void clear_hash();
  const std::string& hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hash();
  PROTOBUF_NODISCARD std::string* release_hash();
  void set_allocated_hash(std::string* hash);
  private:
  const std::string& _internal_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash(const std::string& value);
  std::string* _internal_mutable_hash();
  public:

  // .flyteidl.core.Scalar scalar = 1 [json_name = "scalar"];
  bool has_scalar() const;
  private:
  bool _internal_has_scalar() const;
  public:
  void clear_scalar();
  const ::flyteidl::core::Scalar& scalar() const;
  PROTOBUF_NODISCARD ::flyteidl::core::Scalar* release_scalar();
  ::flyteidl::core::Scalar* mutable_scalar();
  void set_allocated_scalar(::flyteidl::core::Scalar* scalar);
  private:
  const ::flyteidl::core::Scalar& _internal_scalar() const;
  ::flyteidl::core::Scalar* _internal_mutable_scalar();
  public:
  void unsafe_arena_set_allocated_scalar(
      ::flyteidl::core::Scalar* scalar);
  ::flyteidl::core::Scalar* unsafe_arena_release_scalar();

  // .flyteidl.core.LiteralCollection collection = 2 [json_name = "collection"];
  bool has_collection() const;
  private:
  bool _internal_has_collection() const;
  public:
  void clear_collection();
  const ::flyteidl::core::LiteralCollection& collection() const;
  PROTOBUF_NODISCARD ::flyteidl::core::LiteralCollection* release_collection();
  ::flyteidl::core::LiteralCollection* mutable_collection();
  void set_allocated_collection(::flyteidl::core::LiteralCollection* collection);
  private:
  const ::flyteidl::core::LiteralCollection& _internal_collection() const;
  ::flyteidl::core::LiteralCollection* _internal_mutable_collection();
  public:
  void unsafe_arena_set_allocated_collection(
      ::flyteidl::core::LiteralCollection* collection);
  ::flyteidl::core::LiteralCollection* unsafe_arena_release_collection();

  // .flyteidl.core.LiteralMap map = 3 [json_name = "map"];
  bool has_map() const;
  private:
  bool _internal_has_map() const;
  public:
  void clear_map();
  const ::flyteidl::core::LiteralMap& map() const;
  PROTOBUF_NODISCARD ::flyteidl::core::LiteralMap* release_map();
  ::flyteidl::core::LiteralMap* mutable_map();
  void set_allocated_map(::flyteidl::core::LiteralMap* map);
  private:
  const ::flyteidl::core::LiteralMap& _internal_map() const;
  ::flyteidl::core::LiteralMap* _internal_mutable_map();
  public:
  void unsafe_arena_set_allocated_map(
      ::flyteidl::core::LiteralMap* map);
  ::flyteidl::core::LiteralMap* unsafe_arena_release_map();

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:flyteidl.core.Literal)
 private:
  class _Internal;
  void set_has_scalar();
  void set_has_collection();
  void set_has_map();

  inline bool has_value() const;
  inline void clear_has_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
  union ValueUnion {
    constexpr ValueUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::flyteidl::core::Scalar* scalar_;
    ::flyteidl::core::LiteralCollection* collection_;
    ::flyteidl::core::LiteralMap* map_;
  } value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_flyteidl_2fcore_2fliterals_2eproto;
};
// -------------------------------------------------------------------

class LiteralCollection final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.LiteralCollection) */ {
 public:
  inline LiteralCollection() : LiteralCollection(nullptr) {}
  ~LiteralCollection() override;
  explicit constexpr LiteralCollection(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LiteralCollection(const LiteralCollection& from);
  LiteralCollection(LiteralCollection&& from) noexcept
    : LiteralCollection() {
    *this = ::std::move(from);
  }

  inline LiteralCollection& operator=(const LiteralCollection& from) {
    CopyFrom(from);
    return *this;
  }
  inline LiteralCollection& operator=(LiteralCollection&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LiteralCollection& default_instance() {
    return *internal_default_instance();
  }
  static inline const LiteralCollection* internal_default_instance() {
    return reinterpret_cast<const LiteralCollection*>(
               &_LiteralCollection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(LiteralCollection& a, LiteralCollection& b) {
    a.Swap(&b);
  }
  inline void Swap(LiteralCollection* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LiteralCollection* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LiteralCollection* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LiteralCollection>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LiteralCollection* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.core.LiteralCollection";
  }
  protected:
  explicit LiteralCollection(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLiteralsFieldNumber = 1,
  };
  // repeated .flyteidl.core.Literal literals = 1 [json_name = "literals"];
  int literals_size() const;
  private:
  int _internal_literals_size() const;
  public:
  void clear_literals();
  ::flyteidl::core::Literal* mutable_literals(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::core::Literal >*
      mutable_literals();
  private:
  const ::flyteidl::core::Literal& _internal_literals(int index) const;
  ::flyteidl::core::Literal* _internal_add_literals();
  public:
  const ::flyteidl::core::Literal& literals(int index) const;
  ::flyteidl::core::Literal* add_literals();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::core::Literal >&
      literals() const;

  // @@protoc_insertion_point(class_scope:flyteidl.core.LiteralCollection)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::core::Literal > literals_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2fliterals_2eproto;
};
// -------------------------------------------------------------------

class LiteralMap_LiteralsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LiteralMap_LiteralsEntry_DoNotUse, 
    std::string, ::flyteidl::core::Literal,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LiteralMap_LiteralsEntry_DoNotUse, 
    std::string, ::flyteidl::core::Literal,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  LiteralMap_LiteralsEntry_DoNotUse();
  explicit constexpr LiteralMap_LiteralsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit LiteralMap_LiteralsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const LiteralMap_LiteralsEntry_DoNotUse& other);
  static const LiteralMap_LiteralsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const LiteralMap_LiteralsEntry_DoNotUse*>(&_LiteralMap_LiteralsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "flyteidl.core.LiteralMap.LiteralsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class LiteralMap final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.LiteralMap) */ {
 public:
  inline LiteralMap() : LiteralMap(nullptr) {}
  ~LiteralMap() override;
  explicit constexpr LiteralMap(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LiteralMap(const LiteralMap& from);
  LiteralMap(LiteralMap&& from) noexcept
    : LiteralMap() {
    *this = ::std::move(from);
  }

  inline LiteralMap& operator=(const LiteralMap& from) {
    CopyFrom(from);
    return *this;
  }
  inline LiteralMap& operator=(LiteralMap&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LiteralMap& default_instance() {
    return *internal_default_instance();
  }
  static inline const LiteralMap* internal_default_instance() {
    return reinterpret_cast<const LiteralMap*>(
               &_LiteralMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(LiteralMap& a, LiteralMap& b) {
    a.Swap(&b);
  }
  inline void Swap(LiteralMap* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LiteralMap* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LiteralMap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LiteralMap>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LiteralMap* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.core.LiteralMap";
  }
  protected:
  explicit LiteralMap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kLiteralsFieldNumber = 1,
  };
  // map<string, .flyteidl.core.Literal> literals = 1 [json_name = "literals"];
  int literals_size() const;
  private:
  int _internal_literals_size() const;
  public:
  void clear_literals();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::flyteidl::core::Literal >&
      _internal_literals() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::flyteidl::core::Literal >*
      _internal_mutable_literals();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::flyteidl::core::Literal >&
      literals() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::flyteidl::core::Literal >*
      mutable_literals();

  // @@protoc_insertion_point(class_scope:flyteidl.core.LiteralMap)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      LiteralMap_LiteralsEntry_DoNotUse,
      std::string, ::flyteidl::core::Literal,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> literals_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2fliterals_2eproto;
};
// -------------------------------------------------------------------

class BindingDataCollection final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.BindingDataCollection) */ {
 public:
  inline BindingDataCollection() : BindingDataCollection(nullptr) {}
  ~BindingDataCollection() override;
  explicit constexpr BindingDataCollection(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BindingDataCollection(const BindingDataCollection& from);
  BindingDataCollection(BindingDataCollection&& from) noexcept
    : BindingDataCollection() {
    *this = ::std::move(from);
  }

  inline BindingDataCollection& operator=(const BindingDataCollection& from) {
    CopyFrom(from);
    return *this;
  }
  inline BindingDataCollection& operator=(BindingDataCollection&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BindingDataCollection& default_instance() {
    return *internal_default_instance();
  }
  static inline const BindingDataCollection* internal_default_instance() {
    return reinterpret_cast<const BindingDataCollection*>(
               &_BindingDataCollection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(BindingDataCollection& a, BindingDataCollection& b) {
    a.Swap(&b);
  }
  inline void Swap(BindingDataCollection* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BindingDataCollection* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BindingDataCollection* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BindingDataCollection>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BindingDataCollection* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.core.BindingDataCollection";
  }
  protected:
  explicit BindingDataCollection(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBindingsFieldNumber = 1,
  };
  // repeated .flyteidl.core.BindingData bindings = 1 [json_name = "bindings"];
  int bindings_size() const;
  private:
  int _internal_bindings_size() const;
  public:
  void clear_bindings();
  ::flyteidl::core::BindingData* mutable_bindings(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::core::BindingData >*
      mutable_bindings();
  private:
  const ::flyteidl::core::BindingData& _internal_bindings(int index) const;
  ::flyteidl::core::BindingData* _internal_add_bindings();
  public:
  const ::flyteidl::core::BindingData& bindings(int index) const;
  ::flyteidl::core::BindingData* add_bindings();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::core::BindingData >&
      bindings() const;

  // @@protoc_insertion_point(class_scope:flyteidl.core.BindingDataCollection)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::core::BindingData > bindings_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2fliterals_2eproto;
};
// -------------------------------------------------------------------

class BindingDataMap_BindingsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<BindingDataMap_BindingsEntry_DoNotUse, 
    std::string, ::flyteidl::core::BindingData,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<BindingDataMap_BindingsEntry_DoNotUse, 
    std::string, ::flyteidl::core::BindingData,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  BindingDataMap_BindingsEntry_DoNotUse();
  explicit constexpr BindingDataMap_BindingsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit BindingDataMap_BindingsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const BindingDataMap_BindingsEntry_DoNotUse& other);
  static const BindingDataMap_BindingsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const BindingDataMap_BindingsEntry_DoNotUse*>(&_BindingDataMap_BindingsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "flyteidl.core.BindingDataMap.BindingsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class BindingDataMap final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.BindingDataMap) */ {
 public:
  inline BindingDataMap() : BindingDataMap(nullptr) {}
  ~BindingDataMap() override;
  explicit constexpr BindingDataMap(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BindingDataMap(const BindingDataMap& from);
  BindingDataMap(BindingDataMap&& from) noexcept
    : BindingDataMap() {
    *this = ::std::move(from);
  }

  inline BindingDataMap& operator=(const BindingDataMap& from) {
    CopyFrom(from);
    return *this;
  }
  inline BindingDataMap& operator=(BindingDataMap&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BindingDataMap& default_instance() {
    return *internal_default_instance();
  }
  static inline const BindingDataMap* internal_default_instance() {
    return reinterpret_cast<const BindingDataMap*>(
               &_BindingDataMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(BindingDataMap& a, BindingDataMap& b) {
    a.Swap(&b);
  }
  inline void Swap(BindingDataMap* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BindingDataMap* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BindingDataMap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BindingDataMap>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BindingDataMap* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.core.BindingDataMap";
  }
  protected:
  explicit BindingDataMap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kBindingsFieldNumber = 1,
  };
  // map<string, .flyteidl.core.BindingData> bindings = 1 [json_name = "bindings"];
  int bindings_size() const;
  private:
  int _internal_bindings_size() const;
  public:
  void clear_bindings();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::flyteidl::core::BindingData >&
      _internal_bindings() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::flyteidl::core::BindingData >*
      _internal_mutable_bindings();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::flyteidl::core::BindingData >&
      bindings() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::flyteidl::core::BindingData >*
      mutable_bindings();

  // @@protoc_insertion_point(class_scope:flyteidl.core.BindingDataMap)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      BindingDataMap_BindingsEntry_DoNotUse,
      std::string, ::flyteidl::core::BindingData,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> bindings_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2fliterals_2eproto;
};
// -------------------------------------------------------------------

class UnionInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.UnionInfo) */ {
 public:
  inline UnionInfo() : UnionInfo(nullptr) {}
  ~UnionInfo() override;
  explicit constexpr UnionInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnionInfo(const UnionInfo& from);
  UnionInfo(UnionInfo&& from) noexcept
    : UnionInfo() {
    *this = ::std::move(from);
  }

  inline UnionInfo& operator=(const UnionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnionInfo& operator=(UnionInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnionInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnionInfo* internal_default_instance() {
    return reinterpret_cast<const UnionInfo*>(
               &_UnionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(UnionInfo& a, UnionInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(UnionInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnionInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnionInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnionInfo>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnionInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.core.UnionInfo";
  }
  protected:
  explicit UnionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetTypeFieldNumber = 1,
  };
  // .flyteidl.core.LiteralType targetType = 1 [json_name = "targetType"];
  bool has_targettype() const;
  private:
  bool _internal_has_targettype() const;
  public:
  void clear_targettype();
  const ::flyteidl::core::LiteralType& targettype() const;
  PROTOBUF_NODISCARD ::flyteidl::core::LiteralType* release_targettype();
  ::flyteidl::core::LiteralType* mutable_targettype();
  void set_allocated_targettype(::flyteidl::core::LiteralType* targettype);
  private:
  const ::flyteidl::core::LiteralType& _internal_targettype() const;
  ::flyteidl::core::LiteralType* _internal_mutable_targettype();
  public:
  void unsafe_arena_set_allocated_targettype(
      ::flyteidl::core::LiteralType* targettype);
  ::flyteidl::core::LiteralType* unsafe_arena_release_targettype();

  // @@protoc_insertion_point(class_scope:flyteidl.core.UnionInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::flyteidl::core::LiteralType* targettype_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2fliterals_2eproto;
};
// -------------------------------------------------------------------

class BindingData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.BindingData) */ {
 public:
  inline BindingData() : BindingData(nullptr) {}
  ~BindingData() override;
  explicit constexpr BindingData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BindingData(const BindingData& from);
  BindingData(BindingData&& from) noexcept
    : BindingData() {
    *this = ::std::move(from);
  }

  inline BindingData& operator=(const BindingData& from) {
    CopyFrom(from);
    return *this;
  }
  inline BindingData& operator=(BindingData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BindingData& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kScalar = 1,
    kCollection = 2,
    kPromise = 3,
    kMap = 4,
    VALUE_NOT_SET = 0,
  };

  static inline const BindingData* internal_default_instance() {
    return reinterpret_cast<const BindingData*>(
               &_BindingData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(BindingData& a, BindingData& b) {
    a.Swap(&b);
  }
  inline void Swap(BindingData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BindingData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BindingData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BindingData>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BindingData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.core.BindingData";
  }
  protected:
  explicit BindingData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUnionFieldNumber = 5,
    kScalarFieldNumber = 1,
    kCollectionFieldNumber = 2,
    kPromiseFieldNumber = 3,
    kMapFieldNumber = 4,
  };
  // .flyteidl.core.UnionInfo union = 5 [json_name = "union"];
  bool has_union_() const;
  private:
  bool _internal_has_union_() const;
  public:
  void clear_union_();
  const ::flyteidl::core::UnionInfo& union_() const;
  PROTOBUF_NODISCARD ::flyteidl::core::UnionInfo* release_union_();
  ::flyteidl::core::UnionInfo* mutable_union_();
  void set_allocated_union_(::flyteidl::core::UnionInfo* union_);
  private:
  const ::flyteidl::core::UnionInfo& _internal_union_() const;
  ::flyteidl::core::UnionInfo* _internal_mutable_union_();
  public:
  void unsafe_arena_set_allocated_union_(
      ::flyteidl::core::UnionInfo* union_);
  ::flyteidl::core::UnionInfo* unsafe_arena_release_union_();

  // .flyteidl.core.Scalar scalar = 1 [json_name = "scalar"];
  bool has_scalar() const;
  private:
  bool _internal_has_scalar() const;
  public:
  void clear_scalar();
  const ::flyteidl::core::Scalar& scalar() const;
  PROTOBUF_NODISCARD ::flyteidl::core::Scalar* release_scalar();
  ::flyteidl::core::Scalar* mutable_scalar();
  void set_allocated_scalar(::flyteidl::core::Scalar* scalar);
  private:
  const ::flyteidl::core::Scalar& _internal_scalar() const;
  ::flyteidl::core::Scalar* _internal_mutable_scalar();
  public:
  void unsafe_arena_set_allocated_scalar(
      ::flyteidl::core::Scalar* scalar);
  ::flyteidl::core::Scalar* unsafe_arena_release_scalar();

  // .flyteidl.core.BindingDataCollection collection = 2 [json_name = "collection"];
  bool has_collection() const;
  private:
  bool _internal_has_collection() const;
  public:
  void clear_collection();
  const ::flyteidl::core::BindingDataCollection& collection() const;
  PROTOBUF_NODISCARD ::flyteidl::core::BindingDataCollection* release_collection();
  ::flyteidl::core::BindingDataCollection* mutable_collection();
  void set_allocated_collection(::flyteidl::core::BindingDataCollection* collection);
  private:
  const ::flyteidl::core::BindingDataCollection& _internal_collection() const;
  ::flyteidl::core::BindingDataCollection* _internal_mutable_collection();
  public:
  void unsafe_arena_set_allocated_collection(
      ::flyteidl::core::BindingDataCollection* collection);
  ::flyteidl::core::BindingDataCollection* unsafe_arena_release_collection();

  // .flyteidl.core.OutputReference promise = 3 [json_name = "promise"];
  bool has_promise() const;
  private:
  bool _internal_has_promise() const;
  public:
  void clear_promise();
  const ::flyteidl::core::OutputReference& promise() const;
  PROTOBUF_NODISCARD ::flyteidl::core::OutputReference* release_promise();
  ::flyteidl::core::OutputReference* mutable_promise();
  void set_allocated_promise(::flyteidl::core::OutputReference* promise);
  private:
  const ::flyteidl::core::OutputReference& _internal_promise() const;
  ::flyteidl::core::OutputReference* _internal_mutable_promise();
  public:
  void unsafe_arena_set_allocated_promise(
      ::flyteidl::core::OutputReference* promise);
  ::flyteidl::core::OutputReference* unsafe_arena_release_promise();

  // .flyteidl.core.BindingDataMap map = 4 [json_name = "map"];
  bool has_map() const;
  private:
  bool _internal_has_map() const;
  public:
  void clear_map();
  const ::flyteidl::core::BindingDataMap& map() const;
  PROTOBUF_NODISCARD ::flyteidl::core::BindingDataMap* release_map();
  ::flyteidl::core::BindingDataMap* mutable_map();
  void set_allocated_map(::flyteidl::core::BindingDataMap* map);
  private:
  const ::flyteidl::core::BindingDataMap& _internal_map() const;
  ::flyteidl::core::BindingDataMap* _internal_mutable_map();
  public:
  void unsafe_arena_set_allocated_map(
      ::flyteidl::core::BindingDataMap* map);
  ::flyteidl::core::BindingDataMap* unsafe_arena_release_map();

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:flyteidl.core.BindingData)
 private:
  class _Internal;
  void set_has_scalar();
  void set_has_collection();
  void set_has_promise();
  void set_has_map();

  inline bool has_value() const;
  inline void clear_has_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::flyteidl::core::UnionInfo* union__;
  union ValueUnion {
    constexpr ValueUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::flyteidl::core::Scalar* scalar_;
    ::flyteidl::core::BindingDataCollection* collection_;
    ::flyteidl::core::OutputReference* promise_;
    ::flyteidl::core::BindingDataMap* map_;
  } value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_flyteidl_2fcore_2fliterals_2eproto;
};
// -------------------------------------------------------------------

class Binding final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.Binding) */ {
 public:
  inline Binding() : Binding(nullptr) {}
  ~Binding() override;
  explicit constexpr Binding(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Binding(const Binding& from);
  Binding(Binding&& from) noexcept
    : Binding() {
    *this = ::std::move(from);
  }

  inline Binding& operator=(const Binding& from) {
    CopyFrom(from);
    return *this;
  }
  inline Binding& operator=(Binding&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Binding& default_instance() {
    return *internal_default_instance();
  }
  static inline const Binding* internal_default_instance() {
    return reinterpret_cast<const Binding*>(
               &_Binding_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(Binding& a, Binding& b) {
    a.Swap(&b);
  }
  inline void Swap(Binding* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Binding* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Binding* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Binding>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Binding* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.core.Binding";
  }
  protected:
  explicit Binding(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVarFieldNumber = 1,
    kBindingFieldNumber = 2,
  };
  // string var = 1 [json_name = "var"];
  void clear_var();
  const std::string& var() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_var(ArgT0&& arg0, ArgT... args);
  std::string* mutable_var();
  PROTOBUF_NODISCARD std::string* release_var();
  void set_allocated_var(std::string* var);
  private:
  const std::string& _internal_var() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_var(const std::string& value);
  std::string* _internal_mutable_var();
  public:

  // .flyteidl.core.BindingData binding = 2 [json_name = "binding"];
  bool has_binding() const;
  private:
  bool _internal_has_binding() const;
  public:
  void clear_binding();
  const ::flyteidl::core::BindingData& binding() const;
  PROTOBUF_NODISCARD ::flyteidl::core::BindingData* release_binding();
  ::flyteidl::core::BindingData* mutable_binding();
  void set_allocated_binding(::flyteidl::core::BindingData* binding);
  private:
  const ::flyteidl::core::BindingData& _internal_binding() const;
  ::flyteidl::core::BindingData* _internal_mutable_binding();
  public:
  void unsafe_arena_set_allocated_binding(
      ::flyteidl::core::BindingData* binding);
  ::flyteidl::core::BindingData* unsafe_arena_release_binding();

  // @@protoc_insertion_point(class_scope:flyteidl.core.Binding)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr var_;
  ::flyteidl::core::BindingData* binding_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2fliterals_2eproto;
};
// -------------------------------------------------------------------

class KeyValuePair final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.KeyValuePair) */ {
 public:
  inline KeyValuePair() : KeyValuePair(nullptr) {}
  ~KeyValuePair() override;
  explicit constexpr KeyValuePair(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KeyValuePair(const KeyValuePair& from);
  KeyValuePair(KeyValuePair&& from) noexcept
    : KeyValuePair() {
    *this = ::std::move(from);
  }

  inline KeyValuePair& operator=(const KeyValuePair& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyValuePair& operator=(KeyValuePair&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeyValuePair& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeyValuePair* internal_default_instance() {
    return reinterpret_cast<const KeyValuePair*>(
               &_KeyValuePair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(KeyValuePair& a, KeyValuePair& b) {
    a.Swap(&b);
  }
  inline void Swap(KeyValuePair* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyValuePair* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeyValuePair* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KeyValuePair>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyValuePair* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.core.KeyValuePair";
  }
  protected:
  explicit KeyValuePair(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string key = 1 [json_name = "key"];
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // string value = 2 [json_name = "value"];
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:flyteidl.core.KeyValuePair)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2fliterals_2eproto;
};
// -------------------------------------------------------------------

class RetryStrategy final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.RetryStrategy) */ {
 public:
  inline RetryStrategy() : RetryStrategy(nullptr) {}
  ~RetryStrategy() override;
  explicit constexpr RetryStrategy(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RetryStrategy(const RetryStrategy& from);
  RetryStrategy(RetryStrategy&& from) noexcept
    : RetryStrategy() {
    *this = ::std::move(from);
  }

  inline RetryStrategy& operator=(const RetryStrategy& from) {
    CopyFrom(from);
    return *this;
  }
  inline RetryStrategy& operator=(RetryStrategy&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RetryStrategy& default_instance() {
    return *internal_default_instance();
  }
  static inline const RetryStrategy* internal_default_instance() {
    return reinterpret_cast<const RetryStrategy*>(
               &_RetryStrategy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(RetryStrategy& a, RetryStrategy& b) {
    a.Swap(&b);
  }
  inline void Swap(RetryStrategy* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RetryStrategy* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RetryStrategy* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RetryStrategy>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RetryStrategy* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.core.RetryStrategy";
  }
  protected:
  explicit RetryStrategy(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRetriesFieldNumber = 5,
  };
  // uint32 retries = 5 [json_name = "retries"];
  void clear_retries();
  uint32_t retries() const;
  void set_retries(uint32_t value);
  private:
  uint32_t _internal_retries() const;
  void _internal_set_retries(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:flyteidl.core.RetryStrategy)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t retries_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2fliterals_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Primitive

// int64 integer = 1 [json_name = "integer"];
inline bool Primitive::_internal_has_integer() const {
  return value_case() == kInteger;
}
inline bool Primitive::has_integer() const {
  return _internal_has_integer();
}
inline void Primitive::set_has_integer() {
  _oneof_case_[0] = kInteger;
}
inline void Primitive::clear_integer() {
  if (_internal_has_integer()) {
    value_.integer_ = int64_t{0};
    clear_has_value();
  }
}
inline int64_t Primitive::_internal_integer() const {
  if (_internal_has_integer()) {
    return value_.integer_;
  }
  return int64_t{0};
}
inline void Primitive::_internal_set_integer(int64_t value) {
  if (!_internal_has_integer()) {
    clear_value();
    set_has_integer();
  }
  value_.integer_ = value;
}
inline int64_t Primitive::integer() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Primitive.integer)
  return _internal_integer();
}
inline void Primitive::set_integer(int64_t value) {
  _internal_set_integer(value);
  // @@protoc_insertion_point(field_set:flyteidl.core.Primitive.integer)
}

// double float_value = 2 [json_name = "floatValue"];
inline bool Primitive::_internal_has_float_value() const {
  return value_case() == kFloatValue;
}
inline bool Primitive::has_float_value() const {
  return _internal_has_float_value();
}
inline void Primitive::set_has_float_value() {
  _oneof_case_[0] = kFloatValue;
}
inline void Primitive::clear_float_value() {
  if (_internal_has_float_value()) {
    value_.float_value_ = 0;
    clear_has_value();
  }
}
inline double Primitive::_internal_float_value() const {
  if (_internal_has_float_value()) {
    return value_.float_value_;
  }
  return 0;
}
inline void Primitive::_internal_set_float_value(double value) {
  if (!_internal_has_float_value()) {
    clear_value();
    set_has_float_value();
  }
  value_.float_value_ = value;
}
inline double Primitive::float_value() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Primitive.float_value)
  return _internal_float_value();
}
inline void Primitive::set_float_value(double value) {
  _internal_set_float_value(value);
  // @@protoc_insertion_point(field_set:flyteidl.core.Primitive.float_value)
}

// string string_value = 3 [json_name = "stringValue"];
inline bool Primitive::_internal_has_string_value() const {
  return value_case() == kStringValue;
}
inline bool Primitive::has_string_value() const {
  return _internal_has_string_value();
}
inline void Primitive::set_has_string_value() {
  _oneof_case_[0] = kStringValue;
}
inline void Primitive::clear_string_value() {
  if (_internal_has_string_value()) {
    value_.string_value_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_value();
  }
}
inline const std::string& Primitive::string_value() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Primitive.string_value)
  return _internal_string_value();
}
template <typename ArgT0, typename... ArgT>
inline void Primitive::set_string_value(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_string_value()) {
    clear_value();
    set_has_string_value();
    value_.string_value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  value_.string_value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.core.Primitive.string_value)
}
inline std::string* Primitive::mutable_string_value() {
  std::string* _s = _internal_mutable_string_value();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Primitive.string_value)
  return _s;
}
inline const std::string& Primitive::_internal_string_value() const {
  if (_internal_has_string_value()) {
    return value_.string_value_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Primitive::_internal_set_string_value(const std::string& value) {
  if (!_internal_has_string_value()) {
    clear_value();
    set_has_string_value();
    value_.string_value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  value_.string_value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Primitive::_internal_mutable_string_value() {
  if (!_internal_has_string_value()) {
    clear_value();
    set_has_string_value();
    value_.string_value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return value_.string_value_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Primitive::release_string_value() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Primitive.string_value)
  if (_internal_has_string_value()) {
    clear_has_value();
    return value_.string_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void Primitive::set_allocated_string_value(std::string* string_value) {
  if (has_value()) {
    clear_value();
  }
  if (string_value != nullptr) {
    set_has_string_value();
    value_.string_value_.UnsafeSetDefault(string_value);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(string_value);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.Primitive.string_value)
}

// bool boolean = 4 [json_name = "boolean"];
inline bool Primitive::_internal_has_boolean() const {
  return value_case() == kBoolean;
}
inline bool Primitive::has_boolean() const {
  return _internal_has_boolean();
}
inline void Primitive::set_has_boolean() {
  _oneof_case_[0] = kBoolean;
}
inline void Primitive::clear_boolean() {
  if (_internal_has_boolean()) {
    value_.boolean_ = false;
    clear_has_value();
  }
}
inline bool Primitive::_internal_boolean() const {
  if (_internal_has_boolean()) {
    return value_.boolean_;
  }
  return false;
}
inline void Primitive::_internal_set_boolean(bool value) {
  if (!_internal_has_boolean()) {
    clear_value();
    set_has_boolean();
  }
  value_.boolean_ = value;
}
inline bool Primitive::boolean() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Primitive.boolean)
  return _internal_boolean();
}
inline void Primitive::set_boolean(bool value) {
  _internal_set_boolean(value);
  // @@protoc_insertion_point(field_set:flyteidl.core.Primitive.boolean)
}

// .google.protobuf.Timestamp datetime = 5 [json_name = "datetime"];
inline bool Primitive::_internal_has_datetime() const {
  return value_case() == kDatetime;
}
inline bool Primitive::has_datetime() const {
  return _internal_has_datetime();
}
inline void Primitive::set_has_datetime() {
  _oneof_case_[0] = kDatetime;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Primitive::release_datetime() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Primitive.datetime)
  if (_internal_has_datetime()) {
    clear_has_value();
      ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = value_.datetime_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.datetime_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Primitive::_internal_datetime() const {
  return _internal_has_datetime()
      ? *value_.datetime_
      : reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::Timestamp&>(::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Primitive::datetime() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Primitive.datetime)
  return _internal_datetime();
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Primitive::unsafe_arena_release_datetime() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flyteidl.core.Primitive.datetime)
  if (_internal_has_datetime()) {
    clear_has_value();
    ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = value_.datetime_;
    value_.datetime_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Primitive::unsafe_arena_set_allocated_datetime(::PROTOBUF_NAMESPACE_ID::Timestamp* datetime) {
  clear_value();
  if (datetime) {
    set_has_datetime();
    value_.datetime_ = datetime;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.core.Primitive.datetime)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Primitive::_internal_mutable_datetime() {
  if (!_internal_has_datetime()) {
    clear_value();
    set_has_datetime();
    value_.datetime_ = CreateMaybeMessage< ::PROTOBUF_NAMESPACE_ID::Timestamp >(GetArenaForAllocation());
  }
  return value_.datetime_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Primitive::mutable_datetime() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_datetime();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Primitive.datetime)
  return _msg;
}

// .google.protobuf.Duration duration = 6 [json_name = "duration"];
inline bool Primitive::_internal_has_duration() const {
  return value_case() == kDuration;
}
inline bool Primitive::has_duration() const {
  return _internal_has_duration();
}
inline void Primitive::set_has_duration() {
  _oneof_case_[0] = kDuration;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* Primitive::release_duration() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Primitive.duration)
  if (_internal_has_duration()) {
    clear_has_value();
      ::PROTOBUF_NAMESPACE_ID::Duration* temp = value_.duration_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.duration_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& Primitive::_internal_duration() const {
  return _internal_has_duration()
      ? *value_.duration_
      : reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::Duration&>(::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& Primitive::duration() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Primitive.duration)
  return _internal_duration();
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* Primitive::unsafe_arena_release_duration() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flyteidl.core.Primitive.duration)
  if (_internal_has_duration()) {
    clear_has_value();
    ::PROTOBUF_NAMESPACE_ID::Duration* temp = value_.duration_;
    value_.duration_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Primitive::unsafe_arena_set_allocated_duration(::PROTOBUF_NAMESPACE_ID::Duration* duration) {
  clear_value();
  if (duration) {
    set_has_duration();
    value_.duration_ = duration;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.core.Primitive.duration)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* Primitive::_internal_mutable_duration() {
  if (!_internal_has_duration()) {
    clear_value();
    set_has_duration();
    value_.duration_ = CreateMaybeMessage< ::PROTOBUF_NAMESPACE_ID::Duration >(GetArenaForAllocation());
  }
  return value_.duration_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* Primitive::mutable_duration() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_duration();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Primitive.duration)
  return _msg;
}

inline bool Primitive::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void Primitive::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline Primitive::ValueCase Primitive::value_case() const {
  return Primitive::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Void

// -------------------------------------------------------------------

// Blob

// .flyteidl.core.BlobMetadata metadata = 1 [json_name = "metadata"];
inline bool Blob::_internal_has_metadata() const {
  return this != internal_default_instance() && metadata_ != nullptr;
}
inline bool Blob::has_metadata() const {
  return _internal_has_metadata();
}
inline void Blob::clear_metadata() {
  if (GetArenaForAllocation() == nullptr && metadata_ != nullptr) {
    delete metadata_;
  }
  metadata_ = nullptr;
}
inline const ::flyteidl::core::BlobMetadata& Blob::_internal_metadata() const {
  const ::flyteidl::core::BlobMetadata* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::core::BlobMetadata&>(
      ::flyteidl::core::_BlobMetadata_default_instance_);
}
inline const ::flyteidl::core::BlobMetadata& Blob::metadata() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Blob.metadata)
  return _internal_metadata();
}
inline void Blob::unsafe_arena_set_allocated_metadata(
    ::flyteidl::core::BlobMetadata* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.core.Blob.metadata)
}
inline ::flyteidl::core::BlobMetadata* Blob::release_metadata() {
  
  ::flyteidl::core::BlobMetadata* temp = metadata_;
  metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::core::BlobMetadata* Blob::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Blob.metadata)
  
  ::flyteidl::core::BlobMetadata* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::flyteidl::core::BlobMetadata* Blob::_internal_mutable_metadata() {
  
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::BlobMetadata>(GetArenaForAllocation());
    metadata_ = p;
  }
  return metadata_;
}
inline ::flyteidl::core::BlobMetadata* Blob::mutable_metadata() {
  ::flyteidl::core::BlobMetadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Blob.metadata)
  return _msg;
}
inline void Blob::set_allocated_metadata(::flyteidl::core::BlobMetadata* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete metadata_;
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::flyteidl::core::BlobMetadata>::GetOwningArena(metadata);
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.Blob.metadata)
}

// string uri = 3 [json_name = "uri"];
inline void Blob::clear_uri() {
  uri_.ClearToEmpty();
}
inline const std::string& Blob::uri() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Blob.uri)
  return _internal_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Blob::set_uri(ArgT0&& arg0, ArgT... args) {
 
 uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.core.Blob.uri)
}
inline std::string* Blob::mutable_uri() {
  std::string* _s = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Blob.uri)
  return _s;
}
inline const std::string& Blob::_internal_uri() const {
  return uri_.Get();
}
inline void Blob::_internal_set_uri(const std::string& value) {
  
  uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Blob::_internal_mutable_uri() {
  
  return uri_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Blob::release_uri() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Blob.uri)
  return uri_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Blob::set_allocated_uri(std::string* uri) {
  if (uri != nullptr) {
    
  } else {
    
  }
  uri_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uri,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (uri_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    uri_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.Blob.uri)
}

// -------------------------------------------------------------------

// BlobMetadata

// .flyteidl.core.BlobType type = 1 [json_name = "type"];
inline bool BlobMetadata::_internal_has_type() const {
  return this != internal_default_instance() && type_ != nullptr;
}
inline bool BlobMetadata::has_type() const {
  return _internal_has_type();
}
inline const ::flyteidl::core::BlobType& BlobMetadata::_internal_type() const {
  const ::flyteidl::core::BlobType* p = type_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::core::BlobType&>(
      ::flyteidl::core::_BlobType_default_instance_);
}
inline const ::flyteidl::core::BlobType& BlobMetadata::type() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.BlobMetadata.type)
  return _internal_type();
}
inline void BlobMetadata::unsafe_arena_set_allocated_type(
    ::flyteidl::core::BlobType* type) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(type_);
  }
  type_ = type;
  if (type) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.core.BlobMetadata.type)
}
inline ::flyteidl::core::BlobType* BlobMetadata::release_type() {
  
  ::flyteidl::core::BlobType* temp = type_;
  type_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::core::BlobType* BlobMetadata::unsafe_arena_release_type() {
  // @@protoc_insertion_point(field_release:flyteidl.core.BlobMetadata.type)
  
  ::flyteidl::core::BlobType* temp = type_;
  type_ = nullptr;
  return temp;
}
inline ::flyteidl::core::BlobType* BlobMetadata::_internal_mutable_type() {
  
  if (type_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::BlobType>(GetArenaForAllocation());
    type_ = p;
  }
  return type_;
}
inline ::flyteidl::core::BlobType* BlobMetadata::mutable_type() {
  ::flyteidl::core::BlobType* _msg = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.BlobMetadata.type)
  return _msg;
}
inline void BlobMetadata::set_allocated_type(::flyteidl::core::BlobType* type) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(type_);
  }
  if (type) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(type));
    if (message_arena != submessage_arena) {
      type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, type, submessage_arena);
    }
    
  } else {
    
  }
  type_ = type;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.BlobMetadata.type)
}

// -------------------------------------------------------------------

// Binary

// bytes value = 1 [json_name = "value"];
inline void Binary::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& Binary::value() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Binary.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Binary::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.core.Binary.value)
}
inline std::string* Binary::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Binary.value)
  return _s;
}
inline const std::string& Binary::_internal_value() const {
  return value_.Get();
}
inline void Binary::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Binary::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Binary::release_value() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Binary.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Binary::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (value_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.Binary.value)
}

// string tag = 2 [json_name = "tag"];
inline void Binary::clear_tag() {
  tag_.ClearToEmpty();
}
inline const std::string& Binary::tag() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Binary.tag)
  return _internal_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Binary::set_tag(ArgT0&& arg0, ArgT... args) {
 
 tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.core.Binary.tag)
}
inline std::string* Binary::mutable_tag() {
  std::string* _s = _internal_mutable_tag();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Binary.tag)
  return _s;
}
inline const std::string& Binary::_internal_tag() const {
  return tag_.Get();
}
inline void Binary::_internal_set_tag(const std::string& value) {
  
  tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Binary::_internal_mutable_tag() {
  
  return tag_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Binary::release_tag() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Binary.tag)
  return tag_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Binary::set_allocated_tag(std::string* tag) {
  if (tag != nullptr) {
    
  } else {
    
  }
  tag_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tag,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tag_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.Binary.tag)
}

// -------------------------------------------------------------------

// Schema

// string uri = 1 [json_name = "uri"];
inline void Schema::clear_uri() {
  uri_.ClearToEmpty();
}
inline const std::string& Schema::uri() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Schema.uri)
  return _internal_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Schema::set_uri(ArgT0&& arg0, ArgT... args) {
 
 uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.core.Schema.uri)
}
inline std::string* Schema::mutable_uri() {
  std::string* _s = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Schema.uri)
  return _s;
}
inline const std::string& Schema::_internal_uri() const {
  return uri_.Get();
}
inline void Schema::_internal_set_uri(const std::string& value) {
  
  uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Schema::_internal_mutable_uri() {
  
  return uri_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Schema::release_uri() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Schema.uri)
  return uri_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Schema::set_allocated_uri(std::string* uri) {
  if (uri != nullptr) {
    
  } else {
    
  }
  uri_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uri,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (uri_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    uri_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.Schema.uri)
}

// .flyteidl.core.SchemaType type = 3 [json_name = "type"];
inline bool Schema::_internal_has_type() const {
  return this != internal_default_instance() && type_ != nullptr;
}
inline bool Schema::has_type() const {
  return _internal_has_type();
}
inline const ::flyteidl::core::SchemaType& Schema::_internal_type() const {
  const ::flyteidl::core::SchemaType* p = type_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::core::SchemaType&>(
      ::flyteidl::core::_SchemaType_default_instance_);
}
inline const ::flyteidl::core::SchemaType& Schema::type() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Schema.type)
  return _internal_type();
}
inline void Schema::unsafe_arena_set_allocated_type(
    ::flyteidl::core::SchemaType* type) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(type_);
  }
  type_ = type;
  if (type) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.core.Schema.type)
}
inline ::flyteidl::core::SchemaType* Schema::release_type() {
  
  ::flyteidl::core::SchemaType* temp = type_;
  type_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::core::SchemaType* Schema::unsafe_arena_release_type() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Schema.type)
  
  ::flyteidl::core::SchemaType* temp = type_;
  type_ = nullptr;
  return temp;
}
inline ::flyteidl::core::SchemaType* Schema::_internal_mutable_type() {
  
  if (type_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::SchemaType>(GetArenaForAllocation());
    type_ = p;
  }
  return type_;
}
inline ::flyteidl::core::SchemaType* Schema::mutable_type() {
  ::flyteidl::core::SchemaType* _msg = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Schema.type)
  return _msg;
}
inline void Schema::set_allocated_type(::flyteidl::core::SchemaType* type) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(type_);
  }
  if (type) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(type));
    if (message_arena != submessage_arena) {
      type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, type, submessage_arena);
    }
    
  } else {
    
  }
  type_ = type;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.Schema.type)
}

// -------------------------------------------------------------------

// Union

// .flyteidl.core.Literal value = 1 [json_name = "value"];
inline bool Union::_internal_has_value() const {
  return this != internal_default_instance() && value_ != nullptr;
}
inline bool Union::has_value() const {
  return _internal_has_value();
}
inline void Union::clear_value() {
  if (GetArenaForAllocation() == nullptr && value_ != nullptr) {
    delete value_;
  }
  value_ = nullptr;
}
inline const ::flyteidl::core::Literal& Union::_internal_value() const {
  const ::flyteidl::core::Literal* p = value_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::core::Literal&>(
      ::flyteidl::core::_Literal_default_instance_);
}
inline const ::flyteidl::core::Literal& Union::value() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Union.value)
  return _internal_value();
}
inline void Union::unsafe_arena_set_allocated_value(
    ::flyteidl::core::Literal* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.core.Union.value)
}
inline ::flyteidl::core::Literal* Union::release_value() {
  
  ::flyteidl::core::Literal* temp = value_;
  value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::core::Literal* Union::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Union.value)
  
  ::flyteidl::core::Literal* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::flyteidl::core::Literal* Union::_internal_mutable_value() {
  
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::Literal>(GetArenaForAllocation());
    value_ = p;
  }
  return value_;
}
inline ::flyteidl::core::Literal* Union::mutable_value() {
  ::flyteidl::core::Literal* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Union.value)
  return _msg;
}
inline void Union::set_allocated_value(::flyteidl::core::Literal* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete value_;
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::flyteidl::core::Literal>::GetOwningArena(value);
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.Union.value)
}

// .flyteidl.core.LiteralType type = 2 [json_name = "type"];
inline bool Union::_internal_has_type() const {
  return this != internal_default_instance() && type_ != nullptr;
}
inline bool Union::has_type() const {
  return _internal_has_type();
}
inline const ::flyteidl::core::LiteralType& Union::_internal_type() const {
  const ::flyteidl::core::LiteralType* p = type_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::core::LiteralType&>(
      ::flyteidl::core::_LiteralType_default_instance_);
}
inline const ::flyteidl::core::LiteralType& Union::type() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Union.type)
  return _internal_type();
}
inline void Union::unsafe_arena_set_allocated_type(
    ::flyteidl::core::LiteralType* type) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(type_);
  }
  type_ = type;
  if (type) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.core.Union.type)
}
inline ::flyteidl::core::LiteralType* Union::release_type() {
  
  ::flyteidl::core::LiteralType* temp = type_;
  type_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::core::LiteralType* Union::unsafe_arena_release_type() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Union.type)
  
  ::flyteidl::core::LiteralType* temp = type_;
  type_ = nullptr;
  return temp;
}
inline ::flyteidl::core::LiteralType* Union::_internal_mutable_type() {
  
  if (type_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::LiteralType>(GetArenaForAllocation());
    type_ = p;
  }
  return type_;
}
inline ::flyteidl::core::LiteralType* Union::mutable_type() {
  ::flyteidl::core::LiteralType* _msg = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Union.type)
  return _msg;
}
inline void Union::set_allocated_type(::flyteidl::core::LiteralType* type) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(type_);
  }
  if (type) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(type));
    if (message_arena != submessage_arena) {
      type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, type, submessage_arena);
    }
    
  } else {
    
  }
  type_ = type;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.Union.type)
}

// -------------------------------------------------------------------

// StructuredDatasetMetadata

// .flyteidl.core.StructuredDatasetType structured_dataset_type = 1 [json_name = "structuredDatasetType"];
inline bool StructuredDatasetMetadata::_internal_has_structured_dataset_type() const {
  return this != internal_default_instance() && structured_dataset_type_ != nullptr;
}
inline bool StructuredDatasetMetadata::has_structured_dataset_type() const {
  return _internal_has_structured_dataset_type();
}
inline const ::flyteidl::core::StructuredDatasetType& StructuredDatasetMetadata::_internal_structured_dataset_type() const {
  const ::flyteidl::core::StructuredDatasetType* p = structured_dataset_type_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::core::StructuredDatasetType&>(
      ::flyteidl::core::_StructuredDatasetType_default_instance_);
}
inline const ::flyteidl::core::StructuredDatasetType& StructuredDatasetMetadata::structured_dataset_type() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.StructuredDatasetMetadata.structured_dataset_type)
  return _internal_structured_dataset_type();
}
inline void StructuredDatasetMetadata::unsafe_arena_set_allocated_structured_dataset_type(
    ::flyteidl::core::StructuredDatasetType* structured_dataset_type) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(structured_dataset_type_);
  }
  structured_dataset_type_ = structured_dataset_type;
  if (structured_dataset_type) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.core.StructuredDatasetMetadata.structured_dataset_type)
}
inline ::flyteidl::core::StructuredDatasetType* StructuredDatasetMetadata::release_structured_dataset_type() {
  
  ::flyteidl::core::StructuredDatasetType* temp = structured_dataset_type_;
  structured_dataset_type_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::core::StructuredDatasetType* StructuredDatasetMetadata::unsafe_arena_release_structured_dataset_type() {
  // @@protoc_insertion_point(field_release:flyteidl.core.StructuredDatasetMetadata.structured_dataset_type)
  
  ::flyteidl::core::StructuredDatasetType* temp = structured_dataset_type_;
  structured_dataset_type_ = nullptr;
  return temp;
}
inline ::flyteidl::core::StructuredDatasetType* StructuredDatasetMetadata::_internal_mutable_structured_dataset_type() {
  
  if (structured_dataset_type_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::StructuredDatasetType>(GetArenaForAllocation());
    structured_dataset_type_ = p;
  }
  return structured_dataset_type_;
}
inline ::flyteidl::core::StructuredDatasetType* StructuredDatasetMetadata::mutable_structured_dataset_type() {
  ::flyteidl::core::StructuredDatasetType* _msg = _internal_mutable_structured_dataset_type();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.StructuredDatasetMetadata.structured_dataset_type)
  return _msg;
}
inline void StructuredDatasetMetadata::set_allocated_structured_dataset_type(::flyteidl::core::StructuredDatasetType* structured_dataset_type) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(structured_dataset_type_);
  }
  if (structured_dataset_type) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(structured_dataset_type));
    if (message_arena != submessage_arena) {
      structured_dataset_type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, structured_dataset_type, submessage_arena);
    }
    
  } else {
    
  }
  structured_dataset_type_ = structured_dataset_type;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.StructuredDatasetMetadata.structured_dataset_type)
}

// -------------------------------------------------------------------

// StructuredDataset

// string uri = 1 [json_name = "uri"];
inline void StructuredDataset::clear_uri() {
  uri_.ClearToEmpty();
}
inline const std::string& StructuredDataset::uri() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.StructuredDataset.uri)
  return _internal_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StructuredDataset::set_uri(ArgT0&& arg0, ArgT... args) {
 
 uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.core.StructuredDataset.uri)
}
inline std::string* StructuredDataset::mutable_uri() {
  std::string* _s = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.StructuredDataset.uri)
  return _s;
}
inline const std::string& StructuredDataset::_internal_uri() const {
  return uri_.Get();
}
inline void StructuredDataset::_internal_set_uri(const std::string& value) {
  
  uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StructuredDataset::_internal_mutable_uri() {
  
  return uri_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StructuredDataset::release_uri() {
  // @@protoc_insertion_point(field_release:flyteidl.core.StructuredDataset.uri)
  return uri_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void StructuredDataset::set_allocated_uri(std::string* uri) {
  if (uri != nullptr) {
    
  } else {
    
  }
  uri_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uri,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (uri_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    uri_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.StructuredDataset.uri)
}

// .flyteidl.core.StructuredDatasetMetadata metadata = 2 [json_name = "metadata"];
inline bool StructuredDataset::_internal_has_metadata() const {
  return this != internal_default_instance() && metadata_ != nullptr;
}
inline bool StructuredDataset::has_metadata() const {
  return _internal_has_metadata();
}
inline void StructuredDataset::clear_metadata() {
  if (GetArenaForAllocation() == nullptr && metadata_ != nullptr) {
    delete metadata_;
  }
  metadata_ = nullptr;
}
inline const ::flyteidl::core::StructuredDatasetMetadata& StructuredDataset::_internal_metadata() const {
  const ::flyteidl::core::StructuredDatasetMetadata* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::core::StructuredDatasetMetadata&>(
      ::flyteidl::core::_StructuredDatasetMetadata_default_instance_);
}
inline const ::flyteidl::core::StructuredDatasetMetadata& StructuredDataset::metadata() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.StructuredDataset.metadata)
  return _internal_metadata();
}
inline void StructuredDataset::unsafe_arena_set_allocated_metadata(
    ::flyteidl::core::StructuredDatasetMetadata* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.core.StructuredDataset.metadata)
}
inline ::flyteidl::core::StructuredDatasetMetadata* StructuredDataset::release_metadata() {
  
  ::flyteidl::core::StructuredDatasetMetadata* temp = metadata_;
  metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::core::StructuredDatasetMetadata* StructuredDataset::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:flyteidl.core.StructuredDataset.metadata)
  
  ::flyteidl::core::StructuredDatasetMetadata* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::flyteidl::core::StructuredDatasetMetadata* StructuredDataset::_internal_mutable_metadata() {
  
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::StructuredDatasetMetadata>(GetArenaForAllocation());
    metadata_ = p;
  }
  return metadata_;
}
inline ::flyteidl::core::StructuredDatasetMetadata* StructuredDataset::mutable_metadata() {
  ::flyteidl::core::StructuredDatasetMetadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.StructuredDataset.metadata)
  return _msg;
}
inline void StructuredDataset::set_allocated_metadata(::flyteidl::core::StructuredDatasetMetadata* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete metadata_;
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::flyteidl::core::StructuredDatasetMetadata>::GetOwningArena(metadata);
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.StructuredDataset.metadata)
}

// -------------------------------------------------------------------

// Scalar

// .flyteidl.core.Primitive primitive = 1 [json_name = "primitive"];
inline bool Scalar::_internal_has_primitive() const {
  return value_case() == kPrimitive;
}
inline bool Scalar::has_primitive() const {
  return _internal_has_primitive();
}
inline void Scalar::set_has_primitive() {
  _oneof_case_[0] = kPrimitive;
}
inline void Scalar::clear_primitive() {
  if (_internal_has_primitive()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.primitive_;
    }
    clear_has_value();
  }
}
inline ::flyteidl::core::Primitive* Scalar::release_primitive() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Scalar.primitive)
  if (_internal_has_primitive()) {
    clear_has_value();
      ::flyteidl::core::Primitive* temp = value_.primitive_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.primitive_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::core::Primitive& Scalar::_internal_primitive() const {
  return _internal_has_primitive()
      ? *value_.primitive_
      : reinterpret_cast< ::flyteidl::core::Primitive&>(::flyteidl::core::_Primitive_default_instance_);
}
inline const ::flyteidl::core::Primitive& Scalar::primitive() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Scalar.primitive)
  return _internal_primitive();
}
inline ::flyteidl::core::Primitive* Scalar::unsafe_arena_release_primitive() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flyteidl.core.Scalar.primitive)
  if (_internal_has_primitive()) {
    clear_has_value();
    ::flyteidl::core::Primitive* temp = value_.primitive_;
    value_.primitive_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Scalar::unsafe_arena_set_allocated_primitive(::flyteidl::core::Primitive* primitive) {
  clear_value();
  if (primitive) {
    set_has_primitive();
    value_.primitive_ = primitive;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.core.Scalar.primitive)
}
inline ::flyteidl::core::Primitive* Scalar::_internal_mutable_primitive() {
  if (!_internal_has_primitive()) {
    clear_value();
    set_has_primitive();
    value_.primitive_ = CreateMaybeMessage< ::flyteidl::core::Primitive >(GetArenaForAllocation());
  }
  return value_.primitive_;
}
inline ::flyteidl::core::Primitive* Scalar::mutable_primitive() {
  ::flyteidl::core::Primitive* _msg = _internal_mutable_primitive();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Scalar.primitive)
  return _msg;
}

// .flyteidl.core.Blob blob = 2 [json_name = "blob"];
inline bool Scalar::_internal_has_blob() const {
  return value_case() == kBlob;
}
inline bool Scalar::has_blob() const {
  return _internal_has_blob();
}
inline void Scalar::set_has_blob() {
  _oneof_case_[0] = kBlob;
}
inline void Scalar::clear_blob() {
  if (_internal_has_blob()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.blob_;
    }
    clear_has_value();
  }
}
inline ::flyteidl::core::Blob* Scalar::release_blob() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Scalar.blob)
  if (_internal_has_blob()) {
    clear_has_value();
      ::flyteidl::core::Blob* temp = value_.blob_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.blob_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::core::Blob& Scalar::_internal_blob() const {
  return _internal_has_blob()
      ? *value_.blob_
      : reinterpret_cast< ::flyteidl::core::Blob&>(::flyteidl::core::_Blob_default_instance_);
}
inline const ::flyteidl::core::Blob& Scalar::blob() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Scalar.blob)
  return _internal_blob();
}
inline ::flyteidl::core::Blob* Scalar::unsafe_arena_release_blob() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flyteidl.core.Scalar.blob)
  if (_internal_has_blob()) {
    clear_has_value();
    ::flyteidl::core::Blob* temp = value_.blob_;
    value_.blob_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Scalar::unsafe_arena_set_allocated_blob(::flyteidl::core::Blob* blob) {
  clear_value();
  if (blob) {
    set_has_blob();
    value_.blob_ = blob;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.core.Scalar.blob)
}
inline ::flyteidl::core::Blob* Scalar::_internal_mutable_blob() {
  if (!_internal_has_blob()) {
    clear_value();
    set_has_blob();
    value_.blob_ = CreateMaybeMessage< ::flyteidl::core::Blob >(GetArenaForAllocation());
  }
  return value_.blob_;
}
inline ::flyteidl::core::Blob* Scalar::mutable_blob() {
  ::flyteidl::core::Blob* _msg = _internal_mutable_blob();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Scalar.blob)
  return _msg;
}

// .flyteidl.core.Binary binary = 3 [json_name = "binary"];
inline bool Scalar::_internal_has_binary() const {
  return value_case() == kBinary;
}
inline bool Scalar::has_binary() const {
  return _internal_has_binary();
}
inline void Scalar::set_has_binary() {
  _oneof_case_[0] = kBinary;
}
inline void Scalar::clear_binary() {
  if (_internal_has_binary()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.binary_;
    }
    clear_has_value();
  }
}
inline ::flyteidl::core::Binary* Scalar::release_binary() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Scalar.binary)
  if (_internal_has_binary()) {
    clear_has_value();
      ::flyteidl::core::Binary* temp = value_.binary_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.binary_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::core::Binary& Scalar::_internal_binary() const {
  return _internal_has_binary()
      ? *value_.binary_
      : reinterpret_cast< ::flyteidl::core::Binary&>(::flyteidl::core::_Binary_default_instance_);
}
inline const ::flyteidl::core::Binary& Scalar::binary() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Scalar.binary)
  return _internal_binary();
}
inline ::flyteidl::core::Binary* Scalar::unsafe_arena_release_binary() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flyteidl.core.Scalar.binary)
  if (_internal_has_binary()) {
    clear_has_value();
    ::flyteidl::core::Binary* temp = value_.binary_;
    value_.binary_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Scalar::unsafe_arena_set_allocated_binary(::flyteidl::core::Binary* binary) {
  clear_value();
  if (binary) {
    set_has_binary();
    value_.binary_ = binary;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.core.Scalar.binary)
}
inline ::flyteidl::core::Binary* Scalar::_internal_mutable_binary() {
  if (!_internal_has_binary()) {
    clear_value();
    set_has_binary();
    value_.binary_ = CreateMaybeMessage< ::flyteidl::core::Binary >(GetArenaForAllocation());
  }
  return value_.binary_;
}
inline ::flyteidl::core::Binary* Scalar::mutable_binary() {
  ::flyteidl::core::Binary* _msg = _internal_mutable_binary();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Scalar.binary)
  return _msg;
}

// .flyteidl.core.Schema schema = 4 [json_name = "schema"];
inline bool Scalar::_internal_has_schema() const {
  return value_case() == kSchema;
}
inline bool Scalar::has_schema() const {
  return _internal_has_schema();
}
inline void Scalar::set_has_schema() {
  _oneof_case_[0] = kSchema;
}
inline void Scalar::clear_schema() {
  if (_internal_has_schema()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.schema_;
    }
    clear_has_value();
  }
}
inline ::flyteidl::core::Schema* Scalar::release_schema() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Scalar.schema)
  if (_internal_has_schema()) {
    clear_has_value();
      ::flyteidl::core::Schema* temp = value_.schema_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.schema_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::core::Schema& Scalar::_internal_schema() const {
  return _internal_has_schema()
      ? *value_.schema_
      : reinterpret_cast< ::flyteidl::core::Schema&>(::flyteidl::core::_Schema_default_instance_);
}
inline const ::flyteidl::core::Schema& Scalar::schema() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Scalar.schema)
  return _internal_schema();
}
inline ::flyteidl::core::Schema* Scalar::unsafe_arena_release_schema() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flyteidl.core.Scalar.schema)
  if (_internal_has_schema()) {
    clear_has_value();
    ::flyteidl::core::Schema* temp = value_.schema_;
    value_.schema_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Scalar::unsafe_arena_set_allocated_schema(::flyteidl::core::Schema* schema) {
  clear_value();
  if (schema) {
    set_has_schema();
    value_.schema_ = schema;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.core.Scalar.schema)
}
inline ::flyteidl::core::Schema* Scalar::_internal_mutable_schema() {
  if (!_internal_has_schema()) {
    clear_value();
    set_has_schema();
    value_.schema_ = CreateMaybeMessage< ::flyteidl::core::Schema >(GetArenaForAllocation());
  }
  return value_.schema_;
}
inline ::flyteidl::core::Schema* Scalar::mutable_schema() {
  ::flyteidl::core::Schema* _msg = _internal_mutable_schema();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Scalar.schema)
  return _msg;
}

// .flyteidl.core.Void none_type = 5 [json_name = "noneType"];
inline bool Scalar::_internal_has_none_type() const {
  return value_case() == kNoneType;
}
inline bool Scalar::has_none_type() const {
  return _internal_has_none_type();
}
inline void Scalar::set_has_none_type() {
  _oneof_case_[0] = kNoneType;
}
inline void Scalar::clear_none_type() {
  if (_internal_has_none_type()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.none_type_;
    }
    clear_has_value();
  }
}
inline ::flyteidl::core::Void* Scalar::release_none_type() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Scalar.none_type)
  if (_internal_has_none_type()) {
    clear_has_value();
      ::flyteidl::core::Void* temp = value_.none_type_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.none_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::core::Void& Scalar::_internal_none_type() const {
  return _internal_has_none_type()
      ? *value_.none_type_
      : reinterpret_cast< ::flyteidl::core::Void&>(::flyteidl::core::_Void_default_instance_);
}
inline const ::flyteidl::core::Void& Scalar::none_type() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Scalar.none_type)
  return _internal_none_type();
}
inline ::flyteidl::core::Void* Scalar::unsafe_arena_release_none_type() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flyteidl.core.Scalar.none_type)
  if (_internal_has_none_type()) {
    clear_has_value();
    ::flyteidl::core::Void* temp = value_.none_type_;
    value_.none_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Scalar::unsafe_arena_set_allocated_none_type(::flyteidl::core::Void* none_type) {
  clear_value();
  if (none_type) {
    set_has_none_type();
    value_.none_type_ = none_type;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.core.Scalar.none_type)
}
inline ::flyteidl::core::Void* Scalar::_internal_mutable_none_type() {
  if (!_internal_has_none_type()) {
    clear_value();
    set_has_none_type();
    value_.none_type_ = CreateMaybeMessage< ::flyteidl::core::Void >(GetArenaForAllocation());
  }
  return value_.none_type_;
}
inline ::flyteidl::core::Void* Scalar::mutable_none_type() {
  ::flyteidl::core::Void* _msg = _internal_mutable_none_type();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Scalar.none_type)
  return _msg;
}

// .flyteidl.core.Error error = 6 [json_name = "error"];
inline bool Scalar::_internal_has_error() const {
  return value_case() == kError;
}
inline bool Scalar::has_error() const {
  return _internal_has_error();
}
inline void Scalar::set_has_error() {
  _oneof_case_[0] = kError;
}
inline ::flyteidl::core::Error* Scalar::release_error() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Scalar.error)
  if (_internal_has_error()) {
    clear_has_value();
      ::flyteidl::core::Error* temp = value_.error_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::core::Error& Scalar::_internal_error() const {
  return _internal_has_error()
      ? *value_.error_
      : reinterpret_cast< ::flyteidl::core::Error&>(::flyteidl::core::_Error_default_instance_);
}
inline const ::flyteidl::core::Error& Scalar::error() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Scalar.error)
  return _internal_error();
}
inline ::flyteidl::core::Error* Scalar::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flyteidl.core.Scalar.error)
  if (_internal_has_error()) {
    clear_has_value();
    ::flyteidl::core::Error* temp = value_.error_;
    value_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Scalar::unsafe_arena_set_allocated_error(::flyteidl::core::Error* error) {
  clear_value();
  if (error) {
    set_has_error();
    value_.error_ = error;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.core.Scalar.error)
}
inline ::flyteidl::core::Error* Scalar::_internal_mutable_error() {
  if (!_internal_has_error()) {
    clear_value();
    set_has_error();
    value_.error_ = CreateMaybeMessage< ::flyteidl::core::Error >(GetArenaForAllocation());
  }
  return value_.error_;
}
inline ::flyteidl::core::Error* Scalar::mutable_error() {
  ::flyteidl::core::Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Scalar.error)
  return _msg;
}

// .google.protobuf.Struct generic = 7 [json_name = "generic"];
inline bool Scalar::_internal_has_generic() const {
  return value_case() == kGeneric;
}
inline bool Scalar::has_generic() const {
  return _internal_has_generic();
}
inline void Scalar::set_has_generic() {
  _oneof_case_[0] = kGeneric;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Scalar::release_generic() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Scalar.generic)
  if (_internal_has_generic()) {
    clear_has_value();
      ::PROTOBUF_NAMESPACE_ID::Struct* temp = value_.generic_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.generic_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& Scalar::_internal_generic() const {
  return _internal_has_generic()
      ? *value_.generic_
      : reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::Struct&>(::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& Scalar::generic() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Scalar.generic)
  return _internal_generic();
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Scalar::unsafe_arena_release_generic() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flyteidl.core.Scalar.generic)
  if (_internal_has_generic()) {
    clear_has_value();
    ::PROTOBUF_NAMESPACE_ID::Struct* temp = value_.generic_;
    value_.generic_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Scalar::unsafe_arena_set_allocated_generic(::PROTOBUF_NAMESPACE_ID::Struct* generic) {
  clear_value();
  if (generic) {
    set_has_generic();
    value_.generic_ = generic;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.core.Scalar.generic)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Scalar::_internal_mutable_generic() {
  if (!_internal_has_generic()) {
    clear_value();
    set_has_generic();
    value_.generic_ = CreateMaybeMessage< ::PROTOBUF_NAMESPACE_ID::Struct >(GetArenaForAllocation());
  }
  return value_.generic_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Scalar::mutable_generic() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_generic();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Scalar.generic)
  return _msg;
}

// .flyteidl.core.StructuredDataset structured_dataset = 8 [json_name = "structuredDataset"];
inline bool Scalar::_internal_has_structured_dataset() const {
  return value_case() == kStructuredDataset;
}
inline bool Scalar::has_structured_dataset() const {
  return _internal_has_structured_dataset();
}
inline void Scalar::set_has_structured_dataset() {
  _oneof_case_[0] = kStructuredDataset;
}
inline void Scalar::clear_structured_dataset() {
  if (_internal_has_structured_dataset()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.structured_dataset_;
    }
    clear_has_value();
  }
}
inline ::flyteidl::core::StructuredDataset* Scalar::release_structured_dataset() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Scalar.structured_dataset)
  if (_internal_has_structured_dataset()) {
    clear_has_value();
      ::flyteidl::core::StructuredDataset* temp = value_.structured_dataset_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.structured_dataset_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::core::StructuredDataset& Scalar::_internal_structured_dataset() const {
  return _internal_has_structured_dataset()
      ? *value_.structured_dataset_
      : reinterpret_cast< ::flyteidl::core::StructuredDataset&>(::flyteidl::core::_StructuredDataset_default_instance_);
}
inline const ::flyteidl::core::StructuredDataset& Scalar::structured_dataset() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Scalar.structured_dataset)
  return _internal_structured_dataset();
}
inline ::flyteidl::core::StructuredDataset* Scalar::unsafe_arena_release_structured_dataset() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flyteidl.core.Scalar.structured_dataset)
  if (_internal_has_structured_dataset()) {
    clear_has_value();
    ::flyteidl::core::StructuredDataset* temp = value_.structured_dataset_;
    value_.structured_dataset_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Scalar::unsafe_arena_set_allocated_structured_dataset(::flyteidl::core::StructuredDataset* structured_dataset) {
  clear_value();
  if (structured_dataset) {
    set_has_structured_dataset();
    value_.structured_dataset_ = structured_dataset;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.core.Scalar.structured_dataset)
}
inline ::flyteidl::core::StructuredDataset* Scalar::_internal_mutable_structured_dataset() {
  if (!_internal_has_structured_dataset()) {
    clear_value();
    set_has_structured_dataset();
    value_.structured_dataset_ = CreateMaybeMessage< ::flyteidl::core::StructuredDataset >(GetArenaForAllocation());
  }
  return value_.structured_dataset_;
}
inline ::flyteidl::core::StructuredDataset* Scalar::mutable_structured_dataset() {
  ::flyteidl::core::StructuredDataset* _msg = _internal_mutable_structured_dataset();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Scalar.structured_dataset)
  return _msg;
}

// .flyteidl.core.Union union = 9 [json_name = "union"];
inline bool Scalar::_internal_has_union_() const {
  return value_case() == kUnion;
}
inline bool Scalar::has_union_() const {
  return _internal_has_union_();
}
inline void Scalar::set_has_union_() {
  _oneof_case_[0] = kUnion;
}
inline void Scalar::clear_union_() {
  if (_internal_has_union_()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.union__;
    }
    clear_has_value();
  }
}
inline ::flyteidl::core::Union* Scalar::release_union_() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Scalar.union)
  if (_internal_has_union_()) {
    clear_has_value();
      ::flyteidl::core::Union* temp = value_.union__;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.union__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::core::Union& Scalar::_internal_union_() const {
  return _internal_has_union_()
      ? *value_.union__
      : reinterpret_cast< ::flyteidl::core::Union&>(::flyteidl::core::_Union_default_instance_);
}
inline const ::flyteidl::core::Union& Scalar::union_() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Scalar.union)
  return _internal_union_();
}
inline ::flyteidl::core::Union* Scalar::unsafe_arena_release_union_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flyteidl.core.Scalar.union)
  if (_internal_has_union_()) {
    clear_has_value();
    ::flyteidl::core::Union* temp = value_.union__;
    value_.union__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Scalar::unsafe_arena_set_allocated_union_(::flyteidl::core::Union* union_) {
  clear_value();
  if (union_) {
    set_has_union_();
    value_.union__ = union_;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.core.Scalar.union)
}
inline ::flyteidl::core::Union* Scalar::_internal_mutable_union_() {
  if (!_internal_has_union_()) {
    clear_value();
    set_has_union_();
    value_.union__ = CreateMaybeMessage< ::flyteidl::core::Union >(GetArenaForAllocation());
  }
  return value_.union__;
}
inline ::flyteidl::core::Union* Scalar::mutable_union_() {
  ::flyteidl::core::Union* _msg = _internal_mutable_union_();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Scalar.union)
  return _msg;
}

inline bool Scalar::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void Scalar::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline Scalar::ValueCase Scalar::value_case() const {
  return Scalar::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Literal

// .flyteidl.core.Scalar scalar = 1 [json_name = "scalar"];
inline bool Literal::_internal_has_scalar() const {
  return value_case() == kScalar;
}
inline bool Literal::has_scalar() const {
  return _internal_has_scalar();
}
inline void Literal::set_has_scalar() {
  _oneof_case_[0] = kScalar;
}
inline void Literal::clear_scalar() {
  if (_internal_has_scalar()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.scalar_;
    }
    clear_has_value();
  }
}
inline ::flyteidl::core::Scalar* Literal::release_scalar() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Literal.scalar)
  if (_internal_has_scalar()) {
    clear_has_value();
      ::flyteidl::core::Scalar* temp = value_.scalar_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.scalar_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::core::Scalar& Literal::_internal_scalar() const {
  return _internal_has_scalar()
      ? *value_.scalar_
      : reinterpret_cast< ::flyteidl::core::Scalar&>(::flyteidl::core::_Scalar_default_instance_);
}
inline const ::flyteidl::core::Scalar& Literal::scalar() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Literal.scalar)
  return _internal_scalar();
}
inline ::flyteidl::core::Scalar* Literal::unsafe_arena_release_scalar() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flyteidl.core.Literal.scalar)
  if (_internal_has_scalar()) {
    clear_has_value();
    ::flyteidl::core::Scalar* temp = value_.scalar_;
    value_.scalar_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Literal::unsafe_arena_set_allocated_scalar(::flyteidl::core::Scalar* scalar) {
  clear_value();
  if (scalar) {
    set_has_scalar();
    value_.scalar_ = scalar;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.core.Literal.scalar)
}
inline ::flyteidl::core::Scalar* Literal::_internal_mutable_scalar() {
  if (!_internal_has_scalar()) {
    clear_value();
    set_has_scalar();
    value_.scalar_ = CreateMaybeMessage< ::flyteidl::core::Scalar >(GetArenaForAllocation());
  }
  return value_.scalar_;
}
inline ::flyteidl::core::Scalar* Literal::mutable_scalar() {
  ::flyteidl::core::Scalar* _msg = _internal_mutable_scalar();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Literal.scalar)
  return _msg;
}

// .flyteidl.core.LiteralCollection collection = 2 [json_name = "collection"];
inline bool Literal::_internal_has_collection() const {
  return value_case() == kCollection;
}
inline bool Literal::has_collection() const {
  return _internal_has_collection();
}
inline void Literal::set_has_collection() {
  _oneof_case_[0] = kCollection;
}
inline void Literal::clear_collection() {
  if (_internal_has_collection()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.collection_;
    }
    clear_has_value();
  }
}
inline ::flyteidl::core::LiteralCollection* Literal::release_collection() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Literal.collection)
  if (_internal_has_collection()) {
    clear_has_value();
      ::flyteidl::core::LiteralCollection* temp = value_.collection_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.collection_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::core::LiteralCollection& Literal::_internal_collection() const {
  return _internal_has_collection()
      ? *value_.collection_
      : reinterpret_cast< ::flyteidl::core::LiteralCollection&>(::flyteidl::core::_LiteralCollection_default_instance_);
}
inline const ::flyteidl::core::LiteralCollection& Literal::collection() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Literal.collection)
  return _internal_collection();
}
inline ::flyteidl::core::LiteralCollection* Literal::unsafe_arena_release_collection() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flyteidl.core.Literal.collection)
  if (_internal_has_collection()) {
    clear_has_value();
    ::flyteidl::core::LiteralCollection* temp = value_.collection_;
    value_.collection_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Literal::unsafe_arena_set_allocated_collection(::flyteidl::core::LiteralCollection* collection) {
  clear_value();
  if (collection) {
    set_has_collection();
    value_.collection_ = collection;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.core.Literal.collection)
}
inline ::flyteidl::core::LiteralCollection* Literal::_internal_mutable_collection() {
  if (!_internal_has_collection()) {
    clear_value();
    set_has_collection();
    value_.collection_ = CreateMaybeMessage< ::flyteidl::core::LiteralCollection >(GetArenaForAllocation());
  }
  return value_.collection_;
}
inline ::flyteidl::core::LiteralCollection* Literal::mutable_collection() {
  ::flyteidl::core::LiteralCollection* _msg = _internal_mutable_collection();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Literal.collection)
  return _msg;
}

// .flyteidl.core.LiteralMap map = 3 [json_name = "map"];
inline bool Literal::_internal_has_map() const {
  return value_case() == kMap;
}
inline bool Literal::has_map() const {
  return _internal_has_map();
}
inline void Literal::set_has_map() {
  _oneof_case_[0] = kMap;
}
inline void Literal::clear_map() {
  if (_internal_has_map()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.map_;
    }
    clear_has_value();
  }
}
inline ::flyteidl::core::LiteralMap* Literal::release_map() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Literal.map)
  if (_internal_has_map()) {
    clear_has_value();
      ::flyteidl::core::LiteralMap* temp = value_.map_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.map_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::core::LiteralMap& Literal::_internal_map() const {
  return _internal_has_map()
      ? *value_.map_
      : reinterpret_cast< ::flyteidl::core::LiteralMap&>(::flyteidl::core::_LiteralMap_default_instance_);
}
inline const ::flyteidl::core::LiteralMap& Literal::map() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Literal.map)
  return _internal_map();
}
inline ::flyteidl::core::LiteralMap* Literal::unsafe_arena_release_map() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flyteidl.core.Literal.map)
  if (_internal_has_map()) {
    clear_has_value();
    ::flyteidl::core::LiteralMap* temp = value_.map_;
    value_.map_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Literal::unsafe_arena_set_allocated_map(::flyteidl::core::LiteralMap* map) {
  clear_value();
  if (map) {
    set_has_map();
    value_.map_ = map;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.core.Literal.map)
}
inline ::flyteidl::core::LiteralMap* Literal::_internal_mutable_map() {
  if (!_internal_has_map()) {
    clear_value();
    set_has_map();
    value_.map_ = CreateMaybeMessage< ::flyteidl::core::LiteralMap >(GetArenaForAllocation());
  }
  return value_.map_;
}
inline ::flyteidl::core::LiteralMap* Literal::mutable_map() {
  ::flyteidl::core::LiteralMap* _msg = _internal_mutable_map();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Literal.map)
  return _msg;
}

// string hash = 4 [json_name = "hash"];
inline void Literal::clear_hash() {
  hash_.ClearToEmpty();
}
inline const std::string& Literal::hash() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Literal.hash)
  return _internal_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Literal::set_hash(ArgT0&& arg0, ArgT... args) {
 
 hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.core.Literal.hash)
}
inline std::string* Literal::mutable_hash() {
  std::string* _s = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Literal.hash)
  return _s;
}
inline const std::string& Literal::_internal_hash() const {
  return hash_.Get();
}
inline void Literal::_internal_set_hash(const std::string& value) {
  
  hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Literal::_internal_mutable_hash() {
  
  return hash_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Literal::release_hash() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Literal.hash)
  return hash_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Literal::set_allocated_hash(std::string* hash) {
  if (hash != nullptr) {
    
  } else {
    
  }
  hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hash,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (hash_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.Literal.hash)
}

inline bool Literal::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void Literal::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline Literal::ValueCase Literal::value_case() const {
  return Literal::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// LiteralCollection

// repeated .flyteidl.core.Literal literals = 1 [json_name = "literals"];
inline int LiteralCollection::_internal_literals_size() const {
  return literals_.size();
}
inline int LiteralCollection::literals_size() const {
  return _internal_literals_size();
}
inline void LiteralCollection::clear_literals() {
  literals_.Clear();
}
inline ::flyteidl::core::Literal* LiteralCollection::mutable_literals(int index) {
  // @@protoc_insertion_point(field_mutable:flyteidl.core.LiteralCollection.literals)
  return literals_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::core::Literal >*
LiteralCollection::mutable_literals() {
  // @@protoc_insertion_point(field_mutable_list:flyteidl.core.LiteralCollection.literals)
  return &literals_;
}
inline const ::flyteidl::core::Literal& LiteralCollection::_internal_literals(int index) const {
  return literals_.Get(index);
}
inline const ::flyteidl::core::Literal& LiteralCollection::literals(int index) const {
  // @@protoc_insertion_point(field_get:flyteidl.core.LiteralCollection.literals)
  return _internal_literals(index);
}
inline ::flyteidl::core::Literal* LiteralCollection::_internal_add_literals() {
  return literals_.Add();
}
inline ::flyteidl::core::Literal* LiteralCollection::add_literals() {
  ::flyteidl::core::Literal* _add = _internal_add_literals();
  // @@protoc_insertion_point(field_add:flyteidl.core.LiteralCollection.literals)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::core::Literal >&
LiteralCollection::literals() const {
  // @@protoc_insertion_point(field_list:flyteidl.core.LiteralCollection.literals)
  return literals_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// LiteralMap

// map<string, .flyteidl.core.Literal> literals = 1 [json_name = "literals"];
inline int LiteralMap::_internal_literals_size() const {
  return literals_.size();
}
inline int LiteralMap::literals_size() const {
  return _internal_literals_size();
}
inline void LiteralMap::clear_literals() {
  literals_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::flyteidl::core::Literal >&
LiteralMap::_internal_literals() const {
  return literals_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::flyteidl::core::Literal >&
LiteralMap::literals() const {
  // @@protoc_insertion_point(field_map:flyteidl.core.LiteralMap.literals)
  return _internal_literals();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::flyteidl::core::Literal >*
LiteralMap::_internal_mutable_literals() {
  return literals_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::flyteidl::core::Literal >*
LiteralMap::mutable_literals() {
  // @@protoc_insertion_point(field_mutable_map:flyteidl.core.LiteralMap.literals)
  return _internal_mutable_literals();
}

// -------------------------------------------------------------------

// BindingDataCollection

// repeated .flyteidl.core.BindingData bindings = 1 [json_name = "bindings"];
inline int BindingDataCollection::_internal_bindings_size() const {
  return bindings_.size();
}
inline int BindingDataCollection::bindings_size() const {
  return _internal_bindings_size();
}
inline void BindingDataCollection::clear_bindings() {
  bindings_.Clear();
}
inline ::flyteidl::core::BindingData* BindingDataCollection::mutable_bindings(int index) {
  // @@protoc_insertion_point(field_mutable:flyteidl.core.BindingDataCollection.bindings)
  return bindings_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::core::BindingData >*
BindingDataCollection::mutable_bindings() {
  // @@protoc_insertion_point(field_mutable_list:flyteidl.core.BindingDataCollection.bindings)
  return &bindings_;
}
inline const ::flyteidl::core::BindingData& BindingDataCollection::_internal_bindings(int index) const {
  return bindings_.Get(index);
}
inline const ::flyteidl::core::BindingData& BindingDataCollection::bindings(int index) const {
  // @@protoc_insertion_point(field_get:flyteidl.core.BindingDataCollection.bindings)
  return _internal_bindings(index);
}
inline ::flyteidl::core::BindingData* BindingDataCollection::_internal_add_bindings() {
  return bindings_.Add();
}
inline ::flyteidl::core::BindingData* BindingDataCollection::add_bindings() {
  ::flyteidl::core::BindingData* _add = _internal_add_bindings();
  // @@protoc_insertion_point(field_add:flyteidl.core.BindingDataCollection.bindings)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::core::BindingData >&
BindingDataCollection::bindings() const {
  // @@protoc_insertion_point(field_list:flyteidl.core.BindingDataCollection.bindings)
  return bindings_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// BindingDataMap

// map<string, .flyteidl.core.BindingData> bindings = 1 [json_name = "bindings"];
inline int BindingDataMap::_internal_bindings_size() const {
  return bindings_.size();
}
inline int BindingDataMap::bindings_size() const {
  return _internal_bindings_size();
}
inline void BindingDataMap::clear_bindings() {
  bindings_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::flyteidl::core::BindingData >&
BindingDataMap::_internal_bindings() const {
  return bindings_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::flyteidl::core::BindingData >&
BindingDataMap::bindings() const {
  // @@protoc_insertion_point(field_map:flyteidl.core.BindingDataMap.bindings)
  return _internal_bindings();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::flyteidl::core::BindingData >*
BindingDataMap::_internal_mutable_bindings() {
  return bindings_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::flyteidl::core::BindingData >*
BindingDataMap::mutable_bindings() {
  // @@protoc_insertion_point(field_mutable_map:flyteidl.core.BindingDataMap.bindings)
  return _internal_mutable_bindings();
}

// -------------------------------------------------------------------

// UnionInfo

// .flyteidl.core.LiteralType targetType = 1 [json_name = "targetType"];
inline bool UnionInfo::_internal_has_targettype() const {
  return this != internal_default_instance() && targettype_ != nullptr;
}
inline bool UnionInfo::has_targettype() const {
  return _internal_has_targettype();
}
inline const ::flyteidl::core::LiteralType& UnionInfo::_internal_targettype() const {
  const ::flyteidl::core::LiteralType* p = targettype_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::core::LiteralType&>(
      ::flyteidl::core::_LiteralType_default_instance_);
}
inline const ::flyteidl::core::LiteralType& UnionInfo::targettype() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.UnionInfo.targetType)
  return _internal_targettype();
}
inline void UnionInfo::unsafe_arena_set_allocated_targettype(
    ::flyteidl::core::LiteralType* targettype) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(targettype_);
  }
  targettype_ = targettype;
  if (targettype) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.core.UnionInfo.targetType)
}
inline ::flyteidl::core::LiteralType* UnionInfo::release_targettype() {
  
  ::flyteidl::core::LiteralType* temp = targettype_;
  targettype_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::core::LiteralType* UnionInfo::unsafe_arena_release_targettype() {
  // @@protoc_insertion_point(field_release:flyteidl.core.UnionInfo.targetType)
  
  ::flyteidl::core::LiteralType* temp = targettype_;
  targettype_ = nullptr;
  return temp;
}
inline ::flyteidl::core::LiteralType* UnionInfo::_internal_mutable_targettype() {
  
  if (targettype_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::LiteralType>(GetArenaForAllocation());
    targettype_ = p;
  }
  return targettype_;
}
inline ::flyteidl::core::LiteralType* UnionInfo::mutable_targettype() {
  ::flyteidl::core::LiteralType* _msg = _internal_mutable_targettype();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.UnionInfo.targetType)
  return _msg;
}
inline void UnionInfo::set_allocated_targettype(::flyteidl::core::LiteralType* targettype) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(targettype_);
  }
  if (targettype) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(targettype));
    if (message_arena != submessage_arena) {
      targettype = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, targettype, submessage_arena);
    }
    
  } else {
    
  }
  targettype_ = targettype;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.UnionInfo.targetType)
}

// -------------------------------------------------------------------

// BindingData

// .flyteidl.core.Scalar scalar = 1 [json_name = "scalar"];
inline bool BindingData::_internal_has_scalar() const {
  return value_case() == kScalar;
}
inline bool BindingData::has_scalar() const {
  return _internal_has_scalar();
}
inline void BindingData::set_has_scalar() {
  _oneof_case_[0] = kScalar;
}
inline void BindingData::clear_scalar() {
  if (_internal_has_scalar()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.scalar_;
    }
    clear_has_value();
  }
}
inline ::flyteidl::core::Scalar* BindingData::release_scalar() {
  // @@protoc_insertion_point(field_release:flyteidl.core.BindingData.scalar)
  if (_internal_has_scalar()) {
    clear_has_value();
      ::flyteidl::core::Scalar* temp = value_.scalar_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.scalar_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::core::Scalar& BindingData::_internal_scalar() const {
  return _internal_has_scalar()
      ? *value_.scalar_
      : reinterpret_cast< ::flyteidl::core::Scalar&>(::flyteidl::core::_Scalar_default_instance_);
}
inline const ::flyteidl::core::Scalar& BindingData::scalar() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.BindingData.scalar)
  return _internal_scalar();
}
inline ::flyteidl::core::Scalar* BindingData::unsafe_arena_release_scalar() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flyteidl.core.BindingData.scalar)
  if (_internal_has_scalar()) {
    clear_has_value();
    ::flyteidl::core::Scalar* temp = value_.scalar_;
    value_.scalar_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BindingData::unsafe_arena_set_allocated_scalar(::flyteidl::core::Scalar* scalar) {
  clear_value();
  if (scalar) {
    set_has_scalar();
    value_.scalar_ = scalar;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.core.BindingData.scalar)
}
inline ::flyteidl::core::Scalar* BindingData::_internal_mutable_scalar() {
  if (!_internal_has_scalar()) {
    clear_value();
    set_has_scalar();
    value_.scalar_ = CreateMaybeMessage< ::flyteidl::core::Scalar >(GetArenaForAllocation());
  }
  return value_.scalar_;
}
inline ::flyteidl::core::Scalar* BindingData::mutable_scalar() {
  ::flyteidl::core::Scalar* _msg = _internal_mutable_scalar();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.BindingData.scalar)
  return _msg;
}

// .flyteidl.core.BindingDataCollection collection = 2 [json_name = "collection"];
inline bool BindingData::_internal_has_collection() const {
  return value_case() == kCollection;
}
inline bool BindingData::has_collection() const {
  return _internal_has_collection();
}
inline void BindingData::set_has_collection() {
  _oneof_case_[0] = kCollection;
}
inline void BindingData::clear_collection() {
  if (_internal_has_collection()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.collection_;
    }
    clear_has_value();
  }
}
inline ::flyteidl::core::BindingDataCollection* BindingData::release_collection() {
  // @@protoc_insertion_point(field_release:flyteidl.core.BindingData.collection)
  if (_internal_has_collection()) {
    clear_has_value();
      ::flyteidl::core::BindingDataCollection* temp = value_.collection_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.collection_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::core::BindingDataCollection& BindingData::_internal_collection() const {
  return _internal_has_collection()
      ? *value_.collection_
      : reinterpret_cast< ::flyteidl::core::BindingDataCollection&>(::flyteidl::core::_BindingDataCollection_default_instance_);
}
inline const ::flyteidl::core::BindingDataCollection& BindingData::collection() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.BindingData.collection)
  return _internal_collection();
}
inline ::flyteidl::core::BindingDataCollection* BindingData::unsafe_arena_release_collection() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flyteidl.core.BindingData.collection)
  if (_internal_has_collection()) {
    clear_has_value();
    ::flyteidl::core::BindingDataCollection* temp = value_.collection_;
    value_.collection_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BindingData::unsafe_arena_set_allocated_collection(::flyteidl::core::BindingDataCollection* collection) {
  clear_value();
  if (collection) {
    set_has_collection();
    value_.collection_ = collection;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.core.BindingData.collection)
}
inline ::flyteidl::core::BindingDataCollection* BindingData::_internal_mutable_collection() {
  if (!_internal_has_collection()) {
    clear_value();
    set_has_collection();
    value_.collection_ = CreateMaybeMessage< ::flyteidl::core::BindingDataCollection >(GetArenaForAllocation());
  }
  return value_.collection_;
}
inline ::flyteidl::core::BindingDataCollection* BindingData::mutable_collection() {
  ::flyteidl::core::BindingDataCollection* _msg = _internal_mutable_collection();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.BindingData.collection)
  return _msg;
}

// .flyteidl.core.OutputReference promise = 3 [json_name = "promise"];
inline bool BindingData::_internal_has_promise() const {
  return value_case() == kPromise;
}
inline bool BindingData::has_promise() const {
  return _internal_has_promise();
}
inline void BindingData::set_has_promise() {
  _oneof_case_[0] = kPromise;
}
inline ::flyteidl::core::OutputReference* BindingData::release_promise() {
  // @@protoc_insertion_point(field_release:flyteidl.core.BindingData.promise)
  if (_internal_has_promise()) {
    clear_has_value();
      ::flyteidl::core::OutputReference* temp = value_.promise_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.promise_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::core::OutputReference& BindingData::_internal_promise() const {
  return _internal_has_promise()
      ? *value_.promise_
      : reinterpret_cast< ::flyteidl::core::OutputReference&>(::flyteidl::core::_OutputReference_default_instance_);
}
inline const ::flyteidl::core::OutputReference& BindingData::promise() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.BindingData.promise)
  return _internal_promise();
}
inline ::flyteidl::core::OutputReference* BindingData::unsafe_arena_release_promise() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flyteidl.core.BindingData.promise)
  if (_internal_has_promise()) {
    clear_has_value();
    ::flyteidl::core::OutputReference* temp = value_.promise_;
    value_.promise_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BindingData::unsafe_arena_set_allocated_promise(::flyteidl::core::OutputReference* promise) {
  clear_value();
  if (promise) {
    set_has_promise();
    value_.promise_ = promise;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.core.BindingData.promise)
}
inline ::flyteidl::core::OutputReference* BindingData::_internal_mutable_promise() {
  if (!_internal_has_promise()) {
    clear_value();
    set_has_promise();
    value_.promise_ = CreateMaybeMessage< ::flyteidl::core::OutputReference >(GetArenaForAllocation());
  }
  return value_.promise_;
}
inline ::flyteidl::core::OutputReference* BindingData::mutable_promise() {
  ::flyteidl::core::OutputReference* _msg = _internal_mutable_promise();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.BindingData.promise)
  return _msg;
}

// .flyteidl.core.BindingDataMap map = 4 [json_name = "map"];
inline bool BindingData::_internal_has_map() const {
  return value_case() == kMap;
}
inline bool BindingData::has_map() const {
  return _internal_has_map();
}
inline void BindingData::set_has_map() {
  _oneof_case_[0] = kMap;
}
inline void BindingData::clear_map() {
  if (_internal_has_map()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.map_;
    }
    clear_has_value();
  }
}
inline ::flyteidl::core::BindingDataMap* BindingData::release_map() {
  // @@protoc_insertion_point(field_release:flyteidl.core.BindingData.map)
  if (_internal_has_map()) {
    clear_has_value();
      ::flyteidl::core::BindingDataMap* temp = value_.map_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.map_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::core::BindingDataMap& BindingData::_internal_map() const {
  return _internal_has_map()
      ? *value_.map_
      : reinterpret_cast< ::flyteidl::core::BindingDataMap&>(::flyteidl::core::_BindingDataMap_default_instance_);
}
inline const ::flyteidl::core::BindingDataMap& BindingData::map() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.BindingData.map)
  return _internal_map();
}
inline ::flyteidl::core::BindingDataMap* BindingData::unsafe_arena_release_map() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flyteidl.core.BindingData.map)
  if (_internal_has_map()) {
    clear_has_value();
    ::flyteidl::core::BindingDataMap* temp = value_.map_;
    value_.map_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BindingData::unsafe_arena_set_allocated_map(::flyteidl::core::BindingDataMap* map) {
  clear_value();
  if (map) {
    set_has_map();
    value_.map_ = map;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.core.BindingData.map)
}
inline ::flyteidl::core::BindingDataMap* BindingData::_internal_mutable_map() {
  if (!_internal_has_map()) {
    clear_value();
    set_has_map();
    value_.map_ = CreateMaybeMessage< ::flyteidl::core::BindingDataMap >(GetArenaForAllocation());
  }
  return value_.map_;
}
inline ::flyteidl::core::BindingDataMap* BindingData::mutable_map() {
  ::flyteidl::core::BindingDataMap* _msg = _internal_mutable_map();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.BindingData.map)
  return _msg;
}

// .flyteidl.core.UnionInfo union = 5 [json_name = "union"];
inline bool BindingData::_internal_has_union_() const {
  return this != internal_default_instance() && union__ != nullptr;
}
inline bool BindingData::has_union_() const {
  return _internal_has_union_();
}
inline void BindingData::clear_union_() {
  if (GetArenaForAllocation() == nullptr && union__ != nullptr) {
    delete union__;
  }
  union__ = nullptr;
}
inline const ::flyteidl::core::UnionInfo& BindingData::_internal_union_() const {
  const ::flyteidl::core::UnionInfo* p = union__;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::core::UnionInfo&>(
      ::flyteidl::core::_UnionInfo_default_instance_);
}
inline const ::flyteidl::core::UnionInfo& BindingData::union_() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.BindingData.union)
  return _internal_union_();
}
inline void BindingData::unsafe_arena_set_allocated_union_(
    ::flyteidl::core::UnionInfo* union_) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(union__);
  }
  union__ = union_;
  if (union_) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.core.BindingData.union)
}
inline ::flyteidl::core::UnionInfo* BindingData::release_union_() {
  
  ::flyteidl::core::UnionInfo* temp = union__;
  union__ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::core::UnionInfo* BindingData::unsafe_arena_release_union_() {
  // @@protoc_insertion_point(field_release:flyteidl.core.BindingData.union)
  
  ::flyteidl::core::UnionInfo* temp = union__;
  union__ = nullptr;
  return temp;
}
inline ::flyteidl::core::UnionInfo* BindingData::_internal_mutable_union_() {
  
  if (union__ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::UnionInfo>(GetArenaForAllocation());
    union__ = p;
  }
  return union__;
}
inline ::flyteidl::core::UnionInfo* BindingData::mutable_union_() {
  ::flyteidl::core::UnionInfo* _msg = _internal_mutable_union_();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.BindingData.union)
  return _msg;
}
inline void BindingData::set_allocated_union_(::flyteidl::core::UnionInfo* union_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete union__;
  }
  if (union_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::flyteidl::core::UnionInfo>::GetOwningArena(union_);
    if (message_arena != submessage_arena) {
      union_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, union_, submessage_arena);
    }
    
  } else {
    
  }
  union__ = union_;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.BindingData.union)
}

inline bool BindingData::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void BindingData::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline BindingData::ValueCase BindingData::value_case() const {
  return BindingData::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Binding

// string var = 1 [json_name = "var"];
inline void Binding::clear_var() {
  var_.ClearToEmpty();
}
inline const std::string& Binding::var() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Binding.var)
  return _internal_var();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Binding::set_var(ArgT0&& arg0, ArgT... args) {
 
 var_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.core.Binding.var)
}
inline std::string* Binding::mutable_var() {
  std::string* _s = _internal_mutable_var();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Binding.var)
  return _s;
}
inline const std::string& Binding::_internal_var() const {
  return var_.Get();
}
inline void Binding::_internal_set_var(const std::string& value) {
  
  var_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Binding::_internal_mutable_var() {
  
  return var_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Binding::release_var() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Binding.var)
  return var_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Binding::set_allocated_var(std::string* var) {
  if (var != nullptr) {
    
  } else {
    
  }
  var_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), var,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (var_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    var_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.Binding.var)
}

// .flyteidl.core.BindingData binding = 2 [json_name = "binding"];
inline bool Binding::_internal_has_binding() const {
  return this != internal_default_instance() && binding_ != nullptr;
}
inline bool Binding::has_binding() const {
  return _internal_has_binding();
}
inline void Binding::clear_binding() {
  if (GetArenaForAllocation() == nullptr && binding_ != nullptr) {
    delete binding_;
  }
  binding_ = nullptr;
}
inline const ::flyteidl::core::BindingData& Binding::_internal_binding() const {
  const ::flyteidl::core::BindingData* p = binding_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::core::BindingData&>(
      ::flyteidl::core::_BindingData_default_instance_);
}
inline const ::flyteidl::core::BindingData& Binding::binding() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Binding.binding)
  return _internal_binding();
}
inline void Binding::unsafe_arena_set_allocated_binding(
    ::flyteidl::core::BindingData* binding) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(binding_);
  }
  binding_ = binding;
  if (binding) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.core.Binding.binding)
}
inline ::flyteidl::core::BindingData* Binding::release_binding() {
  
  ::flyteidl::core::BindingData* temp = binding_;
  binding_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::core::BindingData* Binding::unsafe_arena_release_binding() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Binding.binding)
  
  ::flyteidl::core::BindingData* temp = binding_;
  binding_ = nullptr;
  return temp;
}
inline ::flyteidl::core::BindingData* Binding::_internal_mutable_binding() {
  
  if (binding_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::BindingData>(GetArenaForAllocation());
    binding_ = p;
  }
  return binding_;
}
inline ::flyteidl::core::BindingData* Binding::mutable_binding() {
  ::flyteidl::core::BindingData* _msg = _internal_mutable_binding();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Binding.binding)
  return _msg;
}
inline void Binding::set_allocated_binding(::flyteidl::core::BindingData* binding) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete binding_;
  }
  if (binding) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::flyteidl::core::BindingData>::GetOwningArena(binding);
    if (message_arena != submessage_arena) {
      binding = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, binding, submessage_arena);
    }
    
  } else {
    
  }
  binding_ = binding;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.Binding.binding)
}

// -------------------------------------------------------------------

// KeyValuePair

// string key = 1 [json_name = "key"];
inline void KeyValuePair::clear_key() {
  key_.ClearToEmpty();
}
inline const std::string& KeyValuePair::key() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.KeyValuePair.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KeyValuePair::set_key(ArgT0&& arg0, ArgT... args) {
 
 key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.core.KeyValuePair.key)
}
inline std::string* KeyValuePair::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.KeyValuePair.key)
  return _s;
}
inline const std::string& KeyValuePair::_internal_key() const {
  return key_.Get();
}
inline void KeyValuePair::_internal_set_key(const std::string& value) {
  
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* KeyValuePair::_internal_mutable_key() {
  
  return key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* KeyValuePair::release_key() {
  // @@protoc_insertion_point(field_release:flyteidl.core.KeyValuePair.key)
  return key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void KeyValuePair::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.KeyValuePair.key)
}

// string value = 2 [json_name = "value"];
inline void KeyValuePair::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& KeyValuePair::value() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.KeyValuePair.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KeyValuePair::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.core.KeyValuePair.value)
}
inline std::string* KeyValuePair::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.KeyValuePair.value)
  return _s;
}
inline const std::string& KeyValuePair::_internal_value() const {
  return value_.Get();
}
inline void KeyValuePair::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* KeyValuePair::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* KeyValuePair::release_value() {
  // @@protoc_insertion_point(field_release:flyteidl.core.KeyValuePair.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void KeyValuePair::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (value_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.KeyValuePair.value)
}

// -------------------------------------------------------------------

// RetryStrategy

// uint32 retries = 5 [json_name = "retries"];
inline void RetryStrategy::clear_retries() {
  retries_ = 0u;
}
inline uint32_t RetryStrategy::_internal_retries() const {
  return retries_;
}
inline uint32_t RetryStrategy::retries() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.RetryStrategy.retries)
  return _internal_retries();
}
inline void RetryStrategy::_internal_set_retries(uint32_t value) {
  
  retries_ = value;
}
inline void RetryStrategy::set_retries(uint32_t value) {
  _internal_set_retries(value);
  // @@protoc_insertion_point(field_set:flyteidl.core.RetryStrategy.retries)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace core
}  // namespace flyteidl

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_flyteidl_2fcore_2fliterals_2eproto
