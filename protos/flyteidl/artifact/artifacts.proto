syntax = "proto3";
package flyteidl.artifact;

option go_package = "github.com/flyteorg/flyteidl/gen/pb-go/flyteidl/artifact";

import "flyteidl/core/literals.proto";
import "flyteidl/core/types.proto";
import "flyteidl/core/identifier.proto";
import "flyteidl/core/interface.proto";


message Artifact {
  core.ArtifactID artifact_id = 1;

  ArtifactSpec spec = 2;

  // references the tag field in ArtifactTag
  repeated string tags = 3;
}

message CreateArtifactRequest {
  // Specify just project/domain on creation
  core.ArtifactKey artifact_key = 1;

  string version = 3;

  ArtifactSpec spec = 2;

  map<string, string> partitions = 4;

  string tag = 5;
}

message ArtifactSpec {
  core.Literal value = 1;

  // This type will not form part of the artifact key, so for user-named artifacts, if the user changes the type, but
  // forgets to change the name, that is okay. And the reason why this is a separate field is because adding the
  // type to all Literals is a lot of work.
  core.LiteralType type = 2;

  oneof source {
    // Outputs of tasks will have this.
    core.TaskExecutionIdentifier task_execution = 5;

    // Workflow outputs will have this.
    core.WorkflowExecutionIdentifier execution = 6;

    // Uploads, either from the UI or from the CLI, or FlyteRemote, will have this.
    string principal = 7;
  }

  string short_description = 8;
  string long_description = 9;
}


message CreateArtifactResponse {
  Artifact artifact = 1;
}

message GetArtifactRequest {
  core.ArtifactQuery query = 1;

  // If false, then long_description is not returned.
  bool details = 2;
}

message GetArtifactResponse {
  Artifact artifact = 1;
}

message ListArtifactNamesRequest {
  string project = 1;
  string domain = 2;
}

message ListArtifactNamesResponse {
  repeated core.ArtifactKey artifact_keys = 1;
}

message ListArtifactsRequest {
  core.ArtifactKey artifact_key = 1;
}

message ListArtifactsResponse {
  repeated Artifact artifacts = 1;
}

// Aliases identify a particular version of an artifact. They are different than tags in that they
// have to be unique for a given artifact project/domain/name. That is, for a given project/domain/name/kind,
// at most one version can have any given value at any point.
message AddTagRequest {
  core.ArtifactID artifact_id = 1;

  string value = 2;

  // If true, and another version already has the specified kind/value, set this version instead
  bool overwrite = 3;
}

message AddTagResponse {}

// Artifact Trigger
message CreateTriggerRequest {
  // TODO: This should be a list of artifact keys
  core.ArtifactKey artifact_key = 1;

  core.Identifier downstream_id = 2;

  core.ParameterMap inputs = 3;
}

message CreateTriggerResponse {}

message DeleteTriggerRequest {
  core.ArtifactKey artifact_key = 1;

  core.Identifier downstream_id = 2;
}

message DeleteTriggerResponse {}

service ArtifactRegistry {
  rpc CreateArtifact (CreateArtifactRequest) returns (CreateArtifactResponse) {}

  rpc GetArtifact (GetArtifactRequest) returns (GetArtifactResponse) {}

//  rpc ListArtifactNames (ListArtifactNamesRequest) returns (ListArtifactNamesResponse) {}
//
//  rpc ListArtifacts (ListArtifactsRequest) returns (ListArtifactsResponse) {}

  rpc CreateTrigger (CreateTriggerRequest) returns (CreateTriggerResponse) {}

  rpc DeleteTrigger (DeleteTriggerRequest) returns (DeleteTriggerResponse) {}

  rpc AddTag(AddTagRequest) returns (AddTagResponse) {}
}
