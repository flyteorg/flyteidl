// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: flyteidl/admin/node_execution.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_flyteidl_2fadmin_2fnode_5fexecution_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_flyteidl_2fadmin_2fnode_5fexecution_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "flyteidl/admin/common.pb.h"
#include "flyteidl/core/execution.pb.h"
#include "flyteidl/core/catalog.pb.h"
#include "flyteidl/core/compiler.pb.h"
#include "flyteidl/core/identifier.pb.h"
#include "flyteidl/core/literals.pb.h"
#include <google/protobuf/timestamp.pb.h>
#include <google/protobuf/duration.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_flyteidl_2fadmin_2fnode_5fexecution_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_flyteidl_2fadmin_2fnode_5fexecution_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[12]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_flyteidl_2fadmin_2fnode_5fexecution_2eproto;
namespace flyteidl {
namespace admin {
class DynamicWorkflowNodeMetadata;
struct DynamicWorkflowNodeMetadataDefaultTypeInternal;
extern DynamicWorkflowNodeMetadataDefaultTypeInternal _DynamicWorkflowNodeMetadata_default_instance_;
class NodeExecution;
struct NodeExecutionDefaultTypeInternal;
extern NodeExecutionDefaultTypeInternal _NodeExecution_default_instance_;
class NodeExecutionClosure;
struct NodeExecutionClosureDefaultTypeInternal;
extern NodeExecutionClosureDefaultTypeInternal _NodeExecutionClosure_default_instance_;
class NodeExecutionForTaskListRequest;
struct NodeExecutionForTaskListRequestDefaultTypeInternal;
extern NodeExecutionForTaskListRequestDefaultTypeInternal _NodeExecutionForTaskListRequest_default_instance_;
class NodeExecutionGetDataRequest;
struct NodeExecutionGetDataRequestDefaultTypeInternal;
extern NodeExecutionGetDataRequestDefaultTypeInternal _NodeExecutionGetDataRequest_default_instance_;
class NodeExecutionGetDataResponse;
struct NodeExecutionGetDataResponseDefaultTypeInternal;
extern NodeExecutionGetDataResponseDefaultTypeInternal _NodeExecutionGetDataResponse_default_instance_;
class NodeExecutionGetRequest;
struct NodeExecutionGetRequestDefaultTypeInternal;
extern NodeExecutionGetRequestDefaultTypeInternal _NodeExecutionGetRequest_default_instance_;
class NodeExecutionList;
struct NodeExecutionListDefaultTypeInternal;
extern NodeExecutionListDefaultTypeInternal _NodeExecutionList_default_instance_;
class NodeExecutionListRequest;
struct NodeExecutionListRequestDefaultTypeInternal;
extern NodeExecutionListRequestDefaultTypeInternal _NodeExecutionListRequest_default_instance_;
class NodeExecutionMetaData;
struct NodeExecutionMetaDataDefaultTypeInternal;
extern NodeExecutionMetaDataDefaultTypeInternal _NodeExecutionMetaData_default_instance_;
class TaskNodeMetadata;
struct TaskNodeMetadataDefaultTypeInternal;
extern TaskNodeMetadataDefaultTypeInternal _TaskNodeMetadata_default_instance_;
class WorkflowNodeMetadata;
struct WorkflowNodeMetadataDefaultTypeInternal;
extern WorkflowNodeMetadataDefaultTypeInternal _WorkflowNodeMetadata_default_instance_;
}  // namespace admin
}  // namespace flyteidl
PROTOBUF_NAMESPACE_OPEN
template<> ::flyteidl::admin::DynamicWorkflowNodeMetadata* Arena::CreateMaybeMessage<::flyteidl::admin::DynamicWorkflowNodeMetadata>(Arena*);
template<> ::flyteidl::admin::NodeExecution* Arena::CreateMaybeMessage<::flyteidl::admin::NodeExecution>(Arena*);
template<> ::flyteidl::admin::NodeExecutionClosure* Arena::CreateMaybeMessage<::flyteidl::admin::NodeExecutionClosure>(Arena*);
template<> ::flyteidl::admin::NodeExecutionForTaskListRequest* Arena::CreateMaybeMessage<::flyteidl::admin::NodeExecutionForTaskListRequest>(Arena*);
template<> ::flyteidl::admin::NodeExecutionGetDataRequest* Arena::CreateMaybeMessage<::flyteidl::admin::NodeExecutionGetDataRequest>(Arena*);
template<> ::flyteidl::admin::NodeExecutionGetDataResponse* Arena::CreateMaybeMessage<::flyteidl::admin::NodeExecutionGetDataResponse>(Arena*);
template<> ::flyteidl::admin::NodeExecutionGetRequest* Arena::CreateMaybeMessage<::flyteidl::admin::NodeExecutionGetRequest>(Arena*);
template<> ::flyteidl::admin::NodeExecutionList* Arena::CreateMaybeMessage<::flyteidl::admin::NodeExecutionList>(Arena*);
template<> ::flyteidl::admin::NodeExecutionListRequest* Arena::CreateMaybeMessage<::flyteidl::admin::NodeExecutionListRequest>(Arena*);
template<> ::flyteidl::admin::NodeExecutionMetaData* Arena::CreateMaybeMessage<::flyteidl::admin::NodeExecutionMetaData>(Arena*);
template<> ::flyteidl::admin::TaskNodeMetadata* Arena::CreateMaybeMessage<::flyteidl::admin::TaskNodeMetadata>(Arena*);
template<> ::flyteidl::admin::WorkflowNodeMetadata* Arena::CreateMaybeMessage<::flyteidl::admin::WorkflowNodeMetadata>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace flyteidl {
namespace admin {

// ===================================================================

class NodeExecutionGetRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.admin.NodeExecutionGetRequest) */ {
 public:
  inline NodeExecutionGetRequest() : NodeExecutionGetRequest(nullptr) {}
  ~NodeExecutionGetRequest() override;
  explicit constexpr NodeExecutionGetRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NodeExecutionGetRequest(const NodeExecutionGetRequest& from);
  NodeExecutionGetRequest(NodeExecutionGetRequest&& from) noexcept
    : NodeExecutionGetRequest() {
    *this = ::std::move(from);
  }

  inline NodeExecutionGetRequest& operator=(const NodeExecutionGetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeExecutionGetRequest& operator=(NodeExecutionGetRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeExecutionGetRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeExecutionGetRequest* internal_default_instance() {
    return reinterpret_cast<const NodeExecutionGetRequest*>(
               &_NodeExecutionGetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(NodeExecutionGetRequest& a, NodeExecutionGetRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeExecutionGetRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeExecutionGetRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeExecutionGetRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodeExecutionGetRequest>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeExecutionGetRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.admin.NodeExecutionGetRequest";
  }
  protected:
  explicit NodeExecutionGetRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // .flyteidl.core.NodeExecutionIdentifier id = 1 [json_name = "id"];
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::flyteidl::core::NodeExecutionIdentifier& id() const;
  PROTOBUF_NODISCARD ::flyteidl::core::NodeExecutionIdentifier* release_id();
  ::flyteidl::core::NodeExecutionIdentifier* mutable_id();
  void set_allocated_id(::flyteidl::core::NodeExecutionIdentifier* id);
  private:
  const ::flyteidl::core::NodeExecutionIdentifier& _internal_id() const;
  ::flyteidl::core::NodeExecutionIdentifier* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::flyteidl::core::NodeExecutionIdentifier* id);
  ::flyteidl::core::NodeExecutionIdentifier* unsafe_arena_release_id();

  // @@protoc_insertion_point(class_scope:flyteidl.admin.NodeExecutionGetRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::flyteidl::core::NodeExecutionIdentifier* id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fadmin_2fnode_5fexecution_2eproto;
};
// -------------------------------------------------------------------

class NodeExecutionListRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.admin.NodeExecutionListRequest) */ {
 public:
  inline NodeExecutionListRequest() : NodeExecutionListRequest(nullptr) {}
  ~NodeExecutionListRequest() override;
  explicit constexpr NodeExecutionListRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NodeExecutionListRequest(const NodeExecutionListRequest& from);
  NodeExecutionListRequest(NodeExecutionListRequest&& from) noexcept
    : NodeExecutionListRequest() {
    *this = ::std::move(from);
  }

  inline NodeExecutionListRequest& operator=(const NodeExecutionListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeExecutionListRequest& operator=(NodeExecutionListRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeExecutionListRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeExecutionListRequest* internal_default_instance() {
    return reinterpret_cast<const NodeExecutionListRequest*>(
               &_NodeExecutionListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(NodeExecutionListRequest& a, NodeExecutionListRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeExecutionListRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeExecutionListRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeExecutionListRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodeExecutionListRequest>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeExecutionListRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.admin.NodeExecutionListRequest";
  }
  protected:
  explicit NodeExecutionListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 3,
    kFiltersFieldNumber = 4,
    kUniqueParentIdFieldNumber = 6,
    kWorkflowExecutionIdFieldNumber = 1,
    kSortByFieldNumber = 5,
    kLimitFieldNumber = 2,
  };
  // string token = 3 [json_name = "token"];
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // string filters = 4 [json_name = "filters"];
  void clear_filters();
  const std::string& filters() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filters(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filters();
  PROTOBUF_NODISCARD std::string* release_filters();
  void set_allocated_filters(std::string* filters);
  private:
  const std::string& _internal_filters() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filters(const std::string& value);
  std::string* _internal_mutable_filters();
  public:

  // string unique_parent_id = 6 [json_name = "uniqueParentId"];
  void clear_unique_parent_id();
  const std::string& unique_parent_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_unique_parent_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_unique_parent_id();
  PROTOBUF_NODISCARD std::string* release_unique_parent_id();
  void set_allocated_unique_parent_id(std::string* unique_parent_id);
  private:
  const std::string& _internal_unique_parent_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_unique_parent_id(const std::string& value);
  std::string* _internal_mutable_unique_parent_id();
  public:

  // .flyteidl.core.WorkflowExecutionIdentifier workflow_execution_id = 1 [json_name = "workflowExecutionId"];
  bool has_workflow_execution_id() const;
  private:
  bool _internal_has_workflow_execution_id() const;
  public:
  void clear_workflow_execution_id();
  const ::flyteidl::core::WorkflowExecutionIdentifier& workflow_execution_id() const;
  PROTOBUF_NODISCARD ::flyteidl::core::WorkflowExecutionIdentifier* release_workflow_execution_id();
  ::flyteidl::core::WorkflowExecutionIdentifier* mutable_workflow_execution_id();
  void set_allocated_workflow_execution_id(::flyteidl::core::WorkflowExecutionIdentifier* workflow_execution_id);
  private:
  const ::flyteidl::core::WorkflowExecutionIdentifier& _internal_workflow_execution_id() const;
  ::flyteidl::core::WorkflowExecutionIdentifier* _internal_mutable_workflow_execution_id();
  public:
  void unsafe_arena_set_allocated_workflow_execution_id(
      ::flyteidl::core::WorkflowExecutionIdentifier* workflow_execution_id);
  ::flyteidl::core::WorkflowExecutionIdentifier* unsafe_arena_release_workflow_execution_id();

  // .flyteidl.admin.Sort sort_by = 5 [json_name = "sortBy"];
  bool has_sort_by() const;
  private:
  bool _internal_has_sort_by() const;
  public:
  void clear_sort_by();
  const ::flyteidl::admin::Sort& sort_by() const;
  PROTOBUF_NODISCARD ::flyteidl::admin::Sort* release_sort_by();
  ::flyteidl::admin::Sort* mutable_sort_by();
  void set_allocated_sort_by(::flyteidl::admin::Sort* sort_by);
  private:
  const ::flyteidl::admin::Sort& _internal_sort_by() const;
  ::flyteidl::admin::Sort* _internal_mutable_sort_by();
  public:
  void unsafe_arena_set_allocated_sort_by(
      ::flyteidl::admin::Sort* sort_by);
  ::flyteidl::admin::Sort* unsafe_arena_release_sort_by();

  // uint32 limit = 2 [json_name = "limit"];
  void clear_limit();
  uint32_t limit() const;
  void set_limit(uint32_t value);
  private:
  uint32_t _internal_limit() const;
  void _internal_set_limit(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:flyteidl.admin.NodeExecutionListRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filters_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr unique_parent_id_;
  ::flyteidl::core::WorkflowExecutionIdentifier* workflow_execution_id_;
  ::flyteidl::admin::Sort* sort_by_;
  uint32_t limit_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fadmin_2fnode_5fexecution_2eproto;
};
// -------------------------------------------------------------------

class NodeExecutionForTaskListRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.admin.NodeExecutionForTaskListRequest) */ {
 public:
  inline NodeExecutionForTaskListRequest() : NodeExecutionForTaskListRequest(nullptr) {}
  ~NodeExecutionForTaskListRequest() override;
  explicit constexpr NodeExecutionForTaskListRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NodeExecutionForTaskListRequest(const NodeExecutionForTaskListRequest& from);
  NodeExecutionForTaskListRequest(NodeExecutionForTaskListRequest&& from) noexcept
    : NodeExecutionForTaskListRequest() {
    *this = ::std::move(from);
  }

  inline NodeExecutionForTaskListRequest& operator=(const NodeExecutionForTaskListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeExecutionForTaskListRequest& operator=(NodeExecutionForTaskListRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeExecutionForTaskListRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeExecutionForTaskListRequest* internal_default_instance() {
    return reinterpret_cast<const NodeExecutionForTaskListRequest*>(
               &_NodeExecutionForTaskListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(NodeExecutionForTaskListRequest& a, NodeExecutionForTaskListRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeExecutionForTaskListRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeExecutionForTaskListRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeExecutionForTaskListRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodeExecutionForTaskListRequest>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeExecutionForTaskListRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.admin.NodeExecutionForTaskListRequest";
  }
  protected:
  explicit NodeExecutionForTaskListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 3,
    kFiltersFieldNumber = 4,
    kTaskExecutionIdFieldNumber = 1,
    kSortByFieldNumber = 5,
    kLimitFieldNumber = 2,
  };
  // string token = 3 [json_name = "token"];
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // string filters = 4 [json_name = "filters"];
  void clear_filters();
  const std::string& filters() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filters(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filters();
  PROTOBUF_NODISCARD std::string* release_filters();
  void set_allocated_filters(std::string* filters);
  private:
  const std::string& _internal_filters() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filters(const std::string& value);
  std::string* _internal_mutable_filters();
  public:

  // .flyteidl.core.TaskExecutionIdentifier task_execution_id = 1 [json_name = "taskExecutionId"];
  bool has_task_execution_id() const;
  private:
  bool _internal_has_task_execution_id() const;
  public:
  void clear_task_execution_id();
  const ::flyteidl::core::TaskExecutionIdentifier& task_execution_id() const;
  PROTOBUF_NODISCARD ::flyteidl::core::TaskExecutionIdentifier* release_task_execution_id();
  ::flyteidl::core::TaskExecutionIdentifier* mutable_task_execution_id();
  void set_allocated_task_execution_id(::flyteidl::core::TaskExecutionIdentifier* task_execution_id);
  private:
  const ::flyteidl::core::TaskExecutionIdentifier& _internal_task_execution_id() const;
  ::flyteidl::core::TaskExecutionIdentifier* _internal_mutable_task_execution_id();
  public:
  void unsafe_arena_set_allocated_task_execution_id(
      ::flyteidl::core::TaskExecutionIdentifier* task_execution_id);
  ::flyteidl::core::TaskExecutionIdentifier* unsafe_arena_release_task_execution_id();

  // .flyteidl.admin.Sort sort_by = 5 [json_name = "sortBy"];
  bool has_sort_by() const;
  private:
  bool _internal_has_sort_by() const;
  public:
  void clear_sort_by();
  const ::flyteidl::admin::Sort& sort_by() const;
  PROTOBUF_NODISCARD ::flyteidl::admin::Sort* release_sort_by();
  ::flyteidl::admin::Sort* mutable_sort_by();
  void set_allocated_sort_by(::flyteidl::admin::Sort* sort_by);
  private:
  const ::flyteidl::admin::Sort& _internal_sort_by() const;
  ::flyteidl::admin::Sort* _internal_mutable_sort_by();
  public:
  void unsafe_arena_set_allocated_sort_by(
      ::flyteidl::admin::Sort* sort_by);
  ::flyteidl::admin::Sort* unsafe_arena_release_sort_by();

  // uint32 limit = 2 [json_name = "limit"];
  void clear_limit();
  uint32_t limit() const;
  void set_limit(uint32_t value);
  private:
  uint32_t _internal_limit() const;
  void _internal_set_limit(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:flyteidl.admin.NodeExecutionForTaskListRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filters_;
  ::flyteidl::core::TaskExecutionIdentifier* task_execution_id_;
  ::flyteidl::admin::Sort* sort_by_;
  uint32_t limit_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fadmin_2fnode_5fexecution_2eproto;
};
// -------------------------------------------------------------------

class NodeExecution final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.admin.NodeExecution) */ {
 public:
  inline NodeExecution() : NodeExecution(nullptr) {}
  ~NodeExecution() override;
  explicit constexpr NodeExecution(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NodeExecution(const NodeExecution& from);
  NodeExecution(NodeExecution&& from) noexcept
    : NodeExecution() {
    *this = ::std::move(from);
  }

  inline NodeExecution& operator=(const NodeExecution& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeExecution& operator=(NodeExecution&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeExecution& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeExecution* internal_default_instance() {
    return reinterpret_cast<const NodeExecution*>(
               &_NodeExecution_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(NodeExecution& a, NodeExecution& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeExecution* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeExecution* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeExecution* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodeExecution>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeExecution* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.admin.NodeExecution";
  }
  protected:
  explicit NodeExecution(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInputUriFieldNumber = 2,
    kIdFieldNumber = 1,
    kClosureFieldNumber = 3,
    kMetadataFieldNumber = 4,
  };
  // string input_uri = 2 [json_name = "inputUri"];
  void clear_input_uri();
  const std::string& input_uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_input_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_input_uri();
  PROTOBUF_NODISCARD std::string* release_input_uri();
  void set_allocated_input_uri(std::string* input_uri);
  private:
  const std::string& _internal_input_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_input_uri(const std::string& value);
  std::string* _internal_mutable_input_uri();
  public:

  // .flyteidl.core.NodeExecutionIdentifier id = 1 [json_name = "id"];
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::flyteidl::core::NodeExecutionIdentifier& id() const;
  PROTOBUF_NODISCARD ::flyteidl::core::NodeExecutionIdentifier* release_id();
  ::flyteidl::core::NodeExecutionIdentifier* mutable_id();
  void set_allocated_id(::flyteidl::core::NodeExecutionIdentifier* id);
  private:
  const ::flyteidl::core::NodeExecutionIdentifier& _internal_id() const;
  ::flyteidl::core::NodeExecutionIdentifier* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::flyteidl::core::NodeExecutionIdentifier* id);
  ::flyteidl::core::NodeExecutionIdentifier* unsafe_arena_release_id();

  // .flyteidl.admin.NodeExecutionClosure closure = 3 [json_name = "closure"];
  bool has_closure() const;
  private:
  bool _internal_has_closure() const;
  public:
  void clear_closure();
  const ::flyteidl::admin::NodeExecutionClosure& closure() const;
  PROTOBUF_NODISCARD ::flyteidl::admin::NodeExecutionClosure* release_closure();
  ::flyteidl::admin::NodeExecutionClosure* mutable_closure();
  void set_allocated_closure(::flyteidl::admin::NodeExecutionClosure* closure);
  private:
  const ::flyteidl::admin::NodeExecutionClosure& _internal_closure() const;
  ::flyteidl::admin::NodeExecutionClosure* _internal_mutable_closure();
  public:
  void unsafe_arena_set_allocated_closure(
      ::flyteidl::admin::NodeExecutionClosure* closure);
  ::flyteidl::admin::NodeExecutionClosure* unsafe_arena_release_closure();

  // .flyteidl.admin.NodeExecutionMetaData metadata = 4 [json_name = "metadata"];
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::flyteidl::admin::NodeExecutionMetaData& metadata() const;
  PROTOBUF_NODISCARD ::flyteidl::admin::NodeExecutionMetaData* release_metadata();
  ::flyteidl::admin::NodeExecutionMetaData* mutable_metadata();
  void set_allocated_metadata(::flyteidl::admin::NodeExecutionMetaData* metadata);
  private:
  const ::flyteidl::admin::NodeExecutionMetaData& _internal_metadata() const;
  ::flyteidl::admin::NodeExecutionMetaData* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::flyteidl::admin::NodeExecutionMetaData* metadata);
  ::flyteidl::admin::NodeExecutionMetaData* unsafe_arena_release_metadata();

  // @@protoc_insertion_point(class_scope:flyteidl.admin.NodeExecution)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr input_uri_;
  ::flyteidl::core::NodeExecutionIdentifier* id_;
  ::flyteidl::admin::NodeExecutionClosure* closure_;
  ::flyteidl::admin::NodeExecutionMetaData* metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fadmin_2fnode_5fexecution_2eproto;
};
// -------------------------------------------------------------------

class NodeExecutionMetaData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.admin.NodeExecutionMetaData) */ {
 public:
  inline NodeExecutionMetaData() : NodeExecutionMetaData(nullptr) {}
  ~NodeExecutionMetaData() override;
  explicit constexpr NodeExecutionMetaData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NodeExecutionMetaData(const NodeExecutionMetaData& from);
  NodeExecutionMetaData(NodeExecutionMetaData&& from) noexcept
    : NodeExecutionMetaData() {
    *this = ::std::move(from);
  }

  inline NodeExecutionMetaData& operator=(const NodeExecutionMetaData& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeExecutionMetaData& operator=(NodeExecutionMetaData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeExecutionMetaData& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeExecutionMetaData* internal_default_instance() {
    return reinterpret_cast<const NodeExecutionMetaData*>(
               &_NodeExecutionMetaData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(NodeExecutionMetaData& a, NodeExecutionMetaData& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeExecutionMetaData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeExecutionMetaData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeExecutionMetaData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodeExecutionMetaData>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeExecutionMetaData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.admin.NodeExecutionMetaData";
  }
  protected:
  explicit NodeExecutionMetaData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRetryGroupFieldNumber = 1,
    kSpecNodeIdFieldNumber = 3,
    kIsParentNodeFieldNumber = 2,
    kIsDynamicFieldNumber = 4,
  };
  // string retry_group = 1 [json_name = "retryGroup"];
  void clear_retry_group();
  const std::string& retry_group() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_retry_group(ArgT0&& arg0, ArgT... args);
  std::string* mutable_retry_group();
  PROTOBUF_NODISCARD std::string* release_retry_group();
  void set_allocated_retry_group(std::string* retry_group);
  private:
  const std::string& _internal_retry_group() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_retry_group(const std::string& value);
  std::string* _internal_mutable_retry_group();
  public:

  // string spec_node_id = 3 [json_name = "specNodeId"];
  void clear_spec_node_id();
  const std::string& spec_node_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_spec_node_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_spec_node_id();
  PROTOBUF_NODISCARD std::string* release_spec_node_id();
  void set_allocated_spec_node_id(std::string* spec_node_id);
  private:
  const std::string& _internal_spec_node_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_spec_node_id(const std::string& value);
  std::string* _internal_mutable_spec_node_id();
  public:

  // bool is_parent_node = 2 [json_name = "isParentNode"];
  void clear_is_parent_node();
  bool is_parent_node() const;
  void set_is_parent_node(bool value);
  private:
  bool _internal_is_parent_node() const;
  void _internal_set_is_parent_node(bool value);
  public:

  // bool is_dynamic = 4 [json_name = "isDynamic"];
  void clear_is_dynamic();
  bool is_dynamic() const;
  void set_is_dynamic(bool value);
  private:
  bool _internal_is_dynamic() const;
  void _internal_set_is_dynamic(bool value);
  public:

  // @@protoc_insertion_point(class_scope:flyteidl.admin.NodeExecutionMetaData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr retry_group_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr spec_node_id_;
  bool is_parent_node_;
  bool is_dynamic_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fadmin_2fnode_5fexecution_2eproto;
};
// -------------------------------------------------------------------

class NodeExecutionList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.admin.NodeExecutionList) */ {
 public:
  inline NodeExecutionList() : NodeExecutionList(nullptr) {}
  ~NodeExecutionList() override;
  explicit constexpr NodeExecutionList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NodeExecutionList(const NodeExecutionList& from);
  NodeExecutionList(NodeExecutionList&& from) noexcept
    : NodeExecutionList() {
    *this = ::std::move(from);
  }

  inline NodeExecutionList& operator=(const NodeExecutionList& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeExecutionList& operator=(NodeExecutionList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeExecutionList& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeExecutionList* internal_default_instance() {
    return reinterpret_cast<const NodeExecutionList*>(
               &_NodeExecutionList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(NodeExecutionList& a, NodeExecutionList& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeExecutionList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeExecutionList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeExecutionList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodeExecutionList>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeExecutionList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.admin.NodeExecutionList";
  }
  protected:
  explicit NodeExecutionList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeExecutionsFieldNumber = 1,
    kTokenFieldNumber = 2,
  };
  // repeated .flyteidl.admin.NodeExecution node_executions = 1 [json_name = "nodeExecutions"];
  int node_executions_size() const;
  private:
  int _internal_node_executions_size() const;
  public:
  void clear_node_executions();
  ::flyteidl::admin::NodeExecution* mutable_node_executions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::admin::NodeExecution >*
      mutable_node_executions();
  private:
  const ::flyteidl::admin::NodeExecution& _internal_node_executions(int index) const;
  ::flyteidl::admin::NodeExecution* _internal_add_node_executions();
  public:
  const ::flyteidl::admin::NodeExecution& node_executions(int index) const;
  ::flyteidl::admin::NodeExecution* add_node_executions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::admin::NodeExecution >&
      node_executions() const;

  // string token = 2 [json_name = "token"];
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // @@protoc_insertion_point(class_scope:flyteidl.admin.NodeExecutionList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::admin::NodeExecution > node_executions_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fadmin_2fnode_5fexecution_2eproto;
};
// -------------------------------------------------------------------

class NodeExecutionClosure final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.admin.NodeExecutionClosure) */ {
 public:
  inline NodeExecutionClosure() : NodeExecutionClosure(nullptr) {}
  ~NodeExecutionClosure() override;
  explicit constexpr NodeExecutionClosure(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NodeExecutionClosure(const NodeExecutionClosure& from);
  NodeExecutionClosure(NodeExecutionClosure&& from) noexcept
    : NodeExecutionClosure() {
    *this = ::std::move(from);
  }

  inline NodeExecutionClosure& operator=(const NodeExecutionClosure& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeExecutionClosure& operator=(NodeExecutionClosure&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeExecutionClosure& default_instance() {
    return *internal_default_instance();
  }
  enum OutputResultCase {
    kOutputUri = 1,
    kError = 2,
    kOutputData = 10,
    OUTPUT_RESULT_NOT_SET = 0,
  };

  enum TargetMetadataCase {
    kWorkflowNodeMetadata = 8,
    kTaskNodeMetadata = 9,
    TARGET_METADATA_NOT_SET = 0,
  };

  static inline const NodeExecutionClosure* internal_default_instance() {
    return reinterpret_cast<const NodeExecutionClosure*>(
               &_NodeExecutionClosure_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(NodeExecutionClosure& a, NodeExecutionClosure& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeExecutionClosure* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeExecutionClosure* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeExecutionClosure* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodeExecutionClosure>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeExecutionClosure* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.admin.NodeExecutionClosure";
  }
  protected:
  explicit NodeExecutionClosure(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartedAtFieldNumber = 4,
    kDurationFieldNumber = 5,
    kCreatedAtFieldNumber = 6,
    kUpdatedAtFieldNumber = 7,
    kPhaseFieldNumber = 3,
    kOutputUriFieldNumber = 1,
    kErrorFieldNumber = 2,
    kOutputDataFieldNumber = 10,
    kWorkflowNodeMetadataFieldNumber = 8,
    kTaskNodeMetadataFieldNumber = 9,
  };
  // .google.protobuf.Timestamp started_at = 4 [json_name = "startedAt"];
  bool has_started_at() const;
  private:
  bool _internal_has_started_at() const;
  public:
  void clear_started_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& started_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_started_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_started_at();
  void set_allocated_started_at(::PROTOBUF_NAMESPACE_ID::Timestamp* started_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_started_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_started_at();
  public:
  void unsafe_arena_set_allocated_started_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* started_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_started_at();

  // .google.protobuf.Duration duration = 5 [json_name = "duration"];
  bool has_duration() const;
  private:
  bool _internal_has_duration() const;
  public:
  void clear_duration();
  const ::PROTOBUF_NAMESPACE_ID::Duration& duration() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_duration();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_duration();
  void set_allocated_duration(::PROTOBUF_NAMESPACE_ID::Duration* duration);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_duration() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_duration();
  public:
  void unsafe_arena_set_allocated_duration(
      ::PROTOBUF_NAMESPACE_ID::Duration* duration);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_duration();

  // .google.protobuf.Timestamp created_at = 6 [json_name = "createdAt"];
  bool has_created_at() const;
  private:
  bool _internal_has_created_at() const;
  public:
  void clear_created_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_at();
  void set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_at();
  public:
  void unsafe_arena_set_allocated_created_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_at();

  // .google.protobuf.Timestamp updated_at = 7 [json_name = "updatedAt"];
  bool has_updated_at() const;
  private:
  bool _internal_has_updated_at() const;
  public:
  void clear_updated_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& updated_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_updated_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_updated_at();
  void set_allocated_updated_at(::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_updated_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_updated_at();
  public:
  void unsafe_arena_set_allocated_updated_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_updated_at();

  // .flyteidl.core.NodeExecution.Phase phase = 3 [json_name = "phase"];
  void clear_phase();
  ::flyteidl::core::NodeExecution_Phase phase() const;
  void set_phase(::flyteidl::core::NodeExecution_Phase value);
  private:
  ::flyteidl::core::NodeExecution_Phase _internal_phase() const;
  void _internal_set_phase(::flyteidl::core::NodeExecution_Phase value);
  public:

  // string output_uri = 1 [json_name = "outputUri", deprecated = true];
  PROTOBUF_DEPRECATED bool has_output_uri() const;
  private:
  bool _internal_has_output_uri() const;
  public:
  PROTOBUF_DEPRECATED void clear_output_uri();
  PROTOBUF_DEPRECATED const std::string& output_uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_output_uri(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_output_uri();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_output_uri();
  PROTOBUF_DEPRECATED void set_allocated_output_uri(std::string* output_uri);
  private:
  const std::string& _internal_output_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_output_uri(const std::string& value);
  std::string* _internal_mutable_output_uri();
  public:

  // .flyteidl.core.ExecutionError error = 2 [json_name = "error"];
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::flyteidl::core::ExecutionError& error() const;
  PROTOBUF_NODISCARD ::flyteidl::core::ExecutionError* release_error();
  ::flyteidl::core::ExecutionError* mutable_error();
  void set_allocated_error(::flyteidl::core::ExecutionError* error);
  private:
  const ::flyteidl::core::ExecutionError& _internal_error() const;
  ::flyteidl::core::ExecutionError* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::flyteidl::core::ExecutionError* error);
  ::flyteidl::core::ExecutionError* unsafe_arena_release_error();

  // .flyteidl.core.LiteralMap output_data = 10 [json_name = "outputData", deprecated = true];
  PROTOBUF_DEPRECATED bool has_output_data() const;
  private:
  bool _internal_has_output_data() const;
  public:
  PROTOBUF_DEPRECATED void clear_output_data();
  PROTOBUF_DEPRECATED const ::flyteidl::core::LiteralMap& output_data() const;
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED ::flyteidl::core::LiteralMap* release_output_data();
  PROTOBUF_DEPRECATED ::flyteidl::core::LiteralMap* mutable_output_data();
  PROTOBUF_DEPRECATED void set_allocated_output_data(::flyteidl::core::LiteralMap* output_data);
  private:
  const ::flyteidl::core::LiteralMap& _internal_output_data() const;
  ::flyteidl::core::LiteralMap* _internal_mutable_output_data();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_output_data(
      ::flyteidl::core::LiteralMap* output_data);
  PROTOBUF_DEPRECATED ::flyteidl::core::LiteralMap* unsafe_arena_release_output_data();

  // .flyteidl.admin.WorkflowNodeMetadata workflow_node_metadata = 8 [json_name = "workflowNodeMetadata"];
  bool has_workflow_node_metadata() const;
  private:
  bool _internal_has_workflow_node_metadata() const;
  public:
  void clear_workflow_node_metadata();
  const ::flyteidl::admin::WorkflowNodeMetadata& workflow_node_metadata() const;
  PROTOBUF_NODISCARD ::flyteidl::admin::WorkflowNodeMetadata* release_workflow_node_metadata();
  ::flyteidl::admin::WorkflowNodeMetadata* mutable_workflow_node_metadata();
  void set_allocated_workflow_node_metadata(::flyteidl::admin::WorkflowNodeMetadata* workflow_node_metadata);
  private:
  const ::flyteidl::admin::WorkflowNodeMetadata& _internal_workflow_node_metadata() const;
  ::flyteidl::admin::WorkflowNodeMetadata* _internal_mutable_workflow_node_metadata();
  public:
  void unsafe_arena_set_allocated_workflow_node_metadata(
      ::flyteidl::admin::WorkflowNodeMetadata* workflow_node_metadata);
  ::flyteidl::admin::WorkflowNodeMetadata* unsafe_arena_release_workflow_node_metadata();

  // .flyteidl.admin.TaskNodeMetadata task_node_metadata = 9 [json_name = "taskNodeMetadata"];
  bool has_task_node_metadata() const;
  private:
  bool _internal_has_task_node_metadata() const;
  public:
  void clear_task_node_metadata();
  const ::flyteidl::admin::TaskNodeMetadata& task_node_metadata() const;
  PROTOBUF_NODISCARD ::flyteidl::admin::TaskNodeMetadata* release_task_node_metadata();
  ::flyteidl::admin::TaskNodeMetadata* mutable_task_node_metadata();
  void set_allocated_task_node_metadata(::flyteidl::admin::TaskNodeMetadata* task_node_metadata);
  private:
  const ::flyteidl::admin::TaskNodeMetadata& _internal_task_node_metadata() const;
  ::flyteidl::admin::TaskNodeMetadata* _internal_mutable_task_node_metadata();
  public:
  void unsafe_arena_set_allocated_task_node_metadata(
      ::flyteidl::admin::TaskNodeMetadata* task_node_metadata);
  ::flyteidl::admin::TaskNodeMetadata* unsafe_arena_release_task_node_metadata();

  void clear_output_result();
  OutputResultCase output_result_case() const;
  void clear_target_metadata();
  TargetMetadataCase target_metadata_case() const;
  // @@protoc_insertion_point(class_scope:flyteidl.admin.NodeExecutionClosure)
 private:
  class _Internal;
  void set_has_output_uri();
  void set_has_error();
  void set_has_output_data();
  void set_has_workflow_node_metadata();
  void set_has_task_node_metadata();

  inline bool has_output_result() const;
  inline void clear_has_output_result();

  inline bool has_target_metadata() const;
  inline void clear_has_target_metadata();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* started_at_;
  ::PROTOBUF_NAMESPACE_ID::Duration* duration_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at_;
  int phase_;
  union OutputResultUnion {
    constexpr OutputResultUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr output_uri_;
    ::flyteidl::core::ExecutionError* error_;
    ::flyteidl::core::LiteralMap* output_data_;
  } output_result_;
  union TargetMetadataUnion {
    constexpr TargetMetadataUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::flyteidl::admin::WorkflowNodeMetadata* workflow_node_metadata_;
    ::flyteidl::admin::TaskNodeMetadata* task_node_metadata_;
  } target_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[2];

  friend struct ::TableStruct_flyteidl_2fadmin_2fnode_5fexecution_2eproto;
};
// -------------------------------------------------------------------

class WorkflowNodeMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.admin.WorkflowNodeMetadata) */ {
 public:
  inline WorkflowNodeMetadata() : WorkflowNodeMetadata(nullptr) {}
  ~WorkflowNodeMetadata() override;
  explicit constexpr WorkflowNodeMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WorkflowNodeMetadata(const WorkflowNodeMetadata& from);
  WorkflowNodeMetadata(WorkflowNodeMetadata&& from) noexcept
    : WorkflowNodeMetadata() {
    *this = ::std::move(from);
  }

  inline WorkflowNodeMetadata& operator=(const WorkflowNodeMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkflowNodeMetadata& operator=(WorkflowNodeMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkflowNodeMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorkflowNodeMetadata* internal_default_instance() {
    return reinterpret_cast<const WorkflowNodeMetadata*>(
               &_WorkflowNodeMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(WorkflowNodeMetadata& a, WorkflowNodeMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkflowNodeMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkflowNodeMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorkflowNodeMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WorkflowNodeMetadata>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkflowNodeMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.admin.WorkflowNodeMetadata";
  }
  protected:
  explicit WorkflowNodeMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExecutionIdFieldNumber = 1,
  };
  // .flyteidl.core.WorkflowExecutionIdentifier executionId = 1 [json_name = "executionId"];
  bool has_executionid() const;
  private:
  bool _internal_has_executionid() const;
  public:
  void clear_executionid();
  const ::flyteidl::core::WorkflowExecutionIdentifier& executionid() const;
  PROTOBUF_NODISCARD ::flyteidl::core::WorkflowExecutionIdentifier* release_executionid();
  ::flyteidl::core::WorkflowExecutionIdentifier* mutable_executionid();
  void set_allocated_executionid(::flyteidl::core::WorkflowExecutionIdentifier* executionid);
  private:
  const ::flyteidl::core::WorkflowExecutionIdentifier& _internal_executionid() const;
  ::flyteidl::core::WorkflowExecutionIdentifier* _internal_mutable_executionid();
  public:
  void unsafe_arena_set_allocated_executionid(
      ::flyteidl::core::WorkflowExecutionIdentifier* executionid);
  ::flyteidl::core::WorkflowExecutionIdentifier* unsafe_arena_release_executionid();

  // @@protoc_insertion_point(class_scope:flyteidl.admin.WorkflowNodeMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::flyteidl::core::WorkflowExecutionIdentifier* executionid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fadmin_2fnode_5fexecution_2eproto;
};
// -------------------------------------------------------------------

class TaskNodeMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.admin.TaskNodeMetadata) */ {
 public:
  inline TaskNodeMetadata() : TaskNodeMetadata(nullptr) {}
  ~TaskNodeMetadata() override;
  explicit constexpr TaskNodeMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TaskNodeMetadata(const TaskNodeMetadata& from);
  TaskNodeMetadata(TaskNodeMetadata&& from) noexcept
    : TaskNodeMetadata() {
    *this = ::std::move(from);
  }

  inline TaskNodeMetadata& operator=(const TaskNodeMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskNodeMetadata& operator=(TaskNodeMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskNodeMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskNodeMetadata* internal_default_instance() {
    return reinterpret_cast<const TaskNodeMetadata*>(
               &_TaskNodeMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(TaskNodeMetadata& a, TaskNodeMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskNodeMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskNodeMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TaskNodeMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TaskNodeMetadata>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskNodeMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.admin.TaskNodeMetadata";
  }
  protected:
  explicit TaskNodeMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCatalogKeyFieldNumber = 2,
    kCacheStatusFieldNumber = 1,
  };
  // .flyteidl.core.CatalogMetadata catalog_key = 2 [json_name = "catalogKey"];
  bool has_catalog_key() const;
  private:
  bool _internal_has_catalog_key() const;
  public:
  void clear_catalog_key();
  const ::flyteidl::core::CatalogMetadata& catalog_key() const;
  PROTOBUF_NODISCARD ::flyteidl::core::CatalogMetadata* release_catalog_key();
  ::flyteidl::core::CatalogMetadata* mutable_catalog_key();
  void set_allocated_catalog_key(::flyteidl::core::CatalogMetadata* catalog_key);
  private:
  const ::flyteidl::core::CatalogMetadata& _internal_catalog_key() const;
  ::flyteidl::core::CatalogMetadata* _internal_mutable_catalog_key();
  public:
  void unsafe_arena_set_allocated_catalog_key(
      ::flyteidl::core::CatalogMetadata* catalog_key);
  ::flyteidl::core::CatalogMetadata* unsafe_arena_release_catalog_key();

  // .flyteidl.core.CatalogCacheStatus cache_status = 1 [json_name = "cacheStatus"];
  void clear_cache_status();
  ::flyteidl::core::CatalogCacheStatus cache_status() const;
  void set_cache_status(::flyteidl::core::CatalogCacheStatus value);
  private:
  ::flyteidl::core::CatalogCacheStatus _internal_cache_status() const;
  void _internal_set_cache_status(::flyteidl::core::CatalogCacheStatus value);
  public:

  // @@protoc_insertion_point(class_scope:flyteidl.admin.TaskNodeMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::flyteidl::core::CatalogMetadata* catalog_key_;
  int cache_status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fadmin_2fnode_5fexecution_2eproto;
};
// -------------------------------------------------------------------

class DynamicWorkflowNodeMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.admin.DynamicWorkflowNodeMetadata) */ {
 public:
  inline DynamicWorkflowNodeMetadata() : DynamicWorkflowNodeMetadata(nullptr) {}
  ~DynamicWorkflowNodeMetadata() override;
  explicit constexpr DynamicWorkflowNodeMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DynamicWorkflowNodeMetadata(const DynamicWorkflowNodeMetadata& from);
  DynamicWorkflowNodeMetadata(DynamicWorkflowNodeMetadata&& from) noexcept
    : DynamicWorkflowNodeMetadata() {
    *this = ::std::move(from);
  }

  inline DynamicWorkflowNodeMetadata& operator=(const DynamicWorkflowNodeMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline DynamicWorkflowNodeMetadata& operator=(DynamicWorkflowNodeMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DynamicWorkflowNodeMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const DynamicWorkflowNodeMetadata* internal_default_instance() {
    return reinterpret_cast<const DynamicWorkflowNodeMetadata*>(
               &_DynamicWorkflowNodeMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(DynamicWorkflowNodeMetadata& a, DynamicWorkflowNodeMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(DynamicWorkflowNodeMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DynamicWorkflowNodeMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DynamicWorkflowNodeMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DynamicWorkflowNodeMetadata>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DynamicWorkflowNodeMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.admin.DynamicWorkflowNodeMetadata";
  }
  protected:
  explicit DynamicWorkflowNodeMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kCompiledWorkflowFieldNumber = 2,
  };
  // .flyteidl.core.Identifier id = 1 [json_name = "id"];
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::flyteidl::core::Identifier& id() const;
  PROTOBUF_NODISCARD ::flyteidl::core::Identifier* release_id();
  ::flyteidl::core::Identifier* mutable_id();
  void set_allocated_id(::flyteidl::core::Identifier* id);
  private:
  const ::flyteidl::core::Identifier& _internal_id() const;
  ::flyteidl::core::Identifier* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::flyteidl::core::Identifier* id);
  ::flyteidl::core::Identifier* unsafe_arena_release_id();

  // .flyteidl.core.CompiledWorkflowClosure compiled_workflow = 2 [json_name = "compiledWorkflow"];
  bool has_compiled_workflow() const;
  private:
  bool _internal_has_compiled_workflow() const;
  public:
  void clear_compiled_workflow();
  const ::flyteidl::core::CompiledWorkflowClosure& compiled_workflow() const;
  PROTOBUF_NODISCARD ::flyteidl::core::CompiledWorkflowClosure* release_compiled_workflow();
  ::flyteidl::core::CompiledWorkflowClosure* mutable_compiled_workflow();
  void set_allocated_compiled_workflow(::flyteidl::core::CompiledWorkflowClosure* compiled_workflow);
  private:
  const ::flyteidl::core::CompiledWorkflowClosure& _internal_compiled_workflow() const;
  ::flyteidl::core::CompiledWorkflowClosure* _internal_mutable_compiled_workflow();
  public:
  void unsafe_arena_set_allocated_compiled_workflow(
      ::flyteidl::core::CompiledWorkflowClosure* compiled_workflow);
  ::flyteidl::core::CompiledWorkflowClosure* unsafe_arena_release_compiled_workflow();

  // @@protoc_insertion_point(class_scope:flyteidl.admin.DynamicWorkflowNodeMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::flyteidl::core::Identifier* id_;
  ::flyteidl::core::CompiledWorkflowClosure* compiled_workflow_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fadmin_2fnode_5fexecution_2eproto;
};
// -------------------------------------------------------------------

class NodeExecutionGetDataRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.admin.NodeExecutionGetDataRequest) */ {
 public:
  inline NodeExecutionGetDataRequest() : NodeExecutionGetDataRequest(nullptr) {}
  ~NodeExecutionGetDataRequest() override;
  explicit constexpr NodeExecutionGetDataRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NodeExecutionGetDataRequest(const NodeExecutionGetDataRequest& from);
  NodeExecutionGetDataRequest(NodeExecutionGetDataRequest&& from) noexcept
    : NodeExecutionGetDataRequest() {
    *this = ::std::move(from);
  }

  inline NodeExecutionGetDataRequest& operator=(const NodeExecutionGetDataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeExecutionGetDataRequest& operator=(NodeExecutionGetDataRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeExecutionGetDataRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeExecutionGetDataRequest* internal_default_instance() {
    return reinterpret_cast<const NodeExecutionGetDataRequest*>(
               &_NodeExecutionGetDataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(NodeExecutionGetDataRequest& a, NodeExecutionGetDataRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeExecutionGetDataRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeExecutionGetDataRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeExecutionGetDataRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodeExecutionGetDataRequest>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeExecutionGetDataRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.admin.NodeExecutionGetDataRequest";
  }
  protected:
  explicit NodeExecutionGetDataRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // .flyteidl.core.NodeExecutionIdentifier id = 1 [json_name = "id"];
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::flyteidl::core::NodeExecutionIdentifier& id() const;
  PROTOBUF_NODISCARD ::flyteidl::core::NodeExecutionIdentifier* release_id();
  ::flyteidl::core::NodeExecutionIdentifier* mutable_id();
  void set_allocated_id(::flyteidl::core::NodeExecutionIdentifier* id);
  private:
  const ::flyteidl::core::NodeExecutionIdentifier& _internal_id() const;
  ::flyteidl::core::NodeExecutionIdentifier* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::flyteidl::core::NodeExecutionIdentifier* id);
  ::flyteidl::core::NodeExecutionIdentifier* unsafe_arena_release_id();

  // @@protoc_insertion_point(class_scope:flyteidl.admin.NodeExecutionGetDataRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::flyteidl::core::NodeExecutionIdentifier* id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fadmin_2fnode_5fexecution_2eproto;
};
// -------------------------------------------------------------------

class NodeExecutionGetDataResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.admin.NodeExecutionGetDataResponse) */ {
 public:
  inline NodeExecutionGetDataResponse() : NodeExecutionGetDataResponse(nullptr) {}
  ~NodeExecutionGetDataResponse() override;
  explicit constexpr NodeExecutionGetDataResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NodeExecutionGetDataResponse(const NodeExecutionGetDataResponse& from);
  NodeExecutionGetDataResponse(NodeExecutionGetDataResponse&& from) noexcept
    : NodeExecutionGetDataResponse() {
    *this = ::std::move(from);
  }

  inline NodeExecutionGetDataResponse& operator=(const NodeExecutionGetDataResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeExecutionGetDataResponse& operator=(NodeExecutionGetDataResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeExecutionGetDataResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeExecutionGetDataResponse* internal_default_instance() {
    return reinterpret_cast<const NodeExecutionGetDataResponse*>(
               &_NodeExecutionGetDataResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(NodeExecutionGetDataResponse& a, NodeExecutionGetDataResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeExecutionGetDataResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeExecutionGetDataResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeExecutionGetDataResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodeExecutionGetDataResponse>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeExecutionGetDataResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.admin.NodeExecutionGetDataResponse";
  }
  protected:
  explicit NodeExecutionGetDataResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInputsFieldNumber = 1,
    kOutputsFieldNumber = 2,
    kFullInputsFieldNumber = 3,
    kFullOutputsFieldNumber = 4,
    kDynamicWorkflowFieldNumber = 16,
  };
  // .flyteidl.admin.UrlBlob inputs = 1 [json_name = "inputs", deprecated = true];
  PROTOBUF_DEPRECATED bool has_inputs() const;
  private:
  bool _internal_has_inputs() const;
  public:
  PROTOBUF_DEPRECATED void clear_inputs();
  PROTOBUF_DEPRECATED const ::flyteidl::admin::UrlBlob& inputs() const;
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED ::flyteidl::admin::UrlBlob* release_inputs();
  PROTOBUF_DEPRECATED ::flyteidl::admin::UrlBlob* mutable_inputs();
  PROTOBUF_DEPRECATED void set_allocated_inputs(::flyteidl::admin::UrlBlob* inputs);
  private:
  const ::flyteidl::admin::UrlBlob& _internal_inputs() const;
  ::flyteidl::admin::UrlBlob* _internal_mutable_inputs();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_inputs(
      ::flyteidl::admin::UrlBlob* inputs);
  PROTOBUF_DEPRECATED ::flyteidl::admin::UrlBlob* unsafe_arena_release_inputs();

  // .flyteidl.admin.UrlBlob outputs = 2 [json_name = "outputs", deprecated = true];
  PROTOBUF_DEPRECATED bool has_outputs() const;
  private:
  bool _internal_has_outputs() const;
  public:
  PROTOBUF_DEPRECATED void clear_outputs();
  PROTOBUF_DEPRECATED const ::flyteidl::admin::UrlBlob& outputs() const;
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED ::flyteidl::admin::UrlBlob* release_outputs();
  PROTOBUF_DEPRECATED ::flyteidl::admin::UrlBlob* mutable_outputs();
  PROTOBUF_DEPRECATED void set_allocated_outputs(::flyteidl::admin::UrlBlob* outputs);
  private:
  const ::flyteidl::admin::UrlBlob& _internal_outputs() const;
  ::flyteidl::admin::UrlBlob* _internal_mutable_outputs();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_outputs(
      ::flyteidl::admin::UrlBlob* outputs);
  PROTOBUF_DEPRECATED ::flyteidl::admin::UrlBlob* unsafe_arena_release_outputs();

  // .flyteidl.core.LiteralMap full_inputs = 3 [json_name = "fullInputs"];
  bool has_full_inputs() const;
  private:
  bool _internal_has_full_inputs() const;
  public:
  void clear_full_inputs();
  const ::flyteidl::core::LiteralMap& full_inputs() const;
  PROTOBUF_NODISCARD ::flyteidl::core::LiteralMap* release_full_inputs();
  ::flyteidl::core::LiteralMap* mutable_full_inputs();
  void set_allocated_full_inputs(::flyteidl::core::LiteralMap* full_inputs);
  private:
  const ::flyteidl::core::LiteralMap& _internal_full_inputs() const;
  ::flyteidl::core::LiteralMap* _internal_mutable_full_inputs();
  public:
  void unsafe_arena_set_allocated_full_inputs(
      ::flyteidl::core::LiteralMap* full_inputs);
  ::flyteidl::core::LiteralMap* unsafe_arena_release_full_inputs();

  // .flyteidl.core.LiteralMap full_outputs = 4 [json_name = "fullOutputs"];
  bool has_full_outputs() const;
  private:
  bool _internal_has_full_outputs() const;
  public:
  void clear_full_outputs();
  const ::flyteidl::core::LiteralMap& full_outputs() const;
  PROTOBUF_NODISCARD ::flyteidl::core::LiteralMap* release_full_outputs();
  ::flyteidl::core::LiteralMap* mutable_full_outputs();
  void set_allocated_full_outputs(::flyteidl::core::LiteralMap* full_outputs);
  private:
  const ::flyteidl::core::LiteralMap& _internal_full_outputs() const;
  ::flyteidl::core::LiteralMap* _internal_mutable_full_outputs();
  public:
  void unsafe_arena_set_allocated_full_outputs(
      ::flyteidl::core::LiteralMap* full_outputs);
  ::flyteidl::core::LiteralMap* unsafe_arena_release_full_outputs();

  // .flyteidl.admin.DynamicWorkflowNodeMetadata dynamic_workflow = 16 [json_name = "dynamicWorkflow"];
  bool has_dynamic_workflow() const;
  private:
  bool _internal_has_dynamic_workflow() const;
  public:
  void clear_dynamic_workflow();
  const ::flyteidl::admin::DynamicWorkflowNodeMetadata& dynamic_workflow() const;
  PROTOBUF_NODISCARD ::flyteidl::admin::DynamicWorkflowNodeMetadata* release_dynamic_workflow();
  ::flyteidl::admin::DynamicWorkflowNodeMetadata* mutable_dynamic_workflow();
  void set_allocated_dynamic_workflow(::flyteidl::admin::DynamicWorkflowNodeMetadata* dynamic_workflow);
  private:
  const ::flyteidl::admin::DynamicWorkflowNodeMetadata& _internal_dynamic_workflow() const;
  ::flyteidl::admin::DynamicWorkflowNodeMetadata* _internal_mutable_dynamic_workflow();
  public:
  void unsafe_arena_set_allocated_dynamic_workflow(
      ::flyteidl::admin::DynamicWorkflowNodeMetadata* dynamic_workflow);
  ::flyteidl::admin::DynamicWorkflowNodeMetadata* unsafe_arena_release_dynamic_workflow();

  // @@protoc_insertion_point(class_scope:flyteidl.admin.NodeExecutionGetDataResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::flyteidl::admin::UrlBlob* inputs_;
  ::flyteidl::admin::UrlBlob* outputs_;
  ::flyteidl::core::LiteralMap* full_inputs_;
  ::flyteidl::core::LiteralMap* full_outputs_;
  ::flyteidl::admin::DynamicWorkflowNodeMetadata* dynamic_workflow_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fadmin_2fnode_5fexecution_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// NodeExecutionGetRequest

// .flyteidl.core.NodeExecutionIdentifier id = 1 [json_name = "id"];
inline bool NodeExecutionGetRequest::_internal_has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline bool NodeExecutionGetRequest::has_id() const {
  return _internal_has_id();
}
inline const ::flyteidl::core::NodeExecutionIdentifier& NodeExecutionGetRequest::_internal_id() const {
  const ::flyteidl::core::NodeExecutionIdentifier* p = id_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::core::NodeExecutionIdentifier&>(
      ::flyteidl::core::_NodeExecutionIdentifier_default_instance_);
}
inline const ::flyteidl::core::NodeExecutionIdentifier& NodeExecutionGetRequest::id() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NodeExecutionGetRequest.id)
  return _internal_id();
}
inline void NodeExecutionGetRequest::unsafe_arena_set_allocated_id(
    ::flyteidl::core::NodeExecutionIdentifier* id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.NodeExecutionGetRequest.id)
}
inline ::flyteidl::core::NodeExecutionIdentifier* NodeExecutionGetRequest::release_id() {
  
  ::flyteidl::core::NodeExecutionIdentifier* temp = id_;
  id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::core::NodeExecutionIdentifier* NodeExecutionGetRequest::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.NodeExecutionGetRequest.id)
  
  ::flyteidl::core::NodeExecutionIdentifier* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::flyteidl::core::NodeExecutionIdentifier* NodeExecutionGetRequest::_internal_mutable_id() {
  
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::NodeExecutionIdentifier>(GetArenaForAllocation());
    id_ = p;
  }
  return id_;
}
inline ::flyteidl::core::NodeExecutionIdentifier* NodeExecutionGetRequest::mutable_id() {
  ::flyteidl::core::NodeExecutionIdentifier* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.NodeExecutionGetRequest.id)
  return _msg;
}
inline void NodeExecutionGetRequest::set_allocated_id(::flyteidl::core::NodeExecutionIdentifier* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id));
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.NodeExecutionGetRequest.id)
}

// -------------------------------------------------------------------

// NodeExecutionListRequest

// .flyteidl.core.WorkflowExecutionIdentifier workflow_execution_id = 1 [json_name = "workflowExecutionId"];
inline bool NodeExecutionListRequest::_internal_has_workflow_execution_id() const {
  return this != internal_default_instance() && workflow_execution_id_ != nullptr;
}
inline bool NodeExecutionListRequest::has_workflow_execution_id() const {
  return _internal_has_workflow_execution_id();
}
inline const ::flyteidl::core::WorkflowExecutionIdentifier& NodeExecutionListRequest::_internal_workflow_execution_id() const {
  const ::flyteidl::core::WorkflowExecutionIdentifier* p = workflow_execution_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::core::WorkflowExecutionIdentifier&>(
      ::flyteidl::core::_WorkflowExecutionIdentifier_default_instance_);
}
inline const ::flyteidl::core::WorkflowExecutionIdentifier& NodeExecutionListRequest::workflow_execution_id() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NodeExecutionListRequest.workflow_execution_id)
  return _internal_workflow_execution_id();
}
inline void NodeExecutionListRequest::unsafe_arena_set_allocated_workflow_execution_id(
    ::flyteidl::core::WorkflowExecutionIdentifier* workflow_execution_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(workflow_execution_id_);
  }
  workflow_execution_id_ = workflow_execution_id;
  if (workflow_execution_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.NodeExecutionListRequest.workflow_execution_id)
}
inline ::flyteidl::core::WorkflowExecutionIdentifier* NodeExecutionListRequest::release_workflow_execution_id() {
  
  ::flyteidl::core::WorkflowExecutionIdentifier* temp = workflow_execution_id_;
  workflow_execution_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::core::WorkflowExecutionIdentifier* NodeExecutionListRequest::unsafe_arena_release_workflow_execution_id() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.NodeExecutionListRequest.workflow_execution_id)
  
  ::flyteidl::core::WorkflowExecutionIdentifier* temp = workflow_execution_id_;
  workflow_execution_id_ = nullptr;
  return temp;
}
inline ::flyteidl::core::WorkflowExecutionIdentifier* NodeExecutionListRequest::_internal_mutable_workflow_execution_id() {
  
  if (workflow_execution_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::WorkflowExecutionIdentifier>(GetArenaForAllocation());
    workflow_execution_id_ = p;
  }
  return workflow_execution_id_;
}
inline ::flyteidl::core::WorkflowExecutionIdentifier* NodeExecutionListRequest::mutable_workflow_execution_id() {
  ::flyteidl::core::WorkflowExecutionIdentifier* _msg = _internal_mutable_workflow_execution_id();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.NodeExecutionListRequest.workflow_execution_id)
  return _msg;
}
inline void NodeExecutionListRequest::set_allocated_workflow_execution_id(::flyteidl::core::WorkflowExecutionIdentifier* workflow_execution_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(workflow_execution_id_);
  }
  if (workflow_execution_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(workflow_execution_id));
    if (message_arena != submessage_arena) {
      workflow_execution_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, workflow_execution_id, submessage_arena);
    }
    
  } else {
    
  }
  workflow_execution_id_ = workflow_execution_id;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.NodeExecutionListRequest.workflow_execution_id)
}

// uint32 limit = 2 [json_name = "limit"];
inline void NodeExecutionListRequest::clear_limit() {
  limit_ = 0u;
}
inline uint32_t NodeExecutionListRequest::_internal_limit() const {
  return limit_;
}
inline uint32_t NodeExecutionListRequest::limit() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NodeExecutionListRequest.limit)
  return _internal_limit();
}
inline void NodeExecutionListRequest::_internal_set_limit(uint32_t value) {
  
  limit_ = value;
}
inline void NodeExecutionListRequest::set_limit(uint32_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:flyteidl.admin.NodeExecutionListRequest.limit)
}

// string token = 3 [json_name = "token"];
inline void NodeExecutionListRequest::clear_token() {
  token_.ClearToEmpty();
}
inline const std::string& NodeExecutionListRequest::token() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NodeExecutionListRequest.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeExecutionListRequest::set_token(ArgT0&& arg0, ArgT... args) {
 
 token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.admin.NodeExecutionListRequest.token)
}
inline std::string* NodeExecutionListRequest::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.NodeExecutionListRequest.token)
  return _s;
}
inline const std::string& NodeExecutionListRequest::_internal_token() const {
  return token_.Get();
}
inline void NodeExecutionListRequest::_internal_set_token(const std::string& value) {
  
  token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NodeExecutionListRequest::_internal_mutable_token() {
  
  return token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NodeExecutionListRequest::release_token() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.NodeExecutionListRequest.token)
  return token_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NodeExecutionListRequest::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.NodeExecutionListRequest.token)
}

// string filters = 4 [json_name = "filters"];
inline void NodeExecutionListRequest::clear_filters() {
  filters_.ClearToEmpty();
}
inline const std::string& NodeExecutionListRequest::filters() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NodeExecutionListRequest.filters)
  return _internal_filters();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeExecutionListRequest::set_filters(ArgT0&& arg0, ArgT... args) {
 
 filters_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.admin.NodeExecutionListRequest.filters)
}
inline std::string* NodeExecutionListRequest::mutable_filters() {
  std::string* _s = _internal_mutable_filters();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.NodeExecutionListRequest.filters)
  return _s;
}
inline const std::string& NodeExecutionListRequest::_internal_filters() const {
  return filters_.Get();
}
inline void NodeExecutionListRequest::_internal_set_filters(const std::string& value) {
  
  filters_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NodeExecutionListRequest::_internal_mutable_filters() {
  
  return filters_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NodeExecutionListRequest::release_filters() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.NodeExecutionListRequest.filters)
  return filters_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NodeExecutionListRequest::set_allocated_filters(std::string* filters) {
  if (filters != nullptr) {
    
  } else {
    
  }
  filters_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), filters,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (filters_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    filters_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.NodeExecutionListRequest.filters)
}

// .flyteidl.admin.Sort sort_by = 5 [json_name = "sortBy"];
inline bool NodeExecutionListRequest::_internal_has_sort_by() const {
  return this != internal_default_instance() && sort_by_ != nullptr;
}
inline bool NodeExecutionListRequest::has_sort_by() const {
  return _internal_has_sort_by();
}
inline const ::flyteidl::admin::Sort& NodeExecutionListRequest::_internal_sort_by() const {
  const ::flyteidl::admin::Sort* p = sort_by_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::admin::Sort&>(
      ::flyteidl::admin::_Sort_default_instance_);
}
inline const ::flyteidl::admin::Sort& NodeExecutionListRequest::sort_by() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NodeExecutionListRequest.sort_by)
  return _internal_sort_by();
}
inline void NodeExecutionListRequest::unsafe_arena_set_allocated_sort_by(
    ::flyteidl::admin::Sort* sort_by) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sort_by_);
  }
  sort_by_ = sort_by;
  if (sort_by) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.NodeExecutionListRequest.sort_by)
}
inline ::flyteidl::admin::Sort* NodeExecutionListRequest::release_sort_by() {
  
  ::flyteidl::admin::Sort* temp = sort_by_;
  sort_by_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::admin::Sort* NodeExecutionListRequest::unsafe_arena_release_sort_by() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.NodeExecutionListRequest.sort_by)
  
  ::flyteidl::admin::Sort* temp = sort_by_;
  sort_by_ = nullptr;
  return temp;
}
inline ::flyteidl::admin::Sort* NodeExecutionListRequest::_internal_mutable_sort_by() {
  
  if (sort_by_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::admin::Sort>(GetArenaForAllocation());
    sort_by_ = p;
  }
  return sort_by_;
}
inline ::flyteidl::admin::Sort* NodeExecutionListRequest::mutable_sort_by() {
  ::flyteidl::admin::Sort* _msg = _internal_mutable_sort_by();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.NodeExecutionListRequest.sort_by)
  return _msg;
}
inline void NodeExecutionListRequest::set_allocated_sort_by(::flyteidl::admin::Sort* sort_by) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(sort_by_);
  }
  if (sort_by) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sort_by));
    if (message_arena != submessage_arena) {
      sort_by = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sort_by, submessage_arena);
    }
    
  } else {
    
  }
  sort_by_ = sort_by;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.NodeExecutionListRequest.sort_by)
}

// string unique_parent_id = 6 [json_name = "uniqueParentId"];
inline void NodeExecutionListRequest::clear_unique_parent_id() {
  unique_parent_id_.ClearToEmpty();
}
inline const std::string& NodeExecutionListRequest::unique_parent_id() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NodeExecutionListRequest.unique_parent_id)
  return _internal_unique_parent_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeExecutionListRequest::set_unique_parent_id(ArgT0&& arg0, ArgT... args) {
 
 unique_parent_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.admin.NodeExecutionListRequest.unique_parent_id)
}
inline std::string* NodeExecutionListRequest::mutable_unique_parent_id() {
  std::string* _s = _internal_mutable_unique_parent_id();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.NodeExecutionListRequest.unique_parent_id)
  return _s;
}
inline const std::string& NodeExecutionListRequest::_internal_unique_parent_id() const {
  return unique_parent_id_.Get();
}
inline void NodeExecutionListRequest::_internal_set_unique_parent_id(const std::string& value) {
  
  unique_parent_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NodeExecutionListRequest::_internal_mutable_unique_parent_id() {
  
  return unique_parent_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NodeExecutionListRequest::release_unique_parent_id() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.NodeExecutionListRequest.unique_parent_id)
  return unique_parent_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NodeExecutionListRequest::set_allocated_unique_parent_id(std::string* unique_parent_id) {
  if (unique_parent_id != nullptr) {
    
  } else {
    
  }
  unique_parent_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), unique_parent_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (unique_parent_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    unique_parent_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.NodeExecutionListRequest.unique_parent_id)
}

// -------------------------------------------------------------------

// NodeExecutionForTaskListRequest

// .flyteidl.core.TaskExecutionIdentifier task_execution_id = 1 [json_name = "taskExecutionId"];
inline bool NodeExecutionForTaskListRequest::_internal_has_task_execution_id() const {
  return this != internal_default_instance() && task_execution_id_ != nullptr;
}
inline bool NodeExecutionForTaskListRequest::has_task_execution_id() const {
  return _internal_has_task_execution_id();
}
inline const ::flyteidl::core::TaskExecutionIdentifier& NodeExecutionForTaskListRequest::_internal_task_execution_id() const {
  const ::flyteidl::core::TaskExecutionIdentifier* p = task_execution_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::core::TaskExecutionIdentifier&>(
      ::flyteidl::core::_TaskExecutionIdentifier_default_instance_);
}
inline const ::flyteidl::core::TaskExecutionIdentifier& NodeExecutionForTaskListRequest::task_execution_id() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NodeExecutionForTaskListRequest.task_execution_id)
  return _internal_task_execution_id();
}
inline void NodeExecutionForTaskListRequest::unsafe_arena_set_allocated_task_execution_id(
    ::flyteidl::core::TaskExecutionIdentifier* task_execution_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(task_execution_id_);
  }
  task_execution_id_ = task_execution_id;
  if (task_execution_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.NodeExecutionForTaskListRequest.task_execution_id)
}
inline ::flyteidl::core::TaskExecutionIdentifier* NodeExecutionForTaskListRequest::release_task_execution_id() {
  
  ::flyteidl::core::TaskExecutionIdentifier* temp = task_execution_id_;
  task_execution_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::core::TaskExecutionIdentifier* NodeExecutionForTaskListRequest::unsafe_arena_release_task_execution_id() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.NodeExecutionForTaskListRequest.task_execution_id)
  
  ::flyteidl::core::TaskExecutionIdentifier* temp = task_execution_id_;
  task_execution_id_ = nullptr;
  return temp;
}
inline ::flyteidl::core::TaskExecutionIdentifier* NodeExecutionForTaskListRequest::_internal_mutable_task_execution_id() {
  
  if (task_execution_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::TaskExecutionIdentifier>(GetArenaForAllocation());
    task_execution_id_ = p;
  }
  return task_execution_id_;
}
inline ::flyteidl::core::TaskExecutionIdentifier* NodeExecutionForTaskListRequest::mutable_task_execution_id() {
  ::flyteidl::core::TaskExecutionIdentifier* _msg = _internal_mutable_task_execution_id();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.NodeExecutionForTaskListRequest.task_execution_id)
  return _msg;
}
inline void NodeExecutionForTaskListRequest::set_allocated_task_execution_id(::flyteidl::core::TaskExecutionIdentifier* task_execution_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(task_execution_id_);
  }
  if (task_execution_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(task_execution_id));
    if (message_arena != submessage_arena) {
      task_execution_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, task_execution_id, submessage_arena);
    }
    
  } else {
    
  }
  task_execution_id_ = task_execution_id;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.NodeExecutionForTaskListRequest.task_execution_id)
}

// uint32 limit = 2 [json_name = "limit"];
inline void NodeExecutionForTaskListRequest::clear_limit() {
  limit_ = 0u;
}
inline uint32_t NodeExecutionForTaskListRequest::_internal_limit() const {
  return limit_;
}
inline uint32_t NodeExecutionForTaskListRequest::limit() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NodeExecutionForTaskListRequest.limit)
  return _internal_limit();
}
inline void NodeExecutionForTaskListRequest::_internal_set_limit(uint32_t value) {
  
  limit_ = value;
}
inline void NodeExecutionForTaskListRequest::set_limit(uint32_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:flyteidl.admin.NodeExecutionForTaskListRequest.limit)
}

// string token = 3 [json_name = "token"];
inline void NodeExecutionForTaskListRequest::clear_token() {
  token_.ClearToEmpty();
}
inline const std::string& NodeExecutionForTaskListRequest::token() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NodeExecutionForTaskListRequest.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeExecutionForTaskListRequest::set_token(ArgT0&& arg0, ArgT... args) {
 
 token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.admin.NodeExecutionForTaskListRequest.token)
}
inline std::string* NodeExecutionForTaskListRequest::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.NodeExecutionForTaskListRequest.token)
  return _s;
}
inline const std::string& NodeExecutionForTaskListRequest::_internal_token() const {
  return token_.Get();
}
inline void NodeExecutionForTaskListRequest::_internal_set_token(const std::string& value) {
  
  token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NodeExecutionForTaskListRequest::_internal_mutable_token() {
  
  return token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NodeExecutionForTaskListRequest::release_token() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.NodeExecutionForTaskListRequest.token)
  return token_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NodeExecutionForTaskListRequest::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.NodeExecutionForTaskListRequest.token)
}

// string filters = 4 [json_name = "filters"];
inline void NodeExecutionForTaskListRequest::clear_filters() {
  filters_.ClearToEmpty();
}
inline const std::string& NodeExecutionForTaskListRequest::filters() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NodeExecutionForTaskListRequest.filters)
  return _internal_filters();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeExecutionForTaskListRequest::set_filters(ArgT0&& arg0, ArgT... args) {
 
 filters_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.admin.NodeExecutionForTaskListRequest.filters)
}
inline std::string* NodeExecutionForTaskListRequest::mutable_filters() {
  std::string* _s = _internal_mutable_filters();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.NodeExecutionForTaskListRequest.filters)
  return _s;
}
inline const std::string& NodeExecutionForTaskListRequest::_internal_filters() const {
  return filters_.Get();
}
inline void NodeExecutionForTaskListRequest::_internal_set_filters(const std::string& value) {
  
  filters_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NodeExecutionForTaskListRequest::_internal_mutable_filters() {
  
  return filters_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NodeExecutionForTaskListRequest::release_filters() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.NodeExecutionForTaskListRequest.filters)
  return filters_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NodeExecutionForTaskListRequest::set_allocated_filters(std::string* filters) {
  if (filters != nullptr) {
    
  } else {
    
  }
  filters_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), filters,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (filters_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    filters_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.NodeExecutionForTaskListRequest.filters)
}

// .flyteidl.admin.Sort sort_by = 5 [json_name = "sortBy"];
inline bool NodeExecutionForTaskListRequest::_internal_has_sort_by() const {
  return this != internal_default_instance() && sort_by_ != nullptr;
}
inline bool NodeExecutionForTaskListRequest::has_sort_by() const {
  return _internal_has_sort_by();
}
inline const ::flyteidl::admin::Sort& NodeExecutionForTaskListRequest::_internal_sort_by() const {
  const ::flyteidl::admin::Sort* p = sort_by_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::admin::Sort&>(
      ::flyteidl::admin::_Sort_default_instance_);
}
inline const ::flyteidl::admin::Sort& NodeExecutionForTaskListRequest::sort_by() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NodeExecutionForTaskListRequest.sort_by)
  return _internal_sort_by();
}
inline void NodeExecutionForTaskListRequest::unsafe_arena_set_allocated_sort_by(
    ::flyteidl::admin::Sort* sort_by) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sort_by_);
  }
  sort_by_ = sort_by;
  if (sort_by) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.NodeExecutionForTaskListRequest.sort_by)
}
inline ::flyteidl::admin::Sort* NodeExecutionForTaskListRequest::release_sort_by() {
  
  ::flyteidl::admin::Sort* temp = sort_by_;
  sort_by_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::admin::Sort* NodeExecutionForTaskListRequest::unsafe_arena_release_sort_by() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.NodeExecutionForTaskListRequest.sort_by)
  
  ::flyteidl::admin::Sort* temp = sort_by_;
  sort_by_ = nullptr;
  return temp;
}
inline ::flyteidl::admin::Sort* NodeExecutionForTaskListRequest::_internal_mutable_sort_by() {
  
  if (sort_by_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::admin::Sort>(GetArenaForAllocation());
    sort_by_ = p;
  }
  return sort_by_;
}
inline ::flyteidl::admin::Sort* NodeExecutionForTaskListRequest::mutable_sort_by() {
  ::flyteidl::admin::Sort* _msg = _internal_mutable_sort_by();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.NodeExecutionForTaskListRequest.sort_by)
  return _msg;
}
inline void NodeExecutionForTaskListRequest::set_allocated_sort_by(::flyteidl::admin::Sort* sort_by) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(sort_by_);
  }
  if (sort_by) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sort_by));
    if (message_arena != submessage_arena) {
      sort_by = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sort_by, submessage_arena);
    }
    
  } else {
    
  }
  sort_by_ = sort_by;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.NodeExecutionForTaskListRequest.sort_by)
}

// -------------------------------------------------------------------

// NodeExecution

// .flyteidl.core.NodeExecutionIdentifier id = 1 [json_name = "id"];
inline bool NodeExecution::_internal_has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline bool NodeExecution::has_id() const {
  return _internal_has_id();
}
inline const ::flyteidl::core::NodeExecutionIdentifier& NodeExecution::_internal_id() const {
  const ::flyteidl::core::NodeExecutionIdentifier* p = id_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::core::NodeExecutionIdentifier&>(
      ::flyteidl::core::_NodeExecutionIdentifier_default_instance_);
}
inline const ::flyteidl::core::NodeExecutionIdentifier& NodeExecution::id() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NodeExecution.id)
  return _internal_id();
}
inline void NodeExecution::unsafe_arena_set_allocated_id(
    ::flyteidl::core::NodeExecutionIdentifier* id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.NodeExecution.id)
}
inline ::flyteidl::core::NodeExecutionIdentifier* NodeExecution::release_id() {
  
  ::flyteidl::core::NodeExecutionIdentifier* temp = id_;
  id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::core::NodeExecutionIdentifier* NodeExecution::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.NodeExecution.id)
  
  ::flyteidl::core::NodeExecutionIdentifier* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::flyteidl::core::NodeExecutionIdentifier* NodeExecution::_internal_mutable_id() {
  
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::NodeExecutionIdentifier>(GetArenaForAllocation());
    id_ = p;
  }
  return id_;
}
inline ::flyteidl::core::NodeExecutionIdentifier* NodeExecution::mutable_id() {
  ::flyteidl::core::NodeExecutionIdentifier* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.NodeExecution.id)
  return _msg;
}
inline void NodeExecution::set_allocated_id(::flyteidl::core::NodeExecutionIdentifier* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id));
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.NodeExecution.id)
}

// string input_uri = 2 [json_name = "inputUri"];
inline void NodeExecution::clear_input_uri() {
  input_uri_.ClearToEmpty();
}
inline const std::string& NodeExecution::input_uri() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NodeExecution.input_uri)
  return _internal_input_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeExecution::set_input_uri(ArgT0&& arg0, ArgT... args) {
 
 input_uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.admin.NodeExecution.input_uri)
}
inline std::string* NodeExecution::mutable_input_uri() {
  std::string* _s = _internal_mutable_input_uri();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.NodeExecution.input_uri)
  return _s;
}
inline const std::string& NodeExecution::_internal_input_uri() const {
  return input_uri_.Get();
}
inline void NodeExecution::_internal_set_input_uri(const std::string& value) {
  
  input_uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NodeExecution::_internal_mutable_input_uri() {
  
  return input_uri_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NodeExecution::release_input_uri() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.NodeExecution.input_uri)
  return input_uri_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NodeExecution::set_allocated_input_uri(std::string* input_uri) {
  if (input_uri != nullptr) {
    
  } else {
    
  }
  input_uri_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), input_uri,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (input_uri_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    input_uri_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.NodeExecution.input_uri)
}

// .flyteidl.admin.NodeExecutionClosure closure = 3 [json_name = "closure"];
inline bool NodeExecution::_internal_has_closure() const {
  return this != internal_default_instance() && closure_ != nullptr;
}
inline bool NodeExecution::has_closure() const {
  return _internal_has_closure();
}
inline void NodeExecution::clear_closure() {
  if (GetArenaForAllocation() == nullptr && closure_ != nullptr) {
    delete closure_;
  }
  closure_ = nullptr;
}
inline const ::flyteidl::admin::NodeExecutionClosure& NodeExecution::_internal_closure() const {
  const ::flyteidl::admin::NodeExecutionClosure* p = closure_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::admin::NodeExecutionClosure&>(
      ::flyteidl::admin::_NodeExecutionClosure_default_instance_);
}
inline const ::flyteidl::admin::NodeExecutionClosure& NodeExecution::closure() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NodeExecution.closure)
  return _internal_closure();
}
inline void NodeExecution::unsafe_arena_set_allocated_closure(
    ::flyteidl::admin::NodeExecutionClosure* closure) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(closure_);
  }
  closure_ = closure;
  if (closure) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.NodeExecution.closure)
}
inline ::flyteidl::admin::NodeExecutionClosure* NodeExecution::release_closure() {
  
  ::flyteidl::admin::NodeExecutionClosure* temp = closure_;
  closure_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::admin::NodeExecutionClosure* NodeExecution::unsafe_arena_release_closure() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.NodeExecution.closure)
  
  ::flyteidl::admin::NodeExecutionClosure* temp = closure_;
  closure_ = nullptr;
  return temp;
}
inline ::flyteidl::admin::NodeExecutionClosure* NodeExecution::_internal_mutable_closure() {
  
  if (closure_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::admin::NodeExecutionClosure>(GetArenaForAllocation());
    closure_ = p;
  }
  return closure_;
}
inline ::flyteidl::admin::NodeExecutionClosure* NodeExecution::mutable_closure() {
  ::flyteidl::admin::NodeExecutionClosure* _msg = _internal_mutable_closure();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.NodeExecution.closure)
  return _msg;
}
inline void NodeExecution::set_allocated_closure(::flyteidl::admin::NodeExecutionClosure* closure) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete closure_;
  }
  if (closure) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::flyteidl::admin::NodeExecutionClosure>::GetOwningArena(closure);
    if (message_arena != submessage_arena) {
      closure = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, closure, submessage_arena);
    }
    
  } else {
    
  }
  closure_ = closure;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.NodeExecution.closure)
}

// .flyteidl.admin.NodeExecutionMetaData metadata = 4 [json_name = "metadata"];
inline bool NodeExecution::_internal_has_metadata() const {
  return this != internal_default_instance() && metadata_ != nullptr;
}
inline bool NodeExecution::has_metadata() const {
  return _internal_has_metadata();
}
inline void NodeExecution::clear_metadata() {
  if (GetArenaForAllocation() == nullptr && metadata_ != nullptr) {
    delete metadata_;
  }
  metadata_ = nullptr;
}
inline const ::flyteidl::admin::NodeExecutionMetaData& NodeExecution::_internal_metadata() const {
  const ::flyteidl::admin::NodeExecutionMetaData* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::admin::NodeExecutionMetaData&>(
      ::flyteidl::admin::_NodeExecutionMetaData_default_instance_);
}
inline const ::flyteidl::admin::NodeExecutionMetaData& NodeExecution::metadata() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NodeExecution.metadata)
  return _internal_metadata();
}
inline void NodeExecution::unsafe_arena_set_allocated_metadata(
    ::flyteidl::admin::NodeExecutionMetaData* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.NodeExecution.metadata)
}
inline ::flyteidl::admin::NodeExecutionMetaData* NodeExecution::release_metadata() {
  
  ::flyteidl::admin::NodeExecutionMetaData* temp = metadata_;
  metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::admin::NodeExecutionMetaData* NodeExecution::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.NodeExecution.metadata)
  
  ::flyteidl::admin::NodeExecutionMetaData* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::flyteidl::admin::NodeExecutionMetaData* NodeExecution::_internal_mutable_metadata() {
  
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::admin::NodeExecutionMetaData>(GetArenaForAllocation());
    metadata_ = p;
  }
  return metadata_;
}
inline ::flyteidl::admin::NodeExecutionMetaData* NodeExecution::mutable_metadata() {
  ::flyteidl::admin::NodeExecutionMetaData* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.NodeExecution.metadata)
  return _msg;
}
inline void NodeExecution::set_allocated_metadata(::flyteidl::admin::NodeExecutionMetaData* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete metadata_;
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::flyteidl::admin::NodeExecutionMetaData>::GetOwningArena(metadata);
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.NodeExecution.metadata)
}

// -------------------------------------------------------------------

// NodeExecutionMetaData

// string retry_group = 1 [json_name = "retryGroup"];
inline void NodeExecutionMetaData::clear_retry_group() {
  retry_group_.ClearToEmpty();
}
inline const std::string& NodeExecutionMetaData::retry_group() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NodeExecutionMetaData.retry_group)
  return _internal_retry_group();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeExecutionMetaData::set_retry_group(ArgT0&& arg0, ArgT... args) {
 
 retry_group_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.admin.NodeExecutionMetaData.retry_group)
}
inline std::string* NodeExecutionMetaData::mutable_retry_group() {
  std::string* _s = _internal_mutable_retry_group();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.NodeExecutionMetaData.retry_group)
  return _s;
}
inline const std::string& NodeExecutionMetaData::_internal_retry_group() const {
  return retry_group_.Get();
}
inline void NodeExecutionMetaData::_internal_set_retry_group(const std::string& value) {
  
  retry_group_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NodeExecutionMetaData::_internal_mutable_retry_group() {
  
  return retry_group_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NodeExecutionMetaData::release_retry_group() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.NodeExecutionMetaData.retry_group)
  return retry_group_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NodeExecutionMetaData::set_allocated_retry_group(std::string* retry_group) {
  if (retry_group != nullptr) {
    
  } else {
    
  }
  retry_group_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), retry_group,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (retry_group_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    retry_group_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.NodeExecutionMetaData.retry_group)
}

// bool is_parent_node = 2 [json_name = "isParentNode"];
inline void NodeExecutionMetaData::clear_is_parent_node() {
  is_parent_node_ = false;
}
inline bool NodeExecutionMetaData::_internal_is_parent_node() const {
  return is_parent_node_;
}
inline bool NodeExecutionMetaData::is_parent_node() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NodeExecutionMetaData.is_parent_node)
  return _internal_is_parent_node();
}
inline void NodeExecutionMetaData::_internal_set_is_parent_node(bool value) {
  
  is_parent_node_ = value;
}
inline void NodeExecutionMetaData::set_is_parent_node(bool value) {
  _internal_set_is_parent_node(value);
  // @@protoc_insertion_point(field_set:flyteidl.admin.NodeExecutionMetaData.is_parent_node)
}

// string spec_node_id = 3 [json_name = "specNodeId"];
inline void NodeExecutionMetaData::clear_spec_node_id() {
  spec_node_id_.ClearToEmpty();
}
inline const std::string& NodeExecutionMetaData::spec_node_id() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NodeExecutionMetaData.spec_node_id)
  return _internal_spec_node_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeExecutionMetaData::set_spec_node_id(ArgT0&& arg0, ArgT... args) {
 
 spec_node_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.admin.NodeExecutionMetaData.spec_node_id)
}
inline std::string* NodeExecutionMetaData::mutable_spec_node_id() {
  std::string* _s = _internal_mutable_spec_node_id();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.NodeExecutionMetaData.spec_node_id)
  return _s;
}
inline const std::string& NodeExecutionMetaData::_internal_spec_node_id() const {
  return spec_node_id_.Get();
}
inline void NodeExecutionMetaData::_internal_set_spec_node_id(const std::string& value) {
  
  spec_node_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NodeExecutionMetaData::_internal_mutable_spec_node_id() {
  
  return spec_node_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NodeExecutionMetaData::release_spec_node_id() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.NodeExecutionMetaData.spec_node_id)
  return spec_node_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NodeExecutionMetaData::set_allocated_spec_node_id(std::string* spec_node_id) {
  if (spec_node_id != nullptr) {
    
  } else {
    
  }
  spec_node_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), spec_node_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (spec_node_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    spec_node_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.NodeExecutionMetaData.spec_node_id)
}

// bool is_dynamic = 4 [json_name = "isDynamic"];
inline void NodeExecutionMetaData::clear_is_dynamic() {
  is_dynamic_ = false;
}
inline bool NodeExecutionMetaData::_internal_is_dynamic() const {
  return is_dynamic_;
}
inline bool NodeExecutionMetaData::is_dynamic() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NodeExecutionMetaData.is_dynamic)
  return _internal_is_dynamic();
}
inline void NodeExecutionMetaData::_internal_set_is_dynamic(bool value) {
  
  is_dynamic_ = value;
}
inline void NodeExecutionMetaData::set_is_dynamic(bool value) {
  _internal_set_is_dynamic(value);
  // @@protoc_insertion_point(field_set:flyteidl.admin.NodeExecutionMetaData.is_dynamic)
}

// -------------------------------------------------------------------

// NodeExecutionList

// repeated .flyteidl.admin.NodeExecution node_executions = 1 [json_name = "nodeExecutions"];
inline int NodeExecutionList::_internal_node_executions_size() const {
  return node_executions_.size();
}
inline int NodeExecutionList::node_executions_size() const {
  return _internal_node_executions_size();
}
inline void NodeExecutionList::clear_node_executions() {
  node_executions_.Clear();
}
inline ::flyteidl::admin::NodeExecution* NodeExecutionList::mutable_node_executions(int index) {
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.NodeExecutionList.node_executions)
  return node_executions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::admin::NodeExecution >*
NodeExecutionList::mutable_node_executions() {
  // @@protoc_insertion_point(field_mutable_list:flyteidl.admin.NodeExecutionList.node_executions)
  return &node_executions_;
}
inline const ::flyteidl::admin::NodeExecution& NodeExecutionList::_internal_node_executions(int index) const {
  return node_executions_.Get(index);
}
inline const ::flyteidl::admin::NodeExecution& NodeExecutionList::node_executions(int index) const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NodeExecutionList.node_executions)
  return _internal_node_executions(index);
}
inline ::flyteidl::admin::NodeExecution* NodeExecutionList::_internal_add_node_executions() {
  return node_executions_.Add();
}
inline ::flyteidl::admin::NodeExecution* NodeExecutionList::add_node_executions() {
  ::flyteidl::admin::NodeExecution* _add = _internal_add_node_executions();
  // @@protoc_insertion_point(field_add:flyteidl.admin.NodeExecutionList.node_executions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::admin::NodeExecution >&
NodeExecutionList::node_executions() const {
  // @@protoc_insertion_point(field_list:flyteidl.admin.NodeExecutionList.node_executions)
  return node_executions_;
}

// string token = 2 [json_name = "token"];
inline void NodeExecutionList::clear_token() {
  token_.ClearToEmpty();
}
inline const std::string& NodeExecutionList::token() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NodeExecutionList.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeExecutionList::set_token(ArgT0&& arg0, ArgT... args) {
 
 token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.admin.NodeExecutionList.token)
}
inline std::string* NodeExecutionList::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.NodeExecutionList.token)
  return _s;
}
inline const std::string& NodeExecutionList::_internal_token() const {
  return token_.Get();
}
inline void NodeExecutionList::_internal_set_token(const std::string& value) {
  
  token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NodeExecutionList::_internal_mutable_token() {
  
  return token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NodeExecutionList::release_token() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.NodeExecutionList.token)
  return token_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NodeExecutionList::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.NodeExecutionList.token)
}

// -------------------------------------------------------------------

// NodeExecutionClosure

// string output_uri = 1 [json_name = "outputUri", deprecated = true];
inline bool NodeExecutionClosure::_internal_has_output_uri() const {
  return output_result_case() == kOutputUri;
}
inline bool NodeExecutionClosure::has_output_uri() const {
  return _internal_has_output_uri();
}
inline void NodeExecutionClosure::set_has_output_uri() {
  _oneof_case_[0] = kOutputUri;
}
inline void NodeExecutionClosure::clear_output_uri() {
  if (_internal_has_output_uri()) {
    output_result_.output_uri_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_output_result();
  }
}
inline const std::string& NodeExecutionClosure::output_uri() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NodeExecutionClosure.output_uri)
  return _internal_output_uri();
}
template <typename ArgT0, typename... ArgT>
inline void NodeExecutionClosure::set_output_uri(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_output_uri()) {
    clear_output_result();
    set_has_output_uri();
    output_result_.output_uri_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  output_result_.output_uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.admin.NodeExecutionClosure.output_uri)
}
inline std::string* NodeExecutionClosure::mutable_output_uri() {
  std::string* _s = _internal_mutable_output_uri();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.NodeExecutionClosure.output_uri)
  return _s;
}
inline const std::string& NodeExecutionClosure::_internal_output_uri() const {
  if (_internal_has_output_uri()) {
    return output_result_.output_uri_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void NodeExecutionClosure::_internal_set_output_uri(const std::string& value) {
  if (!_internal_has_output_uri()) {
    clear_output_result();
    set_has_output_uri();
    output_result_.output_uri_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  output_result_.output_uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NodeExecutionClosure::_internal_mutable_output_uri() {
  if (!_internal_has_output_uri()) {
    clear_output_result();
    set_has_output_uri();
    output_result_.output_uri_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return output_result_.output_uri_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NodeExecutionClosure::release_output_uri() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.NodeExecutionClosure.output_uri)
  if (_internal_has_output_uri()) {
    clear_has_output_result();
    return output_result_.output_uri_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void NodeExecutionClosure::set_allocated_output_uri(std::string* output_uri) {
  if (has_output_result()) {
    clear_output_result();
  }
  if (output_uri != nullptr) {
    set_has_output_uri();
    output_result_.output_uri_.UnsafeSetDefault(output_uri);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(output_uri);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.NodeExecutionClosure.output_uri)
}

// .flyteidl.core.ExecutionError error = 2 [json_name = "error"];
inline bool NodeExecutionClosure::_internal_has_error() const {
  return output_result_case() == kError;
}
inline bool NodeExecutionClosure::has_error() const {
  return _internal_has_error();
}
inline void NodeExecutionClosure::set_has_error() {
  _oneof_case_[0] = kError;
}
inline ::flyteidl::core::ExecutionError* NodeExecutionClosure::release_error() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.NodeExecutionClosure.error)
  if (_internal_has_error()) {
    clear_has_output_result();
      ::flyteidl::core::ExecutionError* temp = output_result_.error_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    output_result_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::core::ExecutionError& NodeExecutionClosure::_internal_error() const {
  return _internal_has_error()
      ? *output_result_.error_
      : reinterpret_cast< ::flyteidl::core::ExecutionError&>(::flyteidl::core::_ExecutionError_default_instance_);
}
inline const ::flyteidl::core::ExecutionError& NodeExecutionClosure::error() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NodeExecutionClosure.error)
  return _internal_error();
}
inline ::flyteidl::core::ExecutionError* NodeExecutionClosure::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flyteidl.admin.NodeExecutionClosure.error)
  if (_internal_has_error()) {
    clear_has_output_result();
    ::flyteidl::core::ExecutionError* temp = output_result_.error_;
    output_result_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void NodeExecutionClosure::unsafe_arena_set_allocated_error(::flyteidl::core::ExecutionError* error) {
  clear_output_result();
  if (error) {
    set_has_error();
    output_result_.error_ = error;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.NodeExecutionClosure.error)
}
inline ::flyteidl::core::ExecutionError* NodeExecutionClosure::_internal_mutable_error() {
  if (!_internal_has_error()) {
    clear_output_result();
    set_has_error();
    output_result_.error_ = CreateMaybeMessage< ::flyteidl::core::ExecutionError >(GetArenaForAllocation());
  }
  return output_result_.error_;
}
inline ::flyteidl::core::ExecutionError* NodeExecutionClosure::mutable_error() {
  ::flyteidl::core::ExecutionError* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.NodeExecutionClosure.error)
  return _msg;
}

// .flyteidl.core.LiteralMap output_data = 10 [json_name = "outputData", deprecated = true];
inline bool NodeExecutionClosure::_internal_has_output_data() const {
  return output_result_case() == kOutputData;
}
inline bool NodeExecutionClosure::has_output_data() const {
  return _internal_has_output_data();
}
inline void NodeExecutionClosure::set_has_output_data() {
  _oneof_case_[0] = kOutputData;
}
inline ::flyteidl::core::LiteralMap* NodeExecutionClosure::release_output_data() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.NodeExecutionClosure.output_data)
  if (_internal_has_output_data()) {
    clear_has_output_result();
      ::flyteidl::core::LiteralMap* temp = output_result_.output_data_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    output_result_.output_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::core::LiteralMap& NodeExecutionClosure::_internal_output_data() const {
  return _internal_has_output_data()
      ? *output_result_.output_data_
      : reinterpret_cast< ::flyteidl::core::LiteralMap&>(::flyteidl::core::_LiteralMap_default_instance_);
}
inline const ::flyteidl::core::LiteralMap& NodeExecutionClosure::output_data() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NodeExecutionClosure.output_data)
  return _internal_output_data();
}
inline ::flyteidl::core::LiteralMap* NodeExecutionClosure::unsafe_arena_release_output_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flyteidl.admin.NodeExecutionClosure.output_data)
  if (_internal_has_output_data()) {
    clear_has_output_result();
    ::flyteidl::core::LiteralMap* temp = output_result_.output_data_;
    output_result_.output_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void NodeExecutionClosure::unsafe_arena_set_allocated_output_data(::flyteidl::core::LiteralMap* output_data) {
  clear_output_result();
  if (output_data) {
    set_has_output_data();
    output_result_.output_data_ = output_data;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.NodeExecutionClosure.output_data)
}
inline ::flyteidl::core::LiteralMap* NodeExecutionClosure::_internal_mutable_output_data() {
  if (!_internal_has_output_data()) {
    clear_output_result();
    set_has_output_data();
    output_result_.output_data_ = CreateMaybeMessage< ::flyteidl::core::LiteralMap >(GetArenaForAllocation());
  }
  return output_result_.output_data_;
}
inline ::flyteidl::core::LiteralMap* NodeExecutionClosure::mutable_output_data() {
  ::flyteidl::core::LiteralMap* _msg = _internal_mutable_output_data();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.NodeExecutionClosure.output_data)
  return _msg;
}

// .flyteidl.core.NodeExecution.Phase phase = 3 [json_name = "phase"];
inline void NodeExecutionClosure::clear_phase() {
  phase_ = 0;
}
inline ::flyteidl::core::NodeExecution_Phase NodeExecutionClosure::_internal_phase() const {
  return static_cast< ::flyteidl::core::NodeExecution_Phase >(phase_);
}
inline ::flyteidl::core::NodeExecution_Phase NodeExecutionClosure::phase() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NodeExecutionClosure.phase)
  return _internal_phase();
}
inline void NodeExecutionClosure::_internal_set_phase(::flyteidl::core::NodeExecution_Phase value) {
  
  phase_ = value;
}
inline void NodeExecutionClosure::set_phase(::flyteidl::core::NodeExecution_Phase value) {
  _internal_set_phase(value);
  // @@protoc_insertion_point(field_set:flyteidl.admin.NodeExecutionClosure.phase)
}

// .google.protobuf.Timestamp started_at = 4 [json_name = "startedAt"];
inline bool NodeExecutionClosure::_internal_has_started_at() const {
  return this != internal_default_instance() && started_at_ != nullptr;
}
inline bool NodeExecutionClosure::has_started_at() const {
  return _internal_has_started_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& NodeExecutionClosure::_internal_started_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = started_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& NodeExecutionClosure::started_at() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NodeExecutionClosure.started_at)
  return _internal_started_at();
}
inline void NodeExecutionClosure::unsafe_arena_set_allocated_started_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* started_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(started_at_);
  }
  started_at_ = started_at;
  if (started_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.NodeExecutionClosure.started_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* NodeExecutionClosure::release_started_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = started_at_;
  started_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* NodeExecutionClosure::unsafe_arena_release_started_at() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.NodeExecutionClosure.started_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = started_at_;
  started_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* NodeExecutionClosure::_internal_mutable_started_at() {
  
  if (started_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    started_at_ = p;
  }
  return started_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* NodeExecutionClosure::mutable_started_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_started_at();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.NodeExecutionClosure.started_at)
  return _msg;
}
inline void NodeExecutionClosure::set_allocated_started_at(::PROTOBUF_NAMESPACE_ID::Timestamp* started_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(started_at_);
  }
  if (started_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(started_at));
    if (message_arena != submessage_arena) {
      started_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, started_at, submessage_arena);
    }
    
  } else {
    
  }
  started_at_ = started_at;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.NodeExecutionClosure.started_at)
}

// .google.protobuf.Duration duration = 5 [json_name = "duration"];
inline bool NodeExecutionClosure::_internal_has_duration() const {
  return this != internal_default_instance() && duration_ != nullptr;
}
inline bool NodeExecutionClosure::has_duration() const {
  return _internal_has_duration();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& NodeExecutionClosure::_internal_duration() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = duration_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& NodeExecutionClosure::duration() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NodeExecutionClosure.duration)
  return _internal_duration();
}
inline void NodeExecutionClosure::unsafe_arena_set_allocated_duration(
    ::PROTOBUF_NAMESPACE_ID::Duration* duration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(duration_);
  }
  duration_ = duration;
  if (duration) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.NodeExecutionClosure.duration)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* NodeExecutionClosure::release_duration() {
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = duration_;
  duration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* NodeExecutionClosure::unsafe_arena_release_duration() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.NodeExecutionClosure.duration)
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = duration_;
  duration_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* NodeExecutionClosure::_internal_mutable_duration() {
  
  if (duration_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    duration_ = p;
  }
  return duration_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* NodeExecutionClosure::mutable_duration() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_duration();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.NodeExecutionClosure.duration)
  return _msg;
}
inline void NodeExecutionClosure::set_allocated_duration(::PROTOBUF_NAMESPACE_ID::Duration* duration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(duration_);
  }
  if (duration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(duration));
    if (message_arena != submessage_arena) {
      duration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, duration, submessage_arena);
    }
    
  } else {
    
  }
  duration_ = duration;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.NodeExecutionClosure.duration)
}

// .google.protobuf.Timestamp created_at = 6 [json_name = "createdAt"];
inline bool NodeExecutionClosure::_internal_has_created_at() const {
  return this != internal_default_instance() && created_at_ != nullptr;
}
inline bool NodeExecutionClosure::has_created_at() const {
  return _internal_has_created_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& NodeExecutionClosure::_internal_created_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& NodeExecutionClosure::created_at() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NodeExecutionClosure.created_at)
  return _internal_created_at();
}
inline void NodeExecutionClosure::unsafe_arena_set_allocated_created_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at_);
  }
  created_at_ = created_at;
  if (created_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.NodeExecutionClosure.created_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* NodeExecutionClosure::release_created_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_at_;
  created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* NodeExecutionClosure::unsafe_arena_release_created_at() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.NodeExecutionClosure.created_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_at_;
  created_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* NodeExecutionClosure::_internal_mutable_created_at() {
  
  if (created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    created_at_ = p;
  }
  return created_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* NodeExecutionClosure::mutable_created_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.NodeExecutionClosure.created_at)
  return _msg;
}
inline void NodeExecutionClosure::set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at_);
  }
  if (created_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at));
    if (message_arena != submessage_arena) {
      created_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_at, submessage_arena);
    }
    
  } else {
    
  }
  created_at_ = created_at;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.NodeExecutionClosure.created_at)
}

// .google.protobuf.Timestamp updated_at = 7 [json_name = "updatedAt"];
inline bool NodeExecutionClosure::_internal_has_updated_at() const {
  return this != internal_default_instance() && updated_at_ != nullptr;
}
inline bool NodeExecutionClosure::has_updated_at() const {
  return _internal_has_updated_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& NodeExecutionClosure::_internal_updated_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = updated_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& NodeExecutionClosure::updated_at() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NodeExecutionClosure.updated_at)
  return _internal_updated_at();
}
inline void NodeExecutionClosure::unsafe_arena_set_allocated_updated_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(updated_at_);
  }
  updated_at_ = updated_at;
  if (updated_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.NodeExecutionClosure.updated_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* NodeExecutionClosure::release_updated_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = updated_at_;
  updated_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* NodeExecutionClosure::unsafe_arena_release_updated_at() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.NodeExecutionClosure.updated_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = updated_at_;
  updated_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* NodeExecutionClosure::_internal_mutable_updated_at() {
  
  if (updated_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    updated_at_ = p;
  }
  return updated_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* NodeExecutionClosure::mutable_updated_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_updated_at();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.NodeExecutionClosure.updated_at)
  return _msg;
}
inline void NodeExecutionClosure::set_allocated_updated_at(::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(updated_at_);
  }
  if (updated_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(updated_at));
    if (message_arena != submessage_arena) {
      updated_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, updated_at, submessage_arena);
    }
    
  } else {
    
  }
  updated_at_ = updated_at;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.NodeExecutionClosure.updated_at)
}

// .flyteidl.admin.WorkflowNodeMetadata workflow_node_metadata = 8 [json_name = "workflowNodeMetadata"];
inline bool NodeExecutionClosure::_internal_has_workflow_node_metadata() const {
  return target_metadata_case() == kWorkflowNodeMetadata;
}
inline bool NodeExecutionClosure::has_workflow_node_metadata() const {
  return _internal_has_workflow_node_metadata();
}
inline void NodeExecutionClosure::set_has_workflow_node_metadata() {
  _oneof_case_[1] = kWorkflowNodeMetadata;
}
inline void NodeExecutionClosure::clear_workflow_node_metadata() {
  if (_internal_has_workflow_node_metadata()) {
    if (GetArenaForAllocation() == nullptr) {
      delete target_metadata_.workflow_node_metadata_;
    }
    clear_has_target_metadata();
  }
}
inline ::flyteidl::admin::WorkflowNodeMetadata* NodeExecutionClosure::release_workflow_node_metadata() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.NodeExecutionClosure.workflow_node_metadata)
  if (_internal_has_workflow_node_metadata()) {
    clear_has_target_metadata();
      ::flyteidl::admin::WorkflowNodeMetadata* temp = target_metadata_.workflow_node_metadata_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    target_metadata_.workflow_node_metadata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::admin::WorkflowNodeMetadata& NodeExecutionClosure::_internal_workflow_node_metadata() const {
  return _internal_has_workflow_node_metadata()
      ? *target_metadata_.workflow_node_metadata_
      : reinterpret_cast< ::flyteidl::admin::WorkflowNodeMetadata&>(::flyteidl::admin::_WorkflowNodeMetadata_default_instance_);
}
inline const ::flyteidl::admin::WorkflowNodeMetadata& NodeExecutionClosure::workflow_node_metadata() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NodeExecutionClosure.workflow_node_metadata)
  return _internal_workflow_node_metadata();
}
inline ::flyteidl::admin::WorkflowNodeMetadata* NodeExecutionClosure::unsafe_arena_release_workflow_node_metadata() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flyteidl.admin.NodeExecutionClosure.workflow_node_metadata)
  if (_internal_has_workflow_node_metadata()) {
    clear_has_target_metadata();
    ::flyteidl::admin::WorkflowNodeMetadata* temp = target_metadata_.workflow_node_metadata_;
    target_metadata_.workflow_node_metadata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void NodeExecutionClosure::unsafe_arena_set_allocated_workflow_node_metadata(::flyteidl::admin::WorkflowNodeMetadata* workflow_node_metadata) {
  clear_target_metadata();
  if (workflow_node_metadata) {
    set_has_workflow_node_metadata();
    target_metadata_.workflow_node_metadata_ = workflow_node_metadata;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.NodeExecutionClosure.workflow_node_metadata)
}
inline ::flyteidl::admin::WorkflowNodeMetadata* NodeExecutionClosure::_internal_mutable_workflow_node_metadata() {
  if (!_internal_has_workflow_node_metadata()) {
    clear_target_metadata();
    set_has_workflow_node_metadata();
    target_metadata_.workflow_node_metadata_ = CreateMaybeMessage< ::flyteidl::admin::WorkflowNodeMetadata >(GetArenaForAllocation());
  }
  return target_metadata_.workflow_node_metadata_;
}
inline ::flyteidl::admin::WorkflowNodeMetadata* NodeExecutionClosure::mutable_workflow_node_metadata() {
  ::flyteidl::admin::WorkflowNodeMetadata* _msg = _internal_mutable_workflow_node_metadata();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.NodeExecutionClosure.workflow_node_metadata)
  return _msg;
}

// .flyteidl.admin.TaskNodeMetadata task_node_metadata = 9 [json_name = "taskNodeMetadata"];
inline bool NodeExecutionClosure::_internal_has_task_node_metadata() const {
  return target_metadata_case() == kTaskNodeMetadata;
}
inline bool NodeExecutionClosure::has_task_node_metadata() const {
  return _internal_has_task_node_metadata();
}
inline void NodeExecutionClosure::set_has_task_node_metadata() {
  _oneof_case_[1] = kTaskNodeMetadata;
}
inline void NodeExecutionClosure::clear_task_node_metadata() {
  if (_internal_has_task_node_metadata()) {
    if (GetArenaForAllocation() == nullptr) {
      delete target_metadata_.task_node_metadata_;
    }
    clear_has_target_metadata();
  }
}
inline ::flyteidl::admin::TaskNodeMetadata* NodeExecutionClosure::release_task_node_metadata() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.NodeExecutionClosure.task_node_metadata)
  if (_internal_has_task_node_metadata()) {
    clear_has_target_metadata();
      ::flyteidl::admin::TaskNodeMetadata* temp = target_metadata_.task_node_metadata_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    target_metadata_.task_node_metadata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::admin::TaskNodeMetadata& NodeExecutionClosure::_internal_task_node_metadata() const {
  return _internal_has_task_node_metadata()
      ? *target_metadata_.task_node_metadata_
      : reinterpret_cast< ::flyteidl::admin::TaskNodeMetadata&>(::flyteidl::admin::_TaskNodeMetadata_default_instance_);
}
inline const ::flyteidl::admin::TaskNodeMetadata& NodeExecutionClosure::task_node_metadata() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NodeExecutionClosure.task_node_metadata)
  return _internal_task_node_metadata();
}
inline ::flyteidl::admin::TaskNodeMetadata* NodeExecutionClosure::unsafe_arena_release_task_node_metadata() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flyteidl.admin.NodeExecutionClosure.task_node_metadata)
  if (_internal_has_task_node_metadata()) {
    clear_has_target_metadata();
    ::flyteidl::admin::TaskNodeMetadata* temp = target_metadata_.task_node_metadata_;
    target_metadata_.task_node_metadata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void NodeExecutionClosure::unsafe_arena_set_allocated_task_node_metadata(::flyteidl::admin::TaskNodeMetadata* task_node_metadata) {
  clear_target_metadata();
  if (task_node_metadata) {
    set_has_task_node_metadata();
    target_metadata_.task_node_metadata_ = task_node_metadata;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.NodeExecutionClosure.task_node_metadata)
}
inline ::flyteidl::admin::TaskNodeMetadata* NodeExecutionClosure::_internal_mutable_task_node_metadata() {
  if (!_internal_has_task_node_metadata()) {
    clear_target_metadata();
    set_has_task_node_metadata();
    target_metadata_.task_node_metadata_ = CreateMaybeMessage< ::flyteidl::admin::TaskNodeMetadata >(GetArenaForAllocation());
  }
  return target_metadata_.task_node_metadata_;
}
inline ::flyteidl::admin::TaskNodeMetadata* NodeExecutionClosure::mutable_task_node_metadata() {
  ::flyteidl::admin::TaskNodeMetadata* _msg = _internal_mutable_task_node_metadata();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.NodeExecutionClosure.task_node_metadata)
  return _msg;
}

inline bool NodeExecutionClosure::has_output_result() const {
  return output_result_case() != OUTPUT_RESULT_NOT_SET;
}
inline void NodeExecutionClosure::clear_has_output_result() {
  _oneof_case_[0] = OUTPUT_RESULT_NOT_SET;
}
inline bool NodeExecutionClosure::has_target_metadata() const {
  return target_metadata_case() != TARGET_METADATA_NOT_SET;
}
inline void NodeExecutionClosure::clear_has_target_metadata() {
  _oneof_case_[1] = TARGET_METADATA_NOT_SET;
}
inline NodeExecutionClosure::OutputResultCase NodeExecutionClosure::output_result_case() const {
  return NodeExecutionClosure::OutputResultCase(_oneof_case_[0]);
}
inline NodeExecutionClosure::TargetMetadataCase NodeExecutionClosure::target_metadata_case() const {
  return NodeExecutionClosure::TargetMetadataCase(_oneof_case_[1]);
}
// -------------------------------------------------------------------

// WorkflowNodeMetadata

// .flyteidl.core.WorkflowExecutionIdentifier executionId = 1 [json_name = "executionId"];
inline bool WorkflowNodeMetadata::_internal_has_executionid() const {
  return this != internal_default_instance() && executionid_ != nullptr;
}
inline bool WorkflowNodeMetadata::has_executionid() const {
  return _internal_has_executionid();
}
inline const ::flyteidl::core::WorkflowExecutionIdentifier& WorkflowNodeMetadata::_internal_executionid() const {
  const ::flyteidl::core::WorkflowExecutionIdentifier* p = executionid_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::core::WorkflowExecutionIdentifier&>(
      ::flyteidl::core::_WorkflowExecutionIdentifier_default_instance_);
}
inline const ::flyteidl::core::WorkflowExecutionIdentifier& WorkflowNodeMetadata::executionid() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.WorkflowNodeMetadata.executionId)
  return _internal_executionid();
}
inline void WorkflowNodeMetadata::unsafe_arena_set_allocated_executionid(
    ::flyteidl::core::WorkflowExecutionIdentifier* executionid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(executionid_);
  }
  executionid_ = executionid;
  if (executionid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.WorkflowNodeMetadata.executionId)
}
inline ::flyteidl::core::WorkflowExecutionIdentifier* WorkflowNodeMetadata::release_executionid() {
  
  ::flyteidl::core::WorkflowExecutionIdentifier* temp = executionid_;
  executionid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::core::WorkflowExecutionIdentifier* WorkflowNodeMetadata::unsafe_arena_release_executionid() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.WorkflowNodeMetadata.executionId)
  
  ::flyteidl::core::WorkflowExecutionIdentifier* temp = executionid_;
  executionid_ = nullptr;
  return temp;
}
inline ::flyteidl::core::WorkflowExecutionIdentifier* WorkflowNodeMetadata::_internal_mutable_executionid() {
  
  if (executionid_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::WorkflowExecutionIdentifier>(GetArenaForAllocation());
    executionid_ = p;
  }
  return executionid_;
}
inline ::flyteidl::core::WorkflowExecutionIdentifier* WorkflowNodeMetadata::mutable_executionid() {
  ::flyteidl::core::WorkflowExecutionIdentifier* _msg = _internal_mutable_executionid();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.WorkflowNodeMetadata.executionId)
  return _msg;
}
inline void WorkflowNodeMetadata::set_allocated_executionid(::flyteidl::core::WorkflowExecutionIdentifier* executionid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(executionid_);
  }
  if (executionid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(executionid));
    if (message_arena != submessage_arena) {
      executionid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, executionid, submessage_arena);
    }
    
  } else {
    
  }
  executionid_ = executionid;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.WorkflowNodeMetadata.executionId)
}

// -------------------------------------------------------------------

// TaskNodeMetadata

// .flyteidl.core.CatalogCacheStatus cache_status = 1 [json_name = "cacheStatus"];
inline void TaskNodeMetadata::clear_cache_status() {
  cache_status_ = 0;
}
inline ::flyteidl::core::CatalogCacheStatus TaskNodeMetadata::_internal_cache_status() const {
  return static_cast< ::flyteidl::core::CatalogCacheStatus >(cache_status_);
}
inline ::flyteidl::core::CatalogCacheStatus TaskNodeMetadata::cache_status() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.TaskNodeMetadata.cache_status)
  return _internal_cache_status();
}
inline void TaskNodeMetadata::_internal_set_cache_status(::flyteidl::core::CatalogCacheStatus value) {
  
  cache_status_ = value;
}
inline void TaskNodeMetadata::set_cache_status(::flyteidl::core::CatalogCacheStatus value) {
  _internal_set_cache_status(value);
  // @@protoc_insertion_point(field_set:flyteidl.admin.TaskNodeMetadata.cache_status)
}

// .flyteidl.core.CatalogMetadata catalog_key = 2 [json_name = "catalogKey"];
inline bool TaskNodeMetadata::_internal_has_catalog_key() const {
  return this != internal_default_instance() && catalog_key_ != nullptr;
}
inline bool TaskNodeMetadata::has_catalog_key() const {
  return _internal_has_catalog_key();
}
inline const ::flyteidl::core::CatalogMetadata& TaskNodeMetadata::_internal_catalog_key() const {
  const ::flyteidl::core::CatalogMetadata* p = catalog_key_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::core::CatalogMetadata&>(
      ::flyteidl::core::_CatalogMetadata_default_instance_);
}
inline const ::flyteidl::core::CatalogMetadata& TaskNodeMetadata::catalog_key() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.TaskNodeMetadata.catalog_key)
  return _internal_catalog_key();
}
inline void TaskNodeMetadata::unsafe_arena_set_allocated_catalog_key(
    ::flyteidl::core::CatalogMetadata* catalog_key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(catalog_key_);
  }
  catalog_key_ = catalog_key;
  if (catalog_key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.TaskNodeMetadata.catalog_key)
}
inline ::flyteidl::core::CatalogMetadata* TaskNodeMetadata::release_catalog_key() {
  
  ::flyteidl::core::CatalogMetadata* temp = catalog_key_;
  catalog_key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::core::CatalogMetadata* TaskNodeMetadata::unsafe_arena_release_catalog_key() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.TaskNodeMetadata.catalog_key)
  
  ::flyteidl::core::CatalogMetadata* temp = catalog_key_;
  catalog_key_ = nullptr;
  return temp;
}
inline ::flyteidl::core::CatalogMetadata* TaskNodeMetadata::_internal_mutable_catalog_key() {
  
  if (catalog_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::CatalogMetadata>(GetArenaForAllocation());
    catalog_key_ = p;
  }
  return catalog_key_;
}
inline ::flyteidl::core::CatalogMetadata* TaskNodeMetadata::mutable_catalog_key() {
  ::flyteidl::core::CatalogMetadata* _msg = _internal_mutable_catalog_key();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.TaskNodeMetadata.catalog_key)
  return _msg;
}
inline void TaskNodeMetadata::set_allocated_catalog_key(::flyteidl::core::CatalogMetadata* catalog_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(catalog_key_);
  }
  if (catalog_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(catalog_key));
    if (message_arena != submessage_arena) {
      catalog_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, catalog_key, submessage_arena);
    }
    
  } else {
    
  }
  catalog_key_ = catalog_key;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.TaskNodeMetadata.catalog_key)
}

// -------------------------------------------------------------------

// DynamicWorkflowNodeMetadata

// .flyteidl.core.Identifier id = 1 [json_name = "id"];
inline bool DynamicWorkflowNodeMetadata::_internal_has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline bool DynamicWorkflowNodeMetadata::has_id() const {
  return _internal_has_id();
}
inline const ::flyteidl::core::Identifier& DynamicWorkflowNodeMetadata::_internal_id() const {
  const ::flyteidl::core::Identifier* p = id_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::core::Identifier&>(
      ::flyteidl::core::_Identifier_default_instance_);
}
inline const ::flyteidl::core::Identifier& DynamicWorkflowNodeMetadata::id() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.DynamicWorkflowNodeMetadata.id)
  return _internal_id();
}
inline void DynamicWorkflowNodeMetadata::unsafe_arena_set_allocated_id(
    ::flyteidl::core::Identifier* id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.DynamicWorkflowNodeMetadata.id)
}
inline ::flyteidl::core::Identifier* DynamicWorkflowNodeMetadata::release_id() {
  
  ::flyteidl::core::Identifier* temp = id_;
  id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::core::Identifier* DynamicWorkflowNodeMetadata::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.DynamicWorkflowNodeMetadata.id)
  
  ::flyteidl::core::Identifier* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::flyteidl::core::Identifier* DynamicWorkflowNodeMetadata::_internal_mutable_id() {
  
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::Identifier>(GetArenaForAllocation());
    id_ = p;
  }
  return id_;
}
inline ::flyteidl::core::Identifier* DynamicWorkflowNodeMetadata::mutable_id() {
  ::flyteidl::core::Identifier* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.DynamicWorkflowNodeMetadata.id)
  return _msg;
}
inline void DynamicWorkflowNodeMetadata::set_allocated_id(::flyteidl::core::Identifier* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id));
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.DynamicWorkflowNodeMetadata.id)
}

// .flyteidl.core.CompiledWorkflowClosure compiled_workflow = 2 [json_name = "compiledWorkflow"];
inline bool DynamicWorkflowNodeMetadata::_internal_has_compiled_workflow() const {
  return this != internal_default_instance() && compiled_workflow_ != nullptr;
}
inline bool DynamicWorkflowNodeMetadata::has_compiled_workflow() const {
  return _internal_has_compiled_workflow();
}
inline const ::flyteidl::core::CompiledWorkflowClosure& DynamicWorkflowNodeMetadata::_internal_compiled_workflow() const {
  const ::flyteidl::core::CompiledWorkflowClosure* p = compiled_workflow_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::core::CompiledWorkflowClosure&>(
      ::flyteidl::core::_CompiledWorkflowClosure_default_instance_);
}
inline const ::flyteidl::core::CompiledWorkflowClosure& DynamicWorkflowNodeMetadata::compiled_workflow() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.DynamicWorkflowNodeMetadata.compiled_workflow)
  return _internal_compiled_workflow();
}
inline void DynamicWorkflowNodeMetadata::unsafe_arena_set_allocated_compiled_workflow(
    ::flyteidl::core::CompiledWorkflowClosure* compiled_workflow) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(compiled_workflow_);
  }
  compiled_workflow_ = compiled_workflow;
  if (compiled_workflow) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.DynamicWorkflowNodeMetadata.compiled_workflow)
}
inline ::flyteidl::core::CompiledWorkflowClosure* DynamicWorkflowNodeMetadata::release_compiled_workflow() {
  
  ::flyteidl::core::CompiledWorkflowClosure* temp = compiled_workflow_;
  compiled_workflow_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::core::CompiledWorkflowClosure* DynamicWorkflowNodeMetadata::unsafe_arena_release_compiled_workflow() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.DynamicWorkflowNodeMetadata.compiled_workflow)
  
  ::flyteidl::core::CompiledWorkflowClosure* temp = compiled_workflow_;
  compiled_workflow_ = nullptr;
  return temp;
}
inline ::flyteidl::core::CompiledWorkflowClosure* DynamicWorkflowNodeMetadata::_internal_mutable_compiled_workflow() {
  
  if (compiled_workflow_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::CompiledWorkflowClosure>(GetArenaForAllocation());
    compiled_workflow_ = p;
  }
  return compiled_workflow_;
}
inline ::flyteidl::core::CompiledWorkflowClosure* DynamicWorkflowNodeMetadata::mutable_compiled_workflow() {
  ::flyteidl::core::CompiledWorkflowClosure* _msg = _internal_mutable_compiled_workflow();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.DynamicWorkflowNodeMetadata.compiled_workflow)
  return _msg;
}
inline void DynamicWorkflowNodeMetadata::set_allocated_compiled_workflow(::flyteidl::core::CompiledWorkflowClosure* compiled_workflow) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(compiled_workflow_);
  }
  if (compiled_workflow) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(compiled_workflow));
    if (message_arena != submessage_arena) {
      compiled_workflow = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, compiled_workflow, submessage_arena);
    }
    
  } else {
    
  }
  compiled_workflow_ = compiled_workflow;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.DynamicWorkflowNodeMetadata.compiled_workflow)
}

// -------------------------------------------------------------------

// NodeExecutionGetDataRequest

// .flyteidl.core.NodeExecutionIdentifier id = 1 [json_name = "id"];
inline bool NodeExecutionGetDataRequest::_internal_has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline bool NodeExecutionGetDataRequest::has_id() const {
  return _internal_has_id();
}
inline const ::flyteidl::core::NodeExecutionIdentifier& NodeExecutionGetDataRequest::_internal_id() const {
  const ::flyteidl::core::NodeExecutionIdentifier* p = id_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::core::NodeExecutionIdentifier&>(
      ::flyteidl::core::_NodeExecutionIdentifier_default_instance_);
}
inline const ::flyteidl::core::NodeExecutionIdentifier& NodeExecutionGetDataRequest::id() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NodeExecutionGetDataRequest.id)
  return _internal_id();
}
inline void NodeExecutionGetDataRequest::unsafe_arena_set_allocated_id(
    ::flyteidl::core::NodeExecutionIdentifier* id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.NodeExecutionGetDataRequest.id)
}
inline ::flyteidl::core::NodeExecutionIdentifier* NodeExecutionGetDataRequest::release_id() {
  
  ::flyteidl::core::NodeExecutionIdentifier* temp = id_;
  id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::core::NodeExecutionIdentifier* NodeExecutionGetDataRequest::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.NodeExecutionGetDataRequest.id)
  
  ::flyteidl::core::NodeExecutionIdentifier* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::flyteidl::core::NodeExecutionIdentifier* NodeExecutionGetDataRequest::_internal_mutable_id() {
  
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::NodeExecutionIdentifier>(GetArenaForAllocation());
    id_ = p;
  }
  return id_;
}
inline ::flyteidl::core::NodeExecutionIdentifier* NodeExecutionGetDataRequest::mutable_id() {
  ::flyteidl::core::NodeExecutionIdentifier* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.NodeExecutionGetDataRequest.id)
  return _msg;
}
inline void NodeExecutionGetDataRequest::set_allocated_id(::flyteidl::core::NodeExecutionIdentifier* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id));
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.NodeExecutionGetDataRequest.id)
}

// -------------------------------------------------------------------

// NodeExecutionGetDataResponse

// .flyteidl.admin.UrlBlob inputs = 1 [json_name = "inputs", deprecated = true];
inline bool NodeExecutionGetDataResponse::_internal_has_inputs() const {
  return this != internal_default_instance() && inputs_ != nullptr;
}
inline bool NodeExecutionGetDataResponse::has_inputs() const {
  return _internal_has_inputs();
}
inline const ::flyteidl::admin::UrlBlob& NodeExecutionGetDataResponse::_internal_inputs() const {
  const ::flyteidl::admin::UrlBlob* p = inputs_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::admin::UrlBlob&>(
      ::flyteidl::admin::_UrlBlob_default_instance_);
}
inline const ::flyteidl::admin::UrlBlob& NodeExecutionGetDataResponse::inputs() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NodeExecutionGetDataResponse.inputs)
  return _internal_inputs();
}
inline void NodeExecutionGetDataResponse::unsafe_arena_set_allocated_inputs(
    ::flyteidl::admin::UrlBlob* inputs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(inputs_);
  }
  inputs_ = inputs;
  if (inputs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.NodeExecutionGetDataResponse.inputs)
}
inline ::flyteidl::admin::UrlBlob* NodeExecutionGetDataResponse::release_inputs() {
  
  ::flyteidl::admin::UrlBlob* temp = inputs_;
  inputs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::admin::UrlBlob* NodeExecutionGetDataResponse::unsafe_arena_release_inputs() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.NodeExecutionGetDataResponse.inputs)
  
  ::flyteidl::admin::UrlBlob* temp = inputs_;
  inputs_ = nullptr;
  return temp;
}
inline ::flyteidl::admin::UrlBlob* NodeExecutionGetDataResponse::_internal_mutable_inputs() {
  
  if (inputs_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::admin::UrlBlob>(GetArenaForAllocation());
    inputs_ = p;
  }
  return inputs_;
}
inline ::flyteidl::admin::UrlBlob* NodeExecutionGetDataResponse::mutable_inputs() {
  ::flyteidl::admin::UrlBlob* _msg = _internal_mutable_inputs();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.NodeExecutionGetDataResponse.inputs)
  return _msg;
}
inline void NodeExecutionGetDataResponse::set_allocated_inputs(::flyteidl::admin::UrlBlob* inputs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(inputs_);
  }
  if (inputs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(inputs));
    if (message_arena != submessage_arena) {
      inputs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, inputs, submessage_arena);
    }
    
  } else {
    
  }
  inputs_ = inputs;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.NodeExecutionGetDataResponse.inputs)
}

// .flyteidl.admin.UrlBlob outputs = 2 [json_name = "outputs", deprecated = true];
inline bool NodeExecutionGetDataResponse::_internal_has_outputs() const {
  return this != internal_default_instance() && outputs_ != nullptr;
}
inline bool NodeExecutionGetDataResponse::has_outputs() const {
  return _internal_has_outputs();
}
inline const ::flyteidl::admin::UrlBlob& NodeExecutionGetDataResponse::_internal_outputs() const {
  const ::flyteidl::admin::UrlBlob* p = outputs_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::admin::UrlBlob&>(
      ::flyteidl::admin::_UrlBlob_default_instance_);
}
inline const ::flyteidl::admin::UrlBlob& NodeExecutionGetDataResponse::outputs() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NodeExecutionGetDataResponse.outputs)
  return _internal_outputs();
}
inline void NodeExecutionGetDataResponse::unsafe_arena_set_allocated_outputs(
    ::flyteidl::admin::UrlBlob* outputs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(outputs_);
  }
  outputs_ = outputs;
  if (outputs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.NodeExecutionGetDataResponse.outputs)
}
inline ::flyteidl::admin::UrlBlob* NodeExecutionGetDataResponse::release_outputs() {
  
  ::flyteidl::admin::UrlBlob* temp = outputs_;
  outputs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::admin::UrlBlob* NodeExecutionGetDataResponse::unsafe_arena_release_outputs() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.NodeExecutionGetDataResponse.outputs)
  
  ::flyteidl::admin::UrlBlob* temp = outputs_;
  outputs_ = nullptr;
  return temp;
}
inline ::flyteidl::admin::UrlBlob* NodeExecutionGetDataResponse::_internal_mutable_outputs() {
  
  if (outputs_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::admin::UrlBlob>(GetArenaForAllocation());
    outputs_ = p;
  }
  return outputs_;
}
inline ::flyteidl::admin::UrlBlob* NodeExecutionGetDataResponse::mutable_outputs() {
  ::flyteidl::admin::UrlBlob* _msg = _internal_mutable_outputs();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.NodeExecutionGetDataResponse.outputs)
  return _msg;
}
inline void NodeExecutionGetDataResponse::set_allocated_outputs(::flyteidl::admin::UrlBlob* outputs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(outputs_);
  }
  if (outputs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(outputs));
    if (message_arena != submessage_arena) {
      outputs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, outputs, submessage_arena);
    }
    
  } else {
    
  }
  outputs_ = outputs;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.NodeExecutionGetDataResponse.outputs)
}

// .flyteidl.core.LiteralMap full_inputs = 3 [json_name = "fullInputs"];
inline bool NodeExecutionGetDataResponse::_internal_has_full_inputs() const {
  return this != internal_default_instance() && full_inputs_ != nullptr;
}
inline bool NodeExecutionGetDataResponse::has_full_inputs() const {
  return _internal_has_full_inputs();
}
inline const ::flyteidl::core::LiteralMap& NodeExecutionGetDataResponse::_internal_full_inputs() const {
  const ::flyteidl::core::LiteralMap* p = full_inputs_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::core::LiteralMap&>(
      ::flyteidl::core::_LiteralMap_default_instance_);
}
inline const ::flyteidl::core::LiteralMap& NodeExecutionGetDataResponse::full_inputs() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NodeExecutionGetDataResponse.full_inputs)
  return _internal_full_inputs();
}
inline void NodeExecutionGetDataResponse::unsafe_arena_set_allocated_full_inputs(
    ::flyteidl::core::LiteralMap* full_inputs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(full_inputs_);
  }
  full_inputs_ = full_inputs;
  if (full_inputs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.NodeExecutionGetDataResponse.full_inputs)
}
inline ::flyteidl::core::LiteralMap* NodeExecutionGetDataResponse::release_full_inputs() {
  
  ::flyteidl::core::LiteralMap* temp = full_inputs_;
  full_inputs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::core::LiteralMap* NodeExecutionGetDataResponse::unsafe_arena_release_full_inputs() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.NodeExecutionGetDataResponse.full_inputs)
  
  ::flyteidl::core::LiteralMap* temp = full_inputs_;
  full_inputs_ = nullptr;
  return temp;
}
inline ::flyteidl::core::LiteralMap* NodeExecutionGetDataResponse::_internal_mutable_full_inputs() {
  
  if (full_inputs_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::LiteralMap>(GetArenaForAllocation());
    full_inputs_ = p;
  }
  return full_inputs_;
}
inline ::flyteidl::core::LiteralMap* NodeExecutionGetDataResponse::mutable_full_inputs() {
  ::flyteidl::core::LiteralMap* _msg = _internal_mutable_full_inputs();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.NodeExecutionGetDataResponse.full_inputs)
  return _msg;
}
inline void NodeExecutionGetDataResponse::set_allocated_full_inputs(::flyteidl::core::LiteralMap* full_inputs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(full_inputs_);
  }
  if (full_inputs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(full_inputs));
    if (message_arena != submessage_arena) {
      full_inputs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, full_inputs, submessage_arena);
    }
    
  } else {
    
  }
  full_inputs_ = full_inputs;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.NodeExecutionGetDataResponse.full_inputs)
}

// .flyteidl.core.LiteralMap full_outputs = 4 [json_name = "fullOutputs"];
inline bool NodeExecutionGetDataResponse::_internal_has_full_outputs() const {
  return this != internal_default_instance() && full_outputs_ != nullptr;
}
inline bool NodeExecutionGetDataResponse::has_full_outputs() const {
  return _internal_has_full_outputs();
}
inline const ::flyteidl::core::LiteralMap& NodeExecutionGetDataResponse::_internal_full_outputs() const {
  const ::flyteidl::core::LiteralMap* p = full_outputs_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::core::LiteralMap&>(
      ::flyteidl::core::_LiteralMap_default_instance_);
}
inline const ::flyteidl::core::LiteralMap& NodeExecutionGetDataResponse::full_outputs() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NodeExecutionGetDataResponse.full_outputs)
  return _internal_full_outputs();
}
inline void NodeExecutionGetDataResponse::unsafe_arena_set_allocated_full_outputs(
    ::flyteidl::core::LiteralMap* full_outputs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(full_outputs_);
  }
  full_outputs_ = full_outputs;
  if (full_outputs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.NodeExecutionGetDataResponse.full_outputs)
}
inline ::flyteidl::core::LiteralMap* NodeExecutionGetDataResponse::release_full_outputs() {
  
  ::flyteidl::core::LiteralMap* temp = full_outputs_;
  full_outputs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::core::LiteralMap* NodeExecutionGetDataResponse::unsafe_arena_release_full_outputs() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.NodeExecutionGetDataResponse.full_outputs)
  
  ::flyteidl::core::LiteralMap* temp = full_outputs_;
  full_outputs_ = nullptr;
  return temp;
}
inline ::flyteidl::core::LiteralMap* NodeExecutionGetDataResponse::_internal_mutable_full_outputs() {
  
  if (full_outputs_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::LiteralMap>(GetArenaForAllocation());
    full_outputs_ = p;
  }
  return full_outputs_;
}
inline ::flyteidl::core::LiteralMap* NodeExecutionGetDataResponse::mutable_full_outputs() {
  ::flyteidl::core::LiteralMap* _msg = _internal_mutable_full_outputs();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.NodeExecutionGetDataResponse.full_outputs)
  return _msg;
}
inline void NodeExecutionGetDataResponse::set_allocated_full_outputs(::flyteidl::core::LiteralMap* full_outputs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(full_outputs_);
  }
  if (full_outputs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(full_outputs));
    if (message_arena != submessage_arena) {
      full_outputs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, full_outputs, submessage_arena);
    }
    
  } else {
    
  }
  full_outputs_ = full_outputs;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.NodeExecutionGetDataResponse.full_outputs)
}

// .flyteidl.admin.DynamicWorkflowNodeMetadata dynamic_workflow = 16 [json_name = "dynamicWorkflow"];
inline bool NodeExecutionGetDataResponse::_internal_has_dynamic_workflow() const {
  return this != internal_default_instance() && dynamic_workflow_ != nullptr;
}
inline bool NodeExecutionGetDataResponse::has_dynamic_workflow() const {
  return _internal_has_dynamic_workflow();
}
inline void NodeExecutionGetDataResponse::clear_dynamic_workflow() {
  if (GetArenaForAllocation() == nullptr && dynamic_workflow_ != nullptr) {
    delete dynamic_workflow_;
  }
  dynamic_workflow_ = nullptr;
}
inline const ::flyteidl::admin::DynamicWorkflowNodeMetadata& NodeExecutionGetDataResponse::_internal_dynamic_workflow() const {
  const ::flyteidl::admin::DynamicWorkflowNodeMetadata* p = dynamic_workflow_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::admin::DynamicWorkflowNodeMetadata&>(
      ::flyteidl::admin::_DynamicWorkflowNodeMetadata_default_instance_);
}
inline const ::flyteidl::admin::DynamicWorkflowNodeMetadata& NodeExecutionGetDataResponse::dynamic_workflow() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NodeExecutionGetDataResponse.dynamic_workflow)
  return _internal_dynamic_workflow();
}
inline void NodeExecutionGetDataResponse::unsafe_arena_set_allocated_dynamic_workflow(
    ::flyteidl::admin::DynamicWorkflowNodeMetadata* dynamic_workflow) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dynamic_workflow_);
  }
  dynamic_workflow_ = dynamic_workflow;
  if (dynamic_workflow) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.NodeExecutionGetDataResponse.dynamic_workflow)
}
inline ::flyteidl::admin::DynamicWorkflowNodeMetadata* NodeExecutionGetDataResponse::release_dynamic_workflow() {
  
  ::flyteidl::admin::DynamicWorkflowNodeMetadata* temp = dynamic_workflow_;
  dynamic_workflow_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::admin::DynamicWorkflowNodeMetadata* NodeExecutionGetDataResponse::unsafe_arena_release_dynamic_workflow() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.NodeExecutionGetDataResponse.dynamic_workflow)
  
  ::flyteidl::admin::DynamicWorkflowNodeMetadata* temp = dynamic_workflow_;
  dynamic_workflow_ = nullptr;
  return temp;
}
inline ::flyteidl::admin::DynamicWorkflowNodeMetadata* NodeExecutionGetDataResponse::_internal_mutable_dynamic_workflow() {
  
  if (dynamic_workflow_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::admin::DynamicWorkflowNodeMetadata>(GetArenaForAllocation());
    dynamic_workflow_ = p;
  }
  return dynamic_workflow_;
}
inline ::flyteidl::admin::DynamicWorkflowNodeMetadata* NodeExecutionGetDataResponse::mutable_dynamic_workflow() {
  ::flyteidl::admin::DynamicWorkflowNodeMetadata* _msg = _internal_mutable_dynamic_workflow();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.NodeExecutionGetDataResponse.dynamic_workflow)
  return _msg;
}
inline void NodeExecutionGetDataResponse::set_allocated_dynamic_workflow(::flyteidl::admin::DynamicWorkflowNodeMetadata* dynamic_workflow) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete dynamic_workflow_;
  }
  if (dynamic_workflow) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::flyteidl::admin::DynamicWorkflowNodeMetadata>::GetOwningArena(dynamic_workflow);
    if (message_arena != submessage_arena) {
      dynamic_workflow = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dynamic_workflow, submessage_arena);
    }
    
  } else {
    
  }
  dynamic_workflow_ = dynamic_workflow;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.NodeExecutionGetDataResponse.dynamic_workflow)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace admin
}  // namespace flyteidl

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_flyteidl_2fadmin_2fnode_5fexecution_2eproto
