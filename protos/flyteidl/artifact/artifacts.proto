syntax = "proto3";
package flyteidl.artifact;

option go_package = "github.com/flyteorg/flyteidl/gen/pb-go/flyteidl/artifact";

import "flyteidl/core/literals.proto";
import "flyteidl/core/types.proto";
import "flyteidl/core/identifier.proto";


message Artifact {
  core.ArtifactID artifact_id = 1;

  ArtifactSpec spec = 2;

  // references the tag field in ArtifactTag
  repeated string tags = 3;
}

message CreateArtifactRequest {
  // Specify just project/domain on creation
  core.ArtifactKey artifact_key = 1;

  string version = 3;

  ArtifactSpec spec = 2;

  map<string, string> partitions = 4;

  string tag = 5;
}

message ArtifactSpec {
  core.Literal value = 1;

  // This type will not form part of the artifact key, so for user-named artifacts, if the user changes the type, but
  // forgets to change the name, that is okay. And the reason why this is a separate field is because adding the
  // type to all Literals is a lot of work.
  core.LiteralType type = 2;

  oneof source {
    // Outputs of tasks will have this.
    core.TaskExecutionIdentifier task_execution = 5;

    // Workflow outputs will have this.
    core.WorkflowExecutionIdentifier execution = 6;

    // Uploads, either from the UI or from the CLI, or FlyteRemote, will have this.
    string principal = 7;
  }

  string short_description = 8;
  string long_description = 9;
}


message CreateArtifactResponse {
  Artifact artifact = 1;
}

message GetArtifactRequest {
  oneof identifier {
    core.ArtifactID artifact_id = 1;
    string uri = 3;
    core.ArtifactQuery query = 4;
  }

  // If false, then long_description is not returned.
  bool details = 5;
}

message GetArtifactResponse {
  Artifact artifact = 1;
}

message ListArtifactNamesRequest {
  string project = 1;
  string domain = 2;
}

message ListArtifactNamesResponse {
  repeated core.ArtifactKey artifact_keys = 1;
}

message ListArtifactsRequest {
  core.ArtifactKey artifact_key = 1;
}

message ListArtifactsResponse {
  repeated Artifact artifacts = 1;
}

// Aliases identify a particular version of an artifact. They are different than tags in that they
// have to be unique for a given artifact project/domain/name. That is, for a given project/domain/name/kind,
// at most one version can have any given value at any point.
message AddTagRequest {
  core.ArtifactID artifact_id = 1;

  string value = 2;

  // If true, and another version already has the specified kind/value, set this version instead
  bool overwrite = 3;
}

message AddTagResponse {}

service ArtifactRegistry {
  rpc CreateArtifact (CreateArtifactRequest) returns (CreateArtifactResponse) {}

  rpc GetArtifact (GetArtifactRequest) returns (GetArtifactResponse) {}

  rpc ListArtifactNames (ListArtifactNamesRequest) returns (ListArtifactNamesResponse) {}

  rpc ListArtifacts (ListArtifactsRequest) returns (ListArtifactsResponse) {}

  rpc AddTag(AddTagRequest) returns (AddTagResponse) {}
}
