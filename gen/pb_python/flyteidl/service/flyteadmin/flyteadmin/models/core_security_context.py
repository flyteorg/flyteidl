# coding: utf-8

"""
    flyteidl/service/admin.proto

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)  # noqa: E501

    OpenAPI spec version: version not set
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


import pprint
import re  # noqa: F401

import six

from flyteadmin.models.core_identity import CoreIdentity  # noqa: F401,E501
from flyteadmin.models.core_o_auth2_token_request import CoreOAuth2TokenRequest  # noqa: F401,E501
from flyteadmin.models.core_secret import CoreSecret  # noqa: F401,E501


class CoreSecurityContext(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """

    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'run_as': 'CoreIdentity',
        'secrets': 'list[CoreSecret]',
        'tokens': 'list[CoreOAuth2TokenRequest]'
    }

    attribute_map = {
        'run_as': 'run_as',
        'secrets': 'secrets',
        'tokens': 'tokens'
    }

    def __init__(self, run_as=None, secrets=None, tokens=None):  # noqa: E501
        """CoreSecurityContext - a model defined in Swagger"""  # noqa: E501

        self._run_as = None
        self._secrets = None
        self._tokens = None
        self.discriminator = None

        if run_as is not None:
            self.run_as = run_as
        if secrets is not None:
            self.secrets = secrets
        if tokens is not None:
            self.tokens = tokens

    @property
    def run_as(self):
        """Gets the run_as of this CoreSecurityContext.  # noqa: E501

        run_as encapsulates the identity a pod should run as. If the task fills in multiple fields here, it'll be up to the backend plugin to choose the appropriate identity for the execution engine the task will run on.  # noqa: E501

        :return: The run_as of this CoreSecurityContext.  # noqa: E501
        :rtype: CoreIdentity
        """
        return self._run_as

    @run_as.setter
    def run_as(self, run_as):
        """Sets the run_as of this CoreSecurityContext.

        run_as encapsulates the identity a pod should run as. If the task fills in multiple fields here, it'll be up to the backend plugin to choose the appropriate identity for the execution engine the task will run on.  # noqa: E501

        :param run_as: The run_as of this CoreSecurityContext.  # noqa: E501
        :type: CoreIdentity
        """

        self._run_as = run_as

    @property
    def secrets(self):
        """Gets the secrets of this CoreSecurityContext.  # noqa: E501

        secrets indicate the list of secrets the task needs in order to proceed. Secrets will be mounted/passed to the pod as it starts. If the plugin responsible for kicking of the task will not run it on a flyte cluster (e.g. AWS Batch), it's the responsibility of the plugin to fetch the secret (which means propeller identity will need access to the secret) and to pass it to the remote execution engine.  # noqa: E501

        :return: The secrets of this CoreSecurityContext.  # noqa: E501
        :rtype: list[CoreSecret]
        """
        return self._secrets

    @secrets.setter
    def secrets(self, secrets):
        """Sets the secrets of this CoreSecurityContext.

        secrets indicate the list of secrets the task needs in order to proceed. Secrets will be mounted/passed to the pod as it starts. If the plugin responsible for kicking of the task will not run it on a flyte cluster (e.g. AWS Batch), it's the responsibility of the plugin to fetch the secret (which means propeller identity will need access to the secret) and to pass it to the remote execution engine.  # noqa: E501

        :param secrets: The secrets of this CoreSecurityContext.  # noqa: E501
        :type: list[CoreSecret]
        """

        self._secrets = secrets

    @property
    def tokens(self):
        """Gets the tokens of this CoreSecurityContext.  # noqa: E501

        tokens indicate the list of token requests the task needs in order to proceed. Tokens will be mounted/passed to the pod as it starts. If the plugin responsible for kicking of the task will not run it on a flyte cluster (e.g. AWS Batch), it's the responsibility of the plugin to fetch the secret (which means propeller identity will need access to the secret) and to pass it to the remote execution engine.  # noqa: E501

        :return: The tokens of this CoreSecurityContext.  # noqa: E501
        :rtype: list[CoreOAuth2TokenRequest]
        """
        return self._tokens

    @tokens.setter
    def tokens(self, tokens):
        """Sets the tokens of this CoreSecurityContext.

        tokens indicate the list of token requests the task needs in order to proceed. Tokens will be mounted/passed to the pod as it starts. If the plugin responsible for kicking of the task will not run it on a flyte cluster (e.g. AWS Batch), it's the responsibility of the plugin to fetch the secret (which means propeller identity will need access to the secret) and to pass it to the remote execution engine.  # noqa: E501

        :param tokens: The tokens of this CoreSecurityContext.  # noqa: E501
        :type: list[CoreOAuth2TokenRequest]
        """

        self._tokens = tokens

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(CoreSecurityContext, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, CoreSecurityContext):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
