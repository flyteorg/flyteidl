{
  "swagger": "2.0",
  "info": {
    "title": "flyteidl/artifact/artifacts.proto",
    "version": "version not set"
  },
  "schemes": [
    "http",
    "https"
  ],
  "consumes": [
    "application/json"
  ],
  "produces": [
    "application/json"
  ],
  "paths": {},
  "definitions": {
    "BlobTypeBlobDimensionality": {
      "type": "string",
      "enum": [
        "SINGLE",
        "MULTIPART"
      ],
      "default": "SINGLE"
    },
    "OAuth2TokenRequestType": {
      "type": "string",
      "enum": [
        "CLIENT_CREDENTIALS"
      ],
      "default": "CLIENT_CREDENTIALS",
      "description": "Type of the token requested.\n\n - CLIENT_CREDENTIALS: CLIENT_CREDENTIALS indicates a 2-legged OAuth token requested using client credentials."
    },
    "QualityOfServiceTier": {
      "type": "string",
      "enum": [
        "UNDEFINED",
        "HIGH",
        "MEDIUM",
        "LOW"
      ],
      "default": "UNDEFINED",
      "description": " - UNDEFINED: Default: no quality of service specified."
    },
    "SchemaColumnSchemaColumnType": {
      "type": "string",
      "enum": [
        "INTEGER",
        "FLOAT",
        "STRING",
        "BOOLEAN",
        "DATETIME",
        "DURATION"
      ],
      "default": "INTEGER"
    },
    "SchemaTypeSchemaColumn": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "title": "A unique name -within the schema type- for the column"
        },
        "type": {
          "$ref": "#/definitions/SchemaColumnSchemaColumnType",
          "description": "The column type. This allows a limited set of types currently."
        }
      }
    },
    "SecretMountType": {
      "type": "string",
      "enum": [
        "ANY",
        "ENV_VAR",
        "FILE"
      ],
      "default": "ANY",
      "description": " - ANY: Default case, indicates the client can tolerate either mounting options.\n - ENV_VAR: ENV_VAR indicates the secret needs to be mounted as an environment variable.\n - FILE: FILE indicates the secret needs to be mounted as a file."
    },
    "StructuredDatasetTypeDatasetColumn": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "A unique name within the schema type for the column."
        },
        "literal_type": {
          "$ref": "#/definitions/coreLiteralType",
          "description": "The column type."
        }
      }
    },
    "adminAnnotations": {
      "type": "object",
      "properties": {
        "values": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Map of custom annotations to be applied to the execution resource."
        }
      },
      "description": "Annotation values to be applied to an execution resource.\nIn the future a mode (e.g. OVERRIDE, APPEND, etc) can be defined\nto specify how to merge annotations defined at registration and execution time."
    },
    "adminAuth": {
      "type": "object",
      "properties": {
        "assumable_iam_role": {
          "type": "string",
          "description": "Defines an optional iam role which will be used for tasks run in executions created with this launch plan."
        },
        "kubernetes_service_account": {
          "type": "string",
          "description": "Defines an optional kubernetes service account which will be used for tasks run in executions created with this launch plan."
        }
      },
      "description": "Defines permissions associated with executions created by this launch plan spec.\nUse either of these roles when they have permissions required by your workflow execution.\nDeprecated."
    },
    "adminAuthRole": {
      "type": "object",
      "properties": {
        "assumable_iam_role": {
          "type": "string",
          "description": "Defines an optional iam role which will be used for tasks run in executions created with this launch plan."
        },
        "kubernetes_service_account": {
          "type": "string",
          "description": "Defines an optional kubernetes service account which will be used for tasks run in executions created with this launch plan."
        }
      },
      "description": "Defines permissions associated with executions created by this launch plan spec.\nUse either of these roles when they have permissions required by your workflow execution.\nDeprecated."
    },
    "adminCronSchedule": {
      "type": "object",
      "properties": {
        "schedule": {
          "type": "string",
          "title": "Standard/default cron implementation as described by https://en.wikipedia.org/wiki/Cron#CRON_expression;\nAlso supports nonstandard predefined scheduling definitions\nas described by https://docs.aws.amazon.com/AmazonCloudWatch/latest/events/ScheduledEvents.html#CronExpressions\nexcept @reboot"
        },
        "offset": {
          "type": "string",
          "title": "ISO 8601 duration as described by https://en.wikipedia.org/wiki/ISO_8601#Durations"
        }
      },
      "description": "Options for schedules to run according to a cron expression."
    },
    "adminEmailNotification": {
      "type": "object",
      "properties": {
        "recipients_email": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "The list of email addresses recipients for this notification.\n+required"
        }
      },
      "description": "Defines an email notification specification."
    },
    "adminEnvs": {
      "type": "object",
      "properties": {
        "values": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/coreKeyValuePair"
          },
          "description": "Map of custom environment variables to be applied to the execution resource."
        }
      },
      "description": "Environment variable values to be applied to an execution resource.\nIn the future a mode (e.g. OVERRIDE, APPEND, etc) can be defined\nto specify how to merge environment variables defined at registration and execution time."
    },
    "adminFixedRate": {
      "type": "object",
      "properties": {
        "value": {
          "type": "integer",
          "format": "int64"
        },
        "unit": {
          "$ref": "#/definitions/adminFixedRateUnit"
        }
      },
      "description": "Option for schedules run at a certain frequency e.g. every 2 minutes."
    },
    "adminFixedRateUnit": {
      "type": "string",
      "enum": [
        "MINUTE",
        "HOUR",
        "DAY"
      ],
      "default": "MINUTE",
      "description": "Represents a frequency at which to run a schedule."
    },
    "adminLabels": {
      "type": "object",
      "properties": {
        "values": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Map of custom labels to be applied to the execution resource."
        }
      },
      "description": "Label values to be applied to an execution resource.\nIn the future a mode (e.g. OVERRIDE, APPEND, etc) can be defined\nto specify how to merge labels defined at registration and execution time."
    },
    "adminLaunchPlan": {
      "type": "object",
      "properties": {
        "id": {
          "$ref": "#/definitions/coreIdentifier",
          "description": "Uniquely identifies a launch plan entity."
        },
        "spec": {
          "$ref": "#/definitions/adminLaunchPlanSpec",
          "description": "User-provided launch plan details, including reference workflow, inputs and other metadata."
        },
        "closure": {
          "$ref": "#/definitions/adminLaunchPlanClosure",
          "description": "Values computed by the flyte platform after launch plan registration."
        }
      },
      "description": "A LaunchPlan provides the capability to templatize workflow executions.\nLaunch plans simplify associating one or more schedules, inputs and notifications with your workflows.\nLaunch plans can be shared and used to trigger executions with predefined inputs even when a workflow\ndefinition doesn't necessarily have a default value for said input."
    },
    "adminLaunchPlanClosure": {
      "type": "object",
      "properties": {
        "state": {
          "$ref": "#/definitions/adminLaunchPlanState",
          "description": "Indicate the Launch plan state."
        },
        "expected_inputs": {
          "$ref": "#/definitions/coreParameterMap",
          "title": "Indicates the set of inputs expected when creating an execution with the Launch plan"
        },
        "expected_outputs": {
          "$ref": "#/definitions/coreVariableMap",
          "title": "Indicates the set of outputs expected to be produced by creating an execution with the Launch plan"
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "Time at which the launch plan was created."
        },
        "updated_at": {
          "type": "string",
          "format": "date-time",
          "description": "Time at which the launch plan was last updated."
        }
      },
      "description": "Values computed by the flyte platform after launch plan registration.\nThese include expected_inputs required to be present in a CreateExecutionRequest\nto launch the reference workflow as well timestamp values associated with the launch plan."
    },
    "adminLaunchPlanMetadata": {
      "type": "object",
      "properties": {
        "schedule": {
          "$ref": "#/definitions/adminSchedule",
          "title": "Schedule to execute the Launch Plan"
        },
        "notifications": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/adminNotification"
          },
          "title": "List of notifications based on Execution status transitions"
        },
        "launch_conditions": {
          "$ref": "#/definitions/protobufAny",
          "title": "Additional metadata for how to launch the launch plan"
        }
      },
      "description": "Additional launch plan attributes included in the LaunchPlanSpec not strictly required to launch\nthe reference workflow."
    },
    "adminLaunchPlanSpec": {
      "type": "object",
      "properties": {
        "workflow_id": {
          "$ref": "#/definitions/coreIdentifier",
          "title": "Reference to the Workflow template that the launch plan references"
        },
        "entity_metadata": {
          "$ref": "#/definitions/adminLaunchPlanMetadata",
          "title": "Metadata for the Launch Plan"
        },
        "default_inputs": {
          "$ref": "#/definitions/coreParameterMap",
          "description": "Input values to be passed for the execution.\nThese can be overriden when an execution is created with this launch plan."
        },
        "fixed_inputs": {
          "$ref": "#/definitions/coreLiteralMap",
          "description": "Fixed, non-overridable inputs for the Launch Plan.\nThese can not be overriden when an execution is created with this launch plan."
        },
        "role": {
          "type": "string",
          "title": "String to indicate the role to use to execute the workflow underneath"
        },
        "labels": {
          "$ref": "#/definitions/adminLabels",
          "description": "Custom labels to be applied to the execution resource."
        },
        "annotations": {
          "$ref": "#/definitions/adminAnnotations",
          "description": "Custom annotations to be applied to the execution resource."
        },
        "auth": {
          "$ref": "#/definitions/adminAuth",
          "description": "Indicates the permission associated with workflow executions triggered with this launch plan."
        },
        "auth_role": {
          "$ref": "#/definitions/adminAuthRole"
        },
        "security_context": {
          "$ref": "#/definitions/coreSecurityContext",
          "title": "Indicates security context for permissions triggered with this launch plan"
        },
        "quality_of_service": {
          "$ref": "#/definitions/coreQualityOfService",
          "description": "Indicates the runtime priority of the execution."
        },
        "raw_output_data_config": {
          "$ref": "#/definitions/adminRawOutputDataConfig",
          "description": "Encapsulates user settings pertaining to offloaded data (i.e. Blobs, Schema, query data, etc.)."
        },
        "max_parallelism": {
          "type": "integer",
          "format": "int32",
          "description": "Controls the maximum number of tasknodes that can be run in parallel for the entire workflow.\nThis is useful to achieve fairness. Note: MapTasks are regarded as one unit,\nand parallelism/concurrency of MapTasks is independent from this."
        },
        "interruptible": {
          "type": "boolean",
          "format": "boolean",
          "description": "Allows for the interruptible flag of a workflow to be overwritten for a single execution.\nOmitting this field uses the workflow's value as a default.\nAs we need to distinguish between the field not being provided and its default value false, we have to use a wrapper\naround the bool field."
        },
        "overwrite_cache": {
          "type": "boolean",
          "format": "boolean",
          "description": "Allows for all cached values of a workflow and its tasks to be overwritten for a single execution.\nIf enabled, all calculations are performed even if cached results would be available, overwriting the stored\ndata once execution finishes successfully."
        },
        "envs": {
          "$ref": "#/definitions/adminEnvs",
          "description": "Environment variables to be set for the execution."
        }
      },
      "description": "User-provided launch plan definition and configuration values."
    },
    "adminLaunchPlanState": {
      "type": "string",
      "enum": [
        "INACTIVE",
        "ACTIVE"
      ],
      "default": "INACTIVE",
      "description": "By default any launch plan regardless of state can be used to launch a workflow execution.\nHowever, at most one version of a launch plan\n(e.g. a NamedEntityIdentifier set of shared project, domain and name values) can be\nactive at a time in regards to *schedules*. That is, at most one schedule in a NamedEntityIdentifier\ngroup will be observed and trigger executions at a defined cadence."
    },
    "adminNotification": {
      "type": "object",
      "properties": {
        "phases": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/coreWorkflowExecutionPhase"
          },
          "title": "A list of phases to which users can associate the notifications to.\n+required"
        },
        "email": {
          "$ref": "#/definitions/adminEmailNotification"
        },
        "pager_duty": {
          "$ref": "#/definitions/adminPagerDutyNotification"
        },
        "slack": {
          "$ref": "#/definitions/adminSlackNotification"
        }
      },
      "description": "Represents a structure for notifications based on execution status.\nThe notification content is configured within flyte admin but can be templatized.\nFuture iterations could expose configuring notifications with custom content."
    },
    "adminPagerDutyNotification": {
      "type": "object",
      "properties": {
        "recipients_email": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "Currently, PagerDuty notifications leverage email to trigger a notification.\n+required"
        }
      },
      "description": "Defines a pager duty notification specification."
    },
    "adminRawOutputDataConfig": {
      "type": "object",
      "properties": {
        "output_location_prefix": {
          "type": "string",
          "title": "Prefix for where offloaded data from user workflows will be written\ne.g. s3://bucket/key or s3://bucket/"
        }
      },
      "description": "Encapsulates user settings pertaining to offloaded data (i.e. Blobs, Schema, query data, etc.).\nSee https://github.com/flyteorg/flyte/issues/211 for more background information."
    },
    "adminSchedule": {
      "type": "object",
      "properties": {
        "cron_expression": {
          "type": "string",
          "title": "Uses AWS syntax: Minutes Hours Day-of-month Month Day-of-week Year\ne.g. for a schedule that runs every 15 minutes: 0/15 * * * ? *"
        },
        "rate": {
          "$ref": "#/definitions/adminFixedRate"
        },
        "cron_schedule": {
          "$ref": "#/definitions/adminCronSchedule"
        },
        "kickoff_time_input_arg": {
          "type": "string",
          "description": "Name of the input variable that the kickoff time will be supplied to when the workflow is kicked off."
        }
      },
      "description": "Defines complete set of information required to trigger an execution on a schedule."
    },
    "adminSlackNotification": {
      "type": "object",
      "properties": {
        "recipients_email": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "Currently, Slack notifications leverage email to trigger a notification.\n+required"
        }
      },
      "description": "Defines a slack notification specification."
    },
    "artifactAddTagResponse": {
      "type": "object"
    },
    "artifactArtifact": {
      "type": "object",
      "properties": {
        "artifact_id": {
          "$ref": "#/definitions/coreArtifactID"
        },
        "spec": {
          "$ref": "#/definitions/artifactArtifactSpec"
        },
        "tags": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "references the tag field in ArtifactTag"
        }
      }
    },
    "artifactArtifactConsumer": {
      "type": "object",
      "properties": {
        "entity_id": {
          "$ref": "#/definitions/coreIdentifier",
          "title": "These should all be launch plan IDs"
        },
        "inputs": {
          "$ref": "#/definitions/coreParameterMap"
        }
      }
    },
    "artifactArtifactProducer": {
      "type": "object",
      "properties": {
        "entity_id": {
          "$ref": "#/definitions/coreIdentifier",
          "description": "These can be tasks, and workflows. Keeping track of the launch plans that a given workflow has is purely in\nAdmin's domain."
        },
        "outputs": {
          "$ref": "#/definitions/coreVariableMap"
        }
      }
    },
    "artifactArtifactSpec": {
      "type": "object",
      "properties": {
        "value": {
          "$ref": "#/definitions/coreLiteral"
        },
        "type": {
          "$ref": "#/definitions/coreLiteralType",
          "description": "This type will not form part of the artifact key, so for user-named artifacts, if the user changes the type, but\nforgets to change the name, that is okay. And the reason why this is a separate field is because adding the\ntype to all Literals is a lot of work."
        },
        "task_execution": {
          "$ref": "#/definitions/coreTaskExecutionIdentifier",
          "description": "Outputs of tasks will have this."
        },
        "execution": {
          "$ref": "#/definitions/coreWorkflowExecutionIdentifier",
          "description": "Workflow outputs will have this."
        },
        "principal": {
          "type": "string",
          "description": "Uploads, either from the UI or from the CLI, or FlyteRemote, will have this."
        },
        "short_description": {
          "type": "string"
        },
        "long_description": {
          "type": "string"
        },
        "user_metadata": {
          "$ref": "#/definitions/protobufAny",
          "title": "Additional user metadata"
        }
      }
    },
    "artifactCreateArtifactResponse": {
      "type": "object",
      "properties": {
        "artifact": {
          "$ref": "#/definitions/artifactArtifact"
        }
      }
    },
    "artifactCreateTriggerResponse": {
      "type": "object"
    },
    "artifactDeleteTriggerResponse": {
      "type": "object"
    },
    "artifactGetArtifactResponse": {
      "type": "object",
      "properties": {
        "artifact": {
          "$ref": "#/definitions/artifactArtifact"
        }
      }
    },
    "artifactRegisterResponse": {
      "type": "object"
    },
    "coreArtifactBindingData": {
      "type": "object",
      "properties": {
        "index": {
          "type": "integer",
          "format": "int64"
        },
        "partition_key": {
          "type": "string",
          "title": "These two fields are only relevant in the partition value case"
        },
        "transform": {
          "type": "string"
        }
      },
      "title": "Only valid for triggers"
    },
    "coreArtifactID": {
      "type": "object",
      "properties": {
        "artifact_key": {
          "$ref": "#/definitions/coreArtifactKey"
        },
        "version": {
          "type": "string"
        },
        "partitions": {
          "$ref": "#/definitions/corePartitions"
        }
      }
    },
    "coreArtifactKey": {
      "type": "object",
      "properties": {
        "project": {
          "type": "string",
          "description": "Project and domain and suffix needs to be unique across a given artifact store."
        },
        "domain": {
          "type": "string"
        },
        "name": {
          "type": "string"
        }
      }
    },
    "coreArtifactQuery": {
      "type": "object",
      "properties": {
        "artifact_id": {
          "$ref": "#/definitions/coreArtifactID"
        },
        "artifact_tag": {
          "$ref": "#/definitions/coreArtifactTag"
        },
        "uri": {
          "type": "string"
        },
        "binding": {
          "$ref": "#/definitions/coreArtifactBindingData",
          "description": "This is used in the trigger case, where a user specifies a value for an input that is one of the triggering\nartifacts, or a partition value derived from a triggering artifact."
        }
      },
      "title": "Uniqueness constraints for Artifacts\n - project, domain, name, version, partitions\nOption 2 (tags are standalone, point to an individual artifact id):\n - project, domain, name, alias (points to one partition if partitioned)\n - project, domain, name, partition key, partition value"
    },
    "coreArtifactTag": {
      "type": "object",
      "properties": {
        "artifact_key": {
          "$ref": "#/definitions/coreArtifactKey"
        },
        "value": {
          "$ref": "#/definitions/coreLabelValue"
        }
      }
    },
    "coreBinary": {
      "type": "object",
      "properties": {
        "value": {
          "type": "string",
          "format": "byte"
        },
        "tag": {
          "type": "string"
        }
      },
      "description": "A simple byte array with a tag to help different parts of the system communicate about what is in the byte array.\nIt's strongly advisable that consumers of this type define a unique tag and validate the tag before parsing the data."
    },
    "coreBlob": {
      "type": "object",
      "properties": {
        "metadata": {
          "$ref": "#/definitions/coreBlobMetadata"
        },
        "uri": {
          "type": "string"
        }
      },
      "description": "Refers to an offloaded set of files. It encapsulates the type of the store and a unique uri for where the data is.\nThere are no restrictions on how the uri is formatted since it will depend on how to interact with the store."
    },
    "coreBlobMetadata": {
      "type": "object",
      "properties": {
        "type": {
          "$ref": "#/definitions/coreBlobType"
        }
      }
    },
    "coreBlobType": {
      "type": "object",
      "properties": {
        "format": {
          "type": "string",
          "title": "Format can be a free form string understood by SDK/UI etc like\ncsv, parquet etc"
        },
        "dimensionality": {
          "$ref": "#/definitions/BlobTypeBlobDimensionality"
        }
      },
      "title": "Defines type behavior for blob objects"
    },
    "coreEnumType": {
      "type": "object",
      "properties": {
        "values": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Predefined set of enum values."
        }
      },
      "description": "Enables declaring enum types, with predefined string values\nFor len(values) \u003e 0, the first value in the ordered list is regarded as the default value. If you wish\nTo provide no defaults, make the first value as undefined."
    },
    "coreError": {
      "type": "object",
      "properties": {
        "failed_node_id": {
          "type": "string",
          "description": "The node id that threw the error."
        },
        "message": {
          "type": "string",
          "description": "Error message thrown."
        }
      },
      "description": "Represents an error thrown from a node."
    },
    "coreIdentifier": {
      "type": "object",
      "properties": {
        "resource_type": {
          "$ref": "#/definitions/coreResourceType",
          "description": "Identifies the specific type of resource that this identifier corresponds to."
        },
        "project": {
          "type": "string",
          "description": "Name of the project the resource belongs to."
        },
        "domain": {
          "type": "string",
          "description": "Name of the domain the resource belongs to.\nA domain can be considered as a subset within a specific project."
        },
        "name": {
          "type": "string",
          "description": "User provided value for the resource."
        },
        "version": {
          "type": "string",
          "description": "Specific version of the resource."
        }
      },
      "description": "Encapsulation of fields that uniquely identifies a Flyte resource."
    },
    "coreIdentity": {
      "type": "object",
      "properties": {
        "iam_role": {
          "type": "string",
          "description": "iam_role references the fully qualified name of Identity \u0026 Access Management role to impersonate."
        },
        "k8s_service_account": {
          "type": "string",
          "description": "k8s_service_account references a kubernetes service account to impersonate."
        },
        "oauth2_client": {
          "$ref": "#/definitions/coreOAuth2Client",
          "description": "oauth2_client references an oauth2 client. Backend plugins can use this information to impersonate the client when\nmaking external calls."
        },
        "execution_identity": {
          "type": "string",
          "title": "execution_identity references the subject who makes the execution"
        }
      },
      "description": "Identity encapsulates the various security identities a task can run as. It's up to the underlying plugin to pick the\nright identity for the execution environment."
    },
    "coreInputBindingData": {
      "type": "object",
      "properties": {
        "var": {
          "type": "string"
        }
      }
    },
    "coreKeyValuePair": {
      "type": "object",
      "properties": {
        "key": {
          "type": "string",
          "description": "required."
        },
        "value": {
          "type": "string",
          "description": "+optional."
        }
      },
      "description": "A generic key value pair."
    },
    "coreLabelValue": {
      "type": "object",
      "properties": {
        "static_value": {
          "type": "string"
        },
        "triggered_binding": {
          "$ref": "#/definitions/coreArtifactBindingData"
        },
        "input_binding": {
          "$ref": "#/definitions/coreInputBindingData"
        }
      }
    },
    "coreLiteral": {
      "type": "object",
      "properties": {
        "scalar": {
          "$ref": "#/definitions/coreScalar",
          "description": "A simple value."
        },
        "collection": {
          "$ref": "#/definitions/coreLiteralCollection",
          "description": "A collection of literals to allow nesting."
        },
        "map": {
          "$ref": "#/definitions/coreLiteralMap",
          "description": "A map of strings to literals."
        },
        "hash": {
          "type": "string",
          "title": "A hash representing this literal.\nThis is used for caching purposes. For more details refer to RFC 1893\n(https://github.com/flyteorg/flyte/blob/master/rfc/system/1893-caching-of-offloaded-objects.md)"
        },
        "metadata": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Additional metadata for literals."
        }
      },
      "description": "A simple value. This supports any level of nesting (e.g. array of array of array of Blobs) as well as simple primitives."
    },
    "coreLiteralCollection": {
      "type": "object",
      "properties": {
        "literals": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/coreLiteral"
          }
        }
      },
      "description": "A collection of literals. This is a workaround since oneofs in proto messages cannot contain a repeated field."
    },
    "coreLiteralMap": {
      "type": "object",
      "properties": {
        "literals": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/coreLiteral"
          }
        }
      },
      "description": "A map of literals. This is a workaround since oneofs in proto messages cannot contain a repeated field."
    },
    "coreLiteralType": {
      "type": "object",
      "properties": {
        "simple": {
          "$ref": "#/definitions/coreSimpleType",
          "description": "A simple type that can be compared one-to-one with another."
        },
        "schema": {
          "$ref": "#/definitions/coreSchemaType",
          "description": "A complex type that requires matching of inner fields."
        },
        "collection_type": {
          "$ref": "#/definitions/coreLiteralType",
          "description": "Defines the type of the value of a collection. Only homogeneous collections are allowed."
        },
        "map_value_type": {
          "$ref": "#/definitions/coreLiteralType",
          "description": "Defines the type of the value of a map type. The type of the key is always a string."
        },
        "blob": {
          "$ref": "#/definitions/coreBlobType",
          "description": "A blob might have specialized implementation details depending on associated metadata."
        },
        "enum_type": {
          "$ref": "#/definitions/coreEnumType",
          "description": "Defines an enum with pre-defined string values."
        },
        "structured_dataset_type": {
          "$ref": "#/definitions/coreStructuredDatasetType",
          "title": "Generalized schema support"
        },
        "union_type": {
          "$ref": "#/definitions/coreUnionType",
          "description": "Defines an union type with pre-defined LiteralTypes."
        },
        "metadata": {
          "$ref": "#/definitions/protobufStruct",
          "description": "This field contains type metadata that is descriptive of the type, but is NOT considered in type-checking.  This might be used by\nconsumers to identify special behavior or display extended information for the type."
        },
        "annotation": {
          "$ref": "#/definitions/coreTypeAnnotation",
          "description": "This field contains arbitrary data that might have special semantic\nmeaning for the client but does not effect internal flyte behavior."
        },
        "structure": {
          "$ref": "#/definitions/coreTypeStructure",
          "description": "Hints to improve type matching."
        }
      },
      "description": "Defines a strong type to allow type checking between interfaces."
    },
    "coreNodeExecutionIdentifier": {
      "type": "object",
      "properties": {
        "node_id": {
          "type": "string"
        },
        "execution_id": {
          "$ref": "#/definitions/coreWorkflowExecutionIdentifier"
        }
      },
      "description": "Encapsulation of fields that identify a Flyte node execution entity."
    },
    "coreOAuth2Client": {
      "type": "object",
      "properties": {
        "client_id": {
          "type": "string",
          "title": "client_id is the public id for the client to use. The system will not perform any pre-auth validation that the\nsecret requested matches the client_id indicated here.\n+required"
        },
        "client_secret": {
          "$ref": "#/definitions/coreSecret",
          "title": "client_secret is a reference to the secret used to authenticate the OAuth2 client.\n+required"
        }
      },
      "description": "OAuth2Client encapsulates OAuth2 Client Credentials to be used when making calls on behalf of that task."
    },
    "coreOAuth2TokenRequest": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "title": "name indicates a unique id for the token request within this task token requests. It'll be used as a suffix for\nenvironment variables and as a filename for mounting tokens as files.\n+required"
        },
        "type": {
          "$ref": "#/definitions/OAuth2TokenRequestType",
          "title": "type indicates the type of the request to make. Defaults to CLIENT_CREDENTIALS.\n+required"
        },
        "client": {
          "$ref": "#/definitions/coreOAuth2Client",
          "title": "client references the client_id/secret to use to request the OAuth2 token.\n+required"
        },
        "idp_discovery_endpoint": {
          "type": "string",
          "title": "idp_discovery_endpoint references the discovery endpoint used to retrieve token endpoint and other related\ninformation.\n+optional"
        },
        "token_endpoint": {
          "type": "string",
          "title": "token_endpoint references the token issuance endpoint. If idp_discovery_endpoint is not provided, this parameter is\nmandatory.\n+optional"
        }
      },
      "description": "OAuth2TokenRequest encapsulates information needed to request an OAuth2 token.\nFLYTE_TOKENS_ENV_PREFIX will be passed to indicate the prefix of the environment variables that will be present if\ntokens are passed through environment variables.\nFLYTE_TOKENS_PATH_PREFIX will be passed to indicate the prefix of the path where secrets will be mounted if tokens\nare passed through file mounts."
    },
    "coreParameter": {
      "type": "object",
      "properties": {
        "var": {
          "$ref": "#/definitions/coreVariable",
          "description": "+required Variable. Defines the type of the variable backing this parameter."
        },
        "default": {
          "$ref": "#/definitions/coreLiteral",
          "description": "Defines a default value that has to match the variable type defined."
        },
        "required": {
          "type": "boolean",
          "format": "boolean",
          "description": "+optional, is this value required to be filled."
        },
        "artifact_query": {
          "$ref": "#/definitions/coreArtifactQuery",
          "description": "This is an execution time search basically that should result in exactly one Artifact with a Type that\nmatches the type of the variable."
        },
        "artifact_id": {
          "$ref": "#/definitions/coreArtifactID"
        }
      },
      "description": "A parameter is used as input to a launch plan and has\nthe special ability to have a default value or mark itself as required."
    },
    "coreParameterMap": {
      "type": "object",
      "properties": {
        "parameters": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/coreParameter"
          },
          "description": "Defines a map of parameter names to parameters."
        }
      },
      "description": "A map of Parameters."
    },
    "corePartitions": {
      "type": "object",
      "properties": {
        "value": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/coreLabelValue"
          }
        }
      }
    },
    "corePrimitive": {
      "type": "object",
      "properties": {
        "integer": {
          "type": "string",
          "format": "int64"
        },
        "float_value": {
          "type": "number",
          "format": "double"
        },
        "string_value": {
          "type": "string"
        },
        "boolean": {
          "type": "boolean",
          "format": "boolean"
        },
        "datetime": {
          "type": "string",
          "format": "date-time"
        },
        "duration": {
          "type": "string"
        }
      },
      "title": "Primitive Types"
    },
    "coreQualityOfService": {
      "type": "object",
      "properties": {
        "tier": {
          "$ref": "#/definitions/QualityOfServiceTier"
        },
        "spec": {
          "$ref": "#/definitions/coreQualityOfServiceSpec"
        }
      },
      "description": "Indicates the priority of an execution."
    },
    "coreQualityOfServiceSpec": {
      "type": "object",
      "properties": {
        "queueing_budget": {
          "type": "string",
          "description": "Indicates how much queueing delay an execution can tolerate."
        }
      },
      "description": "Represents customized execution run-time attributes."
    },
    "coreResourceType": {
      "type": "string",
      "enum": [
        "UNSPECIFIED",
        "TASK",
        "WORKFLOW",
        "LAUNCH_PLAN",
        "DATASET"
      ],
      "default": "UNSPECIFIED",
      "description": "Indicates a resource type within Flyte.\n\n - DATASET: A dataset represents an entity modeled in Flyte DataCatalog. A Dataset is also a versioned entity and can be a compilation of multiple individual objects.\nEventually all Catalog objects should be modeled similar to Flyte Objects. The Dataset entities makes it possible for the UI  and CLI to act on the objects \nin a similar manner to other Flyte objects"
    },
    "coreScalar": {
      "type": "object",
      "properties": {
        "primitive": {
          "$ref": "#/definitions/corePrimitive"
        },
        "blob": {
          "$ref": "#/definitions/coreBlob"
        },
        "binary": {
          "$ref": "#/definitions/coreBinary"
        },
        "schema": {
          "$ref": "#/definitions/coreSchema"
        },
        "none_type": {
          "$ref": "#/definitions/coreVoid"
        },
        "error": {
          "$ref": "#/definitions/coreError"
        },
        "generic": {
          "$ref": "#/definitions/protobufStruct"
        },
        "structured_dataset": {
          "$ref": "#/definitions/coreStructuredDataset"
        },
        "union": {
          "$ref": "#/definitions/coreUnion"
        }
      }
    },
    "coreSchema": {
      "type": "object",
      "properties": {
        "uri": {
          "type": "string"
        },
        "type": {
          "$ref": "#/definitions/coreSchemaType"
        }
      },
      "description": "A strongly typed schema that defines the interface of data retrieved from the underlying storage medium."
    },
    "coreSchemaType": {
      "type": "object",
      "properties": {
        "columns": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/SchemaTypeSchemaColumn"
          },
          "description": "A list of ordered columns this schema comprises of."
        }
      },
      "description": "Defines schema columns and types to strongly type-validate schemas interoperability."
    },
    "coreSecret": {
      "type": "object",
      "properties": {
        "group": {
          "type": "string",
          "title": "The name of the secret group where to find the key referenced below. For K8s secrets, this should be the name of\nthe v1/secret object. For Confidant, this should be the Credential name. For Vault, this should be the secret name.\nFor AWS Secret Manager, this should be the name of the secret.\n+required"
        },
        "group_version": {
          "type": "string",
          "title": "The group version to fetch. This is not supported in all secret management systems. It'll be ignored for the ones\nthat do not support it.\n+optional"
        },
        "key": {
          "type": "string",
          "title": "The name of the secret to mount. This has to match an existing secret in the system. It's up to the implementation\nof the secret management system to require case sensitivity. For K8s secrets, Confidant and Vault, this should\nmatch one of the keys inside the secret. For AWS Secret Manager, it's ignored.\n+optional"
        },
        "mount_requirement": {
          "$ref": "#/definitions/SecretMountType",
          "title": "mount_requirement is optional. Indicates where the secret has to be mounted. If provided, the execution will fail\nif the underlying key management system cannot satisfy that requirement. If not provided, the default location\nwill depend on the key management system.\n+optional"
        }
      },
      "description": "Secret encapsulates information about the secret a task needs to proceed. An environment variable\nFLYTE_SECRETS_ENV_PREFIX will be passed to indicate the prefix of the environment variables that will be present if\nsecrets are passed through environment variables.\nFLYTE_SECRETS_DEFAULT_DIR will be passed to indicate the prefix of the path where secrets will be mounted if secrets\nare passed through file mounts."
    },
    "coreSecurityContext": {
      "type": "object",
      "properties": {
        "run_as": {
          "$ref": "#/definitions/coreIdentity",
          "description": "run_as encapsulates the identity a pod should run as. If the task fills in multiple fields here, it'll be up to the\nbackend plugin to choose the appropriate identity for the execution engine the task will run on."
        },
        "secrets": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/coreSecret"
          },
          "description": "secrets indicate the list of secrets the task needs in order to proceed. Secrets will be mounted/passed to the\npod as it starts. If the plugin responsible for kicking of the task will not run it on a flyte cluster (e.g. AWS\nBatch), it's the responsibility of the plugin to fetch the secret (which means propeller identity will need access\nto the secret) and to pass it to the remote execution engine."
        },
        "tokens": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/coreOAuth2TokenRequest"
          },
          "description": "tokens indicate the list of token requests the task needs in order to proceed. Tokens will be mounted/passed to the\npod as it starts. If the plugin responsible for kicking of the task will not run it on a flyte cluster (e.g. AWS\nBatch), it's the responsibility of the plugin to fetch the secret (which means propeller identity will need access\nto the secret) and to pass it to the remote execution engine."
        }
      },
      "description": "SecurityContext holds security attributes that apply to tasks."
    },
    "coreSimpleType": {
      "type": "string",
      "enum": [
        "NONE",
        "INTEGER",
        "FLOAT",
        "STRING",
        "BOOLEAN",
        "DATETIME",
        "DURATION",
        "BINARY",
        "ERROR",
        "STRUCT"
      ],
      "default": "NONE",
      "description": "Define a set of simple types."
    },
    "coreStructuredDataset": {
      "type": "object",
      "properties": {
        "uri": {
          "type": "string",
          "title": "String location uniquely identifying where the data is.\nShould start with the storage location (e.g. s3://, gs://, bq://, etc.)"
        },
        "metadata": {
          "$ref": "#/definitions/coreStructuredDatasetMetadata"
        }
      }
    },
    "coreStructuredDatasetMetadata": {
      "type": "object",
      "properties": {
        "structured_dataset_type": {
          "$ref": "#/definitions/coreStructuredDatasetType",
          "description": "Bundle the type information along with the literal.\nThis is here because StructuredDatasets can often be more defined at run time than at compile time.\nThat is, at compile time you might only declare a task to return a pandas dataframe or a StructuredDataset,\nwithout any column information, but at run time, you might have that column information.\nflytekit python will copy this type information into the literal, from the type information, if not provided by\nthe various plugins (encoders).\nSince this field is run time generated, it's not used for any type checking."
        }
      }
    },
    "coreStructuredDatasetType": {
      "type": "object",
      "properties": {
        "columns": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/StructuredDatasetTypeDatasetColumn"
          },
          "description": "A list of ordered columns this schema comprises of."
        },
        "format": {
          "type": "string",
          "description": "This is the storage format, the format of the bits at rest\nparquet, feather, csv, etc.\nFor two types to be compatible, the format will need to be an exact match."
        },
        "external_schema_type": {
          "type": "string",
          "description": "This is a string representing the type that the bytes in external_schema_bytes are formatted in.\nThis is an optional field that will not be used for type checking."
        },
        "external_schema_bytes": {
          "type": "string",
          "format": "byte",
          "description": "The serialized bytes of a third-party schema library like Arrow.\nThis is an optional field that will not be used for type checking."
        }
      }
    },
    "coreTaskExecutionIdentifier": {
      "type": "object",
      "properties": {
        "task_id": {
          "$ref": "#/definitions/coreIdentifier"
        },
        "node_execution_id": {
          "$ref": "#/definitions/coreNodeExecutionIdentifier"
        },
        "retry_attempt": {
          "type": "integer",
          "format": "int64"
        }
      },
      "description": "Encapsulation of fields that identify a Flyte task execution entity."
    },
    "coreTypeAnnotation": {
      "type": "object",
      "properties": {
        "annotations": {
          "$ref": "#/definitions/protobufStruct",
          "description": "A arbitrary JSON payload to describe a type."
        }
      },
      "description": "TypeAnnotation encapsulates registration time information about a type. This can be used for various control-plane operations. TypeAnnotation will not be available at runtime when a task runs."
    },
    "coreTypeStructure": {
      "type": "object",
      "properties": {
        "tag": {
          "type": "string",
          "title": "Must exactly match for types to be castable"
        }
      },
      "description": "Hints to improve type matching\ne.g. allows distinguishing output from custom type transformers\neven if the underlying IDL serialization matches."
    },
    "coreUnion": {
      "type": "object",
      "properties": {
        "value": {
          "$ref": "#/definitions/coreLiteral"
        },
        "type": {
          "$ref": "#/definitions/coreLiteralType"
        }
      },
      "description": "The runtime representation of a tagged union value. See `UnionType` for more details."
    },
    "coreUnionType": {
      "type": "object",
      "properties": {
        "variants": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/coreLiteralType"
          },
          "description": "Predefined set of variants in union."
        }
      },
      "description": "Defines a tagged union type, also known as a variant (and formally as the sum type).\n\nA sum type S is defined by a sequence of types (A, B, C, ...), each tagged by a string tag\nA value of type S is constructed from a value of any of the variant types. The specific choice of type is recorded by\nstoring the varaint's tag with the literal value and can be examined in runtime.\n\nType S is typically written as\nS := Apple A | Banana B | Cantaloupe C | ...\n\nNotably, a nullable (optional) type is a sum type between some type X and the singleton type representing a null-value:\nOptional X := X | Null\n\nSee also: https://en.wikipedia.org/wiki/Tagged_union"
    },
    "coreVariable": {
      "type": "object",
      "properties": {
        "type": {
          "$ref": "#/definitions/coreLiteralType",
          "description": "Variable literal type."
        },
        "description": {
          "type": "string",
          "title": "+optional string describing input variable"
        },
        "artifact_partial_id": {
          "$ref": "#/definitions/coreArtifactID",
          "description": "+optional This object allows the user to specify how Artifacts are created.\nname, tag, partitions can be specified. The other fields (version and project/domain) are ignored."
        },
        "artifact_tag": {
          "$ref": "#/definitions/coreArtifactTag"
        }
      },
      "description": "Defines a strongly typed variable."
    },
    "coreVariableMap": {
      "type": "object",
      "properties": {
        "variables": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/coreVariable"
          },
          "description": "Defines a map of variable names to variables."
        }
      },
      "title": "A map of Variables"
    },
    "coreVoid": {
      "type": "object",
      "description": "Used to denote a nil/null/None assignment to a scalar value. The underlying LiteralType for Void is intentionally\nundefined since it can be assigned to a scalar of any LiteralType."
    },
    "coreWorkflowExecutionIdentifier": {
      "type": "object",
      "properties": {
        "project": {
          "type": "string",
          "description": "Name of the project the resource belongs to."
        },
        "domain": {
          "type": "string",
          "description": "Name of the domain the resource belongs to.\nA domain can be considered as a subset within a specific project."
        },
        "name": {
          "type": "string",
          "description": "User or system provided value for the resource."
        }
      },
      "title": "Encapsulation of fields that uniquely identifies a Flyte workflow execution"
    },
    "coreWorkflowExecutionPhase": {
      "type": "string",
      "enum": [
        "UNDEFINED",
        "QUEUED",
        "RUNNING",
        "SUCCEEDING",
        "SUCCEEDED",
        "FAILING",
        "FAILED",
        "ABORTED",
        "TIMED_OUT",
        "ABORTING"
      ],
      "default": "UNDEFINED"
    },
    "protobufAny": {
      "type": "object",
      "properties": {
        "type_url": {
          "type": "string",
          "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
        },
        "value": {
          "type": "string",
          "format": "byte",
          "description": "Must be a valid serialized protocol buffer of the above specified type."
        }
      },
      "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(\u0026foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := \u0026pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := \u0026pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": \u003cstring\u003e,\n      \"lastName\": \u003cstring\u003e\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
    },
    "protobufListValue": {
      "type": "object",
      "properties": {
        "values": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/protobufValue"
          },
          "description": "Repeated field of dynamically typed values."
        }
      },
      "description": "`ListValue` is a wrapper around a repeated field of values.\n\nThe JSON representation for `ListValue` is JSON array."
    },
    "protobufNullValue": {
      "type": "string",
      "enum": [
        "NULL_VALUE"
      ],
      "default": "NULL_VALUE",
      "description": "`NullValue` is a singleton enumeration to represent the null value for the\n`Value` type union.\n\n The JSON representation for `NullValue` is JSON `null`.\n\n - NULL_VALUE: Null value."
    },
    "protobufStruct": {
      "type": "object",
      "properties": {
        "fields": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/protobufValue"
          },
          "description": "Unordered map of dynamically typed values."
        }
      },
      "description": "`Struct` represents a structured data value, consisting of fields\nwhich map to dynamically typed values. In some languages, `Struct`\nmight be supported by a native representation. For example, in\nscripting languages like JS a struct is represented as an\nobject. The details of that representation are described together\nwith the proto support for the language.\n\nThe JSON representation for `Struct` is JSON object."
    },
    "protobufValue": {
      "type": "object",
      "properties": {
        "null_value": {
          "$ref": "#/definitions/protobufNullValue",
          "description": "Represents a null value."
        },
        "number_value": {
          "type": "number",
          "format": "double",
          "description": "Represents a double value."
        },
        "string_value": {
          "type": "string",
          "description": "Represents a string value."
        },
        "bool_value": {
          "type": "boolean",
          "format": "boolean",
          "description": "Represents a boolean value."
        },
        "struct_value": {
          "$ref": "#/definitions/protobufStruct",
          "description": "Represents a structured value."
        },
        "list_value": {
          "$ref": "#/definitions/protobufListValue",
          "description": "Represents a repeated `Value`."
        }
      },
      "description": "`Value` represents a dynamically typed value which can be either\nnull, a number, a string, a boolean, a recursive struct value, or a\nlist of values. A producer of value is expected to set one of that\nvariants, absence of any variant indicates an error.\n\nThe JSON representation for `Value` is JSON value."
    }
  }
}
