syntax = "proto3";

package flyteidl.core;

option go_package = "github.com/flyteorg/flyteidl/gen/pb-go/flyteidl/core";

import "google/protobuf/struct.proto";

// Define a set of simple types.
enum SimpleType {
    NONE = 0;
    INTEGER = 1;
    FLOAT = 2;
    STRING = 3;
    BOOLEAN = 4;
    DATETIME = 5;
    DURATION = 6;
    BINARY = 7;
    ERROR = 8;
    STRUCT = 9;
}

// Defines schema columns and types to strongly type-validate schemas interoperability.
message SchemaType {
    message SchemaColumn {
        // A unique name -within the schema type- for the column
        string name = 1;

        enum SchemaColumnType {
            INTEGER = 0;
            FLOAT = 1;
            STRING = 2;
            BOOLEAN = 3;
            DATETIME = 4;
            DURATION = 5;
        }

        // The column type. This allows a limited set of types currently.
        SchemaColumnType type = 2;
    }

    // A list of ordered columns this schema comprises of.
    repeated SchemaColumn columns = 3;
}

// Defines type behavior for blob objects
message BlobType {
    enum BlobDimensionality {
        SINGLE = 0;
        MULTIPART = 1;
    }

    // Format can be a free form string understood by SDK/UI etc like
    // csv, parquet etc
    string format = 1;
    BlobDimensionality dimensionality = 2;
}

// Enables declaring enum types, with predefined string values
// For len(values) > 0, the first value in the ordered list is regarded as the default value. If you wish
// To provide no defaults, make the first value as undefined.
message EnumType {
    // Predefined set of enum values.
    repeated string values = 1;
}

// Defines a tagged union type, also known as a variant (and formally as the sum type).
//
// A sum type S is defined by a sequence of types (A, B, C, ...) (each tagged by its numerical position in the sequence)
// A value of type S is constructed from a value of any of the variant types. The specific choice of type is recorded by
// storing the varaint's tag (position in the sequence) with the literal value and can be examined in runtime.
//
// Type S is typically written as
// S := A | B | C | ...
// or as
// S := Apple A | Banana B | Cantaloupe C | ...
// if the tags are assigned some name (here arbitrarily chosen to be fruit).
//
// If the tags are ommitted, this implementation resolves ambiguities by choosing the earliest compatible variant type
// For example, a value of type `List (A | B) | List (B | C)` is constructed from a value of type `List B` by using
// the tag for the `List (A | B)` variant since it occurs before `List (B | C)` even though they are both compatible
// When converting from IDL back to the native implementation, the tag should not be relied upon to retrieve the correct output type
// because a value of type `A | B` with tag 0 must be compatible with type `B | A` despite the tag pointing to the wrong variant.
//
// Notably, a nullable (optional) type is a sum type between some type X and the singleton type representing a null-value:
// Optional X := X | Null
//
// Python's `typing.Union` is an example of a union type with no runtime representation.
// It allows ambiguous sum types such as `typing.Union[int, int]` and `Union[list[Union[a, b]], list[Union[b, c]]]`
// since the ambiguity does not influence whether the types are compatible in any way.
// When converting to IDL, runtime values of type-erased unions use the first-compatible rule.
//
// C++'s `std::variant` is an example of a tagged union where the tag is implicit in the order of the types.
// When converting to IDL, runtime values of implicitly-tagged unions should use the index of the variant as the tag.
//
// Haskell's sum types, as well as Rust's and Swift's "enum" types are examples of tagged union types where the tag is explicitly named.
// When converting to IDL, runtime values of explicitly-tagged unions should use the index of the variant as the tag.
// This means that IDL values do not follow language semantics in case the variants are rearranged as IDL values will no longer have the correct tag.
// ^ Haskell example: `Nothing` will have tag `1` for `Maybe a = Just a | Nothing` and tag `0` for `Maybe a = Nothing | Just a`
//                    the tags are incompatible despite the values being compatible by Haskell rules.
//
// See also: https://en.wikipedia.org/wiki/Tagged_union
message UnionType {
    // Predefined set of LiteralTypes in union.
    repeated LiteralType variants = 1;
}

// Defines a strong type to allow type checking between interfaces.
message LiteralType {
    oneof type {
        // A simple type that can be compared one-to-one with another.
        SimpleType simple = 1;

        // A complex type that requires matching of inner fields.
        SchemaType schema = 2;

        // Defines the type of the value of a collection. Only homogeneous collections are allowed.
        LiteralType collection_type = 3;

        // Defines the type of the value of a map type. The type of the key is always a string.
        LiteralType map_value_type = 4;

        // A blob might have specialized implementation details depending on associated metadata.
        BlobType blob = 5;

        // Defines an enum with pre-defined string values.
        EnumType enum_type = 7;

        // Defines an union type with pre-defined LiteralTypes.
        UnionType union_type = 8;
    }

    // This field contains type metadata that is descriptive of the type, but is NOT considered in type-checking.  This might be used by
    // consumers to identify special behavior or display extended information for the type.
    google.protobuf.Struct metadata = 6;
}

// A reference to an output produced by a node. The type can be retrieved -and validated- from
// the underlying interface of the node.
message OutputReference {
    // Node id must exist at the graph layer.
    string node_id = 1;

    // Variable name must refer to an output variable for the node.
    string var = 2;
}

// Represents an error thrown from a node.
message Error {
    // The node id that threw the error.
    string failed_node_id = 1;

    // Error message thrown.
    string message = 2;
}
