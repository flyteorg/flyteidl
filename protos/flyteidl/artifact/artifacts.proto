syntax = "proto3";
package flyteidl.artifact;

option go_package = "github.com/flyteorg/flyteidl/gen/pb-go/flyteidl/artifact";

import "flyteidl/core/literals.proto";
import "flyteidl/core/types.proto";
import "flyteidl/core/identifier.proto";


message Artifact {
  core.ArtifactID artifact_id = 1;

  // This has to be unique across the entire installation. For OSS, we will write the flyte url here for now.
  string uri = 4;

  ArtifactSpec spec = 5;
}

message CreateArtifactRequest {
  // Specify just project/domain on creation
  core.ArtifactKey artifact_key = 1;

  // If given, and conflicting, the request will be rejected.
  // Has to conform to some format, can't collide with the alias format.
  string uri = 2;

  ArtifactSpec spec = 4;
}

message ArtifactSpec {
  core.Literal value = 1;

  // This type will not form part of the artifact key, so for user-named artifacts, if the user changes the type, but
  // forgets to change the name, that is okay. And the reason why this is a separate field is because adding the
  // type to all Literals is a lot of work.
  core.LiteralType type = 2;

  // When you want to set tags on creation.
  repeated Tag tags = 3;

  // Set here when you want to set an alias on creation.
  // Aliases created will have the same project/domain as the artifact.
  repeated Alias aliases = 4;

  oneof source {
    // Outputs of tasks will have this.
    core.TaskExecutionIdentifier task_execution = 5;

    // Workflow outputs will have this.
    core.WorkflowExecutionIdentifier execution = 6;

    // Uploads, either from the UI or from the CLI, or FlyteRemote, will have this.
    string principal = 7;
  }

  string short_description = 8;
  string long_description = 9;
}

// have a bunch of artifacts. they have a project and domain
// This message is something that when coupled with the project and domain, uniquely identifies an artifact.
// so here, project, domain, name, value have to be unique
message Alias {
  // ties this directly to the artifact. do we worry about exposing this to the user? this is likely just the db ID.
  // we can add a uuid field in key (turning it into an ID) for a user facing id.
  string artifact_id = 1;
  // should we add artifactkey (aka project/domain) here?
  // If not adding - this implies that we will always have the same project/domain. You can have a projA/domainD
  // alias pointing to a projB/domainB artifact
  // Also aliases need to be unique on project/domain/alias name/alias value. This is effectively a primary key.
  string name = 2;
  string value = 3;
}

message ArtifactQuery {
  core.ArtifactKey artifact_key = 1;

  Alias alias = 2;
}


message CreateArtifactResponse {
  Artifact artifact = 1;
}

message GetArtifactRequest {
  oneof identifier {
    core.ArtifactID artifact_id = 1;

    string uri = 2;
  }

  // If false, then long_description is not returned.
  bool details = 3;
}

// Tags are general key/value pairs associated with an Artifact. They can be used to search and filter things.
// Tags have to be unique by key for a given artifact. That is, for a given project/domain/name/version/key, there
// can only be one value, obviously.
message Tag {
  // tag types can be user specified if they want, though we'd probably recommend sticking with some constants
  // that we embed in various libraries.
  string key = 1;
  string value = 2;
}

// Add tags on an artifact.
message AddTagsRequest {
  core.ArtifactID artifact_id = 1;

  // Why is this a repeated and not a map? Not sure. Just what ketan and I ended up on when we were quickly
  // hacking this out.
  repeated Tag tags = 2;
}

message AddTagsResponse {}

// Probably will not do value match. Just remove by key.
message RemoveTagsRequest {
  core.ArtifactID artifact_id = 1;

  repeated Tag tags = 2;  // can make these strings if necessary.
}

message RemoveTagsResponse {}

message ListArtifactNamesRequest {
  string project = 1;
  string domain = 2;
}

message ListArtifactNamesResponse {
  repeated core.ArtifactKey artifact_keys = 1;
}

message ListArtifactsRequest {
  core.ArtifactKey artifact_key = 1;
}

message ListArtifactsResponse {
  repeated Artifact artifacts = 1;
}

// Aliases identify a particular version of an artifact. They are different than tags in that they
// have to be unique for a given artifact project/domain/name. That is, for a given project/domain/name/kind,
// at most one version can have any given value at any point.
message CreateAliasRequest {
  core.ArtifactKey artifact_key = 1;

  Alias alias = 2;

  // If true, and another version already has the specified kind/value, set this version instead.
  bool overwrite = 3;
}

message CreateAliasResponse {}

// This removes an exact match only. That is, the kind/value in the Alias have to be set on the version for the
// given core.ArtifactKey.
message RemoveAliasRequest {
  core.ArtifactKey artifact_key = 1;
  Alias alias = 2;
}

message RemoveAliasResponse {}

service ArtifactRegistry {
  rpc CreateArtifact (CreateArtifactRequest) returns (CreateArtifactResponse) {}

  rpc GetArtifact (GetArtifactRequest) returns (Artifact) {}

  rpc ListArtifactNames (ListArtifactNamesRequest) returns (ListArtifactNamesResponse) {}

  rpc ListArtifacts (ListArtifactsRequest) returns (ListArtifactsResponse) {}

  rpc TagArtifact(AddTagsRequest) returns (AddTagsResponse) {}

  rpc RemoveTags(RemoveTagsRequest) returns (RemoveTagsResponse) {}

  rpc CreateAlias(CreateAliasRequest) returns (CreateAliasResponse) {}

  rpc RemoveAlias(RemoveAliasRequest) returns (RemoveAliasResponse) {}
}
