// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: flyteidl/artifact/artifacts.proto

#ifndef PROTOBUF_INCLUDED_flyteidl_2fartifact_2fartifacts_2eproto
#define PROTOBUF_INCLUDED_flyteidl_2fartifact_2fartifacts_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/any.pb.h>
#include "flyteidl/core/literals.pb.h"
#include "flyteidl/core/types.pb.h"
#include "flyteidl/core/identifier.pb.h"
#include "flyteidl/core/interface.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_flyteidl_2fartifact_2fartifacts_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_flyteidl_2fartifact_2fartifacts_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[23]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_flyteidl_2fartifact_2fartifacts_2eproto();
namespace flyteidl {
namespace artifact {
class AddTagRequest;
class AddTagRequestDefaultTypeInternal;
extern AddTagRequestDefaultTypeInternal _AddTagRequest_default_instance_;
class AddTagResponse;
class AddTagResponseDefaultTypeInternal;
extern AddTagResponseDefaultTypeInternal _AddTagResponse_default_instance_;
class Artifact;
class ArtifactDefaultTypeInternal;
extern ArtifactDefaultTypeInternal _Artifact_default_instance_;
class ArtifactConsumer;
class ArtifactConsumerDefaultTypeInternal;
extern ArtifactConsumerDefaultTypeInternal _ArtifactConsumer_default_instance_;
class ArtifactProducer;
class ArtifactProducerDefaultTypeInternal;
extern ArtifactProducerDefaultTypeInternal _ArtifactProducer_default_instance_;
class ArtifactSpec;
class ArtifactSpecDefaultTypeInternal;
extern ArtifactSpecDefaultTypeInternal _ArtifactSpec_default_instance_;
class CreateArtifactRequest;
class CreateArtifactRequestDefaultTypeInternal;
extern CreateArtifactRequestDefaultTypeInternal _CreateArtifactRequest_default_instance_;
class CreateArtifactRequest_PartitionsEntry_DoNotUse;
class CreateArtifactRequest_PartitionsEntry_DoNotUseDefaultTypeInternal;
extern CreateArtifactRequest_PartitionsEntry_DoNotUseDefaultTypeInternal _CreateArtifactRequest_PartitionsEntry_DoNotUse_default_instance_;
class CreateArtifactResponse;
class CreateArtifactResponseDefaultTypeInternal;
extern CreateArtifactResponseDefaultTypeInternal _CreateArtifactResponse_default_instance_;
class CreateTriggerRequest;
class CreateTriggerRequestDefaultTypeInternal;
extern CreateTriggerRequestDefaultTypeInternal _CreateTriggerRequest_default_instance_;
class CreateTriggerResponse;
class CreateTriggerResponseDefaultTypeInternal;
extern CreateTriggerResponseDefaultTypeInternal _CreateTriggerResponse_default_instance_;
class DeleteTriggerRequest;
class DeleteTriggerRequestDefaultTypeInternal;
extern DeleteTriggerRequestDefaultTypeInternal _DeleteTriggerRequest_default_instance_;
class DeleteTriggerResponse;
class DeleteTriggerResponseDefaultTypeInternal;
extern DeleteTriggerResponseDefaultTypeInternal _DeleteTriggerResponse_default_instance_;
class GetArtifactRequest;
class GetArtifactRequestDefaultTypeInternal;
extern GetArtifactRequestDefaultTypeInternal _GetArtifactRequest_default_instance_;
class GetArtifactResponse;
class GetArtifactResponseDefaultTypeInternal;
extern GetArtifactResponseDefaultTypeInternal _GetArtifactResponse_default_instance_;
class ListArtifactNamesRequest;
class ListArtifactNamesRequestDefaultTypeInternal;
extern ListArtifactNamesRequestDefaultTypeInternal _ListArtifactNamesRequest_default_instance_;
class ListArtifactNamesResponse;
class ListArtifactNamesResponseDefaultTypeInternal;
extern ListArtifactNamesResponseDefaultTypeInternal _ListArtifactNamesResponse_default_instance_;
class ListArtifactsRequest;
class ListArtifactsRequestDefaultTypeInternal;
extern ListArtifactsRequestDefaultTypeInternal _ListArtifactsRequest_default_instance_;
class ListArtifactsResponse;
class ListArtifactsResponseDefaultTypeInternal;
extern ListArtifactsResponseDefaultTypeInternal _ListArtifactsResponse_default_instance_;
class RegisterConsumerRequest;
class RegisterConsumerRequestDefaultTypeInternal;
extern RegisterConsumerRequestDefaultTypeInternal _RegisterConsumerRequest_default_instance_;
class RegisterProducerRequest;
class RegisterProducerRequestDefaultTypeInternal;
extern RegisterProducerRequestDefaultTypeInternal _RegisterProducerRequest_default_instance_;
class RegisterResponse;
class RegisterResponseDefaultTypeInternal;
extern RegisterResponseDefaultTypeInternal _RegisterResponse_default_instance_;
class Trigger;
class TriggerDefaultTypeInternal;
extern TriggerDefaultTypeInternal _Trigger_default_instance_;
}  // namespace artifact
}  // namespace flyteidl
namespace google {
namespace protobuf {
template<> ::flyteidl::artifact::AddTagRequest* Arena::CreateMaybeMessage<::flyteidl::artifact::AddTagRequest>(Arena*);
template<> ::flyteidl::artifact::AddTagResponse* Arena::CreateMaybeMessage<::flyteidl::artifact::AddTagResponse>(Arena*);
template<> ::flyteidl::artifact::Artifact* Arena::CreateMaybeMessage<::flyteidl::artifact::Artifact>(Arena*);
template<> ::flyteidl::artifact::ArtifactConsumer* Arena::CreateMaybeMessage<::flyteidl::artifact::ArtifactConsumer>(Arena*);
template<> ::flyteidl::artifact::ArtifactProducer* Arena::CreateMaybeMessage<::flyteidl::artifact::ArtifactProducer>(Arena*);
template<> ::flyteidl::artifact::ArtifactSpec* Arena::CreateMaybeMessage<::flyteidl::artifact::ArtifactSpec>(Arena*);
template<> ::flyteidl::artifact::CreateArtifactRequest* Arena::CreateMaybeMessage<::flyteidl::artifact::CreateArtifactRequest>(Arena*);
template<> ::flyteidl::artifact::CreateArtifactRequest_PartitionsEntry_DoNotUse* Arena::CreateMaybeMessage<::flyteidl::artifact::CreateArtifactRequest_PartitionsEntry_DoNotUse>(Arena*);
template<> ::flyteidl::artifact::CreateArtifactResponse* Arena::CreateMaybeMessage<::flyteidl::artifact::CreateArtifactResponse>(Arena*);
template<> ::flyteidl::artifact::CreateTriggerRequest* Arena::CreateMaybeMessage<::flyteidl::artifact::CreateTriggerRequest>(Arena*);
template<> ::flyteidl::artifact::CreateTriggerResponse* Arena::CreateMaybeMessage<::flyteidl::artifact::CreateTriggerResponse>(Arena*);
template<> ::flyteidl::artifact::DeleteTriggerRequest* Arena::CreateMaybeMessage<::flyteidl::artifact::DeleteTriggerRequest>(Arena*);
template<> ::flyteidl::artifact::DeleteTriggerResponse* Arena::CreateMaybeMessage<::flyteidl::artifact::DeleteTriggerResponse>(Arena*);
template<> ::flyteidl::artifact::GetArtifactRequest* Arena::CreateMaybeMessage<::flyteidl::artifact::GetArtifactRequest>(Arena*);
template<> ::flyteidl::artifact::GetArtifactResponse* Arena::CreateMaybeMessage<::flyteidl::artifact::GetArtifactResponse>(Arena*);
template<> ::flyteidl::artifact::ListArtifactNamesRequest* Arena::CreateMaybeMessage<::flyteidl::artifact::ListArtifactNamesRequest>(Arena*);
template<> ::flyteidl::artifact::ListArtifactNamesResponse* Arena::CreateMaybeMessage<::flyteidl::artifact::ListArtifactNamesResponse>(Arena*);
template<> ::flyteidl::artifact::ListArtifactsRequest* Arena::CreateMaybeMessage<::flyteidl::artifact::ListArtifactsRequest>(Arena*);
template<> ::flyteidl::artifact::ListArtifactsResponse* Arena::CreateMaybeMessage<::flyteidl::artifact::ListArtifactsResponse>(Arena*);
template<> ::flyteidl::artifact::RegisterConsumerRequest* Arena::CreateMaybeMessage<::flyteidl::artifact::RegisterConsumerRequest>(Arena*);
template<> ::flyteidl::artifact::RegisterProducerRequest* Arena::CreateMaybeMessage<::flyteidl::artifact::RegisterProducerRequest>(Arena*);
template<> ::flyteidl::artifact::RegisterResponse* Arena::CreateMaybeMessage<::flyteidl::artifact::RegisterResponse>(Arena*);
template<> ::flyteidl::artifact::Trigger* Arena::CreateMaybeMessage<::flyteidl::artifact::Trigger>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace flyteidl {
namespace artifact {

// ===================================================================

class Artifact final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.Artifact) */ {
 public:
  Artifact();
  virtual ~Artifact();

  Artifact(const Artifact& from);

  inline Artifact& operator=(const Artifact& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Artifact(Artifact&& from) noexcept
    : Artifact() {
    *this = ::std::move(from);
  }

  inline Artifact& operator=(Artifact&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Artifact& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Artifact* internal_default_instance() {
    return reinterpret_cast<const Artifact*>(
               &_Artifact_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Artifact* other);
  friend void swap(Artifact& a, Artifact& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Artifact* New() const final {
    return CreateMaybeMessage<Artifact>(nullptr);
  }

  Artifact* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Artifact>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Artifact& from);
  void MergeFrom(const Artifact& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Artifact* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string tags = 3;
  int tags_size() const;
  void clear_tags();
  static const int kTagsFieldNumber = 3;
  const ::std::string& tags(int index) const;
  ::std::string* mutable_tags(int index);
  void set_tags(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_tags(int index, ::std::string&& value);
  #endif
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, size_t size);
  ::std::string* add_tags();
  void add_tags(const ::std::string& value);
  #if LANG_CXX11
  void add_tags(::std::string&& value);
  #endif
  void add_tags(const char* value);
  void add_tags(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& tags() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_tags();

  // .flyteidl.core.ArtifactID artifact_id = 1;
  bool has_artifact_id() const;
  void clear_artifact_id();
  static const int kArtifactIdFieldNumber = 1;
  const ::flyteidl::core::ArtifactID& artifact_id() const;
  ::flyteidl::core::ArtifactID* release_artifact_id();
  ::flyteidl::core::ArtifactID* mutable_artifact_id();
  void set_allocated_artifact_id(::flyteidl::core::ArtifactID* artifact_id);

  // .flyteidl.artifact.ArtifactSpec spec = 2;
  bool has_spec() const;
  void clear_spec();
  static const int kSpecFieldNumber = 2;
  const ::flyteidl::artifact::ArtifactSpec& spec() const;
  ::flyteidl::artifact::ArtifactSpec* release_spec();
  ::flyteidl::artifact::ArtifactSpec* mutable_spec();
  void set_allocated_spec(::flyteidl::artifact::ArtifactSpec* spec);

  // @@protoc_insertion_point(class_scope:flyteidl.artifact.Artifact)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField<::std::string> tags_;
  ::flyteidl::core::ArtifactID* artifact_id_;
  ::flyteidl::artifact::ArtifactSpec* spec_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// -------------------------------------------------------------------

class Trigger final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.Trigger) */ {
 public:
  Trigger();
  virtual ~Trigger();

  Trigger(const Trigger& from);

  inline Trigger& operator=(const Trigger& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Trigger(Trigger&& from) noexcept
    : Trigger() {
    *this = ::std::move(from);
  }

  inline Trigger& operator=(Trigger&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Trigger& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Trigger* internal_default_instance() {
    return reinterpret_cast<const Trigger*>(
               &_Trigger_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Trigger* other);
  friend void swap(Trigger& a, Trigger& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Trigger* New() const final {
    return CreateMaybeMessage<Trigger>(nullptr);
  }

  Trigger* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Trigger>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Trigger& from);
  void MergeFrom(const Trigger& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Trigger* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .flyteidl.core.ArtifactKey artifact_key = 1;
  int artifact_key_size() const;
  void clear_artifact_key();
  static const int kArtifactKeyFieldNumber = 1;
  ::flyteidl::core::ArtifactKey* mutable_artifact_key(int index);
  ::google::protobuf::RepeatedPtrField< ::flyteidl::core::ArtifactKey >*
      mutable_artifact_key();
  const ::flyteidl::core::ArtifactKey& artifact_key(int index) const;
  ::flyteidl::core::ArtifactKey* add_artifact_key();
  const ::google::protobuf::RepeatedPtrField< ::flyteidl::core::ArtifactKey >&
      artifact_key() const;

  // .flyteidl.core.Identifier downstream_id = 2;
  bool has_downstream_id() const;
  void clear_downstream_id();
  static const int kDownstreamIdFieldNumber = 2;
  const ::flyteidl::core::Identifier& downstream_id() const;
  ::flyteidl::core::Identifier* release_downstream_id();
  ::flyteidl::core::Identifier* mutable_downstream_id();
  void set_allocated_downstream_id(::flyteidl::core::Identifier* downstream_id);

  // .flyteidl.core.ParameterMap inputs = 3;
  bool has_inputs() const;
  void clear_inputs();
  static const int kInputsFieldNumber = 3;
  const ::flyteidl::core::ParameterMap& inputs() const;
  ::flyteidl::core::ParameterMap* release_inputs();
  ::flyteidl::core::ParameterMap* mutable_inputs();
  void set_allocated_inputs(::flyteidl::core::ParameterMap* inputs);

  // @@protoc_insertion_point(class_scope:flyteidl.artifact.Trigger)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::flyteidl::core::ArtifactKey > artifact_key_;
  ::flyteidl::core::Identifier* downstream_id_;
  ::flyteidl::core::ParameterMap* inputs_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// -------------------------------------------------------------------

class CreateArtifactRequest_PartitionsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<CreateArtifactRequest_PartitionsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
static bool _ParseMap(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  typedef ::google::protobuf::internal::MapEntry<CreateArtifactRequest_PartitionsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  CreateArtifactRequest_PartitionsEntry_DoNotUse();
  CreateArtifactRequest_PartitionsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const CreateArtifactRequest_PartitionsEntry_DoNotUse& other);
  static const CreateArtifactRequest_PartitionsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const CreateArtifactRequest_PartitionsEntry_DoNotUse*>(&_CreateArtifactRequest_PartitionsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class CreateArtifactRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.CreateArtifactRequest) */ {
 public:
  CreateArtifactRequest();
  virtual ~CreateArtifactRequest();

  CreateArtifactRequest(const CreateArtifactRequest& from);

  inline CreateArtifactRequest& operator=(const CreateArtifactRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateArtifactRequest(CreateArtifactRequest&& from) noexcept
    : CreateArtifactRequest() {
    *this = ::std::move(from);
  }

  inline CreateArtifactRequest& operator=(CreateArtifactRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CreateArtifactRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateArtifactRequest* internal_default_instance() {
    return reinterpret_cast<const CreateArtifactRequest*>(
               &_CreateArtifactRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(CreateArtifactRequest* other);
  friend void swap(CreateArtifactRequest& a, CreateArtifactRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateArtifactRequest* New() const final {
    return CreateMaybeMessage<CreateArtifactRequest>(nullptr);
  }

  CreateArtifactRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CreateArtifactRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CreateArtifactRequest& from);
  void MergeFrom(const CreateArtifactRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateArtifactRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, string> partitions = 4;
  int partitions_size() const;
  void clear_partitions();
  static const int kPartitionsFieldNumber = 4;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      partitions() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_partitions();

  // string version = 3;
  void clear_version();
  static const int kVersionFieldNumber = 3;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // string tag = 5;
  void clear_tag();
  static const int kTagFieldNumber = 5;
  const ::std::string& tag() const;
  void set_tag(const ::std::string& value);
  #if LANG_CXX11
  void set_tag(::std::string&& value);
  #endif
  void set_tag(const char* value);
  void set_tag(const char* value, size_t size);
  ::std::string* mutable_tag();
  ::std::string* release_tag();
  void set_allocated_tag(::std::string* tag);

  // .flyteidl.core.ArtifactKey artifact_key = 1;
  bool has_artifact_key() const;
  void clear_artifact_key();
  static const int kArtifactKeyFieldNumber = 1;
  const ::flyteidl::core::ArtifactKey& artifact_key() const;
  ::flyteidl::core::ArtifactKey* release_artifact_key();
  ::flyteidl::core::ArtifactKey* mutable_artifact_key();
  void set_allocated_artifact_key(::flyteidl::core::ArtifactKey* artifact_key);

  // .flyteidl.artifact.ArtifactSpec spec = 2;
  bool has_spec() const;
  void clear_spec();
  static const int kSpecFieldNumber = 2;
  const ::flyteidl::artifact::ArtifactSpec& spec() const;
  ::flyteidl::artifact::ArtifactSpec* release_spec();
  ::flyteidl::artifact::ArtifactSpec* mutable_spec();
  void set_allocated_spec(::flyteidl::artifact::ArtifactSpec* spec);

  // @@protoc_insertion_point(class_scope:flyteidl.artifact.CreateArtifactRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      CreateArtifactRequest_PartitionsEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > partitions_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr tag_;
  ::flyteidl::core::ArtifactKey* artifact_key_;
  ::flyteidl::artifact::ArtifactSpec* spec_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// -------------------------------------------------------------------

class ArtifactSpec final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.ArtifactSpec) */ {
 public:
  ArtifactSpec();
  virtual ~ArtifactSpec();

  ArtifactSpec(const ArtifactSpec& from);

  inline ArtifactSpec& operator=(const ArtifactSpec& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ArtifactSpec(ArtifactSpec&& from) noexcept
    : ArtifactSpec() {
    *this = ::std::move(from);
  }

  inline ArtifactSpec& operator=(ArtifactSpec&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ArtifactSpec& default_instance();

  enum SourceCase {
    kTaskExecution = 5,
    kExecution = 6,
    kPrincipal = 7,
    SOURCE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ArtifactSpec* internal_default_instance() {
    return reinterpret_cast<const ArtifactSpec*>(
               &_ArtifactSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(ArtifactSpec* other);
  friend void swap(ArtifactSpec& a, ArtifactSpec& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ArtifactSpec* New() const final {
    return CreateMaybeMessage<ArtifactSpec>(nullptr);
  }

  ArtifactSpec* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ArtifactSpec>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ArtifactSpec& from);
  void MergeFrom(const ArtifactSpec& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArtifactSpec* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string short_description = 8;
  void clear_short_description();
  static const int kShortDescriptionFieldNumber = 8;
  const ::std::string& short_description() const;
  void set_short_description(const ::std::string& value);
  #if LANG_CXX11
  void set_short_description(::std::string&& value);
  #endif
  void set_short_description(const char* value);
  void set_short_description(const char* value, size_t size);
  ::std::string* mutable_short_description();
  ::std::string* release_short_description();
  void set_allocated_short_description(::std::string* short_description);

  // string long_description = 9;
  void clear_long_description();
  static const int kLongDescriptionFieldNumber = 9;
  const ::std::string& long_description() const;
  void set_long_description(const ::std::string& value);
  #if LANG_CXX11
  void set_long_description(::std::string&& value);
  #endif
  void set_long_description(const char* value);
  void set_long_description(const char* value, size_t size);
  ::std::string* mutable_long_description();
  ::std::string* release_long_description();
  void set_allocated_long_description(::std::string* long_description);

  // .flyteidl.core.Literal value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::flyteidl::core::Literal& value() const;
  ::flyteidl::core::Literal* release_value();
  ::flyteidl::core::Literal* mutable_value();
  void set_allocated_value(::flyteidl::core::Literal* value);

  // .flyteidl.core.LiteralType type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  const ::flyteidl::core::LiteralType& type() const;
  ::flyteidl::core::LiteralType* release_type();
  ::flyteidl::core::LiteralType* mutable_type();
  void set_allocated_type(::flyteidl::core::LiteralType* type);

  // .google.protobuf.Any user_metadata = 10;
  bool has_user_metadata() const;
  void clear_user_metadata();
  static const int kUserMetadataFieldNumber = 10;
  const ::google::protobuf::Any& user_metadata() const;
  ::google::protobuf::Any* release_user_metadata();
  ::google::protobuf::Any* mutable_user_metadata();
  void set_allocated_user_metadata(::google::protobuf::Any* user_metadata);

  // .flyteidl.core.TaskExecutionIdentifier task_execution = 5;
  bool has_task_execution() const;
  void clear_task_execution();
  static const int kTaskExecutionFieldNumber = 5;
  const ::flyteidl::core::TaskExecutionIdentifier& task_execution() const;
  ::flyteidl::core::TaskExecutionIdentifier* release_task_execution();
  ::flyteidl::core::TaskExecutionIdentifier* mutable_task_execution();
  void set_allocated_task_execution(::flyteidl::core::TaskExecutionIdentifier* task_execution);

  // .flyteidl.core.WorkflowExecutionIdentifier execution = 6;
  bool has_execution() const;
  void clear_execution();
  static const int kExecutionFieldNumber = 6;
  const ::flyteidl::core::WorkflowExecutionIdentifier& execution() const;
  ::flyteidl::core::WorkflowExecutionIdentifier* release_execution();
  ::flyteidl::core::WorkflowExecutionIdentifier* mutable_execution();
  void set_allocated_execution(::flyteidl::core::WorkflowExecutionIdentifier* execution);

  // string principal = 7;
  private:
  bool has_principal() const;
  public:
  void clear_principal();
  static const int kPrincipalFieldNumber = 7;
  const ::std::string& principal() const;
  void set_principal(const ::std::string& value);
  #if LANG_CXX11
  void set_principal(::std::string&& value);
  #endif
  void set_principal(const char* value);
  void set_principal(const char* value, size_t size);
  ::std::string* mutable_principal();
  ::std::string* release_principal();
  void set_allocated_principal(::std::string* principal);

  void clear_source();
  SourceCase source_case() const;
  // @@protoc_insertion_point(class_scope:flyteidl.artifact.ArtifactSpec)
 private:
  class HasBitSetters;
  void set_has_task_execution();
  void set_has_execution();
  void set_has_principal();

  inline bool has_source() const;
  inline void clear_has_source();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr short_description_;
  ::google::protobuf::internal::ArenaStringPtr long_description_;
  ::flyteidl::core::Literal* value_;
  ::flyteidl::core::LiteralType* type_;
  ::google::protobuf::Any* user_metadata_;
  union SourceUnion {
    SourceUnion() {}
    ::flyteidl::core::TaskExecutionIdentifier* task_execution_;
    ::flyteidl::core::WorkflowExecutionIdentifier* execution_;
    ::google::protobuf::internal::ArenaStringPtr principal_;
  } source_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// -------------------------------------------------------------------

class CreateArtifactResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.CreateArtifactResponse) */ {
 public:
  CreateArtifactResponse();
  virtual ~CreateArtifactResponse();

  CreateArtifactResponse(const CreateArtifactResponse& from);

  inline CreateArtifactResponse& operator=(const CreateArtifactResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateArtifactResponse(CreateArtifactResponse&& from) noexcept
    : CreateArtifactResponse() {
    *this = ::std::move(from);
  }

  inline CreateArtifactResponse& operator=(CreateArtifactResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CreateArtifactResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateArtifactResponse* internal_default_instance() {
    return reinterpret_cast<const CreateArtifactResponse*>(
               &_CreateArtifactResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(CreateArtifactResponse* other);
  friend void swap(CreateArtifactResponse& a, CreateArtifactResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateArtifactResponse* New() const final {
    return CreateMaybeMessage<CreateArtifactResponse>(nullptr);
  }

  CreateArtifactResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CreateArtifactResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CreateArtifactResponse& from);
  void MergeFrom(const CreateArtifactResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateArtifactResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .flyteidl.artifact.Artifact artifact = 1;
  bool has_artifact() const;
  void clear_artifact();
  static const int kArtifactFieldNumber = 1;
  const ::flyteidl::artifact::Artifact& artifact() const;
  ::flyteidl::artifact::Artifact* release_artifact();
  ::flyteidl::artifact::Artifact* mutable_artifact();
  void set_allocated_artifact(::flyteidl::artifact::Artifact* artifact);

  // @@protoc_insertion_point(class_scope:flyteidl.artifact.CreateArtifactResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::flyteidl::artifact::Artifact* artifact_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// -------------------------------------------------------------------

class GetArtifactRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.GetArtifactRequest) */ {
 public:
  GetArtifactRequest();
  virtual ~GetArtifactRequest();

  GetArtifactRequest(const GetArtifactRequest& from);

  inline GetArtifactRequest& operator=(const GetArtifactRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetArtifactRequest(GetArtifactRequest&& from) noexcept
    : GetArtifactRequest() {
    *this = ::std::move(from);
  }

  inline GetArtifactRequest& operator=(GetArtifactRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GetArtifactRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetArtifactRequest* internal_default_instance() {
    return reinterpret_cast<const GetArtifactRequest*>(
               &_GetArtifactRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(GetArtifactRequest* other);
  friend void swap(GetArtifactRequest& a, GetArtifactRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetArtifactRequest* New() const final {
    return CreateMaybeMessage<GetArtifactRequest>(nullptr);
  }

  GetArtifactRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetArtifactRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetArtifactRequest& from);
  void MergeFrom(const GetArtifactRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetArtifactRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .flyteidl.core.ArtifactQuery query = 1;
  bool has_query() const;
  void clear_query();
  static const int kQueryFieldNumber = 1;
  const ::flyteidl::core::ArtifactQuery& query() const;
  ::flyteidl::core::ArtifactQuery* release_query();
  ::flyteidl::core::ArtifactQuery* mutable_query();
  void set_allocated_query(::flyteidl::core::ArtifactQuery* query);

  // bool details = 2;
  void clear_details();
  static const int kDetailsFieldNumber = 2;
  bool details() const;
  void set_details(bool value);

  // @@protoc_insertion_point(class_scope:flyteidl.artifact.GetArtifactRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::flyteidl::core::ArtifactQuery* query_;
  bool details_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// -------------------------------------------------------------------

class GetArtifactResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.GetArtifactResponse) */ {
 public:
  GetArtifactResponse();
  virtual ~GetArtifactResponse();

  GetArtifactResponse(const GetArtifactResponse& from);

  inline GetArtifactResponse& operator=(const GetArtifactResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetArtifactResponse(GetArtifactResponse&& from) noexcept
    : GetArtifactResponse() {
    *this = ::std::move(from);
  }

  inline GetArtifactResponse& operator=(GetArtifactResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GetArtifactResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetArtifactResponse* internal_default_instance() {
    return reinterpret_cast<const GetArtifactResponse*>(
               &_GetArtifactResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(GetArtifactResponse* other);
  friend void swap(GetArtifactResponse& a, GetArtifactResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetArtifactResponse* New() const final {
    return CreateMaybeMessage<GetArtifactResponse>(nullptr);
  }

  GetArtifactResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetArtifactResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetArtifactResponse& from);
  void MergeFrom(const GetArtifactResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetArtifactResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .flyteidl.artifact.Artifact artifact = 1;
  bool has_artifact() const;
  void clear_artifact();
  static const int kArtifactFieldNumber = 1;
  const ::flyteidl::artifact::Artifact& artifact() const;
  ::flyteidl::artifact::Artifact* release_artifact();
  ::flyteidl::artifact::Artifact* mutable_artifact();
  void set_allocated_artifact(::flyteidl::artifact::Artifact* artifact);

  // @@protoc_insertion_point(class_scope:flyteidl.artifact.GetArtifactResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::flyteidl::artifact::Artifact* artifact_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// -------------------------------------------------------------------

class ListArtifactNamesRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.ListArtifactNamesRequest) */ {
 public:
  ListArtifactNamesRequest();
  virtual ~ListArtifactNamesRequest();

  ListArtifactNamesRequest(const ListArtifactNamesRequest& from);

  inline ListArtifactNamesRequest& operator=(const ListArtifactNamesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ListArtifactNamesRequest(ListArtifactNamesRequest&& from) noexcept
    : ListArtifactNamesRequest() {
    *this = ::std::move(from);
  }

  inline ListArtifactNamesRequest& operator=(ListArtifactNamesRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ListArtifactNamesRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListArtifactNamesRequest* internal_default_instance() {
    return reinterpret_cast<const ListArtifactNamesRequest*>(
               &_ListArtifactNamesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(ListArtifactNamesRequest* other);
  friend void swap(ListArtifactNamesRequest& a, ListArtifactNamesRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ListArtifactNamesRequest* New() const final {
    return CreateMaybeMessage<ListArtifactNamesRequest>(nullptr);
  }

  ListArtifactNamesRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ListArtifactNamesRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ListArtifactNamesRequest& from);
  void MergeFrom(const ListArtifactNamesRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListArtifactNamesRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string project = 1;
  void clear_project();
  static const int kProjectFieldNumber = 1;
  const ::std::string& project() const;
  void set_project(const ::std::string& value);
  #if LANG_CXX11
  void set_project(::std::string&& value);
  #endif
  void set_project(const char* value);
  void set_project(const char* value, size_t size);
  ::std::string* mutable_project();
  ::std::string* release_project();
  void set_allocated_project(::std::string* project);

  // string domain = 2;
  void clear_domain();
  static const int kDomainFieldNumber = 2;
  const ::std::string& domain() const;
  void set_domain(const ::std::string& value);
  #if LANG_CXX11
  void set_domain(::std::string&& value);
  #endif
  void set_domain(const char* value);
  void set_domain(const char* value, size_t size);
  ::std::string* mutable_domain();
  ::std::string* release_domain();
  void set_allocated_domain(::std::string* domain);

  // @@protoc_insertion_point(class_scope:flyteidl.artifact.ListArtifactNamesRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr project_;
  ::google::protobuf::internal::ArenaStringPtr domain_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// -------------------------------------------------------------------

class ListArtifactNamesResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.ListArtifactNamesResponse) */ {
 public:
  ListArtifactNamesResponse();
  virtual ~ListArtifactNamesResponse();

  ListArtifactNamesResponse(const ListArtifactNamesResponse& from);

  inline ListArtifactNamesResponse& operator=(const ListArtifactNamesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ListArtifactNamesResponse(ListArtifactNamesResponse&& from) noexcept
    : ListArtifactNamesResponse() {
    *this = ::std::move(from);
  }

  inline ListArtifactNamesResponse& operator=(ListArtifactNamesResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ListArtifactNamesResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListArtifactNamesResponse* internal_default_instance() {
    return reinterpret_cast<const ListArtifactNamesResponse*>(
               &_ListArtifactNamesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(ListArtifactNamesResponse* other);
  friend void swap(ListArtifactNamesResponse& a, ListArtifactNamesResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ListArtifactNamesResponse* New() const final {
    return CreateMaybeMessage<ListArtifactNamesResponse>(nullptr);
  }

  ListArtifactNamesResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ListArtifactNamesResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ListArtifactNamesResponse& from);
  void MergeFrom(const ListArtifactNamesResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListArtifactNamesResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .flyteidl.core.ArtifactKey artifact_keys = 1;
  int artifact_keys_size() const;
  void clear_artifact_keys();
  static const int kArtifactKeysFieldNumber = 1;
  ::flyteidl::core::ArtifactKey* mutable_artifact_keys(int index);
  ::google::protobuf::RepeatedPtrField< ::flyteidl::core::ArtifactKey >*
      mutable_artifact_keys();
  const ::flyteidl::core::ArtifactKey& artifact_keys(int index) const;
  ::flyteidl::core::ArtifactKey* add_artifact_keys();
  const ::google::protobuf::RepeatedPtrField< ::flyteidl::core::ArtifactKey >&
      artifact_keys() const;

  // @@protoc_insertion_point(class_scope:flyteidl.artifact.ListArtifactNamesResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::flyteidl::core::ArtifactKey > artifact_keys_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// -------------------------------------------------------------------

class ListArtifactsRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.ListArtifactsRequest) */ {
 public:
  ListArtifactsRequest();
  virtual ~ListArtifactsRequest();

  ListArtifactsRequest(const ListArtifactsRequest& from);

  inline ListArtifactsRequest& operator=(const ListArtifactsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ListArtifactsRequest(ListArtifactsRequest&& from) noexcept
    : ListArtifactsRequest() {
    *this = ::std::move(from);
  }

  inline ListArtifactsRequest& operator=(ListArtifactsRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ListArtifactsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListArtifactsRequest* internal_default_instance() {
    return reinterpret_cast<const ListArtifactsRequest*>(
               &_ListArtifactsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(ListArtifactsRequest* other);
  friend void swap(ListArtifactsRequest& a, ListArtifactsRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ListArtifactsRequest* New() const final {
    return CreateMaybeMessage<ListArtifactsRequest>(nullptr);
  }

  ListArtifactsRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ListArtifactsRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ListArtifactsRequest& from);
  void MergeFrom(const ListArtifactsRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListArtifactsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .flyteidl.core.ArtifactKey artifact_key = 1;
  bool has_artifact_key() const;
  void clear_artifact_key();
  static const int kArtifactKeyFieldNumber = 1;
  const ::flyteidl::core::ArtifactKey& artifact_key() const;
  ::flyteidl::core::ArtifactKey* release_artifact_key();
  ::flyteidl::core::ArtifactKey* mutable_artifact_key();
  void set_allocated_artifact_key(::flyteidl::core::ArtifactKey* artifact_key);

  // @@protoc_insertion_point(class_scope:flyteidl.artifact.ListArtifactsRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::flyteidl::core::ArtifactKey* artifact_key_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// -------------------------------------------------------------------

class ListArtifactsResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.ListArtifactsResponse) */ {
 public:
  ListArtifactsResponse();
  virtual ~ListArtifactsResponse();

  ListArtifactsResponse(const ListArtifactsResponse& from);

  inline ListArtifactsResponse& operator=(const ListArtifactsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ListArtifactsResponse(ListArtifactsResponse&& from) noexcept
    : ListArtifactsResponse() {
    *this = ::std::move(from);
  }

  inline ListArtifactsResponse& operator=(ListArtifactsResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ListArtifactsResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListArtifactsResponse* internal_default_instance() {
    return reinterpret_cast<const ListArtifactsResponse*>(
               &_ListArtifactsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(ListArtifactsResponse* other);
  friend void swap(ListArtifactsResponse& a, ListArtifactsResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ListArtifactsResponse* New() const final {
    return CreateMaybeMessage<ListArtifactsResponse>(nullptr);
  }

  ListArtifactsResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ListArtifactsResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ListArtifactsResponse& from);
  void MergeFrom(const ListArtifactsResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListArtifactsResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .flyteidl.artifact.Artifact artifacts = 1;
  int artifacts_size() const;
  void clear_artifacts();
  static const int kArtifactsFieldNumber = 1;
  ::flyteidl::artifact::Artifact* mutable_artifacts(int index);
  ::google::protobuf::RepeatedPtrField< ::flyteidl::artifact::Artifact >*
      mutable_artifacts();
  const ::flyteidl::artifact::Artifact& artifacts(int index) const;
  ::flyteidl::artifact::Artifact* add_artifacts();
  const ::google::protobuf::RepeatedPtrField< ::flyteidl::artifact::Artifact >&
      artifacts() const;

  // @@protoc_insertion_point(class_scope:flyteidl.artifact.ListArtifactsResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::flyteidl::artifact::Artifact > artifacts_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// -------------------------------------------------------------------

class AddTagRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.AddTagRequest) */ {
 public:
  AddTagRequest();
  virtual ~AddTagRequest();

  AddTagRequest(const AddTagRequest& from);

  inline AddTagRequest& operator=(const AddTagRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AddTagRequest(AddTagRequest&& from) noexcept
    : AddTagRequest() {
    *this = ::std::move(from);
  }

  inline AddTagRequest& operator=(AddTagRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const AddTagRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AddTagRequest* internal_default_instance() {
    return reinterpret_cast<const AddTagRequest*>(
               &_AddTagRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(AddTagRequest* other);
  friend void swap(AddTagRequest& a, AddTagRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AddTagRequest* New() const final {
    return CreateMaybeMessage<AddTagRequest>(nullptr);
  }

  AddTagRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AddTagRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AddTagRequest& from);
  void MergeFrom(const AddTagRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddTagRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // .flyteidl.core.ArtifactID artifact_id = 1;
  bool has_artifact_id() const;
  void clear_artifact_id();
  static const int kArtifactIdFieldNumber = 1;
  const ::flyteidl::core::ArtifactID& artifact_id() const;
  ::flyteidl::core::ArtifactID* release_artifact_id();
  ::flyteidl::core::ArtifactID* mutable_artifact_id();
  void set_allocated_artifact_id(::flyteidl::core::ArtifactID* artifact_id);

  // bool overwrite = 3;
  void clear_overwrite();
  static const int kOverwriteFieldNumber = 3;
  bool overwrite() const;
  void set_overwrite(bool value);

  // @@protoc_insertion_point(class_scope:flyteidl.artifact.AddTagRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::flyteidl::core::ArtifactID* artifact_id_;
  bool overwrite_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// -------------------------------------------------------------------

class AddTagResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.AddTagResponse) */ {
 public:
  AddTagResponse();
  virtual ~AddTagResponse();

  AddTagResponse(const AddTagResponse& from);

  inline AddTagResponse& operator=(const AddTagResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AddTagResponse(AddTagResponse&& from) noexcept
    : AddTagResponse() {
    *this = ::std::move(from);
  }

  inline AddTagResponse& operator=(AddTagResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const AddTagResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AddTagResponse* internal_default_instance() {
    return reinterpret_cast<const AddTagResponse*>(
               &_AddTagResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(AddTagResponse* other);
  friend void swap(AddTagResponse& a, AddTagResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AddTagResponse* New() const final {
    return CreateMaybeMessage<AddTagResponse>(nullptr);
  }

  AddTagResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AddTagResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AddTagResponse& from);
  void MergeFrom(const AddTagResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddTagResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:flyteidl.artifact.AddTagResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// -------------------------------------------------------------------

class CreateTriggerRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.CreateTriggerRequest) */ {
 public:
  CreateTriggerRequest();
  virtual ~CreateTriggerRequest();

  CreateTriggerRequest(const CreateTriggerRequest& from);

  inline CreateTriggerRequest& operator=(const CreateTriggerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateTriggerRequest(CreateTriggerRequest&& from) noexcept
    : CreateTriggerRequest() {
    *this = ::std::move(from);
  }

  inline CreateTriggerRequest& operator=(CreateTriggerRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CreateTriggerRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateTriggerRequest* internal_default_instance() {
    return reinterpret_cast<const CreateTriggerRequest*>(
               &_CreateTriggerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(CreateTriggerRequest* other);
  friend void swap(CreateTriggerRequest& a, CreateTriggerRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateTriggerRequest* New() const final {
    return CreateMaybeMessage<CreateTriggerRequest>(nullptr);
  }

  CreateTriggerRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CreateTriggerRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CreateTriggerRequest& from);
  void MergeFrom(const CreateTriggerRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateTriggerRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .flyteidl.artifact.Trigger trigger = 1;
  bool has_trigger() const;
  void clear_trigger();
  static const int kTriggerFieldNumber = 1;
  const ::flyteidl::artifact::Trigger& trigger() const;
  ::flyteidl::artifact::Trigger* release_trigger();
  ::flyteidl::artifact::Trigger* mutable_trigger();
  void set_allocated_trigger(::flyteidl::artifact::Trigger* trigger);

  // @@protoc_insertion_point(class_scope:flyteidl.artifact.CreateTriggerRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::flyteidl::artifact::Trigger* trigger_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// -------------------------------------------------------------------

class CreateTriggerResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.CreateTriggerResponse) */ {
 public:
  CreateTriggerResponse();
  virtual ~CreateTriggerResponse();

  CreateTriggerResponse(const CreateTriggerResponse& from);

  inline CreateTriggerResponse& operator=(const CreateTriggerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateTriggerResponse(CreateTriggerResponse&& from) noexcept
    : CreateTriggerResponse() {
    *this = ::std::move(from);
  }

  inline CreateTriggerResponse& operator=(CreateTriggerResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CreateTriggerResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateTriggerResponse* internal_default_instance() {
    return reinterpret_cast<const CreateTriggerResponse*>(
               &_CreateTriggerResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(CreateTriggerResponse* other);
  friend void swap(CreateTriggerResponse& a, CreateTriggerResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateTriggerResponse* New() const final {
    return CreateMaybeMessage<CreateTriggerResponse>(nullptr);
  }

  CreateTriggerResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CreateTriggerResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CreateTriggerResponse& from);
  void MergeFrom(const CreateTriggerResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateTriggerResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:flyteidl.artifact.CreateTriggerResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// -------------------------------------------------------------------

class DeleteTriggerRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.DeleteTriggerRequest) */ {
 public:
  DeleteTriggerRequest();
  virtual ~DeleteTriggerRequest();

  DeleteTriggerRequest(const DeleteTriggerRequest& from);

  inline DeleteTriggerRequest& operator=(const DeleteTriggerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeleteTriggerRequest(DeleteTriggerRequest&& from) noexcept
    : DeleteTriggerRequest() {
    *this = ::std::move(from);
  }

  inline DeleteTriggerRequest& operator=(DeleteTriggerRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const DeleteTriggerRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteTriggerRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteTriggerRequest*>(
               &_DeleteTriggerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(DeleteTriggerRequest* other);
  friend void swap(DeleteTriggerRequest& a, DeleteTriggerRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeleteTriggerRequest* New() const final {
    return CreateMaybeMessage<DeleteTriggerRequest>(nullptr);
  }

  DeleteTriggerRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DeleteTriggerRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DeleteTriggerRequest& from);
  void MergeFrom(const DeleteTriggerRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteTriggerRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .flyteidl.artifact.Trigger trigger = 1;
  bool has_trigger() const;
  void clear_trigger();
  static const int kTriggerFieldNumber = 1;
  const ::flyteidl::artifact::Trigger& trigger() const;
  ::flyteidl::artifact::Trigger* release_trigger();
  ::flyteidl::artifact::Trigger* mutable_trigger();
  void set_allocated_trigger(::flyteidl::artifact::Trigger* trigger);

  // @@protoc_insertion_point(class_scope:flyteidl.artifact.DeleteTriggerRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::flyteidl::artifact::Trigger* trigger_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// -------------------------------------------------------------------

class DeleteTriggerResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.DeleteTriggerResponse) */ {
 public:
  DeleteTriggerResponse();
  virtual ~DeleteTriggerResponse();

  DeleteTriggerResponse(const DeleteTriggerResponse& from);

  inline DeleteTriggerResponse& operator=(const DeleteTriggerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeleteTriggerResponse(DeleteTriggerResponse&& from) noexcept
    : DeleteTriggerResponse() {
    *this = ::std::move(from);
  }

  inline DeleteTriggerResponse& operator=(DeleteTriggerResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const DeleteTriggerResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteTriggerResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteTriggerResponse*>(
               &_DeleteTriggerResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(DeleteTriggerResponse* other);
  friend void swap(DeleteTriggerResponse& a, DeleteTriggerResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeleteTriggerResponse* New() const final {
    return CreateMaybeMessage<DeleteTriggerResponse>(nullptr);
  }

  DeleteTriggerResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DeleteTriggerResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DeleteTriggerResponse& from);
  void MergeFrom(const DeleteTriggerResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteTriggerResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:flyteidl.artifact.DeleteTriggerResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// -------------------------------------------------------------------

class ArtifactProducer final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.ArtifactProducer) */ {
 public:
  ArtifactProducer();
  virtual ~ArtifactProducer();

  ArtifactProducer(const ArtifactProducer& from);

  inline ArtifactProducer& operator=(const ArtifactProducer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ArtifactProducer(ArtifactProducer&& from) noexcept
    : ArtifactProducer() {
    *this = ::std::move(from);
  }

  inline ArtifactProducer& operator=(ArtifactProducer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ArtifactProducer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ArtifactProducer* internal_default_instance() {
    return reinterpret_cast<const ArtifactProducer*>(
               &_ArtifactProducer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(ArtifactProducer* other);
  friend void swap(ArtifactProducer& a, ArtifactProducer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ArtifactProducer* New() const final {
    return CreateMaybeMessage<ArtifactProducer>(nullptr);
  }

  ArtifactProducer* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ArtifactProducer>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ArtifactProducer& from);
  void MergeFrom(const ArtifactProducer& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArtifactProducer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .flyteidl.core.Identifier entity_id = 1;
  bool has_entity_id() const;
  void clear_entity_id();
  static const int kEntityIdFieldNumber = 1;
  const ::flyteidl::core::Identifier& entity_id() const;
  ::flyteidl::core::Identifier* release_entity_id();
  ::flyteidl::core::Identifier* mutable_entity_id();
  void set_allocated_entity_id(::flyteidl::core::Identifier* entity_id);

  // .flyteidl.core.VariableMap outputs = 2;
  bool has_outputs() const;
  void clear_outputs();
  static const int kOutputsFieldNumber = 2;
  const ::flyteidl::core::VariableMap& outputs() const;
  ::flyteidl::core::VariableMap* release_outputs();
  ::flyteidl::core::VariableMap* mutable_outputs();
  void set_allocated_outputs(::flyteidl::core::VariableMap* outputs);

  // @@protoc_insertion_point(class_scope:flyteidl.artifact.ArtifactProducer)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::flyteidl::core::Identifier* entity_id_;
  ::flyteidl::core::VariableMap* outputs_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// -------------------------------------------------------------------

class RegisterProducerRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.RegisterProducerRequest) */ {
 public:
  RegisterProducerRequest();
  virtual ~RegisterProducerRequest();

  RegisterProducerRequest(const RegisterProducerRequest& from);

  inline RegisterProducerRequest& operator=(const RegisterProducerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegisterProducerRequest(RegisterProducerRequest&& from) noexcept
    : RegisterProducerRequest() {
    *this = ::std::move(from);
  }

  inline RegisterProducerRequest& operator=(RegisterProducerRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RegisterProducerRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegisterProducerRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterProducerRequest*>(
               &_RegisterProducerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(RegisterProducerRequest* other);
  friend void swap(RegisterProducerRequest& a, RegisterProducerRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegisterProducerRequest* New() const final {
    return CreateMaybeMessage<RegisterProducerRequest>(nullptr);
  }

  RegisterProducerRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RegisterProducerRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RegisterProducerRequest& from);
  void MergeFrom(const RegisterProducerRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterProducerRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .flyteidl.artifact.ArtifactProducer producers = 1;
  int producers_size() const;
  void clear_producers();
  static const int kProducersFieldNumber = 1;
  ::flyteidl::artifact::ArtifactProducer* mutable_producers(int index);
  ::google::protobuf::RepeatedPtrField< ::flyteidl::artifact::ArtifactProducer >*
      mutable_producers();
  const ::flyteidl::artifact::ArtifactProducer& producers(int index) const;
  ::flyteidl::artifact::ArtifactProducer* add_producers();
  const ::google::protobuf::RepeatedPtrField< ::flyteidl::artifact::ArtifactProducer >&
      producers() const;

  // @@protoc_insertion_point(class_scope:flyteidl.artifact.RegisterProducerRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::flyteidl::artifact::ArtifactProducer > producers_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// -------------------------------------------------------------------

class ArtifactConsumer final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.ArtifactConsumer) */ {
 public:
  ArtifactConsumer();
  virtual ~ArtifactConsumer();

  ArtifactConsumer(const ArtifactConsumer& from);

  inline ArtifactConsumer& operator=(const ArtifactConsumer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ArtifactConsumer(ArtifactConsumer&& from) noexcept
    : ArtifactConsumer() {
    *this = ::std::move(from);
  }

  inline ArtifactConsumer& operator=(ArtifactConsumer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ArtifactConsumer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ArtifactConsumer* internal_default_instance() {
    return reinterpret_cast<const ArtifactConsumer*>(
               &_ArtifactConsumer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(ArtifactConsumer* other);
  friend void swap(ArtifactConsumer& a, ArtifactConsumer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ArtifactConsumer* New() const final {
    return CreateMaybeMessage<ArtifactConsumer>(nullptr);
  }

  ArtifactConsumer* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ArtifactConsumer>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ArtifactConsumer& from);
  void MergeFrom(const ArtifactConsumer& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArtifactConsumer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .flyteidl.core.Identifier entity_id = 1;
  bool has_entity_id() const;
  void clear_entity_id();
  static const int kEntityIdFieldNumber = 1;
  const ::flyteidl::core::Identifier& entity_id() const;
  ::flyteidl::core::Identifier* release_entity_id();
  ::flyteidl::core::Identifier* mutable_entity_id();
  void set_allocated_entity_id(::flyteidl::core::Identifier* entity_id);

  // .flyteidl.core.ParameterMap inputs = 2;
  bool has_inputs() const;
  void clear_inputs();
  static const int kInputsFieldNumber = 2;
  const ::flyteidl::core::ParameterMap& inputs() const;
  ::flyteidl::core::ParameterMap* release_inputs();
  ::flyteidl::core::ParameterMap* mutable_inputs();
  void set_allocated_inputs(::flyteidl::core::ParameterMap* inputs);

  // @@protoc_insertion_point(class_scope:flyteidl.artifact.ArtifactConsumer)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::flyteidl::core::Identifier* entity_id_;
  ::flyteidl::core::ParameterMap* inputs_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// -------------------------------------------------------------------

class RegisterConsumerRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.RegisterConsumerRequest) */ {
 public:
  RegisterConsumerRequest();
  virtual ~RegisterConsumerRequest();

  RegisterConsumerRequest(const RegisterConsumerRequest& from);

  inline RegisterConsumerRequest& operator=(const RegisterConsumerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegisterConsumerRequest(RegisterConsumerRequest&& from) noexcept
    : RegisterConsumerRequest() {
    *this = ::std::move(from);
  }

  inline RegisterConsumerRequest& operator=(RegisterConsumerRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RegisterConsumerRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegisterConsumerRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterConsumerRequest*>(
               &_RegisterConsumerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(RegisterConsumerRequest* other);
  friend void swap(RegisterConsumerRequest& a, RegisterConsumerRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegisterConsumerRequest* New() const final {
    return CreateMaybeMessage<RegisterConsumerRequest>(nullptr);
  }

  RegisterConsumerRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RegisterConsumerRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RegisterConsumerRequest& from);
  void MergeFrom(const RegisterConsumerRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterConsumerRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .flyteidl.artifact.ArtifactConsumer consumers = 1;
  int consumers_size() const;
  void clear_consumers();
  static const int kConsumersFieldNumber = 1;
  ::flyteidl::artifact::ArtifactConsumer* mutable_consumers(int index);
  ::google::protobuf::RepeatedPtrField< ::flyteidl::artifact::ArtifactConsumer >*
      mutable_consumers();
  const ::flyteidl::artifact::ArtifactConsumer& consumers(int index) const;
  ::flyteidl::artifact::ArtifactConsumer* add_consumers();
  const ::google::protobuf::RepeatedPtrField< ::flyteidl::artifact::ArtifactConsumer >&
      consumers() const;

  // @@protoc_insertion_point(class_scope:flyteidl.artifact.RegisterConsumerRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::flyteidl::artifact::ArtifactConsumer > consumers_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// -------------------------------------------------------------------

class RegisterResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.RegisterResponse) */ {
 public:
  RegisterResponse();
  virtual ~RegisterResponse();

  RegisterResponse(const RegisterResponse& from);

  inline RegisterResponse& operator=(const RegisterResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegisterResponse(RegisterResponse&& from) noexcept
    : RegisterResponse() {
    *this = ::std::move(from);
  }

  inline RegisterResponse& operator=(RegisterResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RegisterResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegisterResponse* internal_default_instance() {
    return reinterpret_cast<const RegisterResponse*>(
               &_RegisterResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(RegisterResponse* other);
  friend void swap(RegisterResponse& a, RegisterResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegisterResponse* New() const final {
    return CreateMaybeMessage<RegisterResponse>(nullptr);
  }

  RegisterResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RegisterResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RegisterResponse& from);
  void MergeFrom(const RegisterResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:flyteidl.artifact.RegisterResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Artifact

// .flyteidl.core.ArtifactID artifact_id = 1;
inline bool Artifact::has_artifact_id() const {
  return this != internal_default_instance() && artifact_id_ != nullptr;
}
inline const ::flyteidl::core::ArtifactID& Artifact::artifact_id() const {
  const ::flyteidl::core::ArtifactID* p = artifact_id_;
  // @@protoc_insertion_point(field_get:flyteidl.artifact.Artifact.artifact_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::ArtifactID*>(
      &::flyteidl::core::_ArtifactID_default_instance_);
}
inline ::flyteidl::core::ArtifactID* Artifact::release_artifact_id() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.Artifact.artifact_id)
  
  ::flyteidl::core::ArtifactID* temp = artifact_id_;
  artifact_id_ = nullptr;
  return temp;
}
inline ::flyteidl::core::ArtifactID* Artifact::mutable_artifact_id() {
  
  if (artifact_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::ArtifactID>(GetArenaNoVirtual());
    artifact_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.Artifact.artifact_id)
  return artifact_id_;
}
inline void Artifact::set_allocated_artifact_id(::flyteidl::core::ArtifactID* artifact_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(artifact_id_);
  }
  if (artifact_id) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      artifact_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, artifact_id, submessage_arena);
    }
    
  } else {
    
  }
  artifact_id_ = artifact_id;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.Artifact.artifact_id)
}

// .flyteidl.artifact.ArtifactSpec spec = 2;
inline bool Artifact::has_spec() const {
  return this != internal_default_instance() && spec_ != nullptr;
}
inline void Artifact::clear_spec() {
  if (GetArenaNoVirtual() == nullptr && spec_ != nullptr) {
    delete spec_;
  }
  spec_ = nullptr;
}
inline const ::flyteidl::artifact::ArtifactSpec& Artifact::spec() const {
  const ::flyteidl::artifact::ArtifactSpec* p = spec_;
  // @@protoc_insertion_point(field_get:flyteidl.artifact.Artifact.spec)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::artifact::ArtifactSpec*>(
      &::flyteidl::artifact::_ArtifactSpec_default_instance_);
}
inline ::flyteidl::artifact::ArtifactSpec* Artifact::release_spec() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.Artifact.spec)
  
  ::flyteidl::artifact::ArtifactSpec* temp = spec_;
  spec_ = nullptr;
  return temp;
}
inline ::flyteidl::artifact::ArtifactSpec* Artifact::mutable_spec() {
  
  if (spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::artifact::ArtifactSpec>(GetArenaNoVirtual());
    spec_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.Artifact.spec)
  return spec_;
}
inline void Artifact::set_allocated_spec(::flyteidl::artifact::ArtifactSpec* spec) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete spec_;
  }
  if (spec) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      spec = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    
  } else {
    
  }
  spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.Artifact.spec)
}

// repeated string tags = 3;
inline int Artifact::tags_size() const {
  return tags_.size();
}
inline void Artifact::clear_tags() {
  tags_.Clear();
}
inline const ::std::string& Artifact::tags(int index) const {
  // @@protoc_insertion_point(field_get:flyteidl.artifact.Artifact.tags)
  return tags_.Get(index);
}
inline ::std::string* Artifact::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.Artifact.tags)
  return tags_.Mutable(index);
}
inline void Artifact::set_tags(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:flyteidl.artifact.Artifact.tags)
  tags_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Artifact::set_tags(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:flyteidl.artifact.Artifact.tags)
  tags_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Artifact::set_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:flyteidl.artifact.Artifact.tags)
}
inline void Artifact::set_tags(int index, const char* value, size_t size) {
  tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:flyteidl.artifact.Artifact.tags)
}
inline ::std::string* Artifact::add_tags() {
  // @@protoc_insertion_point(field_add_mutable:flyteidl.artifact.Artifact.tags)
  return tags_.Add();
}
inline void Artifact::add_tags(const ::std::string& value) {
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:flyteidl.artifact.Artifact.tags)
}
#if LANG_CXX11
inline void Artifact::add_tags(::std::string&& value) {
  tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:flyteidl.artifact.Artifact.tags)
}
#endif
inline void Artifact::add_tags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:flyteidl.artifact.Artifact.tags)
}
inline void Artifact::add_tags(const char* value, size_t size) {
  tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:flyteidl.artifact.Artifact.tags)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
Artifact::tags() const {
  // @@protoc_insertion_point(field_list:flyteidl.artifact.Artifact.tags)
  return tags_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
Artifact::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:flyteidl.artifact.Artifact.tags)
  return &tags_;
}

// -------------------------------------------------------------------

// Trigger

// repeated .flyteidl.core.ArtifactKey artifact_key = 1;
inline int Trigger::artifact_key_size() const {
  return artifact_key_.size();
}
inline ::flyteidl::core::ArtifactKey* Trigger::mutable_artifact_key(int index) {
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.Trigger.artifact_key)
  return artifact_key_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::flyteidl::core::ArtifactKey >*
Trigger::mutable_artifact_key() {
  // @@protoc_insertion_point(field_mutable_list:flyteidl.artifact.Trigger.artifact_key)
  return &artifact_key_;
}
inline const ::flyteidl::core::ArtifactKey& Trigger::artifact_key(int index) const {
  // @@protoc_insertion_point(field_get:flyteidl.artifact.Trigger.artifact_key)
  return artifact_key_.Get(index);
}
inline ::flyteidl::core::ArtifactKey* Trigger::add_artifact_key() {
  // @@protoc_insertion_point(field_add:flyteidl.artifact.Trigger.artifact_key)
  return artifact_key_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::flyteidl::core::ArtifactKey >&
Trigger::artifact_key() const {
  // @@protoc_insertion_point(field_list:flyteidl.artifact.Trigger.artifact_key)
  return artifact_key_;
}

// .flyteidl.core.Identifier downstream_id = 2;
inline bool Trigger::has_downstream_id() const {
  return this != internal_default_instance() && downstream_id_ != nullptr;
}
inline const ::flyteidl::core::Identifier& Trigger::downstream_id() const {
  const ::flyteidl::core::Identifier* p = downstream_id_;
  // @@protoc_insertion_point(field_get:flyteidl.artifact.Trigger.downstream_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::Identifier*>(
      &::flyteidl::core::_Identifier_default_instance_);
}
inline ::flyteidl::core::Identifier* Trigger::release_downstream_id() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.Trigger.downstream_id)
  
  ::flyteidl::core::Identifier* temp = downstream_id_;
  downstream_id_ = nullptr;
  return temp;
}
inline ::flyteidl::core::Identifier* Trigger::mutable_downstream_id() {
  
  if (downstream_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::Identifier>(GetArenaNoVirtual());
    downstream_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.Trigger.downstream_id)
  return downstream_id_;
}
inline void Trigger::set_allocated_downstream_id(::flyteidl::core::Identifier* downstream_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(downstream_id_);
  }
  if (downstream_id) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      downstream_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, downstream_id, submessage_arena);
    }
    
  } else {
    
  }
  downstream_id_ = downstream_id;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.Trigger.downstream_id)
}

// .flyteidl.core.ParameterMap inputs = 3;
inline bool Trigger::has_inputs() const {
  return this != internal_default_instance() && inputs_ != nullptr;
}
inline const ::flyteidl::core::ParameterMap& Trigger::inputs() const {
  const ::flyteidl::core::ParameterMap* p = inputs_;
  // @@protoc_insertion_point(field_get:flyteidl.artifact.Trigger.inputs)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::ParameterMap*>(
      &::flyteidl::core::_ParameterMap_default_instance_);
}
inline ::flyteidl::core::ParameterMap* Trigger::release_inputs() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.Trigger.inputs)
  
  ::flyteidl::core::ParameterMap* temp = inputs_;
  inputs_ = nullptr;
  return temp;
}
inline ::flyteidl::core::ParameterMap* Trigger::mutable_inputs() {
  
  if (inputs_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::ParameterMap>(GetArenaNoVirtual());
    inputs_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.Trigger.inputs)
  return inputs_;
}
inline void Trigger::set_allocated_inputs(::flyteidl::core::ParameterMap* inputs) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(inputs_);
  }
  if (inputs) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      inputs = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, inputs, submessage_arena);
    }
    
  } else {
    
  }
  inputs_ = inputs;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.Trigger.inputs)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// CreateArtifactRequest

// .flyteidl.core.ArtifactKey artifact_key = 1;
inline bool CreateArtifactRequest::has_artifact_key() const {
  return this != internal_default_instance() && artifact_key_ != nullptr;
}
inline const ::flyteidl::core::ArtifactKey& CreateArtifactRequest::artifact_key() const {
  const ::flyteidl::core::ArtifactKey* p = artifact_key_;
  // @@protoc_insertion_point(field_get:flyteidl.artifact.CreateArtifactRequest.artifact_key)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::ArtifactKey*>(
      &::flyteidl::core::_ArtifactKey_default_instance_);
}
inline ::flyteidl::core::ArtifactKey* CreateArtifactRequest::release_artifact_key() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.CreateArtifactRequest.artifact_key)
  
  ::flyteidl::core::ArtifactKey* temp = artifact_key_;
  artifact_key_ = nullptr;
  return temp;
}
inline ::flyteidl::core::ArtifactKey* CreateArtifactRequest::mutable_artifact_key() {
  
  if (artifact_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::ArtifactKey>(GetArenaNoVirtual());
    artifact_key_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.CreateArtifactRequest.artifact_key)
  return artifact_key_;
}
inline void CreateArtifactRequest::set_allocated_artifact_key(::flyteidl::core::ArtifactKey* artifact_key) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(artifact_key_);
  }
  if (artifact_key) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      artifact_key = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, artifact_key, submessage_arena);
    }
    
  } else {
    
  }
  artifact_key_ = artifact_key;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.CreateArtifactRequest.artifact_key)
}

// string version = 3;
inline void CreateArtifactRequest::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CreateArtifactRequest::version() const {
  // @@protoc_insertion_point(field_get:flyteidl.artifact.CreateArtifactRequest.version)
  return version_.GetNoArena();
}
inline void CreateArtifactRequest::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.artifact.CreateArtifactRequest.version)
}
#if LANG_CXX11
inline void CreateArtifactRequest::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.artifact.CreateArtifactRequest.version)
}
#endif
inline void CreateArtifactRequest::set_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.artifact.CreateArtifactRequest.version)
}
inline void CreateArtifactRequest::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.artifact.CreateArtifactRequest.version)
}
inline ::std::string* CreateArtifactRequest::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.CreateArtifactRequest.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateArtifactRequest::release_version() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.CreateArtifactRequest.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateArtifactRequest::set_allocated_version(::std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.CreateArtifactRequest.version)
}

// .flyteidl.artifact.ArtifactSpec spec = 2;
inline bool CreateArtifactRequest::has_spec() const {
  return this != internal_default_instance() && spec_ != nullptr;
}
inline void CreateArtifactRequest::clear_spec() {
  if (GetArenaNoVirtual() == nullptr && spec_ != nullptr) {
    delete spec_;
  }
  spec_ = nullptr;
}
inline const ::flyteidl::artifact::ArtifactSpec& CreateArtifactRequest::spec() const {
  const ::flyteidl::artifact::ArtifactSpec* p = spec_;
  // @@protoc_insertion_point(field_get:flyteidl.artifact.CreateArtifactRequest.spec)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::artifact::ArtifactSpec*>(
      &::flyteidl::artifact::_ArtifactSpec_default_instance_);
}
inline ::flyteidl::artifact::ArtifactSpec* CreateArtifactRequest::release_spec() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.CreateArtifactRequest.spec)
  
  ::flyteidl::artifact::ArtifactSpec* temp = spec_;
  spec_ = nullptr;
  return temp;
}
inline ::flyteidl::artifact::ArtifactSpec* CreateArtifactRequest::mutable_spec() {
  
  if (spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::artifact::ArtifactSpec>(GetArenaNoVirtual());
    spec_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.CreateArtifactRequest.spec)
  return spec_;
}
inline void CreateArtifactRequest::set_allocated_spec(::flyteidl::artifact::ArtifactSpec* spec) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete spec_;
  }
  if (spec) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      spec = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    
  } else {
    
  }
  spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.CreateArtifactRequest.spec)
}

// map<string, string> partitions = 4;
inline int CreateArtifactRequest::partitions_size() const {
  return partitions_.size();
}
inline void CreateArtifactRequest::clear_partitions() {
  partitions_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
CreateArtifactRequest::partitions() const {
  // @@protoc_insertion_point(field_map:flyteidl.artifact.CreateArtifactRequest.partitions)
  return partitions_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
CreateArtifactRequest::mutable_partitions() {
  // @@protoc_insertion_point(field_mutable_map:flyteidl.artifact.CreateArtifactRequest.partitions)
  return partitions_.MutableMap();
}

// string tag = 5;
inline void CreateArtifactRequest::clear_tag() {
  tag_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CreateArtifactRequest::tag() const {
  // @@protoc_insertion_point(field_get:flyteidl.artifact.CreateArtifactRequest.tag)
  return tag_.GetNoArena();
}
inline void CreateArtifactRequest::set_tag(const ::std::string& value) {
  
  tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.artifact.CreateArtifactRequest.tag)
}
#if LANG_CXX11
inline void CreateArtifactRequest::set_tag(::std::string&& value) {
  
  tag_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.artifact.CreateArtifactRequest.tag)
}
#endif
inline void CreateArtifactRequest::set_tag(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.artifact.CreateArtifactRequest.tag)
}
inline void CreateArtifactRequest::set_tag(const char* value, size_t size) {
  
  tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.artifact.CreateArtifactRequest.tag)
}
inline ::std::string* CreateArtifactRequest::mutable_tag() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.CreateArtifactRequest.tag)
  return tag_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateArtifactRequest::release_tag() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.CreateArtifactRequest.tag)
  
  return tag_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateArtifactRequest::set_allocated_tag(::std::string* tag) {
  if (tag != nullptr) {
    
  } else {
    
  }
  tag_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tag);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.CreateArtifactRequest.tag)
}

// -------------------------------------------------------------------

// ArtifactSpec

// .flyteidl.core.Literal value = 1;
inline bool ArtifactSpec::has_value() const {
  return this != internal_default_instance() && value_ != nullptr;
}
inline const ::flyteidl::core::Literal& ArtifactSpec::value() const {
  const ::flyteidl::core::Literal* p = value_;
  // @@protoc_insertion_point(field_get:flyteidl.artifact.ArtifactSpec.value)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::Literal*>(
      &::flyteidl::core::_Literal_default_instance_);
}
inline ::flyteidl::core::Literal* ArtifactSpec::release_value() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.ArtifactSpec.value)
  
  ::flyteidl::core::Literal* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::flyteidl::core::Literal* ArtifactSpec::mutable_value() {
  
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::Literal>(GetArenaNoVirtual());
    value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.ArtifactSpec.value)
  return value_;
}
inline void ArtifactSpec::set_allocated_value(::flyteidl::core::Literal* value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(value_);
  }
  if (value) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.ArtifactSpec.value)
}

// .flyteidl.core.LiteralType type = 2;
inline bool ArtifactSpec::has_type() const {
  return this != internal_default_instance() && type_ != nullptr;
}
inline const ::flyteidl::core::LiteralType& ArtifactSpec::type() const {
  const ::flyteidl::core::LiteralType* p = type_;
  // @@protoc_insertion_point(field_get:flyteidl.artifact.ArtifactSpec.type)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::LiteralType*>(
      &::flyteidl::core::_LiteralType_default_instance_);
}
inline ::flyteidl::core::LiteralType* ArtifactSpec::release_type() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.ArtifactSpec.type)
  
  ::flyteidl::core::LiteralType* temp = type_;
  type_ = nullptr;
  return temp;
}
inline ::flyteidl::core::LiteralType* ArtifactSpec::mutable_type() {
  
  if (type_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::LiteralType>(GetArenaNoVirtual());
    type_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.ArtifactSpec.type)
  return type_;
}
inline void ArtifactSpec::set_allocated_type(::flyteidl::core::LiteralType* type) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(type_);
  }
  if (type) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      type = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, type, submessage_arena);
    }
    
  } else {
    
  }
  type_ = type;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.ArtifactSpec.type)
}

// .flyteidl.core.TaskExecutionIdentifier task_execution = 5;
inline bool ArtifactSpec::has_task_execution() const {
  return source_case() == kTaskExecution;
}
inline void ArtifactSpec::set_has_task_execution() {
  _oneof_case_[0] = kTaskExecution;
}
inline ::flyteidl::core::TaskExecutionIdentifier* ArtifactSpec::release_task_execution() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.ArtifactSpec.task_execution)
  if (has_task_execution()) {
    clear_has_source();
      ::flyteidl::core::TaskExecutionIdentifier* temp = source_.task_execution_;
    source_.task_execution_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::core::TaskExecutionIdentifier& ArtifactSpec::task_execution() const {
  // @@protoc_insertion_point(field_get:flyteidl.artifact.ArtifactSpec.task_execution)
  return has_task_execution()
      ? *source_.task_execution_
      : *reinterpret_cast< ::flyteidl::core::TaskExecutionIdentifier*>(&::flyteidl::core::_TaskExecutionIdentifier_default_instance_);
}
inline ::flyteidl::core::TaskExecutionIdentifier* ArtifactSpec::mutable_task_execution() {
  if (!has_task_execution()) {
    clear_source();
    set_has_task_execution();
    source_.task_execution_ = CreateMaybeMessage< ::flyteidl::core::TaskExecutionIdentifier >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.ArtifactSpec.task_execution)
  return source_.task_execution_;
}

// .flyteidl.core.WorkflowExecutionIdentifier execution = 6;
inline bool ArtifactSpec::has_execution() const {
  return source_case() == kExecution;
}
inline void ArtifactSpec::set_has_execution() {
  _oneof_case_[0] = kExecution;
}
inline ::flyteidl::core::WorkflowExecutionIdentifier* ArtifactSpec::release_execution() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.ArtifactSpec.execution)
  if (has_execution()) {
    clear_has_source();
      ::flyteidl::core::WorkflowExecutionIdentifier* temp = source_.execution_;
    source_.execution_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::core::WorkflowExecutionIdentifier& ArtifactSpec::execution() const {
  // @@protoc_insertion_point(field_get:flyteidl.artifact.ArtifactSpec.execution)
  return has_execution()
      ? *source_.execution_
      : *reinterpret_cast< ::flyteidl::core::WorkflowExecutionIdentifier*>(&::flyteidl::core::_WorkflowExecutionIdentifier_default_instance_);
}
inline ::flyteidl::core::WorkflowExecutionIdentifier* ArtifactSpec::mutable_execution() {
  if (!has_execution()) {
    clear_source();
    set_has_execution();
    source_.execution_ = CreateMaybeMessage< ::flyteidl::core::WorkflowExecutionIdentifier >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.ArtifactSpec.execution)
  return source_.execution_;
}

// string principal = 7;
inline bool ArtifactSpec::has_principal() const {
  return source_case() == kPrincipal;
}
inline void ArtifactSpec::set_has_principal() {
  _oneof_case_[0] = kPrincipal;
}
inline void ArtifactSpec::clear_principal() {
  if (has_principal()) {
    source_.principal_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_source();
  }
}
inline const ::std::string& ArtifactSpec::principal() const {
  // @@protoc_insertion_point(field_get:flyteidl.artifact.ArtifactSpec.principal)
  if (has_principal()) {
    return source_.principal_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void ArtifactSpec::set_principal(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:flyteidl.artifact.ArtifactSpec.principal)
  if (!has_principal()) {
    clear_source();
    set_has_principal();
    source_.principal_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  source_.principal_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.artifact.ArtifactSpec.principal)
}
#if LANG_CXX11
inline void ArtifactSpec::set_principal(::std::string&& value) {
  // @@protoc_insertion_point(field_set:flyteidl.artifact.ArtifactSpec.principal)
  if (!has_principal()) {
    clear_source();
    set_has_principal();
    source_.principal_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  source_.principal_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.artifact.ArtifactSpec.principal)
}
#endif
inline void ArtifactSpec::set_principal(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!has_principal()) {
    clear_source();
    set_has_principal();
    source_.principal_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  source_.principal_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.artifact.ArtifactSpec.principal)
}
inline void ArtifactSpec::set_principal(const char* value, size_t size) {
  if (!has_principal()) {
    clear_source();
    set_has_principal();
    source_.principal_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  source_.principal_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.artifact.ArtifactSpec.principal)
}
inline ::std::string* ArtifactSpec::mutable_principal() {
  if (!has_principal()) {
    clear_source();
    set_has_principal();
    source_.principal_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.ArtifactSpec.principal)
  return source_.principal_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ArtifactSpec::release_principal() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.ArtifactSpec.principal)
  if (has_principal()) {
    clear_has_source();
    return source_.principal_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return nullptr;
  }
}
inline void ArtifactSpec::set_allocated_principal(::std::string* principal) {
  if (has_source()) {
    clear_source();
  }
  if (principal != nullptr) {
    set_has_principal();
    source_.principal_.UnsafeSetDefault(principal);
  }
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.ArtifactSpec.principal)
}

// string short_description = 8;
inline void ArtifactSpec::clear_short_description() {
  short_description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ArtifactSpec::short_description() const {
  // @@protoc_insertion_point(field_get:flyteidl.artifact.ArtifactSpec.short_description)
  return short_description_.GetNoArena();
}
inline void ArtifactSpec::set_short_description(const ::std::string& value) {
  
  short_description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.artifact.ArtifactSpec.short_description)
}
#if LANG_CXX11
inline void ArtifactSpec::set_short_description(::std::string&& value) {
  
  short_description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.artifact.ArtifactSpec.short_description)
}
#endif
inline void ArtifactSpec::set_short_description(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  short_description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.artifact.ArtifactSpec.short_description)
}
inline void ArtifactSpec::set_short_description(const char* value, size_t size) {
  
  short_description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.artifact.ArtifactSpec.short_description)
}
inline ::std::string* ArtifactSpec::mutable_short_description() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.ArtifactSpec.short_description)
  return short_description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ArtifactSpec::release_short_description() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.ArtifactSpec.short_description)
  
  return short_description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ArtifactSpec::set_allocated_short_description(::std::string* short_description) {
  if (short_description != nullptr) {
    
  } else {
    
  }
  short_description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), short_description);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.ArtifactSpec.short_description)
}

// string long_description = 9;
inline void ArtifactSpec::clear_long_description() {
  long_description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ArtifactSpec::long_description() const {
  // @@protoc_insertion_point(field_get:flyteidl.artifact.ArtifactSpec.long_description)
  return long_description_.GetNoArena();
}
inline void ArtifactSpec::set_long_description(const ::std::string& value) {
  
  long_description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.artifact.ArtifactSpec.long_description)
}
#if LANG_CXX11
inline void ArtifactSpec::set_long_description(::std::string&& value) {
  
  long_description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.artifact.ArtifactSpec.long_description)
}
#endif
inline void ArtifactSpec::set_long_description(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  long_description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.artifact.ArtifactSpec.long_description)
}
inline void ArtifactSpec::set_long_description(const char* value, size_t size) {
  
  long_description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.artifact.ArtifactSpec.long_description)
}
inline ::std::string* ArtifactSpec::mutable_long_description() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.ArtifactSpec.long_description)
  return long_description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ArtifactSpec::release_long_description() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.ArtifactSpec.long_description)
  
  return long_description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ArtifactSpec::set_allocated_long_description(::std::string* long_description) {
  if (long_description != nullptr) {
    
  } else {
    
  }
  long_description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), long_description);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.ArtifactSpec.long_description)
}

// .google.protobuf.Any user_metadata = 10;
inline bool ArtifactSpec::has_user_metadata() const {
  return this != internal_default_instance() && user_metadata_ != nullptr;
}
inline const ::google::protobuf::Any& ArtifactSpec::user_metadata() const {
  const ::google::protobuf::Any* p = user_metadata_;
  // @@protoc_insertion_point(field_get:flyteidl.artifact.ArtifactSpec.user_metadata)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::Any*>(
      &::google::protobuf::_Any_default_instance_);
}
inline ::google::protobuf::Any* ArtifactSpec::release_user_metadata() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.ArtifactSpec.user_metadata)
  
  ::google::protobuf::Any* temp = user_metadata_;
  user_metadata_ = nullptr;
  return temp;
}
inline ::google::protobuf::Any* ArtifactSpec::mutable_user_metadata() {
  
  if (user_metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Any>(GetArenaNoVirtual());
    user_metadata_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.ArtifactSpec.user_metadata)
  return user_metadata_;
}
inline void ArtifactSpec::set_allocated_user_metadata(::google::protobuf::Any* user_metadata) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(user_metadata_);
  }
  if (user_metadata) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      user_metadata = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, user_metadata, submessage_arena);
    }
    
  } else {
    
  }
  user_metadata_ = user_metadata;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.ArtifactSpec.user_metadata)
}

inline bool ArtifactSpec::has_source() const {
  return source_case() != SOURCE_NOT_SET;
}
inline void ArtifactSpec::clear_has_source() {
  _oneof_case_[0] = SOURCE_NOT_SET;
}
inline ArtifactSpec::SourceCase ArtifactSpec::source_case() const {
  return ArtifactSpec::SourceCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// CreateArtifactResponse

// .flyteidl.artifact.Artifact artifact = 1;
inline bool CreateArtifactResponse::has_artifact() const {
  return this != internal_default_instance() && artifact_ != nullptr;
}
inline void CreateArtifactResponse::clear_artifact() {
  if (GetArenaNoVirtual() == nullptr && artifact_ != nullptr) {
    delete artifact_;
  }
  artifact_ = nullptr;
}
inline const ::flyteidl::artifact::Artifact& CreateArtifactResponse::artifact() const {
  const ::flyteidl::artifact::Artifact* p = artifact_;
  // @@protoc_insertion_point(field_get:flyteidl.artifact.CreateArtifactResponse.artifact)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::artifact::Artifact*>(
      &::flyteidl::artifact::_Artifact_default_instance_);
}
inline ::flyteidl::artifact::Artifact* CreateArtifactResponse::release_artifact() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.CreateArtifactResponse.artifact)
  
  ::flyteidl::artifact::Artifact* temp = artifact_;
  artifact_ = nullptr;
  return temp;
}
inline ::flyteidl::artifact::Artifact* CreateArtifactResponse::mutable_artifact() {
  
  if (artifact_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::artifact::Artifact>(GetArenaNoVirtual());
    artifact_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.CreateArtifactResponse.artifact)
  return artifact_;
}
inline void CreateArtifactResponse::set_allocated_artifact(::flyteidl::artifact::Artifact* artifact) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete artifact_;
  }
  if (artifact) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      artifact = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, artifact, submessage_arena);
    }
    
  } else {
    
  }
  artifact_ = artifact;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.CreateArtifactResponse.artifact)
}

// -------------------------------------------------------------------

// GetArtifactRequest

// .flyteidl.core.ArtifactQuery query = 1;
inline bool GetArtifactRequest::has_query() const {
  return this != internal_default_instance() && query_ != nullptr;
}
inline const ::flyteidl::core::ArtifactQuery& GetArtifactRequest::query() const {
  const ::flyteidl::core::ArtifactQuery* p = query_;
  // @@protoc_insertion_point(field_get:flyteidl.artifact.GetArtifactRequest.query)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::ArtifactQuery*>(
      &::flyteidl::core::_ArtifactQuery_default_instance_);
}
inline ::flyteidl::core::ArtifactQuery* GetArtifactRequest::release_query() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.GetArtifactRequest.query)
  
  ::flyteidl::core::ArtifactQuery* temp = query_;
  query_ = nullptr;
  return temp;
}
inline ::flyteidl::core::ArtifactQuery* GetArtifactRequest::mutable_query() {
  
  if (query_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::ArtifactQuery>(GetArenaNoVirtual());
    query_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.GetArtifactRequest.query)
  return query_;
}
inline void GetArtifactRequest::set_allocated_query(::flyteidl::core::ArtifactQuery* query) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(query_);
  }
  if (query) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      query = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, query, submessage_arena);
    }
    
  } else {
    
  }
  query_ = query;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.GetArtifactRequest.query)
}

// bool details = 2;
inline void GetArtifactRequest::clear_details() {
  details_ = false;
}
inline bool GetArtifactRequest::details() const {
  // @@protoc_insertion_point(field_get:flyteidl.artifact.GetArtifactRequest.details)
  return details_;
}
inline void GetArtifactRequest::set_details(bool value) {
  
  details_ = value;
  // @@protoc_insertion_point(field_set:flyteidl.artifact.GetArtifactRequest.details)
}

// -------------------------------------------------------------------

// GetArtifactResponse

// .flyteidl.artifact.Artifact artifact = 1;
inline bool GetArtifactResponse::has_artifact() const {
  return this != internal_default_instance() && artifact_ != nullptr;
}
inline void GetArtifactResponse::clear_artifact() {
  if (GetArenaNoVirtual() == nullptr && artifact_ != nullptr) {
    delete artifact_;
  }
  artifact_ = nullptr;
}
inline const ::flyteidl::artifact::Artifact& GetArtifactResponse::artifact() const {
  const ::flyteidl::artifact::Artifact* p = artifact_;
  // @@protoc_insertion_point(field_get:flyteidl.artifact.GetArtifactResponse.artifact)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::artifact::Artifact*>(
      &::flyteidl::artifact::_Artifact_default_instance_);
}
inline ::flyteidl::artifact::Artifact* GetArtifactResponse::release_artifact() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.GetArtifactResponse.artifact)
  
  ::flyteidl::artifact::Artifact* temp = artifact_;
  artifact_ = nullptr;
  return temp;
}
inline ::flyteidl::artifact::Artifact* GetArtifactResponse::mutable_artifact() {
  
  if (artifact_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::artifact::Artifact>(GetArenaNoVirtual());
    artifact_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.GetArtifactResponse.artifact)
  return artifact_;
}
inline void GetArtifactResponse::set_allocated_artifact(::flyteidl::artifact::Artifact* artifact) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete artifact_;
  }
  if (artifact) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      artifact = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, artifact, submessage_arena);
    }
    
  } else {
    
  }
  artifact_ = artifact;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.GetArtifactResponse.artifact)
}

// -------------------------------------------------------------------

// ListArtifactNamesRequest

// string project = 1;
inline void ListArtifactNamesRequest::clear_project() {
  project_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ListArtifactNamesRequest::project() const {
  // @@protoc_insertion_point(field_get:flyteidl.artifact.ListArtifactNamesRequest.project)
  return project_.GetNoArena();
}
inline void ListArtifactNamesRequest::set_project(const ::std::string& value) {
  
  project_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.artifact.ListArtifactNamesRequest.project)
}
#if LANG_CXX11
inline void ListArtifactNamesRequest::set_project(::std::string&& value) {
  
  project_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.artifact.ListArtifactNamesRequest.project)
}
#endif
inline void ListArtifactNamesRequest::set_project(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  project_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.artifact.ListArtifactNamesRequest.project)
}
inline void ListArtifactNamesRequest::set_project(const char* value, size_t size) {
  
  project_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.artifact.ListArtifactNamesRequest.project)
}
inline ::std::string* ListArtifactNamesRequest::mutable_project() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.ListArtifactNamesRequest.project)
  return project_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ListArtifactNamesRequest::release_project() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.ListArtifactNamesRequest.project)
  
  return project_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ListArtifactNamesRequest::set_allocated_project(::std::string* project) {
  if (project != nullptr) {
    
  } else {
    
  }
  project_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), project);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.ListArtifactNamesRequest.project)
}

// string domain = 2;
inline void ListArtifactNamesRequest::clear_domain() {
  domain_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ListArtifactNamesRequest::domain() const {
  // @@protoc_insertion_point(field_get:flyteidl.artifact.ListArtifactNamesRequest.domain)
  return domain_.GetNoArena();
}
inline void ListArtifactNamesRequest::set_domain(const ::std::string& value) {
  
  domain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.artifact.ListArtifactNamesRequest.domain)
}
#if LANG_CXX11
inline void ListArtifactNamesRequest::set_domain(::std::string&& value) {
  
  domain_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.artifact.ListArtifactNamesRequest.domain)
}
#endif
inline void ListArtifactNamesRequest::set_domain(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  domain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.artifact.ListArtifactNamesRequest.domain)
}
inline void ListArtifactNamesRequest::set_domain(const char* value, size_t size) {
  
  domain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.artifact.ListArtifactNamesRequest.domain)
}
inline ::std::string* ListArtifactNamesRequest::mutable_domain() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.ListArtifactNamesRequest.domain)
  return domain_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ListArtifactNamesRequest::release_domain() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.ListArtifactNamesRequest.domain)
  
  return domain_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ListArtifactNamesRequest::set_allocated_domain(::std::string* domain) {
  if (domain != nullptr) {
    
  } else {
    
  }
  domain_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), domain);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.ListArtifactNamesRequest.domain)
}

// -------------------------------------------------------------------

// ListArtifactNamesResponse

// repeated .flyteidl.core.ArtifactKey artifact_keys = 1;
inline int ListArtifactNamesResponse::artifact_keys_size() const {
  return artifact_keys_.size();
}
inline ::flyteidl::core::ArtifactKey* ListArtifactNamesResponse::mutable_artifact_keys(int index) {
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.ListArtifactNamesResponse.artifact_keys)
  return artifact_keys_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::flyteidl::core::ArtifactKey >*
ListArtifactNamesResponse::mutable_artifact_keys() {
  // @@protoc_insertion_point(field_mutable_list:flyteidl.artifact.ListArtifactNamesResponse.artifact_keys)
  return &artifact_keys_;
}
inline const ::flyteidl::core::ArtifactKey& ListArtifactNamesResponse::artifact_keys(int index) const {
  // @@protoc_insertion_point(field_get:flyteidl.artifact.ListArtifactNamesResponse.artifact_keys)
  return artifact_keys_.Get(index);
}
inline ::flyteidl::core::ArtifactKey* ListArtifactNamesResponse::add_artifact_keys() {
  // @@protoc_insertion_point(field_add:flyteidl.artifact.ListArtifactNamesResponse.artifact_keys)
  return artifact_keys_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::flyteidl::core::ArtifactKey >&
ListArtifactNamesResponse::artifact_keys() const {
  // @@protoc_insertion_point(field_list:flyteidl.artifact.ListArtifactNamesResponse.artifact_keys)
  return artifact_keys_;
}

// -------------------------------------------------------------------

// ListArtifactsRequest

// .flyteidl.core.ArtifactKey artifact_key = 1;
inline bool ListArtifactsRequest::has_artifact_key() const {
  return this != internal_default_instance() && artifact_key_ != nullptr;
}
inline const ::flyteidl::core::ArtifactKey& ListArtifactsRequest::artifact_key() const {
  const ::flyteidl::core::ArtifactKey* p = artifact_key_;
  // @@protoc_insertion_point(field_get:flyteidl.artifact.ListArtifactsRequest.artifact_key)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::ArtifactKey*>(
      &::flyteidl::core::_ArtifactKey_default_instance_);
}
inline ::flyteidl::core::ArtifactKey* ListArtifactsRequest::release_artifact_key() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.ListArtifactsRequest.artifact_key)
  
  ::flyteidl::core::ArtifactKey* temp = artifact_key_;
  artifact_key_ = nullptr;
  return temp;
}
inline ::flyteidl::core::ArtifactKey* ListArtifactsRequest::mutable_artifact_key() {
  
  if (artifact_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::ArtifactKey>(GetArenaNoVirtual());
    artifact_key_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.ListArtifactsRequest.artifact_key)
  return artifact_key_;
}
inline void ListArtifactsRequest::set_allocated_artifact_key(::flyteidl::core::ArtifactKey* artifact_key) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(artifact_key_);
  }
  if (artifact_key) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      artifact_key = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, artifact_key, submessage_arena);
    }
    
  } else {
    
  }
  artifact_key_ = artifact_key;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.ListArtifactsRequest.artifact_key)
}

// -------------------------------------------------------------------

// ListArtifactsResponse

// repeated .flyteidl.artifact.Artifact artifacts = 1;
inline int ListArtifactsResponse::artifacts_size() const {
  return artifacts_.size();
}
inline void ListArtifactsResponse::clear_artifacts() {
  artifacts_.Clear();
}
inline ::flyteidl::artifact::Artifact* ListArtifactsResponse::mutable_artifacts(int index) {
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.ListArtifactsResponse.artifacts)
  return artifacts_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::flyteidl::artifact::Artifact >*
ListArtifactsResponse::mutable_artifacts() {
  // @@protoc_insertion_point(field_mutable_list:flyteidl.artifact.ListArtifactsResponse.artifacts)
  return &artifacts_;
}
inline const ::flyteidl::artifact::Artifact& ListArtifactsResponse::artifacts(int index) const {
  // @@protoc_insertion_point(field_get:flyteidl.artifact.ListArtifactsResponse.artifacts)
  return artifacts_.Get(index);
}
inline ::flyteidl::artifact::Artifact* ListArtifactsResponse::add_artifacts() {
  // @@protoc_insertion_point(field_add:flyteidl.artifact.ListArtifactsResponse.artifacts)
  return artifacts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::flyteidl::artifact::Artifact >&
ListArtifactsResponse::artifacts() const {
  // @@protoc_insertion_point(field_list:flyteidl.artifact.ListArtifactsResponse.artifacts)
  return artifacts_;
}

// -------------------------------------------------------------------

// AddTagRequest

// .flyteidl.core.ArtifactID artifact_id = 1;
inline bool AddTagRequest::has_artifact_id() const {
  return this != internal_default_instance() && artifact_id_ != nullptr;
}
inline const ::flyteidl::core::ArtifactID& AddTagRequest::artifact_id() const {
  const ::flyteidl::core::ArtifactID* p = artifact_id_;
  // @@protoc_insertion_point(field_get:flyteidl.artifact.AddTagRequest.artifact_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::ArtifactID*>(
      &::flyteidl::core::_ArtifactID_default_instance_);
}
inline ::flyteidl::core::ArtifactID* AddTagRequest::release_artifact_id() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.AddTagRequest.artifact_id)
  
  ::flyteidl::core::ArtifactID* temp = artifact_id_;
  artifact_id_ = nullptr;
  return temp;
}
inline ::flyteidl::core::ArtifactID* AddTagRequest::mutable_artifact_id() {
  
  if (artifact_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::ArtifactID>(GetArenaNoVirtual());
    artifact_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.AddTagRequest.artifact_id)
  return artifact_id_;
}
inline void AddTagRequest::set_allocated_artifact_id(::flyteidl::core::ArtifactID* artifact_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(artifact_id_);
  }
  if (artifact_id) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      artifact_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, artifact_id, submessage_arena);
    }
    
  } else {
    
  }
  artifact_id_ = artifact_id;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.AddTagRequest.artifact_id)
}

// string value = 2;
inline void AddTagRequest::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AddTagRequest::value() const {
  // @@protoc_insertion_point(field_get:flyteidl.artifact.AddTagRequest.value)
  return value_.GetNoArena();
}
inline void AddTagRequest::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.artifact.AddTagRequest.value)
}
#if LANG_CXX11
inline void AddTagRequest::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.artifact.AddTagRequest.value)
}
#endif
inline void AddTagRequest::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.artifact.AddTagRequest.value)
}
inline void AddTagRequest::set_value(const char* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.artifact.AddTagRequest.value)
}
inline ::std::string* AddTagRequest::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.AddTagRequest.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AddTagRequest::release_value() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.AddTagRequest.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AddTagRequest::set_allocated_value(::std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.AddTagRequest.value)
}

// bool overwrite = 3;
inline void AddTagRequest::clear_overwrite() {
  overwrite_ = false;
}
inline bool AddTagRequest::overwrite() const {
  // @@protoc_insertion_point(field_get:flyteidl.artifact.AddTagRequest.overwrite)
  return overwrite_;
}
inline void AddTagRequest::set_overwrite(bool value) {
  
  overwrite_ = value;
  // @@protoc_insertion_point(field_set:flyteidl.artifact.AddTagRequest.overwrite)
}

// -------------------------------------------------------------------

// AddTagResponse

// -------------------------------------------------------------------

// CreateTriggerRequest

// .flyteidl.artifact.Trigger trigger = 1;
inline bool CreateTriggerRequest::has_trigger() const {
  return this != internal_default_instance() && trigger_ != nullptr;
}
inline void CreateTriggerRequest::clear_trigger() {
  if (GetArenaNoVirtual() == nullptr && trigger_ != nullptr) {
    delete trigger_;
  }
  trigger_ = nullptr;
}
inline const ::flyteidl::artifact::Trigger& CreateTriggerRequest::trigger() const {
  const ::flyteidl::artifact::Trigger* p = trigger_;
  // @@protoc_insertion_point(field_get:flyteidl.artifact.CreateTriggerRequest.trigger)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::artifact::Trigger*>(
      &::flyteidl::artifact::_Trigger_default_instance_);
}
inline ::flyteidl::artifact::Trigger* CreateTriggerRequest::release_trigger() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.CreateTriggerRequest.trigger)
  
  ::flyteidl::artifact::Trigger* temp = trigger_;
  trigger_ = nullptr;
  return temp;
}
inline ::flyteidl::artifact::Trigger* CreateTriggerRequest::mutable_trigger() {
  
  if (trigger_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::artifact::Trigger>(GetArenaNoVirtual());
    trigger_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.CreateTriggerRequest.trigger)
  return trigger_;
}
inline void CreateTriggerRequest::set_allocated_trigger(::flyteidl::artifact::Trigger* trigger) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete trigger_;
  }
  if (trigger) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      trigger = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, trigger, submessage_arena);
    }
    
  } else {
    
  }
  trigger_ = trigger;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.CreateTriggerRequest.trigger)
}

// -------------------------------------------------------------------

// CreateTriggerResponse

// -------------------------------------------------------------------

// DeleteTriggerRequest

// .flyteidl.artifact.Trigger trigger = 1;
inline bool DeleteTriggerRequest::has_trigger() const {
  return this != internal_default_instance() && trigger_ != nullptr;
}
inline void DeleteTriggerRequest::clear_trigger() {
  if (GetArenaNoVirtual() == nullptr && trigger_ != nullptr) {
    delete trigger_;
  }
  trigger_ = nullptr;
}
inline const ::flyteidl::artifact::Trigger& DeleteTriggerRequest::trigger() const {
  const ::flyteidl::artifact::Trigger* p = trigger_;
  // @@protoc_insertion_point(field_get:flyteidl.artifact.DeleteTriggerRequest.trigger)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::artifact::Trigger*>(
      &::flyteidl::artifact::_Trigger_default_instance_);
}
inline ::flyteidl::artifact::Trigger* DeleteTriggerRequest::release_trigger() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.DeleteTriggerRequest.trigger)
  
  ::flyteidl::artifact::Trigger* temp = trigger_;
  trigger_ = nullptr;
  return temp;
}
inline ::flyteidl::artifact::Trigger* DeleteTriggerRequest::mutable_trigger() {
  
  if (trigger_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::artifact::Trigger>(GetArenaNoVirtual());
    trigger_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.DeleteTriggerRequest.trigger)
  return trigger_;
}
inline void DeleteTriggerRequest::set_allocated_trigger(::flyteidl::artifact::Trigger* trigger) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete trigger_;
  }
  if (trigger) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      trigger = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, trigger, submessage_arena);
    }
    
  } else {
    
  }
  trigger_ = trigger;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.DeleteTriggerRequest.trigger)
}

// -------------------------------------------------------------------

// DeleteTriggerResponse

// -------------------------------------------------------------------

// ArtifactProducer

// .flyteidl.core.Identifier entity_id = 1;
inline bool ArtifactProducer::has_entity_id() const {
  return this != internal_default_instance() && entity_id_ != nullptr;
}
inline const ::flyteidl::core::Identifier& ArtifactProducer::entity_id() const {
  const ::flyteidl::core::Identifier* p = entity_id_;
  // @@protoc_insertion_point(field_get:flyteidl.artifact.ArtifactProducer.entity_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::Identifier*>(
      &::flyteidl::core::_Identifier_default_instance_);
}
inline ::flyteidl::core::Identifier* ArtifactProducer::release_entity_id() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.ArtifactProducer.entity_id)
  
  ::flyteidl::core::Identifier* temp = entity_id_;
  entity_id_ = nullptr;
  return temp;
}
inline ::flyteidl::core::Identifier* ArtifactProducer::mutable_entity_id() {
  
  if (entity_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::Identifier>(GetArenaNoVirtual());
    entity_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.ArtifactProducer.entity_id)
  return entity_id_;
}
inline void ArtifactProducer::set_allocated_entity_id(::flyteidl::core::Identifier* entity_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(entity_id_);
  }
  if (entity_id) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      entity_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, entity_id, submessage_arena);
    }
    
  } else {
    
  }
  entity_id_ = entity_id;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.ArtifactProducer.entity_id)
}

// .flyteidl.core.VariableMap outputs = 2;
inline bool ArtifactProducer::has_outputs() const {
  return this != internal_default_instance() && outputs_ != nullptr;
}
inline const ::flyteidl::core::VariableMap& ArtifactProducer::outputs() const {
  const ::flyteidl::core::VariableMap* p = outputs_;
  // @@protoc_insertion_point(field_get:flyteidl.artifact.ArtifactProducer.outputs)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::VariableMap*>(
      &::flyteidl::core::_VariableMap_default_instance_);
}
inline ::flyteidl::core::VariableMap* ArtifactProducer::release_outputs() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.ArtifactProducer.outputs)
  
  ::flyteidl::core::VariableMap* temp = outputs_;
  outputs_ = nullptr;
  return temp;
}
inline ::flyteidl::core::VariableMap* ArtifactProducer::mutable_outputs() {
  
  if (outputs_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::VariableMap>(GetArenaNoVirtual());
    outputs_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.ArtifactProducer.outputs)
  return outputs_;
}
inline void ArtifactProducer::set_allocated_outputs(::flyteidl::core::VariableMap* outputs) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(outputs_);
  }
  if (outputs) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      outputs = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, outputs, submessage_arena);
    }
    
  } else {
    
  }
  outputs_ = outputs;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.ArtifactProducer.outputs)
}

// -------------------------------------------------------------------

// RegisterProducerRequest

// repeated .flyteidl.artifact.ArtifactProducer producers = 1;
inline int RegisterProducerRequest::producers_size() const {
  return producers_.size();
}
inline void RegisterProducerRequest::clear_producers() {
  producers_.Clear();
}
inline ::flyteidl::artifact::ArtifactProducer* RegisterProducerRequest::mutable_producers(int index) {
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.RegisterProducerRequest.producers)
  return producers_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::flyteidl::artifact::ArtifactProducer >*
RegisterProducerRequest::mutable_producers() {
  // @@protoc_insertion_point(field_mutable_list:flyteidl.artifact.RegisterProducerRequest.producers)
  return &producers_;
}
inline const ::flyteidl::artifact::ArtifactProducer& RegisterProducerRequest::producers(int index) const {
  // @@protoc_insertion_point(field_get:flyteidl.artifact.RegisterProducerRequest.producers)
  return producers_.Get(index);
}
inline ::flyteidl::artifact::ArtifactProducer* RegisterProducerRequest::add_producers() {
  // @@protoc_insertion_point(field_add:flyteidl.artifact.RegisterProducerRequest.producers)
  return producers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::flyteidl::artifact::ArtifactProducer >&
RegisterProducerRequest::producers() const {
  // @@protoc_insertion_point(field_list:flyteidl.artifact.RegisterProducerRequest.producers)
  return producers_;
}

// -------------------------------------------------------------------

// ArtifactConsumer

// .flyteidl.core.Identifier entity_id = 1;
inline bool ArtifactConsumer::has_entity_id() const {
  return this != internal_default_instance() && entity_id_ != nullptr;
}
inline const ::flyteidl::core::Identifier& ArtifactConsumer::entity_id() const {
  const ::flyteidl::core::Identifier* p = entity_id_;
  // @@protoc_insertion_point(field_get:flyteidl.artifact.ArtifactConsumer.entity_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::Identifier*>(
      &::flyteidl::core::_Identifier_default_instance_);
}
inline ::flyteidl::core::Identifier* ArtifactConsumer::release_entity_id() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.ArtifactConsumer.entity_id)
  
  ::flyteidl::core::Identifier* temp = entity_id_;
  entity_id_ = nullptr;
  return temp;
}
inline ::flyteidl::core::Identifier* ArtifactConsumer::mutable_entity_id() {
  
  if (entity_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::Identifier>(GetArenaNoVirtual());
    entity_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.ArtifactConsumer.entity_id)
  return entity_id_;
}
inline void ArtifactConsumer::set_allocated_entity_id(::flyteidl::core::Identifier* entity_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(entity_id_);
  }
  if (entity_id) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      entity_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, entity_id, submessage_arena);
    }
    
  } else {
    
  }
  entity_id_ = entity_id;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.ArtifactConsumer.entity_id)
}

// .flyteidl.core.ParameterMap inputs = 2;
inline bool ArtifactConsumer::has_inputs() const {
  return this != internal_default_instance() && inputs_ != nullptr;
}
inline const ::flyteidl::core::ParameterMap& ArtifactConsumer::inputs() const {
  const ::flyteidl::core::ParameterMap* p = inputs_;
  // @@protoc_insertion_point(field_get:flyteidl.artifact.ArtifactConsumer.inputs)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::ParameterMap*>(
      &::flyteidl::core::_ParameterMap_default_instance_);
}
inline ::flyteidl::core::ParameterMap* ArtifactConsumer::release_inputs() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.ArtifactConsumer.inputs)
  
  ::flyteidl::core::ParameterMap* temp = inputs_;
  inputs_ = nullptr;
  return temp;
}
inline ::flyteidl::core::ParameterMap* ArtifactConsumer::mutable_inputs() {
  
  if (inputs_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::ParameterMap>(GetArenaNoVirtual());
    inputs_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.ArtifactConsumer.inputs)
  return inputs_;
}
inline void ArtifactConsumer::set_allocated_inputs(::flyteidl::core::ParameterMap* inputs) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(inputs_);
  }
  if (inputs) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      inputs = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, inputs, submessage_arena);
    }
    
  } else {
    
  }
  inputs_ = inputs;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.ArtifactConsumer.inputs)
}

// -------------------------------------------------------------------

// RegisterConsumerRequest

// repeated .flyteidl.artifact.ArtifactConsumer consumers = 1;
inline int RegisterConsumerRequest::consumers_size() const {
  return consumers_.size();
}
inline void RegisterConsumerRequest::clear_consumers() {
  consumers_.Clear();
}
inline ::flyteidl::artifact::ArtifactConsumer* RegisterConsumerRequest::mutable_consumers(int index) {
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.RegisterConsumerRequest.consumers)
  return consumers_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::flyteidl::artifact::ArtifactConsumer >*
RegisterConsumerRequest::mutable_consumers() {
  // @@protoc_insertion_point(field_mutable_list:flyteidl.artifact.RegisterConsumerRequest.consumers)
  return &consumers_;
}
inline const ::flyteidl::artifact::ArtifactConsumer& RegisterConsumerRequest::consumers(int index) const {
  // @@protoc_insertion_point(field_get:flyteidl.artifact.RegisterConsumerRequest.consumers)
  return consumers_.Get(index);
}
inline ::flyteidl::artifact::ArtifactConsumer* RegisterConsumerRequest::add_consumers() {
  // @@protoc_insertion_point(field_add:flyteidl.artifact.RegisterConsumerRequest.consumers)
  return consumers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::flyteidl::artifact::ArtifactConsumer >&
RegisterConsumerRequest::consumers() const {
  // @@protoc_insertion_point(field_list:flyteidl.artifact.RegisterConsumerRequest.consumers)
  return consumers_;
}

// -------------------------------------------------------------------

// RegisterResponse

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace artifact
}  // namespace flyteidl

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_flyteidl_2fartifact_2fartifacts_2eproto
