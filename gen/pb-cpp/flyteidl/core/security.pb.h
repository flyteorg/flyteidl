// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: flyteidl/core/security.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_flyteidl_2fcore_2fsecurity_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_flyteidl_2fcore_2fsecurity_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_flyteidl_2fcore_2fsecurity_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_flyteidl_2fcore_2fsecurity_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[5]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_flyteidl_2fcore_2fsecurity_2eproto;
namespace flyteidl {
namespace core {
class Identity;
struct IdentityDefaultTypeInternal;
extern IdentityDefaultTypeInternal _Identity_default_instance_;
class OAuth2Client;
struct OAuth2ClientDefaultTypeInternal;
extern OAuth2ClientDefaultTypeInternal _OAuth2Client_default_instance_;
class OAuth2TokenRequest;
struct OAuth2TokenRequestDefaultTypeInternal;
extern OAuth2TokenRequestDefaultTypeInternal _OAuth2TokenRequest_default_instance_;
class Secret;
struct SecretDefaultTypeInternal;
extern SecretDefaultTypeInternal _Secret_default_instance_;
class SecurityContext;
struct SecurityContextDefaultTypeInternal;
extern SecurityContextDefaultTypeInternal _SecurityContext_default_instance_;
}  // namespace core
}  // namespace flyteidl
PROTOBUF_NAMESPACE_OPEN
template<> ::flyteidl::core::Identity* Arena::CreateMaybeMessage<::flyteidl::core::Identity>(Arena*);
template<> ::flyteidl::core::OAuth2Client* Arena::CreateMaybeMessage<::flyteidl::core::OAuth2Client>(Arena*);
template<> ::flyteidl::core::OAuth2TokenRequest* Arena::CreateMaybeMessage<::flyteidl::core::OAuth2TokenRequest>(Arena*);
template<> ::flyteidl::core::Secret* Arena::CreateMaybeMessage<::flyteidl::core::Secret>(Arena*);
template<> ::flyteidl::core::SecurityContext* Arena::CreateMaybeMessage<::flyteidl::core::SecurityContext>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace flyteidl {
namespace core {

enum Secret_MountType : int {
  Secret_MountType_ANY = 0,
  Secret_MountType_ENV_VAR = 1,
  Secret_MountType_FILE = 2,
  Secret_MountType_Secret_MountType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Secret_MountType_Secret_MountType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Secret_MountType_IsValid(int value);
constexpr Secret_MountType Secret_MountType_MountType_MIN = Secret_MountType_ANY;
constexpr Secret_MountType Secret_MountType_MountType_MAX = Secret_MountType_FILE;
constexpr int Secret_MountType_MountType_ARRAYSIZE = Secret_MountType_MountType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Secret_MountType_descriptor();
template<typename T>
inline const std::string& Secret_MountType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Secret_MountType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Secret_MountType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Secret_MountType_descriptor(), enum_t_value);
}
inline bool Secret_MountType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Secret_MountType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Secret_MountType>(
    Secret_MountType_descriptor(), name, value);
}
enum OAuth2TokenRequest_Type : int {
  OAuth2TokenRequest_Type_CLIENT_CREDENTIALS = 0,
  OAuth2TokenRequest_Type_OAuth2TokenRequest_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  OAuth2TokenRequest_Type_OAuth2TokenRequest_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool OAuth2TokenRequest_Type_IsValid(int value);
constexpr OAuth2TokenRequest_Type OAuth2TokenRequest_Type_Type_MIN = OAuth2TokenRequest_Type_CLIENT_CREDENTIALS;
constexpr OAuth2TokenRequest_Type OAuth2TokenRequest_Type_Type_MAX = OAuth2TokenRequest_Type_CLIENT_CREDENTIALS;
constexpr int OAuth2TokenRequest_Type_Type_ARRAYSIZE = OAuth2TokenRequest_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OAuth2TokenRequest_Type_descriptor();
template<typename T>
inline const std::string& OAuth2TokenRequest_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OAuth2TokenRequest_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OAuth2TokenRequest_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OAuth2TokenRequest_Type_descriptor(), enum_t_value);
}
inline bool OAuth2TokenRequest_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OAuth2TokenRequest_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OAuth2TokenRequest_Type>(
    OAuth2TokenRequest_Type_descriptor(), name, value);
}
// ===================================================================

class Secret final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.Secret) */ {
 public:
  inline Secret() : Secret(nullptr) {}
  ~Secret() override;
  explicit constexpr Secret(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Secret(const Secret& from);
  Secret(Secret&& from) noexcept
    : Secret() {
    *this = ::std::move(from);
  }

  inline Secret& operator=(const Secret& from) {
    CopyFrom(from);
    return *this;
  }
  inline Secret& operator=(Secret&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Secret& default_instance() {
    return *internal_default_instance();
  }
  static inline const Secret* internal_default_instance() {
    return reinterpret_cast<const Secret*>(
               &_Secret_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Secret& a, Secret& b) {
    a.Swap(&b);
  }
  inline void Swap(Secret* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Secret* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Secret* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Secret>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Secret* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.core.Secret";
  }
  protected:
  explicit Secret(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Secret_MountType MountType;
  static constexpr MountType ANY =
    Secret_MountType_ANY;
  static constexpr MountType ENV_VAR =
    Secret_MountType_ENV_VAR;
  static constexpr MountType FILE =
    Secret_MountType_FILE;
  static inline bool MountType_IsValid(int value) {
    return Secret_MountType_IsValid(value);
  }
  static constexpr MountType MountType_MIN =
    Secret_MountType_MountType_MIN;
  static constexpr MountType MountType_MAX =
    Secret_MountType_MountType_MAX;
  static constexpr int MountType_ARRAYSIZE =
    Secret_MountType_MountType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  MountType_descriptor() {
    return Secret_MountType_descriptor();
  }
  template<typename T>
  static inline const std::string& MountType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MountType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MountType_Name.");
    return Secret_MountType_Name(enum_t_value);
  }
  static inline bool MountType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      MountType* value) {
    return Secret_MountType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kGroupFieldNumber = 1,
    kGroupVersionFieldNumber = 2,
    kKeyFieldNumber = 3,
    kMountRequirementFieldNumber = 4,
  };
  // string group = 1 [json_name = "group"];
  void clear_group();
  const std::string& group() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_group(ArgT0&& arg0, ArgT... args);
  std::string* mutable_group();
  PROTOBUF_NODISCARD std::string* release_group();
  void set_allocated_group(std::string* group);
  private:
  const std::string& _internal_group() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_group(const std::string& value);
  std::string* _internal_mutable_group();
  public:

  // string group_version = 2 [json_name = "groupVersion"];
  void clear_group_version();
  const std::string& group_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_group_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_group_version();
  PROTOBUF_NODISCARD std::string* release_group_version();
  void set_allocated_group_version(std::string* group_version);
  private:
  const std::string& _internal_group_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_group_version(const std::string& value);
  std::string* _internal_mutable_group_version();
  public:

  // string key = 3 [json_name = "key"];
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // .flyteidl.core.Secret.MountType mount_requirement = 4 [json_name = "mountRequirement"];
  void clear_mount_requirement();
  ::flyteidl::core::Secret_MountType mount_requirement() const;
  void set_mount_requirement(::flyteidl::core::Secret_MountType value);
  private:
  ::flyteidl::core::Secret_MountType _internal_mount_requirement() const;
  void _internal_set_mount_requirement(::flyteidl::core::Secret_MountType value);
  public:

  // @@protoc_insertion_point(class_scope:flyteidl.core.Secret)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr group_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr group_version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  int mount_requirement_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2fsecurity_2eproto;
};
// -------------------------------------------------------------------

class OAuth2Client final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.OAuth2Client) */ {
 public:
  inline OAuth2Client() : OAuth2Client(nullptr) {}
  ~OAuth2Client() override;
  explicit constexpr OAuth2Client(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OAuth2Client(const OAuth2Client& from);
  OAuth2Client(OAuth2Client&& from) noexcept
    : OAuth2Client() {
    *this = ::std::move(from);
  }

  inline OAuth2Client& operator=(const OAuth2Client& from) {
    CopyFrom(from);
    return *this;
  }
  inline OAuth2Client& operator=(OAuth2Client&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OAuth2Client& default_instance() {
    return *internal_default_instance();
  }
  static inline const OAuth2Client* internal_default_instance() {
    return reinterpret_cast<const OAuth2Client*>(
               &_OAuth2Client_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(OAuth2Client& a, OAuth2Client& b) {
    a.Swap(&b);
  }
  inline void Swap(OAuth2Client* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OAuth2Client* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OAuth2Client* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OAuth2Client>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OAuth2Client* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.core.OAuth2Client";
  }
  protected:
  explicit OAuth2Client(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 1,
    kClientSecretFieldNumber = 2,
  };
  // string client_id = 1 [json_name = "clientId"];
  void clear_client_id();
  const std::string& client_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_client_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_client_id();
  PROTOBUF_NODISCARD std::string* release_client_id();
  void set_allocated_client_id(std::string* client_id);
  private:
  const std::string& _internal_client_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_id(const std::string& value);
  std::string* _internal_mutable_client_id();
  public:

  // .flyteidl.core.Secret client_secret = 2 [json_name = "clientSecret"];
  bool has_client_secret() const;
  private:
  bool _internal_has_client_secret() const;
  public:
  void clear_client_secret();
  const ::flyteidl::core::Secret& client_secret() const;
  PROTOBUF_NODISCARD ::flyteidl::core::Secret* release_client_secret();
  ::flyteidl::core::Secret* mutable_client_secret();
  void set_allocated_client_secret(::flyteidl::core::Secret* client_secret);
  private:
  const ::flyteidl::core::Secret& _internal_client_secret() const;
  ::flyteidl::core::Secret* _internal_mutable_client_secret();
  public:
  void unsafe_arena_set_allocated_client_secret(
      ::flyteidl::core::Secret* client_secret);
  ::flyteidl::core::Secret* unsafe_arena_release_client_secret();

  // @@protoc_insertion_point(class_scope:flyteidl.core.OAuth2Client)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_id_;
  ::flyteidl::core::Secret* client_secret_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2fsecurity_2eproto;
};
// -------------------------------------------------------------------

class Identity final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.Identity) */ {
 public:
  inline Identity() : Identity(nullptr) {}
  ~Identity() override;
  explicit constexpr Identity(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Identity(const Identity& from);
  Identity(Identity&& from) noexcept
    : Identity() {
    *this = ::std::move(from);
  }

  inline Identity& operator=(const Identity& from) {
    CopyFrom(from);
    return *this;
  }
  inline Identity& operator=(Identity&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Identity& default_instance() {
    return *internal_default_instance();
  }
  static inline const Identity* internal_default_instance() {
    return reinterpret_cast<const Identity*>(
               &_Identity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Identity& a, Identity& b) {
    a.Swap(&b);
  }
  inline void Swap(Identity* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Identity* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Identity* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Identity>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Identity* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.core.Identity";
  }
  protected:
  explicit Identity(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIamRoleFieldNumber = 1,
    kK8SServiceAccountFieldNumber = 2,
    kOauth2ClientFieldNumber = 3,
  };
  // string iam_role = 1 [json_name = "iamRole"];
  void clear_iam_role();
  const std::string& iam_role() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_iam_role(ArgT0&& arg0, ArgT... args);
  std::string* mutable_iam_role();
  PROTOBUF_NODISCARD std::string* release_iam_role();
  void set_allocated_iam_role(std::string* iam_role);
  private:
  const std::string& _internal_iam_role() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_iam_role(const std::string& value);
  std::string* _internal_mutable_iam_role();
  public:

  // string k8s_service_account = 2 [json_name = "k8sServiceAccount"];
  void clear_k8s_service_account();
  const std::string& k8s_service_account() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_k8s_service_account(ArgT0&& arg0, ArgT... args);
  std::string* mutable_k8s_service_account();
  PROTOBUF_NODISCARD std::string* release_k8s_service_account();
  void set_allocated_k8s_service_account(std::string* k8s_service_account);
  private:
  const std::string& _internal_k8s_service_account() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_k8s_service_account(const std::string& value);
  std::string* _internal_mutable_k8s_service_account();
  public:

  // .flyteidl.core.OAuth2Client oauth2_client = 3 [json_name = "oauth2Client"];
  bool has_oauth2_client() const;
  private:
  bool _internal_has_oauth2_client() const;
  public:
  void clear_oauth2_client();
  const ::flyteidl::core::OAuth2Client& oauth2_client() const;
  PROTOBUF_NODISCARD ::flyteidl::core::OAuth2Client* release_oauth2_client();
  ::flyteidl::core::OAuth2Client* mutable_oauth2_client();
  void set_allocated_oauth2_client(::flyteidl::core::OAuth2Client* oauth2_client);
  private:
  const ::flyteidl::core::OAuth2Client& _internal_oauth2_client() const;
  ::flyteidl::core::OAuth2Client* _internal_mutable_oauth2_client();
  public:
  void unsafe_arena_set_allocated_oauth2_client(
      ::flyteidl::core::OAuth2Client* oauth2_client);
  ::flyteidl::core::OAuth2Client* unsafe_arena_release_oauth2_client();

  // @@protoc_insertion_point(class_scope:flyteidl.core.Identity)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr iam_role_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr k8s_service_account_;
  ::flyteidl::core::OAuth2Client* oauth2_client_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2fsecurity_2eproto;
};
// -------------------------------------------------------------------

class OAuth2TokenRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.OAuth2TokenRequest) */ {
 public:
  inline OAuth2TokenRequest() : OAuth2TokenRequest(nullptr) {}
  ~OAuth2TokenRequest() override;
  explicit constexpr OAuth2TokenRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OAuth2TokenRequest(const OAuth2TokenRequest& from);
  OAuth2TokenRequest(OAuth2TokenRequest&& from) noexcept
    : OAuth2TokenRequest() {
    *this = ::std::move(from);
  }

  inline OAuth2TokenRequest& operator=(const OAuth2TokenRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline OAuth2TokenRequest& operator=(OAuth2TokenRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OAuth2TokenRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const OAuth2TokenRequest* internal_default_instance() {
    return reinterpret_cast<const OAuth2TokenRequest*>(
               &_OAuth2TokenRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(OAuth2TokenRequest& a, OAuth2TokenRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(OAuth2TokenRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OAuth2TokenRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OAuth2TokenRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OAuth2TokenRequest>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OAuth2TokenRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.core.OAuth2TokenRequest";
  }
  protected:
  explicit OAuth2TokenRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef OAuth2TokenRequest_Type Type;
  static constexpr Type CLIENT_CREDENTIALS =
    OAuth2TokenRequest_Type_CLIENT_CREDENTIALS;
  static inline bool Type_IsValid(int value) {
    return OAuth2TokenRequest_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    OAuth2TokenRequest_Type_Type_MIN;
  static constexpr Type Type_MAX =
    OAuth2TokenRequest_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    OAuth2TokenRequest_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return OAuth2TokenRequest_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return OAuth2TokenRequest_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return OAuth2TokenRequest_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kIdpDiscoveryEndpointFieldNumber = 4,
    kTokenEndpointFieldNumber = 5,
    kClientFieldNumber = 3,
    kTypeFieldNumber = 2,
  };
  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string idp_discovery_endpoint = 4 [json_name = "idpDiscoveryEndpoint"];
  void clear_idp_discovery_endpoint();
  const std::string& idp_discovery_endpoint() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_idp_discovery_endpoint(ArgT0&& arg0, ArgT... args);
  std::string* mutable_idp_discovery_endpoint();
  PROTOBUF_NODISCARD std::string* release_idp_discovery_endpoint();
  void set_allocated_idp_discovery_endpoint(std::string* idp_discovery_endpoint);
  private:
  const std::string& _internal_idp_discovery_endpoint() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_idp_discovery_endpoint(const std::string& value);
  std::string* _internal_mutable_idp_discovery_endpoint();
  public:

  // string token_endpoint = 5 [json_name = "tokenEndpoint"];
  void clear_token_endpoint();
  const std::string& token_endpoint() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token_endpoint(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token_endpoint();
  PROTOBUF_NODISCARD std::string* release_token_endpoint();
  void set_allocated_token_endpoint(std::string* token_endpoint);
  private:
  const std::string& _internal_token_endpoint() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token_endpoint(const std::string& value);
  std::string* _internal_mutable_token_endpoint();
  public:

  // .flyteidl.core.OAuth2Client client = 3 [json_name = "client"];
  bool has_client() const;
  private:
  bool _internal_has_client() const;
  public:
  void clear_client();
  const ::flyteidl::core::OAuth2Client& client() const;
  PROTOBUF_NODISCARD ::flyteidl::core::OAuth2Client* release_client();
  ::flyteidl::core::OAuth2Client* mutable_client();
  void set_allocated_client(::flyteidl::core::OAuth2Client* client);
  private:
  const ::flyteidl::core::OAuth2Client& _internal_client() const;
  ::flyteidl::core::OAuth2Client* _internal_mutable_client();
  public:
  void unsafe_arena_set_allocated_client(
      ::flyteidl::core::OAuth2Client* client);
  ::flyteidl::core::OAuth2Client* unsafe_arena_release_client();

  // .flyteidl.core.OAuth2TokenRequest.Type type = 2 [json_name = "type"];
  void clear_type();
  ::flyteidl::core::OAuth2TokenRequest_Type type() const;
  void set_type(::flyteidl::core::OAuth2TokenRequest_Type value);
  private:
  ::flyteidl::core::OAuth2TokenRequest_Type _internal_type() const;
  void _internal_set_type(::flyteidl::core::OAuth2TokenRequest_Type value);
  public:

  // @@protoc_insertion_point(class_scope:flyteidl.core.OAuth2TokenRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr idp_discovery_endpoint_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_endpoint_;
  ::flyteidl::core::OAuth2Client* client_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2fsecurity_2eproto;
};
// -------------------------------------------------------------------

class SecurityContext final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.SecurityContext) */ {
 public:
  inline SecurityContext() : SecurityContext(nullptr) {}
  ~SecurityContext() override;
  explicit constexpr SecurityContext(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SecurityContext(const SecurityContext& from);
  SecurityContext(SecurityContext&& from) noexcept
    : SecurityContext() {
    *this = ::std::move(from);
  }

  inline SecurityContext& operator=(const SecurityContext& from) {
    CopyFrom(from);
    return *this;
  }
  inline SecurityContext& operator=(SecurityContext&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SecurityContext& default_instance() {
    return *internal_default_instance();
  }
  static inline const SecurityContext* internal_default_instance() {
    return reinterpret_cast<const SecurityContext*>(
               &_SecurityContext_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SecurityContext& a, SecurityContext& b) {
    a.Swap(&b);
  }
  inline void Swap(SecurityContext* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SecurityContext* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SecurityContext* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SecurityContext>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SecurityContext* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.core.SecurityContext";
  }
  protected:
  explicit SecurityContext(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecretsFieldNumber = 2,
    kTokensFieldNumber = 3,
    kRunAsFieldNumber = 1,
  };
  // repeated .flyteidl.core.Secret secrets = 2 [json_name = "secrets"];
  int secrets_size() const;
  private:
  int _internal_secrets_size() const;
  public:
  void clear_secrets();
  ::flyteidl::core::Secret* mutable_secrets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::core::Secret >*
      mutable_secrets();
  private:
  const ::flyteidl::core::Secret& _internal_secrets(int index) const;
  ::flyteidl::core::Secret* _internal_add_secrets();
  public:
  const ::flyteidl::core::Secret& secrets(int index) const;
  ::flyteidl::core::Secret* add_secrets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::core::Secret >&
      secrets() const;

  // repeated .flyteidl.core.OAuth2TokenRequest tokens = 3 [json_name = "tokens"];
  int tokens_size() const;
  private:
  int _internal_tokens_size() const;
  public:
  void clear_tokens();
  ::flyteidl::core::OAuth2TokenRequest* mutable_tokens(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::core::OAuth2TokenRequest >*
      mutable_tokens();
  private:
  const ::flyteidl::core::OAuth2TokenRequest& _internal_tokens(int index) const;
  ::flyteidl::core::OAuth2TokenRequest* _internal_add_tokens();
  public:
  const ::flyteidl::core::OAuth2TokenRequest& tokens(int index) const;
  ::flyteidl::core::OAuth2TokenRequest* add_tokens();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::core::OAuth2TokenRequest >&
      tokens() const;

  // .flyteidl.core.Identity run_as = 1 [json_name = "runAs"];
  bool has_run_as() const;
  private:
  bool _internal_has_run_as() const;
  public:
  void clear_run_as();
  const ::flyteidl::core::Identity& run_as() const;
  PROTOBUF_NODISCARD ::flyteidl::core::Identity* release_run_as();
  ::flyteidl::core::Identity* mutable_run_as();
  void set_allocated_run_as(::flyteidl::core::Identity* run_as);
  private:
  const ::flyteidl::core::Identity& _internal_run_as() const;
  ::flyteidl::core::Identity* _internal_mutable_run_as();
  public:
  void unsafe_arena_set_allocated_run_as(
      ::flyteidl::core::Identity* run_as);
  ::flyteidl::core::Identity* unsafe_arena_release_run_as();

  // @@protoc_insertion_point(class_scope:flyteidl.core.SecurityContext)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::core::Secret > secrets_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::core::OAuth2TokenRequest > tokens_;
  ::flyteidl::core::Identity* run_as_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2fsecurity_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Secret

// string group = 1 [json_name = "group"];
inline void Secret::clear_group() {
  group_.ClearToEmpty();
}
inline const std::string& Secret::group() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Secret.group)
  return _internal_group();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Secret::set_group(ArgT0&& arg0, ArgT... args) {
 
 group_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.core.Secret.group)
}
inline std::string* Secret::mutable_group() {
  std::string* _s = _internal_mutable_group();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Secret.group)
  return _s;
}
inline const std::string& Secret::_internal_group() const {
  return group_.Get();
}
inline void Secret::_internal_set_group(const std::string& value) {
  
  group_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Secret::_internal_mutable_group() {
  
  return group_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Secret::release_group() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Secret.group)
  return group_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Secret::set_allocated_group(std::string* group) {
  if (group != nullptr) {
    
  } else {
    
  }
  group_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), group,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (group_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    group_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.Secret.group)
}

// string group_version = 2 [json_name = "groupVersion"];
inline void Secret::clear_group_version() {
  group_version_.ClearToEmpty();
}
inline const std::string& Secret::group_version() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Secret.group_version)
  return _internal_group_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Secret::set_group_version(ArgT0&& arg0, ArgT... args) {
 
 group_version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.core.Secret.group_version)
}
inline std::string* Secret::mutable_group_version() {
  std::string* _s = _internal_mutable_group_version();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Secret.group_version)
  return _s;
}
inline const std::string& Secret::_internal_group_version() const {
  return group_version_.Get();
}
inline void Secret::_internal_set_group_version(const std::string& value) {
  
  group_version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Secret::_internal_mutable_group_version() {
  
  return group_version_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Secret::release_group_version() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Secret.group_version)
  return group_version_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Secret::set_allocated_group_version(std::string* group_version) {
  if (group_version != nullptr) {
    
  } else {
    
  }
  group_version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), group_version,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (group_version_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    group_version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.Secret.group_version)
}

// string key = 3 [json_name = "key"];
inline void Secret::clear_key() {
  key_.ClearToEmpty();
}
inline const std::string& Secret::key() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Secret.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Secret::set_key(ArgT0&& arg0, ArgT... args) {
 
 key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.core.Secret.key)
}
inline std::string* Secret::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Secret.key)
  return _s;
}
inline const std::string& Secret::_internal_key() const {
  return key_.Get();
}
inline void Secret::_internal_set_key(const std::string& value) {
  
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Secret::_internal_mutable_key() {
  
  return key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Secret::release_key() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Secret.key)
  return key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Secret::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.Secret.key)
}

// .flyteidl.core.Secret.MountType mount_requirement = 4 [json_name = "mountRequirement"];
inline void Secret::clear_mount_requirement() {
  mount_requirement_ = 0;
}
inline ::flyteidl::core::Secret_MountType Secret::_internal_mount_requirement() const {
  return static_cast< ::flyteidl::core::Secret_MountType >(mount_requirement_);
}
inline ::flyteidl::core::Secret_MountType Secret::mount_requirement() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Secret.mount_requirement)
  return _internal_mount_requirement();
}
inline void Secret::_internal_set_mount_requirement(::flyteidl::core::Secret_MountType value) {
  
  mount_requirement_ = value;
}
inline void Secret::set_mount_requirement(::flyteidl::core::Secret_MountType value) {
  _internal_set_mount_requirement(value);
  // @@protoc_insertion_point(field_set:flyteidl.core.Secret.mount_requirement)
}

// -------------------------------------------------------------------

// OAuth2Client

// string client_id = 1 [json_name = "clientId"];
inline void OAuth2Client::clear_client_id() {
  client_id_.ClearToEmpty();
}
inline const std::string& OAuth2Client::client_id() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.OAuth2Client.client_id)
  return _internal_client_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OAuth2Client::set_client_id(ArgT0&& arg0, ArgT... args) {
 
 client_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.core.OAuth2Client.client_id)
}
inline std::string* OAuth2Client::mutable_client_id() {
  std::string* _s = _internal_mutable_client_id();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.OAuth2Client.client_id)
  return _s;
}
inline const std::string& OAuth2Client::_internal_client_id() const {
  return client_id_.Get();
}
inline void OAuth2Client::_internal_set_client_id(const std::string& value) {
  
  client_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* OAuth2Client::_internal_mutable_client_id() {
  
  return client_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* OAuth2Client::release_client_id() {
  // @@protoc_insertion_point(field_release:flyteidl.core.OAuth2Client.client_id)
  return client_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void OAuth2Client::set_allocated_client_id(std::string* client_id) {
  if (client_id != nullptr) {
    
  } else {
    
  }
  client_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), client_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (client_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    client_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.OAuth2Client.client_id)
}

// .flyteidl.core.Secret client_secret = 2 [json_name = "clientSecret"];
inline bool OAuth2Client::_internal_has_client_secret() const {
  return this != internal_default_instance() && client_secret_ != nullptr;
}
inline bool OAuth2Client::has_client_secret() const {
  return _internal_has_client_secret();
}
inline void OAuth2Client::clear_client_secret() {
  if (GetArenaForAllocation() == nullptr && client_secret_ != nullptr) {
    delete client_secret_;
  }
  client_secret_ = nullptr;
}
inline const ::flyteidl::core::Secret& OAuth2Client::_internal_client_secret() const {
  const ::flyteidl::core::Secret* p = client_secret_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::core::Secret&>(
      ::flyteidl::core::_Secret_default_instance_);
}
inline const ::flyteidl::core::Secret& OAuth2Client::client_secret() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.OAuth2Client.client_secret)
  return _internal_client_secret();
}
inline void OAuth2Client::unsafe_arena_set_allocated_client_secret(
    ::flyteidl::core::Secret* client_secret) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(client_secret_);
  }
  client_secret_ = client_secret;
  if (client_secret) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.core.OAuth2Client.client_secret)
}
inline ::flyteidl::core::Secret* OAuth2Client::release_client_secret() {
  
  ::flyteidl::core::Secret* temp = client_secret_;
  client_secret_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::core::Secret* OAuth2Client::unsafe_arena_release_client_secret() {
  // @@protoc_insertion_point(field_release:flyteidl.core.OAuth2Client.client_secret)
  
  ::flyteidl::core::Secret* temp = client_secret_;
  client_secret_ = nullptr;
  return temp;
}
inline ::flyteidl::core::Secret* OAuth2Client::_internal_mutable_client_secret() {
  
  if (client_secret_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::Secret>(GetArenaForAllocation());
    client_secret_ = p;
  }
  return client_secret_;
}
inline ::flyteidl::core::Secret* OAuth2Client::mutable_client_secret() {
  ::flyteidl::core::Secret* _msg = _internal_mutable_client_secret();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.OAuth2Client.client_secret)
  return _msg;
}
inline void OAuth2Client::set_allocated_client_secret(::flyteidl::core::Secret* client_secret) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete client_secret_;
  }
  if (client_secret) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::flyteidl::core::Secret>::GetOwningArena(client_secret);
    if (message_arena != submessage_arena) {
      client_secret = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client_secret, submessage_arena);
    }
    
  } else {
    
  }
  client_secret_ = client_secret;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.OAuth2Client.client_secret)
}

// -------------------------------------------------------------------

// Identity

// string iam_role = 1 [json_name = "iamRole"];
inline void Identity::clear_iam_role() {
  iam_role_.ClearToEmpty();
}
inline const std::string& Identity::iam_role() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Identity.iam_role)
  return _internal_iam_role();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Identity::set_iam_role(ArgT0&& arg0, ArgT... args) {
 
 iam_role_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.core.Identity.iam_role)
}
inline std::string* Identity::mutable_iam_role() {
  std::string* _s = _internal_mutable_iam_role();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Identity.iam_role)
  return _s;
}
inline const std::string& Identity::_internal_iam_role() const {
  return iam_role_.Get();
}
inline void Identity::_internal_set_iam_role(const std::string& value) {
  
  iam_role_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Identity::_internal_mutable_iam_role() {
  
  return iam_role_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Identity::release_iam_role() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Identity.iam_role)
  return iam_role_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Identity::set_allocated_iam_role(std::string* iam_role) {
  if (iam_role != nullptr) {
    
  } else {
    
  }
  iam_role_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), iam_role,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (iam_role_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    iam_role_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.Identity.iam_role)
}

// string k8s_service_account = 2 [json_name = "k8sServiceAccount"];
inline void Identity::clear_k8s_service_account() {
  k8s_service_account_.ClearToEmpty();
}
inline const std::string& Identity::k8s_service_account() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Identity.k8s_service_account)
  return _internal_k8s_service_account();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Identity::set_k8s_service_account(ArgT0&& arg0, ArgT... args) {
 
 k8s_service_account_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.core.Identity.k8s_service_account)
}
inline std::string* Identity::mutable_k8s_service_account() {
  std::string* _s = _internal_mutable_k8s_service_account();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Identity.k8s_service_account)
  return _s;
}
inline const std::string& Identity::_internal_k8s_service_account() const {
  return k8s_service_account_.Get();
}
inline void Identity::_internal_set_k8s_service_account(const std::string& value) {
  
  k8s_service_account_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Identity::_internal_mutable_k8s_service_account() {
  
  return k8s_service_account_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Identity::release_k8s_service_account() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Identity.k8s_service_account)
  return k8s_service_account_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Identity::set_allocated_k8s_service_account(std::string* k8s_service_account) {
  if (k8s_service_account != nullptr) {
    
  } else {
    
  }
  k8s_service_account_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), k8s_service_account,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (k8s_service_account_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    k8s_service_account_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.Identity.k8s_service_account)
}

// .flyteidl.core.OAuth2Client oauth2_client = 3 [json_name = "oauth2Client"];
inline bool Identity::_internal_has_oauth2_client() const {
  return this != internal_default_instance() && oauth2_client_ != nullptr;
}
inline bool Identity::has_oauth2_client() const {
  return _internal_has_oauth2_client();
}
inline void Identity::clear_oauth2_client() {
  if (GetArenaForAllocation() == nullptr && oauth2_client_ != nullptr) {
    delete oauth2_client_;
  }
  oauth2_client_ = nullptr;
}
inline const ::flyteidl::core::OAuth2Client& Identity::_internal_oauth2_client() const {
  const ::flyteidl::core::OAuth2Client* p = oauth2_client_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::core::OAuth2Client&>(
      ::flyteidl::core::_OAuth2Client_default_instance_);
}
inline const ::flyteidl::core::OAuth2Client& Identity::oauth2_client() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Identity.oauth2_client)
  return _internal_oauth2_client();
}
inline void Identity::unsafe_arena_set_allocated_oauth2_client(
    ::flyteidl::core::OAuth2Client* oauth2_client) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(oauth2_client_);
  }
  oauth2_client_ = oauth2_client;
  if (oauth2_client) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.core.Identity.oauth2_client)
}
inline ::flyteidl::core::OAuth2Client* Identity::release_oauth2_client() {
  
  ::flyteidl::core::OAuth2Client* temp = oauth2_client_;
  oauth2_client_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::core::OAuth2Client* Identity::unsafe_arena_release_oauth2_client() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Identity.oauth2_client)
  
  ::flyteidl::core::OAuth2Client* temp = oauth2_client_;
  oauth2_client_ = nullptr;
  return temp;
}
inline ::flyteidl::core::OAuth2Client* Identity::_internal_mutable_oauth2_client() {
  
  if (oauth2_client_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::OAuth2Client>(GetArenaForAllocation());
    oauth2_client_ = p;
  }
  return oauth2_client_;
}
inline ::flyteidl::core::OAuth2Client* Identity::mutable_oauth2_client() {
  ::flyteidl::core::OAuth2Client* _msg = _internal_mutable_oauth2_client();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Identity.oauth2_client)
  return _msg;
}
inline void Identity::set_allocated_oauth2_client(::flyteidl::core::OAuth2Client* oauth2_client) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete oauth2_client_;
  }
  if (oauth2_client) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::flyteidl::core::OAuth2Client>::GetOwningArena(oauth2_client);
    if (message_arena != submessage_arena) {
      oauth2_client = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, oauth2_client, submessage_arena);
    }
    
  } else {
    
  }
  oauth2_client_ = oauth2_client;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.Identity.oauth2_client)
}

// -------------------------------------------------------------------

// OAuth2TokenRequest

// string name = 1 [json_name = "name"];
inline void OAuth2TokenRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& OAuth2TokenRequest::name() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.OAuth2TokenRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OAuth2TokenRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.core.OAuth2TokenRequest.name)
}
inline std::string* OAuth2TokenRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.OAuth2TokenRequest.name)
  return _s;
}
inline const std::string& OAuth2TokenRequest::_internal_name() const {
  return name_.Get();
}
inline void OAuth2TokenRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* OAuth2TokenRequest::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* OAuth2TokenRequest::release_name() {
  // @@protoc_insertion_point(field_release:flyteidl.core.OAuth2TokenRequest.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void OAuth2TokenRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.OAuth2TokenRequest.name)
}

// .flyteidl.core.OAuth2TokenRequest.Type type = 2 [json_name = "type"];
inline void OAuth2TokenRequest::clear_type() {
  type_ = 0;
}
inline ::flyteidl::core::OAuth2TokenRequest_Type OAuth2TokenRequest::_internal_type() const {
  return static_cast< ::flyteidl::core::OAuth2TokenRequest_Type >(type_);
}
inline ::flyteidl::core::OAuth2TokenRequest_Type OAuth2TokenRequest::type() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.OAuth2TokenRequest.type)
  return _internal_type();
}
inline void OAuth2TokenRequest::_internal_set_type(::flyteidl::core::OAuth2TokenRequest_Type value) {
  
  type_ = value;
}
inline void OAuth2TokenRequest::set_type(::flyteidl::core::OAuth2TokenRequest_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:flyteidl.core.OAuth2TokenRequest.type)
}

// .flyteidl.core.OAuth2Client client = 3 [json_name = "client"];
inline bool OAuth2TokenRequest::_internal_has_client() const {
  return this != internal_default_instance() && client_ != nullptr;
}
inline bool OAuth2TokenRequest::has_client() const {
  return _internal_has_client();
}
inline void OAuth2TokenRequest::clear_client() {
  if (GetArenaForAllocation() == nullptr && client_ != nullptr) {
    delete client_;
  }
  client_ = nullptr;
}
inline const ::flyteidl::core::OAuth2Client& OAuth2TokenRequest::_internal_client() const {
  const ::flyteidl::core::OAuth2Client* p = client_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::core::OAuth2Client&>(
      ::flyteidl::core::_OAuth2Client_default_instance_);
}
inline const ::flyteidl::core::OAuth2Client& OAuth2TokenRequest::client() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.OAuth2TokenRequest.client)
  return _internal_client();
}
inline void OAuth2TokenRequest::unsafe_arena_set_allocated_client(
    ::flyteidl::core::OAuth2Client* client) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(client_);
  }
  client_ = client;
  if (client) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.core.OAuth2TokenRequest.client)
}
inline ::flyteidl::core::OAuth2Client* OAuth2TokenRequest::release_client() {
  
  ::flyteidl::core::OAuth2Client* temp = client_;
  client_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::core::OAuth2Client* OAuth2TokenRequest::unsafe_arena_release_client() {
  // @@protoc_insertion_point(field_release:flyteidl.core.OAuth2TokenRequest.client)
  
  ::flyteidl::core::OAuth2Client* temp = client_;
  client_ = nullptr;
  return temp;
}
inline ::flyteidl::core::OAuth2Client* OAuth2TokenRequest::_internal_mutable_client() {
  
  if (client_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::OAuth2Client>(GetArenaForAllocation());
    client_ = p;
  }
  return client_;
}
inline ::flyteidl::core::OAuth2Client* OAuth2TokenRequest::mutable_client() {
  ::flyteidl::core::OAuth2Client* _msg = _internal_mutable_client();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.OAuth2TokenRequest.client)
  return _msg;
}
inline void OAuth2TokenRequest::set_allocated_client(::flyteidl::core::OAuth2Client* client) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete client_;
  }
  if (client) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::flyteidl::core::OAuth2Client>::GetOwningArena(client);
    if (message_arena != submessage_arena) {
      client = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client, submessage_arena);
    }
    
  } else {
    
  }
  client_ = client;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.OAuth2TokenRequest.client)
}

// string idp_discovery_endpoint = 4 [json_name = "idpDiscoveryEndpoint"];
inline void OAuth2TokenRequest::clear_idp_discovery_endpoint() {
  idp_discovery_endpoint_.ClearToEmpty();
}
inline const std::string& OAuth2TokenRequest::idp_discovery_endpoint() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.OAuth2TokenRequest.idp_discovery_endpoint)
  return _internal_idp_discovery_endpoint();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OAuth2TokenRequest::set_idp_discovery_endpoint(ArgT0&& arg0, ArgT... args) {
 
 idp_discovery_endpoint_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.core.OAuth2TokenRequest.idp_discovery_endpoint)
}
inline std::string* OAuth2TokenRequest::mutable_idp_discovery_endpoint() {
  std::string* _s = _internal_mutable_idp_discovery_endpoint();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.OAuth2TokenRequest.idp_discovery_endpoint)
  return _s;
}
inline const std::string& OAuth2TokenRequest::_internal_idp_discovery_endpoint() const {
  return idp_discovery_endpoint_.Get();
}
inline void OAuth2TokenRequest::_internal_set_idp_discovery_endpoint(const std::string& value) {
  
  idp_discovery_endpoint_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* OAuth2TokenRequest::_internal_mutable_idp_discovery_endpoint() {
  
  return idp_discovery_endpoint_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* OAuth2TokenRequest::release_idp_discovery_endpoint() {
  // @@protoc_insertion_point(field_release:flyteidl.core.OAuth2TokenRequest.idp_discovery_endpoint)
  return idp_discovery_endpoint_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void OAuth2TokenRequest::set_allocated_idp_discovery_endpoint(std::string* idp_discovery_endpoint) {
  if (idp_discovery_endpoint != nullptr) {
    
  } else {
    
  }
  idp_discovery_endpoint_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), idp_discovery_endpoint,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (idp_discovery_endpoint_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    idp_discovery_endpoint_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.OAuth2TokenRequest.idp_discovery_endpoint)
}

// string token_endpoint = 5 [json_name = "tokenEndpoint"];
inline void OAuth2TokenRequest::clear_token_endpoint() {
  token_endpoint_.ClearToEmpty();
}
inline const std::string& OAuth2TokenRequest::token_endpoint() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.OAuth2TokenRequest.token_endpoint)
  return _internal_token_endpoint();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OAuth2TokenRequest::set_token_endpoint(ArgT0&& arg0, ArgT... args) {
 
 token_endpoint_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.core.OAuth2TokenRequest.token_endpoint)
}
inline std::string* OAuth2TokenRequest::mutable_token_endpoint() {
  std::string* _s = _internal_mutable_token_endpoint();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.OAuth2TokenRequest.token_endpoint)
  return _s;
}
inline const std::string& OAuth2TokenRequest::_internal_token_endpoint() const {
  return token_endpoint_.Get();
}
inline void OAuth2TokenRequest::_internal_set_token_endpoint(const std::string& value) {
  
  token_endpoint_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* OAuth2TokenRequest::_internal_mutable_token_endpoint() {
  
  return token_endpoint_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* OAuth2TokenRequest::release_token_endpoint() {
  // @@protoc_insertion_point(field_release:flyteidl.core.OAuth2TokenRequest.token_endpoint)
  return token_endpoint_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void OAuth2TokenRequest::set_allocated_token_endpoint(std::string* token_endpoint) {
  if (token_endpoint != nullptr) {
    
  } else {
    
  }
  token_endpoint_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token_endpoint,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (token_endpoint_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    token_endpoint_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.OAuth2TokenRequest.token_endpoint)
}

// -------------------------------------------------------------------

// SecurityContext

// .flyteidl.core.Identity run_as = 1 [json_name = "runAs"];
inline bool SecurityContext::_internal_has_run_as() const {
  return this != internal_default_instance() && run_as_ != nullptr;
}
inline bool SecurityContext::has_run_as() const {
  return _internal_has_run_as();
}
inline void SecurityContext::clear_run_as() {
  if (GetArenaForAllocation() == nullptr && run_as_ != nullptr) {
    delete run_as_;
  }
  run_as_ = nullptr;
}
inline const ::flyteidl::core::Identity& SecurityContext::_internal_run_as() const {
  const ::flyteidl::core::Identity* p = run_as_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::core::Identity&>(
      ::flyteidl::core::_Identity_default_instance_);
}
inline const ::flyteidl::core::Identity& SecurityContext::run_as() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.SecurityContext.run_as)
  return _internal_run_as();
}
inline void SecurityContext::unsafe_arena_set_allocated_run_as(
    ::flyteidl::core::Identity* run_as) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(run_as_);
  }
  run_as_ = run_as;
  if (run_as) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.core.SecurityContext.run_as)
}
inline ::flyteidl::core::Identity* SecurityContext::release_run_as() {
  
  ::flyteidl::core::Identity* temp = run_as_;
  run_as_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::core::Identity* SecurityContext::unsafe_arena_release_run_as() {
  // @@protoc_insertion_point(field_release:flyteidl.core.SecurityContext.run_as)
  
  ::flyteidl::core::Identity* temp = run_as_;
  run_as_ = nullptr;
  return temp;
}
inline ::flyteidl::core::Identity* SecurityContext::_internal_mutable_run_as() {
  
  if (run_as_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::Identity>(GetArenaForAllocation());
    run_as_ = p;
  }
  return run_as_;
}
inline ::flyteidl::core::Identity* SecurityContext::mutable_run_as() {
  ::flyteidl::core::Identity* _msg = _internal_mutable_run_as();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.SecurityContext.run_as)
  return _msg;
}
inline void SecurityContext::set_allocated_run_as(::flyteidl::core::Identity* run_as) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete run_as_;
  }
  if (run_as) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::flyteidl::core::Identity>::GetOwningArena(run_as);
    if (message_arena != submessage_arena) {
      run_as = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, run_as, submessage_arena);
    }
    
  } else {
    
  }
  run_as_ = run_as;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.SecurityContext.run_as)
}

// repeated .flyteidl.core.Secret secrets = 2 [json_name = "secrets"];
inline int SecurityContext::_internal_secrets_size() const {
  return secrets_.size();
}
inline int SecurityContext::secrets_size() const {
  return _internal_secrets_size();
}
inline void SecurityContext::clear_secrets() {
  secrets_.Clear();
}
inline ::flyteidl::core::Secret* SecurityContext::mutable_secrets(int index) {
  // @@protoc_insertion_point(field_mutable:flyteidl.core.SecurityContext.secrets)
  return secrets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::core::Secret >*
SecurityContext::mutable_secrets() {
  // @@protoc_insertion_point(field_mutable_list:flyteidl.core.SecurityContext.secrets)
  return &secrets_;
}
inline const ::flyteidl::core::Secret& SecurityContext::_internal_secrets(int index) const {
  return secrets_.Get(index);
}
inline const ::flyteidl::core::Secret& SecurityContext::secrets(int index) const {
  // @@protoc_insertion_point(field_get:flyteidl.core.SecurityContext.secrets)
  return _internal_secrets(index);
}
inline ::flyteidl::core::Secret* SecurityContext::_internal_add_secrets() {
  return secrets_.Add();
}
inline ::flyteidl::core::Secret* SecurityContext::add_secrets() {
  ::flyteidl::core::Secret* _add = _internal_add_secrets();
  // @@protoc_insertion_point(field_add:flyteidl.core.SecurityContext.secrets)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::core::Secret >&
SecurityContext::secrets() const {
  // @@protoc_insertion_point(field_list:flyteidl.core.SecurityContext.secrets)
  return secrets_;
}

// repeated .flyteidl.core.OAuth2TokenRequest tokens = 3 [json_name = "tokens"];
inline int SecurityContext::_internal_tokens_size() const {
  return tokens_.size();
}
inline int SecurityContext::tokens_size() const {
  return _internal_tokens_size();
}
inline void SecurityContext::clear_tokens() {
  tokens_.Clear();
}
inline ::flyteidl::core::OAuth2TokenRequest* SecurityContext::mutable_tokens(int index) {
  // @@protoc_insertion_point(field_mutable:flyteidl.core.SecurityContext.tokens)
  return tokens_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::core::OAuth2TokenRequest >*
SecurityContext::mutable_tokens() {
  // @@protoc_insertion_point(field_mutable_list:flyteidl.core.SecurityContext.tokens)
  return &tokens_;
}
inline const ::flyteidl::core::OAuth2TokenRequest& SecurityContext::_internal_tokens(int index) const {
  return tokens_.Get(index);
}
inline const ::flyteidl::core::OAuth2TokenRequest& SecurityContext::tokens(int index) const {
  // @@protoc_insertion_point(field_get:flyteidl.core.SecurityContext.tokens)
  return _internal_tokens(index);
}
inline ::flyteidl::core::OAuth2TokenRequest* SecurityContext::_internal_add_tokens() {
  return tokens_.Add();
}
inline ::flyteidl::core::OAuth2TokenRequest* SecurityContext::add_tokens() {
  ::flyteidl::core::OAuth2TokenRequest* _add = _internal_add_tokens();
  // @@protoc_insertion_point(field_add:flyteidl.core.SecurityContext.tokens)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::core::OAuth2TokenRequest >&
SecurityContext::tokens() const {
  // @@protoc_insertion_point(field_list:flyteidl.core.SecurityContext.tokens)
  return tokens_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace core
}  // namespace flyteidl

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::flyteidl::core::Secret_MountType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::flyteidl::core::Secret_MountType>() {
  return ::flyteidl::core::Secret_MountType_descriptor();
}
template <> struct is_proto_enum< ::flyteidl::core::OAuth2TokenRequest_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::flyteidl::core::OAuth2TokenRequest_Type>() {
  return ::flyteidl::core::OAuth2TokenRequest_Type_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_flyteidl_2fcore_2fsecurity_2eproto
