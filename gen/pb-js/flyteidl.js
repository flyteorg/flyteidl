/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
import * as $protobuf from "protobufjs/minimal";

// Common aliases
const $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
const $root = $protobuf.roots.flyteidl || ($protobuf.roots.flyteidl = {});

export const flyteidl = $root.flyteidl = (() => {

    /**
     * Namespace flyteidl.
     * @exports flyteidl
     * @namespace
     */
    const flyteidl = {};

    flyteidl.core = (function() {

        /**
         * Namespace core.
         * @memberof flyteidl
         * @namespace
         */
        const core = {};

        core.ConnectionSet = (function() {

            /**
             * Properties of a ConnectionSet.
             * @memberof flyteidl.core
             * @interface IConnectionSet
             * @property {Object.<string,flyteidl.core.ConnectionSet.IIdList>|null} [downstream] ConnectionSet downstream
             * @property {Object.<string,flyteidl.core.ConnectionSet.IIdList>|null} [upstream] ConnectionSet upstream
             */

            /**
             * Constructs a new ConnectionSet.
             * @memberof flyteidl.core
             * @classdesc Represents a ConnectionSet.
             * @implements IConnectionSet
             * @constructor
             * @param {flyteidl.core.IConnectionSet=} [properties] Properties to set
             */
            function ConnectionSet(properties) {
                this.downstream = {};
                this.upstream = {};
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ConnectionSet downstream.
             * @member {Object.<string,flyteidl.core.ConnectionSet.IIdList>} downstream
             * @memberof flyteidl.core.ConnectionSet
             * @instance
             */
            ConnectionSet.prototype.downstream = $util.emptyObject;

            /**
             * ConnectionSet upstream.
             * @member {Object.<string,flyteidl.core.ConnectionSet.IIdList>} upstream
             * @memberof flyteidl.core.ConnectionSet
             * @instance
             */
            ConnectionSet.prototype.upstream = $util.emptyObject;

            /**
             * Creates a new ConnectionSet instance using the specified properties.
             * @function create
             * @memberof flyteidl.core.ConnectionSet
             * @static
             * @param {flyteidl.core.IConnectionSet=} [properties] Properties to set
             * @returns {flyteidl.core.ConnectionSet} ConnectionSet instance
             */
            ConnectionSet.create = function create(properties) {
                return new ConnectionSet(properties);
            };

            /**
             * Encodes the specified ConnectionSet message. Does not implicitly {@link flyteidl.core.ConnectionSet.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.core.ConnectionSet
             * @static
             * @param {flyteidl.core.IConnectionSet} message ConnectionSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConnectionSet.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.downstream != null && message.hasOwnProperty("downstream"))
                    for (let keys = Object.keys(message.downstream), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 7, wireType 2 =*/58).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.flyteidl.core.ConnectionSet.IdList.encode(message.downstream[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                if (message.upstream != null && message.hasOwnProperty("upstream"))
                    for (let keys = Object.keys(message.upstream), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 8, wireType 2 =*/66).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.flyteidl.core.ConnectionSet.IdList.encode(message.upstream[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                return writer;
            };

            /**
             * Decodes a ConnectionSet message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.core.ConnectionSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.core.ConnectionSet} ConnectionSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConnectionSet.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.core.ConnectionSet(), key;
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 7:
                        reader.skip().pos++;
                        if (message.downstream === $util.emptyObject)
                            message.downstream = {};
                        key = reader.string();
                        reader.pos++;
                        message.downstream[key] = $root.flyteidl.core.ConnectionSet.IdList.decode(reader, reader.uint32());
                        break;
                    case 8:
                        reader.skip().pos++;
                        if (message.upstream === $util.emptyObject)
                            message.upstream = {};
                        key = reader.string();
                        reader.pos++;
                        message.upstream[key] = $root.flyteidl.core.ConnectionSet.IdList.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a ConnectionSet message.
             * @function verify
             * @memberof flyteidl.core.ConnectionSet
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ConnectionSet.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.downstream != null && message.hasOwnProperty("downstream")) {
                    if (!$util.isObject(message.downstream))
                        return "downstream: object expected";
                    let key = Object.keys(message.downstream);
                    for (let i = 0; i < key.length; ++i) {
                        let error = $root.flyteidl.core.ConnectionSet.IdList.verify(message.downstream[key[i]]);
                        if (error)
                            return "downstream." + error;
                    }
                }
                if (message.upstream != null && message.hasOwnProperty("upstream")) {
                    if (!$util.isObject(message.upstream))
                        return "upstream: object expected";
                    let key = Object.keys(message.upstream);
                    for (let i = 0; i < key.length; ++i) {
                        let error = $root.flyteidl.core.ConnectionSet.IdList.verify(message.upstream[key[i]]);
                        if (error)
                            return "upstream." + error;
                    }
                }
                return null;
            };

            ConnectionSet.IdList = (function() {

                /**
                 * Properties of an IdList.
                 * @memberof flyteidl.core.ConnectionSet
                 * @interface IIdList
                 * @property {Array.<string>|null} [ids] IdList ids
                 */

                /**
                 * Constructs a new IdList.
                 * @memberof flyteidl.core.ConnectionSet
                 * @classdesc Represents an IdList.
                 * @implements IIdList
                 * @constructor
                 * @param {flyteidl.core.ConnectionSet.IIdList=} [properties] Properties to set
                 */
                function IdList(properties) {
                    this.ids = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * IdList ids.
                 * @member {Array.<string>} ids
                 * @memberof flyteidl.core.ConnectionSet.IdList
                 * @instance
                 */
                IdList.prototype.ids = $util.emptyArray;

                /**
                 * Creates a new IdList instance using the specified properties.
                 * @function create
                 * @memberof flyteidl.core.ConnectionSet.IdList
                 * @static
                 * @param {flyteidl.core.ConnectionSet.IIdList=} [properties] Properties to set
                 * @returns {flyteidl.core.ConnectionSet.IdList} IdList instance
                 */
                IdList.create = function create(properties) {
                    return new IdList(properties);
                };

                /**
                 * Encodes the specified IdList message. Does not implicitly {@link flyteidl.core.ConnectionSet.IdList.verify|verify} messages.
                 * @function encode
                 * @memberof flyteidl.core.ConnectionSet.IdList
                 * @static
                 * @param {flyteidl.core.ConnectionSet.IIdList} message IdList message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                IdList.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.ids != null && message.ids.length)
                        for (let i = 0; i < message.ids.length; ++i)
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.ids[i]);
                    return writer;
                };

                /**
                 * Decodes an IdList message from the specified reader or buffer.
                 * @function decode
                 * @memberof flyteidl.core.ConnectionSet.IdList
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {flyteidl.core.ConnectionSet.IdList} IdList
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                IdList.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.core.ConnectionSet.IdList();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.ids && message.ids.length))
                                message.ids = [];
                            message.ids.push(reader.string());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Verifies an IdList message.
                 * @function verify
                 * @memberof flyteidl.core.ConnectionSet.IdList
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                IdList.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.ids != null && message.hasOwnProperty("ids")) {
                        if (!Array.isArray(message.ids))
                            return "ids: array expected";
                        for (let i = 0; i < message.ids.length; ++i)
                            if (!$util.isString(message.ids[i]))
                                return "ids: string[] expected";
                    }
                    return null;
                };

                return IdList;
            })();

            return ConnectionSet;
        })();

        core.CompiledWorkflow = (function() {

            /**
             * Properties of a CompiledWorkflow.
             * @memberof flyteidl.core
             * @interface ICompiledWorkflow
             * @property {flyteidl.core.IWorkflowTemplate|null} [template] CompiledWorkflow template
             * @property {flyteidl.core.IConnectionSet|null} [connections] CompiledWorkflow connections
             */

            /**
             * Constructs a new CompiledWorkflow.
             * @memberof flyteidl.core
             * @classdesc Represents a CompiledWorkflow.
             * @implements ICompiledWorkflow
             * @constructor
             * @param {flyteidl.core.ICompiledWorkflow=} [properties] Properties to set
             */
            function CompiledWorkflow(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CompiledWorkflow template.
             * @member {flyteidl.core.IWorkflowTemplate|null|undefined} template
             * @memberof flyteidl.core.CompiledWorkflow
             * @instance
             */
            CompiledWorkflow.prototype.template = null;

            /**
             * CompiledWorkflow connections.
             * @member {flyteidl.core.IConnectionSet|null|undefined} connections
             * @memberof flyteidl.core.CompiledWorkflow
             * @instance
             */
            CompiledWorkflow.prototype.connections = null;

            /**
             * Creates a new CompiledWorkflow instance using the specified properties.
             * @function create
             * @memberof flyteidl.core.CompiledWorkflow
             * @static
             * @param {flyteidl.core.ICompiledWorkflow=} [properties] Properties to set
             * @returns {flyteidl.core.CompiledWorkflow} CompiledWorkflow instance
             */
            CompiledWorkflow.create = function create(properties) {
                return new CompiledWorkflow(properties);
            };

            /**
             * Encodes the specified CompiledWorkflow message. Does not implicitly {@link flyteidl.core.CompiledWorkflow.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.core.CompiledWorkflow
             * @static
             * @param {flyteidl.core.ICompiledWorkflow} message CompiledWorkflow message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CompiledWorkflow.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.template != null && message.hasOwnProperty("template"))
                    $root.flyteidl.core.WorkflowTemplate.encode(message.template, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.connections != null && message.hasOwnProperty("connections"))
                    $root.flyteidl.core.ConnectionSet.encode(message.connections, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a CompiledWorkflow message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.core.CompiledWorkflow
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.core.CompiledWorkflow} CompiledWorkflow
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CompiledWorkflow.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.core.CompiledWorkflow();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.template = $root.flyteidl.core.WorkflowTemplate.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.connections = $root.flyteidl.core.ConnectionSet.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a CompiledWorkflow message.
             * @function verify
             * @memberof flyteidl.core.CompiledWorkflow
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CompiledWorkflow.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.template != null && message.hasOwnProperty("template")) {
                    let error = $root.flyteidl.core.WorkflowTemplate.verify(message.template);
                    if (error)
                        return "template." + error;
                }
                if (message.connections != null && message.hasOwnProperty("connections")) {
                    let error = $root.flyteidl.core.ConnectionSet.verify(message.connections);
                    if (error)
                        return "connections." + error;
                }
                return null;
            };

            return CompiledWorkflow;
        })();

        core.CompiledTask = (function() {

            /**
             * Properties of a CompiledTask.
             * @memberof flyteidl.core
             * @interface ICompiledTask
             * @property {flyteidl.core.ITaskTemplate|null} [template] CompiledTask template
             */

            /**
             * Constructs a new CompiledTask.
             * @memberof flyteidl.core
             * @classdesc Represents a CompiledTask.
             * @implements ICompiledTask
             * @constructor
             * @param {flyteidl.core.ICompiledTask=} [properties] Properties to set
             */
            function CompiledTask(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CompiledTask template.
             * @member {flyteidl.core.ITaskTemplate|null|undefined} template
             * @memberof flyteidl.core.CompiledTask
             * @instance
             */
            CompiledTask.prototype.template = null;

            /**
             * Creates a new CompiledTask instance using the specified properties.
             * @function create
             * @memberof flyteidl.core.CompiledTask
             * @static
             * @param {flyteidl.core.ICompiledTask=} [properties] Properties to set
             * @returns {flyteidl.core.CompiledTask} CompiledTask instance
             */
            CompiledTask.create = function create(properties) {
                return new CompiledTask(properties);
            };

            /**
             * Encodes the specified CompiledTask message. Does not implicitly {@link flyteidl.core.CompiledTask.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.core.CompiledTask
             * @static
             * @param {flyteidl.core.ICompiledTask} message CompiledTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CompiledTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.template != null && message.hasOwnProperty("template"))
                    $root.flyteidl.core.TaskTemplate.encode(message.template, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a CompiledTask message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.core.CompiledTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.core.CompiledTask} CompiledTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CompiledTask.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.core.CompiledTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.template = $root.flyteidl.core.TaskTemplate.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a CompiledTask message.
             * @function verify
             * @memberof flyteidl.core.CompiledTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CompiledTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.template != null && message.hasOwnProperty("template")) {
                    let error = $root.flyteidl.core.TaskTemplate.verify(message.template);
                    if (error)
                        return "template." + error;
                }
                return null;
            };

            return CompiledTask;
        })();

        core.CompiledWorkflowClosure = (function() {

            /**
             * Properties of a CompiledWorkflowClosure.
             * @memberof flyteidl.core
             * @interface ICompiledWorkflowClosure
             * @property {flyteidl.core.ICompiledWorkflow|null} [primary] CompiledWorkflowClosure primary
             * @property {Array.<flyteidl.core.ICompiledWorkflow>|null} [subWorkflows] CompiledWorkflowClosure subWorkflows
             * @property {Array.<flyteidl.core.ICompiledTask>|null} [tasks] CompiledWorkflowClosure tasks
             */

            /**
             * Constructs a new CompiledWorkflowClosure.
             * @memberof flyteidl.core
             * @classdesc Represents a CompiledWorkflowClosure.
             * @implements ICompiledWorkflowClosure
             * @constructor
             * @param {flyteidl.core.ICompiledWorkflowClosure=} [properties] Properties to set
             */
            function CompiledWorkflowClosure(properties) {
                this.subWorkflows = [];
                this.tasks = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CompiledWorkflowClosure primary.
             * @member {flyteidl.core.ICompiledWorkflow|null|undefined} primary
             * @memberof flyteidl.core.CompiledWorkflowClosure
             * @instance
             */
            CompiledWorkflowClosure.prototype.primary = null;

            /**
             * CompiledWorkflowClosure subWorkflows.
             * @member {Array.<flyteidl.core.ICompiledWorkflow>} subWorkflows
             * @memberof flyteidl.core.CompiledWorkflowClosure
             * @instance
             */
            CompiledWorkflowClosure.prototype.subWorkflows = $util.emptyArray;

            /**
             * CompiledWorkflowClosure tasks.
             * @member {Array.<flyteidl.core.ICompiledTask>} tasks
             * @memberof flyteidl.core.CompiledWorkflowClosure
             * @instance
             */
            CompiledWorkflowClosure.prototype.tasks = $util.emptyArray;

            /**
             * Creates a new CompiledWorkflowClosure instance using the specified properties.
             * @function create
             * @memberof flyteidl.core.CompiledWorkflowClosure
             * @static
             * @param {flyteidl.core.ICompiledWorkflowClosure=} [properties] Properties to set
             * @returns {flyteidl.core.CompiledWorkflowClosure} CompiledWorkflowClosure instance
             */
            CompiledWorkflowClosure.create = function create(properties) {
                return new CompiledWorkflowClosure(properties);
            };

            /**
             * Encodes the specified CompiledWorkflowClosure message. Does not implicitly {@link flyteidl.core.CompiledWorkflowClosure.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.core.CompiledWorkflowClosure
             * @static
             * @param {flyteidl.core.ICompiledWorkflowClosure} message CompiledWorkflowClosure message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CompiledWorkflowClosure.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.primary != null && message.hasOwnProperty("primary"))
                    $root.flyteidl.core.CompiledWorkflow.encode(message.primary, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.subWorkflows != null && message.subWorkflows.length)
                    for (let i = 0; i < message.subWorkflows.length; ++i)
                        $root.flyteidl.core.CompiledWorkflow.encode(message.subWorkflows[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.tasks != null && message.tasks.length)
                    for (let i = 0; i < message.tasks.length; ++i)
                        $root.flyteidl.core.CompiledTask.encode(message.tasks[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a CompiledWorkflowClosure message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.core.CompiledWorkflowClosure
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.core.CompiledWorkflowClosure} CompiledWorkflowClosure
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CompiledWorkflowClosure.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.core.CompiledWorkflowClosure();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.primary = $root.flyteidl.core.CompiledWorkflow.decode(reader, reader.uint32());
                        break;
                    case 2:
                        if (!(message.subWorkflows && message.subWorkflows.length))
                            message.subWorkflows = [];
                        message.subWorkflows.push($root.flyteidl.core.CompiledWorkflow.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        if (!(message.tasks && message.tasks.length))
                            message.tasks = [];
                        message.tasks.push($root.flyteidl.core.CompiledTask.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a CompiledWorkflowClosure message.
             * @function verify
             * @memberof flyteidl.core.CompiledWorkflowClosure
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CompiledWorkflowClosure.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.primary != null && message.hasOwnProperty("primary")) {
                    let error = $root.flyteidl.core.CompiledWorkflow.verify(message.primary);
                    if (error)
                        return "primary." + error;
                }
                if (message.subWorkflows != null && message.hasOwnProperty("subWorkflows")) {
                    if (!Array.isArray(message.subWorkflows))
                        return "subWorkflows: array expected";
                    for (let i = 0; i < message.subWorkflows.length; ++i) {
                        let error = $root.flyteidl.core.CompiledWorkflow.verify(message.subWorkflows[i]);
                        if (error)
                            return "subWorkflows." + error;
                    }
                }
                if (message.tasks != null && message.hasOwnProperty("tasks")) {
                    if (!Array.isArray(message.tasks))
                        return "tasks: array expected";
                    for (let i = 0; i < message.tasks.length; ++i) {
                        let error = $root.flyteidl.core.CompiledTask.verify(message.tasks[i]);
                        if (error)
                            return "tasks." + error;
                    }
                }
                return null;
            };

            return CompiledWorkflowClosure;
        })();

        core.IfBlock = (function() {

            /**
             * Properties of an IfBlock.
             * @memberof flyteidl.core
             * @interface IIfBlock
             * @property {flyteidl.core.IBooleanExpression|null} [condition] IfBlock condition
             * @property {flyteidl.core.INode|null} [thenNode] IfBlock thenNode
             */

            /**
             * Constructs a new IfBlock.
             * @memberof flyteidl.core
             * @classdesc Represents an IfBlock.
             * @implements IIfBlock
             * @constructor
             * @param {flyteidl.core.IIfBlock=} [properties] Properties to set
             */
            function IfBlock(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * IfBlock condition.
             * @member {flyteidl.core.IBooleanExpression|null|undefined} condition
             * @memberof flyteidl.core.IfBlock
             * @instance
             */
            IfBlock.prototype.condition = null;

            /**
             * IfBlock thenNode.
             * @member {flyteidl.core.INode|null|undefined} thenNode
             * @memberof flyteidl.core.IfBlock
             * @instance
             */
            IfBlock.prototype.thenNode = null;

            /**
             * Creates a new IfBlock instance using the specified properties.
             * @function create
             * @memberof flyteidl.core.IfBlock
             * @static
             * @param {flyteidl.core.IIfBlock=} [properties] Properties to set
             * @returns {flyteidl.core.IfBlock} IfBlock instance
             */
            IfBlock.create = function create(properties) {
                return new IfBlock(properties);
            };

            /**
             * Encodes the specified IfBlock message. Does not implicitly {@link flyteidl.core.IfBlock.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.core.IfBlock
             * @static
             * @param {flyteidl.core.IIfBlock} message IfBlock message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IfBlock.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.condition != null && message.hasOwnProperty("condition"))
                    $root.flyteidl.core.BooleanExpression.encode(message.condition, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.thenNode != null && message.hasOwnProperty("thenNode"))
                    $root.flyteidl.core.Node.encode(message.thenNode, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes an IfBlock message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.core.IfBlock
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.core.IfBlock} IfBlock
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IfBlock.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.core.IfBlock();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.condition = $root.flyteidl.core.BooleanExpression.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.thenNode = $root.flyteidl.core.Node.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies an IfBlock message.
             * @function verify
             * @memberof flyteidl.core.IfBlock
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            IfBlock.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.condition != null && message.hasOwnProperty("condition")) {
                    let error = $root.flyteidl.core.BooleanExpression.verify(message.condition);
                    if (error)
                        return "condition." + error;
                }
                if (message.thenNode != null && message.hasOwnProperty("thenNode")) {
                    let error = $root.flyteidl.core.Node.verify(message.thenNode);
                    if (error)
                        return "thenNode." + error;
                }
                return null;
            };

            return IfBlock;
        })();

        core.IfElseBlock = (function() {

            /**
             * Properties of an IfElseBlock.
             * @memberof flyteidl.core
             * @interface IIfElseBlock
             * @property {flyteidl.core.IIfBlock|null} ["case"] IfElseBlock case
             * @property {Array.<flyteidl.core.IIfBlock>|null} [other] IfElseBlock other
             * @property {flyteidl.core.INode|null} [elseNode] IfElseBlock elseNode
             * @property {flyteidl.core.IError|null} [error] IfElseBlock error
             */

            /**
             * Constructs a new IfElseBlock.
             * @memberof flyteidl.core
             * @classdesc Represents an IfElseBlock.
             * @implements IIfElseBlock
             * @constructor
             * @param {flyteidl.core.IIfElseBlock=} [properties] Properties to set
             */
            function IfElseBlock(properties) {
                this.other = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * IfElseBlock case.
             * @member {flyteidl.core.IIfBlock|null|undefined} case
             * @memberof flyteidl.core.IfElseBlock
             * @instance
             */
            IfElseBlock.prototype["case"] = null;

            /**
             * IfElseBlock other.
             * @member {Array.<flyteidl.core.IIfBlock>} other
             * @memberof flyteidl.core.IfElseBlock
             * @instance
             */
            IfElseBlock.prototype.other = $util.emptyArray;

            /**
             * IfElseBlock elseNode.
             * @member {flyteidl.core.INode|null|undefined} elseNode
             * @memberof flyteidl.core.IfElseBlock
             * @instance
             */
            IfElseBlock.prototype.elseNode = null;

            /**
             * IfElseBlock error.
             * @member {flyteidl.core.IError|null|undefined} error
             * @memberof flyteidl.core.IfElseBlock
             * @instance
             */
            IfElseBlock.prototype.error = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * IfElseBlock default.
             * @member {"elseNode"|"error"|undefined} default_
             * @memberof flyteidl.core.IfElseBlock
             * @instance
             */
            Object.defineProperty(IfElseBlock.prototype, "default", {
                get: $util.oneOfGetter($oneOfFields = ["elseNode", "error"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new IfElseBlock instance using the specified properties.
             * @function create
             * @memberof flyteidl.core.IfElseBlock
             * @static
             * @param {flyteidl.core.IIfElseBlock=} [properties] Properties to set
             * @returns {flyteidl.core.IfElseBlock} IfElseBlock instance
             */
            IfElseBlock.create = function create(properties) {
                return new IfElseBlock(properties);
            };

            /**
             * Encodes the specified IfElseBlock message. Does not implicitly {@link flyteidl.core.IfElseBlock.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.core.IfElseBlock
             * @static
             * @param {flyteidl.core.IIfElseBlock} message IfElseBlock message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IfElseBlock.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message["case"] != null && message.hasOwnProperty("case"))
                    $root.flyteidl.core.IfBlock.encode(message["case"], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.other != null && message.other.length)
                    for (let i = 0; i < message.other.length; ++i)
                        $root.flyteidl.core.IfBlock.encode(message.other[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.elseNode != null && message.hasOwnProperty("elseNode"))
                    $root.flyteidl.core.Node.encode(message.elseNode, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.error != null && message.hasOwnProperty("error"))
                    $root.flyteidl.core.Error.encode(message.error, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes an IfElseBlock message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.core.IfElseBlock
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.core.IfElseBlock} IfElseBlock
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IfElseBlock.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.core.IfElseBlock();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message["case"] = $root.flyteidl.core.IfBlock.decode(reader, reader.uint32());
                        break;
                    case 2:
                        if (!(message.other && message.other.length))
                            message.other = [];
                        message.other.push($root.flyteidl.core.IfBlock.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.elseNode = $root.flyteidl.core.Node.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.error = $root.flyteidl.core.Error.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies an IfElseBlock message.
             * @function verify
             * @memberof flyteidl.core.IfElseBlock
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            IfElseBlock.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message["case"] != null && message.hasOwnProperty("case")) {
                    let error = $root.flyteidl.core.IfBlock.verify(message["case"]);
                    if (error)
                        return "case." + error;
                }
                if (message.other != null && message.hasOwnProperty("other")) {
                    if (!Array.isArray(message.other))
                        return "other: array expected";
                    for (let i = 0; i < message.other.length; ++i) {
                        let error = $root.flyteidl.core.IfBlock.verify(message.other[i]);
                        if (error)
                            return "other." + error;
                    }
                }
                if (message.elseNode != null && message.hasOwnProperty("elseNode")) {
                    properties["default"] = 1;
                    {
                        let error = $root.flyteidl.core.Node.verify(message.elseNode);
                        if (error)
                            return "elseNode." + error;
                    }
                }
                if (message.error != null && message.hasOwnProperty("error")) {
                    if (properties["default"] === 1)
                        return "default: multiple values";
                    properties["default"] = 1;
                    {
                        let error = $root.flyteidl.core.Error.verify(message.error);
                        if (error)
                            return "error." + error;
                    }
                }
                return null;
            };

            return IfElseBlock;
        })();

        core.BranchNode = (function() {

            /**
             * Properties of a BranchNode.
             * @memberof flyteidl.core
             * @interface IBranchNode
             * @property {flyteidl.core.IIfElseBlock|null} [ifElse] BranchNode ifElse
             */

            /**
             * Constructs a new BranchNode.
             * @memberof flyteidl.core
             * @classdesc Represents a BranchNode.
             * @implements IBranchNode
             * @constructor
             * @param {flyteidl.core.IBranchNode=} [properties] Properties to set
             */
            function BranchNode(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BranchNode ifElse.
             * @member {flyteidl.core.IIfElseBlock|null|undefined} ifElse
             * @memberof flyteidl.core.BranchNode
             * @instance
             */
            BranchNode.prototype.ifElse = null;

            /**
             * Creates a new BranchNode instance using the specified properties.
             * @function create
             * @memberof flyteidl.core.BranchNode
             * @static
             * @param {flyteidl.core.IBranchNode=} [properties] Properties to set
             * @returns {flyteidl.core.BranchNode} BranchNode instance
             */
            BranchNode.create = function create(properties) {
                return new BranchNode(properties);
            };

            /**
             * Encodes the specified BranchNode message. Does not implicitly {@link flyteidl.core.BranchNode.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.core.BranchNode
             * @static
             * @param {flyteidl.core.IBranchNode} message BranchNode message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BranchNode.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.ifElse != null && message.hasOwnProperty("ifElse"))
                    $root.flyteidl.core.IfElseBlock.encode(message.ifElse, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a BranchNode message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.core.BranchNode
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.core.BranchNode} BranchNode
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BranchNode.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.core.BranchNode();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.ifElse = $root.flyteidl.core.IfElseBlock.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a BranchNode message.
             * @function verify
             * @memberof flyteidl.core.BranchNode
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BranchNode.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.ifElse != null && message.hasOwnProperty("ifElse")) {
                    let error = $root.flyteidl.core.IfElseBlock.verify(message.ifElse);
                    if (error)
                        return "ifElse." + error;
                }
                return null;
            };

            return BranchNode;
        })();

        core.TaskNode = (function() {

            /**
             * Properties of a TaskNode.
             * @memberof flyteidl.core
             * @interface ITaskNode
             * @property {flyteidl.core.IIdentifier|null} [referenceId] TaskNode referenceId
             */

            /**
             * Constructs a new TaskNode.
             * @memberof flyteidl.core
             * @classdesc Represents a TaskNode.
             * @implements ITaskNode
             * @constructor
             * @param {flyteidl.core.ITaskNode=} [properties] Properties to set
             */
            function TaskNode(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TaskNode referenceId.
             * @member {flyteidl.core.IIdentifier|null|undefined} referenceId
             * @memberof flyteidl.core.TaskNode
             * @instance
             */
            TaskNode.prototype.referenceId = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * TaskNode reference.
             * @member {"referenceId"|undefined} reference
             * @memberof flyteidl.core.TaskNode
             * @instance
             */
            Object.defineProperty(TaskNode.prototype, "reference", {
                get: $util.oneOfGetter($oneOfFields = ["referenceId"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new TaskNode instance using the specified properties.
             * @function create
             * @memberof flyteidl.core.TaskNode
             * @static
             * @param {flyteidl.core.ITaskNode=} [properties] Properties to set
             * @returns {flyteidl.core.TaskNode} TaskNode instance
             */
            TaskNode.create = function create(properties) {
                return new TaskNode(properties);
            };

            /**
             * Encodes the specified TaskNode message. Does not implicitly {@link flyteidl.core.TaskNode.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.core.TaskNode
             * @static
             * @param {flyteidl.core.ITaskNode} message TaskNode message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TaskNode.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.referenceId != null && message.hasOwnProperty("referenceId"))
                    $root.flyteidl.core.Identifier.encode(message.referenceId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a TaskNode message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.core.TaskNode
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.core.TaskNode} TaskNode
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TaskNode.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.core.TaskNode();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.referenceId = $root.flyteidl.core.Identifier.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a TaskNode message.
             * @function verify
             * @memberof flyteidl.core.TaskNode
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TaskNode.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.referenceId != null && message.hasOwnProperty("referenceId")) {
                    properties.reference = 1;
                    {
                        let error = $root.flyteidl.core.Identifier.verify(message.referenceId);
                        if (error)
                            return "referenceId." + error;
                    }
                }
                return null;
            };

            return TaskNode;
        })();

        core.WorkflowNode = (function() {

            /**
             * Properties of a WorkflowNode.
             * @memberof flyteidl.core
             * @interface IWorkflowNode
             * @property {flyteidl.core.IIdentifier|null} [launchplanRef] WorkflowNode launchplanRef
             * @property {flyteidl.core.IIdentifier|null} [subWorkflowRef] WorkflowNode subWorkflowRef
             */

            /**
             * Constructs a new WorkflowNode.
             * @memberof flyteidl.core
             * @classdesc Represents a WorkflowNode.
             * @implements IWorkflowNode
             * @constructor
             * @param {flyteidl.core.IWorkflowNode=} [properties] Properties to set
             */
            function WorkflowNode(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WorkflowNode launchplanRef.
             * @member {flyteidl.core.IIdentifier|null|undefined} launchplanRef
             * @memberof flyteidl.core.WorkflowNode
             * @instance
             */
            WorkflowNode.prototype.launchplanRef = null;

            /**
             * WorkflowNode subWorkflowRef.
             * @member {flyteidl.core.IIdentifier|null|undefined} subWorkflowRef
             * @memberof flyteidl.core.WorkflowNode
             * @instance
             */
            WorkflowNode.prototype.subWorkflowRef = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * WorkflowNode reference.
             * @member {"launchplanRef"|"subWorkflowRef"|undefined} reference
             * @memberof flyteidl.core.WorkflowNode
             * @instance
             */
            Object.defineProperty(WorkflowNode.prototype, "reference", {
                get: $util.oneOfGetter($oneOfFields = ["launchplanRef", "subWorkflowRef"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new WorkflowNode instance using the specified properties.
             * @function create
             * @memberof flyteidl.core.WorkflowNode
             * @static
             * @param {flyteidl.core.IWorkflowNode=} [properties] Properties to set
             * @returns {flyteidl.core.WorkflowNode} WorkflowNode instance
             */
            WorkflowNode.create = function create(properties) {
                return new WorkflowNode(properties);
            };

            /**
             * Encodes the specified WorkflowNode message. Does not implicitly {@link flyteidl.core.WorkflowNode.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.core.WorkflowNode
             * @static
             * @param {flyteidl.core.IWorkflowNode} message WorkflowNode message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WorkflowNode.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.launchplanRef != null && message.hasOwnProperty("launchplanRef"))
                    $root.flyteidl.core.Identifier.encode(message.launchplanRef, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.subWorkflowRef != null && message.hasOwnProperty("subWorkflowRef"))
                    $root.flyteidl.core.Identifier.encode(message.subWorkflowRef, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a WorkflowNode message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.core.WorkflowNode
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.core.WorkflowNode} WorkflowNode
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WorkflowNode.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.core.WorkflowNode();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.launchplanRef = $root.flyteidl.core.Identifier.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.subWorkflowRef = $root.flyteidl.core.Identifier.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a WorkflowNode message.
             * @function verify
             * @memberof flyteidl.core.WorkflowNode
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WorkflowNode.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.launchplanRef != null && message.hasOwnProperty("launchplanRef")) {
                    properties.reference = 1;
                    {
                        let error = $root.flyteidl.core.Identifier.verify(message.launchplanRef);
                        if (error)
                            return "launchplanRef." + error;
                    }
                }
                if (message.subWorkflowRef != null && message.hasOwnProperty("subWorkflowRef")) {
                    if (properties.reference === 1)
                        return "reference: multiple values";
                    properties.reference = 1;
                    {
                        let error = $root.flyteidl.core.Identifier.verify(message.subWorkflowRef);
                        if (error)
                            return "subWorkflowRef." + error;
                    }
                }
                return null;
            };

            return WorkflowNode;
        })();

        core.NodeMetadata = (function() {

            /**
             * Properties of a NodeMetadata.
             * @memberof flyteidl.core
             * @interface INodeMetadata
             * @property {string|null} [name] NodeMetadata name
             * @property {google.protobuf.IDuration|null} [timeout] NodeMetadata timeout
             * @property {flyteidl.core.IRetryStrategy|null} [retries] NodeMetadata retries
             * @property {boolean|null} [interruptible] NodeMetadata interruptible
             */

            /**
             * Constructs a new NodeMetadata.
             * @memberof flyteidl.core
             * @classdesc Represents a NodeMetadata.
             * @implements INodeMetadata
             * @constructor
             * @param {flyteidl.core.INodeMetadata=} [properties] Properties to set
             */
            function NodeMetadata(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NodeMetadata name.
             * @member {string} name
             * @memberof flyteidl.core.NodeMetadata
             * @instance
             */
            NodeMetadata.prototype.name = "";

            /**
             * NodeMetadata timeout.
             * @member {google.protobuf.IDuration|null|undefined} timeout
             * @memberof flyteidl.core.NodeMetadata
             * @instance
             */
            NodeMetadata.prototype.timeout = null;

            /**
             * NodeMetadata retries.
             * @member {flyteidl.core.IRetryStrategy|null|undefined} retries
             * @memberof flyteidl.core.NodeMetadata
             * @instance
             */
            NodeMetadata.prototype.retries = null;

            /**
             * NodeMetadata interruptible.
             * @member {boolean} interruptible
             * @memberof flyteidl.core.NodeMetadata
             * @instance
             */
            NodeMetadata.prototype.interruptible = false;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * NodeMetadata interruptibleValue.
             * @member {"interruptible"|undefined} interruptibleValue
             * @memberof flyteidl.core.NodeMetadata
             * @instance
             */
            Object.defineProperty(NodeMetadata.prototype, "interruptibleValue", {
                get: $util.oneOfGetter($oneOfFields = ["interruptible"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new NodeMetadata instance using the specified properties.
             * @function create
             * @memberof flyteidl.core.NodeMetadata
             * @static
             * @param {flyteidl.core.INodeMetadata=} [properties] Properties to set
             * @returns {flyteidl.core.NodeMetadata} NodeMetadata instance
             */
            NodeMetadata.create = function create(properties) {
                return new NodeMetadata(properties);
            };

            /**
             * Encodes the specified NodeMetadata message. Does not implicitly {@link flyteidl.core.NodeMetadata.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.core.NodeMetadata
             * @static
             * @param {flyteidl.core.INodeMetadata} message NodeMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NodeMetadata.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.timeout != null && message.hasOwnProperty("timeout"))
                    $root.google.protobuf.Duration.encode(message.timeout, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.retries != null && message.hasOwnProperty("retries"))
                    $root.flyteidl.core.RetryStrategy.encode(message.retries, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.interruptible != null && message.hasOwnProperty("interruptible"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.interruptible);
                return writer;
            };

            /**
             * Decodes a NodeMetadata message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.core.NodeMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.core.NodeMetadata} NodeMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NodeMetadata.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.core.NodeMetadata();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 4:
                        message.timeout = $root.google.protobuf.Duration.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.retries = $root.flyteidl.core.RetryStrategy.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.interruptible = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a NodeMetadata message.
             * @function verify
             * @memberof flyteidl.core.NodeMetadata
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NodeMetadata.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.timeout != null && message.hasOwnProperty("timeout")) {
                    let error = $root.google.protobuf.Duration.verify(message.timeout);
                    if (error)
                        return "timeout." + error;
                }
                if (message.retries != null && message.hasOwnProperty("retries")) {
                    let error = $root.flyteidl.core.RetryStrategy.verify(message.retries);
                    if (error)
                        return "retries." + error;
                }
                if (message.interruptible != null && message.hasOwnProperty("interruptible")) {
                    properties.interruptibleValue = 1;
                    if (typeof message.interruptible !== "boolean")
                        return "interruptible: boolean expected";
                }
                return null;
            };

            return NodeMetadata;
        })();

        core.Alias = (function() {

            /**
             * Properties of an Alias.
             * @memberof flyteidl.core
             * @interface IAlias
             * @property {string|null} ["var"] Alias var
             * @property {string|null} [alias] Alias alias
             */

            /**
             * Constructs a new Alias.
             * @memberof flyteidl.core
             * @classdesc Represents an Alias.
             * @implements IAlias
             * @constructor
             * @param {flyteidl.core.IAlias=} [properties] Properties to set
             */
            function Alias(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Alias var.
             * @member {string} var
             * @memberof flyteidl.core.Alias
             * @instance
             */
            Alias.prototype["var"] = "";

            /**
             * Alias alias.
             * @member {string} alias
             * @memberof flyteidl.core.Alias
             * @instance
             */
            Alias.prototype.alias = "";

            /**
             * Creates a new Alias instance using the specified properties.
             * @function create
             * @memberof flyteidl.core.Alias
             * @static
             * @param {flyteidl.core.IAlias=} [properties] Properties to set
             * @returns {flyteidl.core.Alias} Alias instance
             */
            Alias.create = function create(properties) {
                return new Alias(properties);
            };

            /**
             * Encodes the specified Alias message. Does not implicitly {@link flyteidl.core.Alias.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.core.Alias
             * @static
             * @param {flyteidl.core.IAlias} message Alias message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Alias.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message["var"] != null && message.hasOwnProperty("var"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message["var"]);
                if (message.alias != null && message.hasOwnProperty("alias"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.alias);
                return writer;
            };

            /**
             * Decodes an Alias message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.core.Alias
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.core.Alias} Alias
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Alias.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.core.Alias();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message["var"] = reader.string();
                        break;
                    case 2:
                        message.alias = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies an Alias message.
             * @function verify
             * @memberof flyteidl.core.Alias
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Alias.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message["var"] != null && message.hasOwnProperty("var"))
                    if (!$util.isString(message["var"]))
                        return "var: string expected";
                if (message.alias != null && message.hasOwnProperty("alias"))
                    if (!$util.isString(message.alias))
                        return "alias: string expected";
                return null;
            };

            return Alias;
        })();

        core.Node = (function() {

            /**
             * Properties of a Node.
             * @memberof flyteidl.core
             * @interface INode
             * @property {string|null} [id] Node id
             * @property {flyteidl.core.INodeMetadata|null} [metadata] Node metadata
             * @property {Array.<flyteidl.core.IBinding>|null} [inputs] Node inputs
             * @property {Array.<string>|null} [upstreamNodeIds] Node upstreamNodeIds
             * @property {Array.<flyteidl.core.IAlias>|null} [outputAliases] Node outputAliases
             * @property {flyteidl.core.ITaskNode|null} [taskNode] Node taskNode
             * @property {flyteidl.core.IWorkflowNode|null} [workflowNode] Node workflowNode
             * @property {flyteidl.core.IBranchNode|null} [branchNode] Node branchNode
             */

            /**
             * Constructs a new Node.
             * @memberof flyteidl.core
             * @classdesc Represents a Node.
             * @implements INode
             * @constructor
             * @param {flyteidl.core.INode=} [properties] Properties to set
             */
            function Node(properties) {
                this.inputs = [];
                this.upstreamNodeIds = [];
                this.outputAliases = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Node id.
             * @member {string} id
             * @memberof flyteidl.core.Node
             * @instance
             */
            Node.prototype.id = "";

            /**
             * Node metadata.
             * @member {flyteidl.core.INodeMetadata|null|undefined} metadata
             * @memberof flyteidl.core.Node
             * @instance
             */
            Node.prototype.metadata = null;

            /**
             * Node inputs.
             * @member {Array.<flyteidl.core.IBinding>} inputs
             * @memberof flyteidl.core.Node
             * @instance
             */
            Node.prototype.inputs = $util.emptyArray;

            /**
             * Node upstreamNodeIds.
             * @member {Array.<string>} upstreamNodeIds
             * @memberof flyteidl.core.Node
             * @instance
             */
            Node.prototype.upstreamNodeIds = $util.emptyArray;

            /**
             * Node outputAliases.
             * @member {Array.<flyteidl.core.IAlias>} outputAliases
             * @memberof flyteidl.core.Node
             * @instance
             */
            Node.prototype.outputAliases = $util.emptyArray;

            /**
             * Node taskNode.
             * @member {flyteidl.core.ITaskNode|null|undefined} taskNode
             * @memberof flyteidl.core.Node
             * @instance
             */
            Node.prototype.taskNode = null;

            /**
             * Node workflowNode.
             * @member {flyteidl.core.IWorkflowNode|null|undefined} workflowNode
             * @memberof flyteidl.core.Node
             * @instance
             */
            Node.prototype.workflowNode = null;

            /**
             * Node branchNode.
             * @member {flyteidl.core.IBranchNode|null|undefined} branchNode
             * @memberof flyteidl.core.Node
             * @instance
             */
            Node.prototype.branchNode = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * Node target.
             * @member {"taskNode"|"workflowNode"|"branchNode"|undefined} target
             * @memberof flyteidl.core.Node
             * @instance
             */
            Object.defineProperty(Node.prototype, "target", {
                get: $util.oneOfGetter($oneOfFields = ["taskNode", "workflowNode", "branchNode"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new Node instance using the specified properties.
             * @function create
             * @memberof flyteidl.core.Node
             * @static
             * @param {flyteidl.core.INode=} [properties] Properties to set
             * @returns {flyteidl.core.Node} Node instance
             */
            Node.create = function create(properties) {
                return new Node(properties);
            };

            /**
             * Encodes the specified Node message. Does not implicitly {@link flyteidl.core.Node.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.core.Node
             * @static
             * @param {flyteidl.core.INode} message Node message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Node.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    $root.flyteidl.core.NodeMetadata.encode(message.metadata, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.inputs != null && message.inputs.length)
                    for (let i = 0; i < message.inputs.length; ++i)
                        $root.flyteidl.core.Binding.encode(message.inputs[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.upstreamNodeIds != null && message.upstreamNodeIds.length)
                    for (let i = 0; i < message.upstreamNodeIds.length; ++i)
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.upstreamNodeIds[i]);
                if (message.outputAliases != null && message.outputAliases.length)
                    for (let i = 0; i < message.outputAliases.length; ++i)
                        $root.flyteidl.core.Alias.encode(message.outputAliases[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.taskNode != null && message.hasOwnProperty("taskNode"))
                    $root.flyteidl.core.TaskNode.encode(message.taskNode, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.workflowNode != null && message.hasOwnProperty("workflowNode"))
                    $root.flyteidl.core.WorkflowNode.encode(message.workflowNode, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.branchNode != null && message.hasOwnProperty("branchNode"))
                    $root.flyteidl.core.BranchNode.encode(message.branchNode, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a Node message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.core.Node
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.core.Node} Node
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Node.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.core.Node();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        message.metadata = $root.flyteidl.core.NodeMetadata.decode(reader, reader.uint32());
                        break;
                    case 3:
                        if (!(message.inputs && message.inputs.length))
                            message.inputs = [];
                        message.inputs.push($root.flyteidl.core.Binding.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        if (!(message.upstreamNodeIds && message.upstreamNodeIds.length))
                            message.upstreamNodeIds = [];
                        message.upstreamNodeIds.push(reader.string());
                        break;
                    case 5:
                        if (!(message.outputAliases && message.outputAliases.length))
                            message.outputAliases = [];
                        message.outputAliases.push($root.flyteidl.core.Alias.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        message.taskNode = $root.flyteidl.core.TaskNode.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.workflowNode = $root.flyteidl.core.WorkflowNode.decode(reader, reader.uint32());
                        break;
                    case 8:
                        message.branchNode = $root.flyteidl.core.BranchNode.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a Node message.
             * @function verify
             * @memberof flyteidl.core.Node
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Node.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.metadata != null && message.hasOwnProperty("metadata")) {
                    let error = $root.flyteidl.core.NodeMetadata.verify(message.metadata);
                    if (error)
                        return "metadata." + error;
                }
                if (message.inputs != null && message.hasOwnProperty("inputs")) {
                    if (!Array.isArray(message.inputs))
                        return "inputs: array expected";
                    for (let i = 0; i < message.inputs.length; ++i) {
                        let error = $root.flyteidl.core.Binding.verify(message.inputs[i]);
                        if (error)
                            return "inputs." + error;
                    }
                }
                if (message.upstreamNodeIds != null && message.hasOwnProperty("upstreamNodeIds")) {
                    if (!Array.isArray(message.upstreamNodeIds))
                        return "upstreamNodeIds: array expected";
                    for (let i = 0; i < message.upstreamNodeIds.length; ++i)
                        if (!$util.isString(message.upstreamNodeIds[i]))
                            return "upstreamNodeIds: string[] expected";
                }
                if (message.outputAliases != null && message.hasOwnProperty("outputAliases")) {
                    if (!Array.isArray(message.outputAliases))
                        return "outputAliases: array expected";
                    for (let i = 0; i < message.outputAliases.length; ++i) {
                        let error = $root.flyteidl.core.Alias.verify(message.outputAliases[i]);
                        if (error)
                            return "outputAliases." + error;
                    }
                }
                if (message.taskNode != null && message.hasOwnProperty("taskNode")) {
                    properties.target = 1;
                    {
                        let error = $root.flyteidl.core.TaskNode.verify(message.taskNode);
                        if (error)
                            return "taskNode." + error;
                    }
                }
                if (message.workflowNode != null && message.hasOwnProperty("workflowNode")) {
                    if (properties.target === 1)
                        return "target: multiple values";
                    properties.target = 1;
                    {
                        let error = $root.flyteidl.core.WorkflowNode.verify(message.workflowNode);
                        if (error)
                            return "workflowNode." + error;
                    }
                }
                if (message.branchNode != null && message.hasOwnProperty("branchNode")) {
                    if (properties.target === 1)
                        return "target: multiple values";
                    properties.target = 1;
                    {
                        let error = $root.flyteidl.core.BranchNode.verify(message.branchNode);
                        if (error)
                            return "branchNode." + error;
                    }
                }
                return null;
            };

            return Node;
        })();

        core.WorkflowMetadata = (function() {

            /**
             * Properties of a WorkflowMetadata.
             * @memberof flyteidl.core
             * @interface IWorkflowMetadata
             * @property {google.protobuf.IDuration|null} [queuingBudget] WorkflowMetadata queuingBudget
             */

            /**
             * Constructs a new WorkflowMetadata.
             * @memberof flyteidl.core
             * @classdesc Represents a WorkflowMetadata.
             * @implements IWorkflowMetadata
             * @constructor
             * @param {flyteidl.core.IWorkflowMetadata=} [properties] Properties to set
             */
            function WorkflowMetadata(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WorkflowMetadata queuingBudget.
             * @member {google.protobuf.IDuration|null|undefined} queuingBudget
             * @memberof flyteidl.core.WorkflowMetadata
             * @instance
             */
            WorkflowMetadata.prototype.queuingBudget = null;

            /**
             * Creates a new WorkflowMetadata instance using the specified properties.
             * @function create
             * @memberof flyteidl.core.WorkflowMetadata
             * @static
             * @param {flyteidl.core.IWorkflowMetadata=} [properties] Properties to set
             * @returns {flyteidl.core.WorkflowMetadata} WorkflowMetadata instance
             */
            WorkflowMetadata.create = function create(properties) {
                return new WorkflowMetadata(properties);
            };

            /**
             * Encodes the specified WorkflowMetadata message. Does not implicitly {@link flyteidl.core.WorkflowMetadata.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.core.WorkflowMetadata
             * @static
             * @param {flyteidl.core.IWorkflowMetadata} message WorkflowMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WorkflowMetadata.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.queuingBudget != null && message.hasOwnProperty("queuingBudget"))
                    $root.google.protobuf.Duration.encode(message.queuingBudget, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a WorkflowMetadata message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.core.WorkflowMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.core.WorkflowMetadata} WorkflowMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WorkflowMetadata.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.core.WorkflowMetadata();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.queuingBudget = $root.google.protobuf.Duration.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a WorkflowMetadata message.
             * @function verify
             * @memberof flyteidl.core.WorkflowMetadata
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WorkflowMetadata.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.queuingBudget != null && message.hasOwnProperty("queuingBudget")) {
                    let error = $root.google.protobuf.Duration.verify(message.queuingBudget);
                    if (error)
                        return "queuingBudget." + error;
                }
                return null;
            };

            return WorkflowMetadata;
        })();

        core.WorkflowMetadataDefaults = (function() {

            /**
             * Properties of a WorkflowMetadataDefaults.
             * @memberof flyteidl.core
             * @interface IWorkflowMetadataDefaults
             * @property {boolean|null} [interruptible] WorkflowMetadataDefaults interruptible
             */

            /**
             * Constructs a new WorkflowMetadataDefaults.
             * @memberof flyteidl.core
             * @classdesc Represents a WorkflowMetadataDefaults.
             * @implements IWorkflowMetadataDefaults
             * @constructor
             * @param {flyteidl.core.IWorkflowMetadataDefaults=} [properties] Properties to set
             */
            function WorkflowMetadataDefaults(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WorkflowMetadataDefaults interruptible.
             * @member {boolean} interruptible
             * @memberof flyteidl.core.WorkflowMetadataDefaults
             * @instance
             */
            WorkflowMetadataDefaults.prototype.interruptible = false;

            /**
             * Creates a new WorkflowMetadataDefaults instance using the specified properties.
             * @function create
             * @memberof flyteidl.core.WorkflowMetadataDefaults
             * @static
             * @param {flyteidl.core.IWorkflowMetadataDefaults=} [properties] Properties to set
             * @returns {flyteidl.core.WorkflowMetadataDefaults} WorkflowMetadataDefaults instance
             */
            WorkflowMetadataDefaults.create = function create(properties) {
                return new WorkflowMetadataDefaults(properties);
            };

            /**
             * Encodes the specified WorkflowMetadataDefaults message. Does not implicitly {@link flyteidl.core.WorkflowMetadataDefaults.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.core.WorkflowMetadataDefaults
             * @static
             * @param {flyteidl.core.IWorkflowMetadataDefaults} message WorkflowMetadataDefaults message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WorkflowMetadataDefaults.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.interruptible != null && message.hasOwnProperty("interruptible"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.interruptible);
                return writer;
            };

            /**
             * Decodes a WorkflowMetadataDefaults message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.core.WorkflowMetadataDefaults
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.core.WorkflowMetadataDefaults} WorkflowMetadataDefaults
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WorkflowMetadataDefaults.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.core.WorkflowMetadataDefaults();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.interruptible = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a WorkflowMetadataDefaults message.
             * @function verify
             * @memberof flyteidl.core.WorkflowMetadataDefaults
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WorkflowMetadataDefaults.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.interruptible != null && message.hasOwnProperty("interruptible"))
                    if (typeof message.interruptible !== "boolean")
                        return "interruptible: boolean expected";
                return null;
            };

            return WorkflowMetadataDefaults;
        })();

        core.WorkflowTemplate = (function() {

            /**
             * Properties of a WorkflowTemplate.
             * @memberof flyteidl.core
             * @interface IWorkflowTemplate
             * @property {flyteidl.core.IIdentifier|null} [id] WorkflowTemplate id
             * @property {flyteidl.core.IWorkflowMetadata|null} [metadata] WorkflowTemplate metadata
             * @property {flyteidl.core.ITypedInterface|null} ["interface"] WorkflowTemplate interface
             * @property {Array.<flyteidl.core.INode>|null} [nodes] WorkflowTemplate nodes
             * @property {Array.<flyteidl.core.IBinding>|null} [outputs] WorkflowTemplate outputs
             * @property {flyteidl.core.INode|null} [failureNode] WorkflowTemplate failureNode
             * @property {flyteidl.core.IWorkflowMetadataDefaults|null} [metadataDefaults] WorkflowTemplate metadataDefaults
             */

            /**
             * Constructs a new WorkflowTemplate.
             * @memberof flyteidl.core
             * @classdesc Represents a WorkflowTemplate.
             * @implements IWorkflowTemplate
             * @constructor
             * @param {flyteidl.core.IWorkflowTemplate=} [properties] Properties to set
             */
            function WorkflowTemplate(properties) {
                this.nodes = [];
                this.outputs = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WorkflowTemplate id.
             * @member {flyteidl.core.IIdentifier|null|undefined} id
             * @memberof flyteidl.core.WorkflowTemplate
             * @instance
             */
            WorkflowTemplate.prototype.id = null;

            /**
             * WorkflowTemplate metadata.
             * @member {flyteidl.core.IWorkflowMetadata|null|undefined} metadata
             * @memberof flyteidl.core.WorkflowTemplate
             * @instance
             */
            WorkflowTemplate.prototype.metadata = null;

            /**
             * WorkflowTemplate interface.
             * @member {flyteidl.core.ITypedInterface|null|undefined} interface
             * @memberof flyteidl.core.WorkflowTemplate
             * @instance
             */
            WorkflowTemplate.prototype["interface"] = null;

            /**
             * WorkflowTemplate nodes.
             * @member {Array.<flyteidl.core.INode>} nodes
             * @memberof flyteidl.core.WorkflowTemplate
             * @instance
             */
            WorkflowTemplate.prototype.nodes = $util.emptyArray;

            /**
             * WorkflowTemplate outputs.
             * @member {Array.<flyteidl.core.IBinding>} outputs
             * @memberof flyteidl.core.WorkflowTemplate
             * @instance
             */
            WorkflowTemplate.prototype.outputs = $util.emptyArray;

            /**
             * WorkflowTemplate failureNode.
             * @member {flyteidl.core.INode|null|undefined} failureNode
             * @memberof flyteidl.core.WorkflowTemplate
             * @instance
             */
            WorkflowTemplate.prototype.failureNode = null;

            /**
             * WorkflowTemplate metadataDefaults.
             * @member {flyteidl.core.IWorkflowMetadataDefaults|null|undefined} metadataDefaults
             * @memberof flyteidl.core.WorkflowTemplate
             * @instance
             */
            WorkflowTemplate.prototype.metadataDefaults = null;

            /**
             * Creates a new WorkflowTemplate instance using the specified properties.
             * @function create
             * @memberof flyteidl.core.WorkflowTemplate
             * @static
             * @param {flyteidl.core.IWorkflowTemplate=} [properties] Properties to set
             * @returns {flyteidl.core.WorkflowTemplate} WorkflowTemplate instance
             */
            WorkflowTemplate.create = function create(properties) {
                return new WorkflowTemplate(properties);
            };

            /**
             * Encodes the specified WorkflowTemplate message. Does not implicitly {@link flyteidl.core.WorkflowTemplate.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.core.WorkflowTemplate
             * @static
             * @param {flyteidl.core.IWorkflowTemplate} message WorkflowTemplate message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WorkflowTemplate.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    $root.flyteidl.core.Identifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    $root.flyteidl.core.WorkflowMetadata.encode(message.metadata, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message["interface"] != null && message.hasOwnProperty("interface"))
                    $root.flyteidl.core.TypedInterface.encode(message["interface"], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.nodes != null && message.nodes.length)
                    for (let i = 0; i < message.nodes.length; ++i)
                        $root.flyteidl.core.Node.encode(message.nodes[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.outputs != null && message.outputs.length)
                    for (let i = 0; i < message.outputs.length; ++i)
                        $root.flyteidl.core.Binding.encode(message.outputs[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.failureNode != null && message.hasOwnProperty("failureNode"))
                    $root.flyteidl.core.Node.encode(message.failureNode, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.metadataDefaults != null && message.hasOwnProperty("metadataDefaults"))
                    $root.flyteidl.core.WorkflowMetadataDefaults.encode(message.metadataDefaults, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a WorkflowTemplate message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.core.WorkflowTemplate
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.core.WorkflowTemplate} WorkflowTemplate
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WorkflowTemplate.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.core.WorkflowTemplate();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = $root.flyteidl.core.Identifier.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.metadata = $root.flyteidl.core.WorkflowMetadata.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message["interface"] = $root.flyteidl.core.TypedInterface.decode(reader, reader.uint32());
                        break;
                    case 4:
                        if (!(message.nodes && message.nodes.length))
                            message.nodes = [];
                        message.nodes.push($root.flyteidl.core.Node.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        if (!(message.outputs && message.outputs.length))
                            message.outputs = [];
                        message.outputs.push($root.flyteidl.core.Binding.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        message.failureNode = $root.flyteidl.core.Node.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.metadataDefaults = $root.flyteidl.core.WorkflowMetadataDefaults.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a WorkflowTemplate message.
             * @function verify
             * @memberof flyteidl.core.WorkflowTemplate
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WorkflowTemplate.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id")) {
                    let error = $root.flyteidl.core.Identifier.verify(message.id);
                    if (error)
                        return "id." + error;
                }
                if (message.metadata != null && message.hasOwnProperty("metadata")) {
                    let error = $root.flyteidl.core.WorkflowMetadata.verify(message.metadata);
                    if (error)
                        return "metadata." + error;
                }
                if (message["interface"] != null && message.hasOwnProperty("interface")) {
                    let error = $root.flyteidl.core.TypedInterface.verify(message["interface"]);
                    if (error)
                        return "interface." + error;
                }
                if (message.nodes != null && message.hasOwnProperty("nodes")) {
                    if (!Array.isArray(message.nodes))
                        return "nodes: array expected";
                    for (let i = 0; i < message.nodes.length; ++i) {
                        let error = $root.flyteidl.core.Node.verify(message.nodes[i]);
                        if (error)
                            return "nodes." + error;
                    }
                }
                if (message.outputs != null && message.hasOwnProperty("outputs")) {
                    if (!Array.isArray(message.outputs))
                        return "outputs: array expected";
                    for (let i = 0; i < message.outputs.length; ++i) {
                        let error = $root.flyteidl.core.Binding.verify(message.outputs[i]);
                        if (error)
                            return "outputs." + error;
                    }
                }
                if (message.failureNode != null && message.hasOwnProperty("failureNode")) {
                    let error = $root.flyteidl.core.Node.verify(message.failureNode);
                    if (error)
                        return "failureNode." + error;
                }
                if (message.metadataDefaults != null && message.hasOwnProperty("metadataDefaults")) {
                    let error = $root.flyteidl.core.WorkflowMetadataDefaults.verify(message.metadataDefaults);
                    if (error)
                        return "metadataDefaults." + error;
                }
                return null;
            };

            return WorkflowTemplate;
        })();

        core.ComparisonExpression = (function() {

            /**
             * Properties of a ComparisonExpression.
             * @memberof flyteidl.core
             * @interface IComparisonExpression
             * @property {flyteidl.core.ComparisonExpression.Operator|null} [operator] ComparisonExpression operator
             * @property {flyteidl.core.IOperand|null} [leftValue] ComparisonExpression leftValue
             * @property {flyteidl.core.IOperand|null} [rightValue] ComparisonExpression rightValue
             */

            /**
             * Constructs a new ComparisonExpression.
             * @memberof flyteidl.core
             * @classdesc Represents a ComparisonExpression.
             * @implements IComparisonExpression
             * @constructor
             * @param {flyteidl.core.IComparisonExpression=} [properties] Properties to set
             */
            function ComparisonExpression(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ComparisonExpression operator.
             * @member {flyteidl.core.ComparisonExpression.Operator} operator
             * @memberof flyteidl.core.ComparisonExpression
             * @instance
             */
            ComparisonExpression.prototype.operator = 0;

            /**
             * ComparisonExpression leftValue.
             * @member {flyteidl.core.IOperand|null|undefined} leftValue
             * @memberof flyteidl.core.ComparisonExpression
             * @instance
             */
            ComparisonExpression.prototype.leftValue = null;

            /**
             * ComparisonExpression rightValue.
             * @member {flyteidl.core.IOperand|null|undefined} rightValue
             * @memberof flyteidl.core.ComparisonExpression
             * @instance
             */
            ComparisonExpression.prototype.rightValue = null;

            /**
             * Creates a new ComparisonExpression instance using the specified properties.
             * @function create
             * @memberof flyteidl.core.ComparisonExpression
             * @static
             * @param {flyteidl.core.IComparisonExpression=} [properties] Properties to set
             * @returns {flyteidl.core.ComparisonExpression} ComparisonExpression instance
             */
            ComparisonExpression.create = function create(properties) {
                return new ComparisonExpression(properties);
            };

            /**
             * Encodes the specified ComparisonExpression message. Does not implicitly {@link flyteidl.core.ComparisonExpression.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.core.ComparisonExpression
             * @static
             * @param {flyteidl.core.IComparisonExpression} message ComparisonExpression message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ComparisonExpression.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operator != null && message.hasOwnProperty("operator"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.operator);
                if (message.leftValue != null && message.hasOwnProperty("leftValue"))
                    $root.flyteidl.core.Operand.encode(message.leftValue, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.rightValue != null && message.hasOwnProperty("rightValue"))
                    $root.flyteidl.core.Operand.encode(message.rightValue, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a ComparisonExpression message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.core.ComparisonExpression
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.core.ComparisonExpression} ComparisonExpression
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ComparisonExpression.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.core.ComparisonExpression();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operator = reader.int32();
                        break;
                    case 2:
                        message.leftValue = $root.flyteidl.core.Operand.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.rightValue = $root.flyteidl.core.Operand.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a ComparisonExpression message.
             * @function verify
             * @memberof flyteidl.core.ComparisonExpression
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ComparisonExpression.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operator != null && message.hasOwnProperty("operator"))
                    switch (message.operator) {
                    default:
                        return "operator: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                        break;
                    }
                if (message.leftValue != null && message.hasOwnProperty("leftValue")) {
                    let error = $root.flyteidl.core.Operand.verify(message.leftValue);
                    if (error)
                        return "leftValue." + error;
                }
                if (message.rightValue != null && message.hasOwnProperty("rightValue")) {
                    let error = $root.flyteidl.core.Operand.verify(message.rightValue);
                    if (error)
                        return "rightValue." + error;
                }
                return null;
            };

            /**
             * Operator enum.
             * @name flyteidl.core.ComparisonExpression.Operator
             * @enum {string}
             * @property {number} EQ=0 EQ value
             * @property {number} NEQ=1 NEQ value
             * @property {number} GT=2 GT value
             * @property {number} GTE=3 GTE value
             * @property {number} LT=4 LT value
             * @property {number} LTE=5 LTE value
             */
            ComparisonExpression.Operator = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "EQ"] = 0;
                values[valuesById[1] = "NEQ"] = 1;
                values[valuesById[2] = "GT"] = 2;
                values[valuesById[3] = "GTE"] = 3;
                values[valuesById[4] = "LT"] = 4;
                values[valuesById[5] = "LTE"] = 5;
                return values;
            })();

            return ComparisonExpression;
        })();

        core.Operand = (function() {

            /**
             * Properties of an Operand.
             * @memberof flyteidl.core
             * @interface IOperand
             * @property {flyteidl.core.IPrimitive|null} [primitive] Operand primitive
             * @property {string|null} ["var"] Operand var
             */

            /**
             * Constructs a new Operand.
             * @memberof flyteidl.core
             * @classdesc Represents an Operand.
             * @implements IOperand
             * @constructor
             * @param {flyteidl.core.IOperand=} [properties] Properties to set
             */
            function Operand(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Operand primitive.
             * @member {flyteidl.core.IPrimitive|null|undefined} primitive
             * @memberof flyteidl.core.Operand
             * @instance
             */
            Operand.prototype.primitive = null;

            /**
             * Operand var.
             * @member {string} var
             * @memberof flyteidl.core.Operand
             * @instance
             */
            Operand.prototype["var"] = "";

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * Operand val.
             * @member {"primitive"|"var"|undefined} val
             * @memberof flyteidl.core.Operand
             * @instance
             */
            Object.defineProperty(Operand.prototype, "val", {
                get: $util.oneOfGetter($oneOfFields = ["primitive", "var"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new Operand instance using the specified properties.
             * @function create
             * @memberof flyteidl.core.Operand
             * @static
             * @param {flyteidl.core.IOperand=} [properties] Properties to set
             * @returns {flyteidl.core.Operand} Operand instance
             */
            Operand.create = function create(properties) {
                return new Operand(properties);
            };

            /**
             * Encodes the specified Operand message. Does not implicitly {@link flyteidl.core.Operand.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.core.Operand
             * @static
             * @param {flyteidl.core.IOperand} message Operand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Operand.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.primitive != null && message.hasOwnProperty("primitive"))
                    $root.flyteidl.core.Primitive.encode(message.primitive, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message["var"] != null && message.hasOwnProperty("var"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message["var"]);
                return writer;
            };

            /**
             * Decodes an Operand message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.core.Operand
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.core.Operand} Operand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Operand.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.core.Operand();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.primitive = $root.flyteidl.core.Primitive.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message["var"] = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies an Operand message.
             * @function verify
             * @memberof flyteidl.core.Operand
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Operand.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.primitive != null && message.hasOwnProperty("primitive")) {
                    properties.val = 1;
                    {
                        let error = $root.flyteidl.core.Primitive.verify(message.primitive);
                        if (error)
                            return "primitive." + error;
                    }
                }
                if (message["var"] != null && message.hasOwnProperty("var")) {
                    if (properties.val === 1)
                        return "val: multiple values";
                    properties.val = 1;
                    if (!$util.isString(message["var"]))
                        return "var: string expected";
                }
                return null;
            };

            return Operand;
        })();

        core.BooleanExpression = (function() {

            /**
             * Properties of a BooleanExpression.
             * @memberof flyteidl.core
             * @interface IBooleanExpression
             * @property {flyteidl.core.IConjunctionExpression|null} [conjunction] BooleanExpression conjunction
             * @property {flyteidl.core.IComparisonExpression|null} [comparison] BooleanExpression comparison
             */

            /**
             * Constructs a new BooleanExpression.
             * @memberof flyteidl.core
             * @classdesc Represents a BooleanExpression.
             * @implements IBooleanExpression
             * @constructor
             * @param {flyteidl.core.IBooleanExpression=} [properties] Properties to set
             */
            function BooleanExpression(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BooleanExpression conjunction.
             * @member {flyteidl.core.IConjunctionExpression|null|undefined} conjunction
             * @memberof flyteidl.core.BooleanExpression
             * @instance
             */
            BooleanExpression.prototype.conjunction = null;

            /**
             * BooleanExpression comparison.
             * @member {flyteidl.core.IComparisonExpression|null|undefined} comparison
             * @memberof flyteidl.core.BooleanExpression
             * @instance
             */
            BooleanExpression.prototype.comparison = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * BooleanExpression expr.
             * @member {"conjunction"|"comparison"|undefined} expr
             * @memberof flyteidl.core.BooleanExpression
             * @instance
             */
            Object.defineProperty(BooleanExpression.prototype, "expr", {
                get: $util.oneOfGetter($oneOfFields = ["conjunction", "comparison"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new BooleanExpression instance using the specified properties.
             * @function create
             * @memberof flyteidl.core.BooleanExpression
             * @static
             * @param {flyteidl.core.IBooleanExpression=} [properties] Properties to set
             * @returns {flyteidl.core.BooleanExpression} BooleanExpression instance
             */
            BooleanExpression.create = function create(properties) {
                return new BooleanExpression(properties);
            };

            /**
             * Encodes the specified BooleanExpression message. Does not implicitly {@link flyteidl.core.BooleanExpression.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.core.BooleanExpression
             * @static
             * @param {flyteidl.core.IBooleanExpression} message BooleanExpression message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BooleanExpression.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.conjunction != null && message.hasOwnProperty("conjunction"))
                    $root.flyteidl.core.ConjunctionExpression.encode(message.conjunction, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.comparison != null && message.hasOwnProperty("comparison"))
                    $root.flyteidl.core.ComparisonExpression.encode(message.comparison, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a BooleanExpression message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.core.BooleanExpression
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.core.BooleanExpression} BooleanExpression
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BooleanExpression.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.core.BooleanExpression();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.conjunction = $root.flyteidl.core.ConjunctionExpression.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.comparison = $root.flyteidl.core.ComparisonExpression.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a BooleanExpression message.
             * @function verify
             * @memberof flyteidl.core.BooleanExpression
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BooleanExpression.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.conjunction != null && message.hasOwnProperty("conjunction")) {
                    properties.expr = 1;
                    {
                        let error = $root.flyteidl.core.ConjunctionExpression.verify(message.conjunction);
                        if (error)
                            return "conjunction." + error;
                    }
                }
                if (message.comparison != null && message.hasOwnProperty("comparison")) {
                    if (properties.expr === 1)
                        return "expr: multiple values";
                    properties.expr = 1;
                    {
                        let error = $root.flyteidl.core.ComparisonExpression.verify(message.comparison);
                        if (error)
                            return "comparison." + error;
                    }
                }
                return null;
            };

            return BooleanExpression;
        })();

        core.ConjunctionExpression = (function() {

            /**
             * Properties of a ConjunctionExpression.
             * @memberof flyteidl.core
             * @interface IConjunctionExpression
             * @property {flyteidl.core.ConjunctionExpression.LogicalOperator|null} [operator] ConjunctionExpression operator
             * @property {flyteidl.core.IBooleanExpression|null} [leftExpression] ConjunctionExpression leftExpression
             * @property {flyteidl.core.IBooleanExpression|null} [rightExpression] ConjunctionExpression rightExpression
             */

            /**
             * Constructs a new ConjunctionExpression.
             * @memberof flyteidl.core
             * @classdesc Represents a ConjunctionExpression.
             * @implements IConjunctionExpression
             * @constructor
             * @param {flyteidl.core.IConjunctionExpression=} [properties] Properties to set
             */
            function ConjunctionExpression(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ConjunctionExpression operator.
             * @member {flyteidl.core.ConjunctionExpression.LogicalOperator} operator
             * @memberof flyteidl.core.ConjunctionExpression
             * @instance
             */
            ConjunctionExpression.prototype.operator = 0;

            /**
             * ConjunctionExpression leftExpression.
             * @member {flyteidl.core.IBooleanExpression|null|undefined} leftExpression
             * @memberof flyteidl.core.ConjunctionExpression
             * @instance
             */
            ConjunctionExpression.prototype.leftExpression = null;

            /**
             * ConjunctionExpression rightExpression.
             * @member {flyteidl.core.IBooleanExpression|null|undefined} rightExpression
             * @memberof flyteidl.core.ConjunctionExpression
             * @instance
             */
            ConjunctionExpression.prototype.rightExpression = null;

            /**
             * Creates a new ConjunctionExpression instance using the specified properties.
             * @function create
             * @memberof flyteidl.core.ConjunctionExpression
             * @static
             * @param {flyteidl.core.IConjunctionExpression=} [properties] Properties to set
             * @returns {flyteidl.core.ConjunctionExpression} ConjunctionExpression instance
             */
            ConjunctionExpression.create = function create(properties) {
                return new ConjunctionExpression(properties);
            };

            /**
             * Encodes the specified ConjunctionExpression message. Does not implicitly {@link flyteidl.core.ConjunctionExpression.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.core.ConjunctionExpression
             * @static
             * @param {flyteidl.core.IConjunctionExpression} message ConjunctionExpression message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConjunctionExpression.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operator != null && message.hasOwnProperty("operator"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.operator);
                if (message.leftExpression != null && message.hasOwnProperty("leftExpression"))
                    $root.flyteidl.core.BooleanExpression.encode(message.leftExpression, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.rightExpression != null && message.hasOwnProperty("rightExpression"))
                    $root.flyteidl.core.BooleanExpression.encode(message.rightExpression, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a ConjunctionExpression message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.core.ConjunctionExpression
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.core.ConjunctionExpression} ConjunctionExpression
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConjunctionExpression.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.core.ConjunctionExpression();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operator = reader.int32();
                        break;
                    case 2:
                        message.leftExpression = $root.flyteidl.core.BooleanExpression.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.rightExpression = $root.flyteidl.core.BooleanExpression.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a ConjunctionExpression message.
             * @function verify
             * @memberof flyteidl.core.ConjunctionExpression
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ConjunctionExpression.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operator != null && message.hasOwnProperty("operator"))
                    switch (message.operator) {
                    default:
                        return "operator: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                if (message.leftExpression != null && message.hasOwnProperty("leftExpression")) {
                    let error = $root.flyteidl.core.BooleanExpression.verify(message.leftExpression);
                    if (error)
                        return "leftExpression." + error;
                }
                if (message.rightExpression != null && message.hasOwnProperty("rightExpression")) {
                    let error = $root.flyteidl.core.BooleanExpression.verify(message.rightExpression);
                    if (error)
                        return "rightExpression." + error;
                }
                return null;
            };

            /**
             * LogicalOperator enum.
             * @name flyteidl.core.ConjunctionExpression.LogicalOperator
             * @enum {string}
             * @property {number} AND=0 AND value
             * @property {number} OR=1 OR value
             */
            ConjunctionExpression.LogicalOperator = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "AND"] = 0;
                values[valuesById[1] = "OR"] = 1;
                return values;
            })();

            return ConjunctionExpression;
        })();

        core.Primitive = (function() {

            /**
             * Properties of a Primitive.
             * @memberof flyteidl.core
             * @interface IPrimitive
             * @property {Long|null} [integer] Primitive integer
             * @property {number|null} [floatValue] Primitive floatValue
             * @property {string|null} [stringValue] Primitive stringValue
             * @property {boolean|null} [boolean] Primitive boolean
             * @property {google.protobuf.ITimestamp|null} [datetime] Primitive datetime
             * @property {google.protobuf.IDuration|null} [duration] Primitive duration
             */

            /**
             * Constructs a new Primitive.
             * @memberof flyteidl.core
             * @classdesc Represents a Primitive.
             * @implements IPrimitive
             * @constructor
             * @param {flyteidl.core.IPrimitive=} [properties] Properties to set
             */
            function Primitive(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Primitive integer.
             * @member {Long} integer
             * @memberof flyteidl.core.Primitive
             * @instance
             */
            Primitive.prototype.integer = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Primitive floatValue.
             * @member {number} floatValue
             * @memberof flyteidl.core.Primitive
             * @instance
             */
            Primitive.prototype.floatValue = 0;

            /**
             * Primitive stringValue.
             * @member {string} stringValue
             * @memberof flyteidl.core.Primitive
             * @instance
             */
            Primitive.prototype.stringValue = "";

            /**
             * Primitive boolean.
             * @member {boolean} boolean
             * @memberof flyteidl.core.Primitive
             * @instance
             */
            Primitive.prototype.boolean = false;

            /**
             * Primitive datetime.
             * @member {google.protobuf.ITimestamp|null|undefined} datetime
             * @memberof flyteidl.core.Primitive
             * @instance
             */
            Primitive.prototype.datetime = null;

            /**
             * Primitive duration.
             * @member {google.protobuf.IDuration|null|undefined} duration
             * @memberof flyteidl.core.Primitive
             * @instance
             */
            Primitive.prototype.duration = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * Primitive value.
             * @member {"integer"|"floatValue"|"stringValue"|"boolean"|"datetime"|"duration"|undefined} value
             * @memberof flyteidl.core.Primitive
             * @instance
             */
            Object.defineProperty(Primitive.prototype, "value", {
                get: $util.oneOfGetter($oneOfFields = ["integer", "floatValue", "stringValue", "boolean", "datetime", "duration"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new Primitive instance using the specified properties.
             * @function create
             * @memberof flyteidl.core.Primitive
             * @static
             * @param {flyteidl.core.IPrimitive=} [properties] Properties to set
             * @returns {flyteidl.core.Primitive} Primitive instance
             */
            Primitive.create = function create(properties) {
                return new Primitive(properties);
            };

            /**
             * Encodes the specified Primitive message. Does not implicitly {@link flyteidl.core.Primitive.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.core.Primitive
             * @static
             * @param {flyteidl.core.IPrimitive} message Primitive message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Primitive.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.integer != null && message.hasOwnProperty("integer"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.integer);
                if (message.floatValue != null && message.hasOwnProperty("floatValue"))
                    writer.uint32(/* id 2, wireType 1 =*/17).double(message.floatValue);
                if (message.stringValue != null && message.hasOwnProperty("stringValue"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.stringValue);
                if (message.boolean != null && message.hasOwnProperty("boolean"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.boolean);
                if (message.datetime != null && message.hasOwnProperty("datetime"))
                    $root.google.protobuf.Timestamp.encode(message.datetime, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.duration != null && message.hasOwnProperty("duration"))
                    $root.google.protobuf.Duration.encode(message.duration, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a Primitive message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.core.Primitive
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.core.Primitive} Primitive
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Primitive.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.core.Primitive();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.integer = reader.int64();
                        break;
                    case 2:
                        message.floatValue = reader.double();
                        break;
                    case 3:
                        message.stringValue = reader.string();
                        break;
                    case 4:
                        message.boolean = reader.bool();
                        break;
                    case 5:
                        message.datetime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.duration = $root.google.protobuf.Duration.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a Primitive message.
             * @function verify
             * @memberof flyteidl.core.Primitive
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Primitive.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.integer != null && message.hasOwnProperty("integer")) {
                    properties.value = 1;
                    if (!$util.isInteger(message.integer) && !(message.integer && $util.isInteger(message.integer.low) && $util.isInteger(message.integer.high)))
                        return "integer: integer|Long expected";
                }
                if (message.floatValue != null && message.hasOwnProperty("floatValue")) {
                    if (properties.value === 1)
                        return "value: multiple values";
                    properties.value = 1;
                    if (typeof message.floatValue !== "number")
                        return "floatValue: number expected";
                }
                if (message.stringValue != null && message.hasOwnProperty("stringValue")) {
                    if (properties.value === 1)
                        return "value: multiple values";
                    properties.value = 1;
                    if (!$util.isString(message.stringValue))
                        return "stringValue: string expected";
                }
                if (message.boolean != null && message.hasOwnProperty("boolean")) {
                    if (properties.value === 1)
                        return "value: multiple values";
                    properties.value = 1;
                    if (typeof message.boolean !== "boolean")
                        return "boolean: boolean expected";
                }
                if (message.datetime != null && message.hasOwnProperty("datetime")) {
                    if (properties.value === 1)
                        return "value: multiple values";
                    properties.value = 1;
                    {
                        let error = $root.google.protobuf.Timestamp.verify(message.datetime);
                        if (error)
                            return "datetime." + error;
                    }
                }
                if (message.duration != null && message.hasOwnProperty("duration")) {
                    if (properties.value === 1)
                        return "value: multiple values";
                    properties.value = 1;
                    {
                        let error = $root.google.protobuf.Duration.verify(message.duration);
                        if (error)
                            return "duration." + error;
                    }
                }
                return null;
            };

            return Primitive;
        })();

        core.Void = (function() {

            /**
             * Properties of a Void.
             * @memberof flyteidl.core
             * @interface IVoid
             */

            /**
             * Constructs a new Void.
             * @memberof flyteidl.core
             * @classdesc Represents a Void.
             * @implements IVoid
             * @constructor
             * @param {flyteidl.core.IVoid=} [properties] Properties to set
             */
            function Void(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new Void instance using the specified properties.
             * @function create
             * @memberof flyteidl.core.Void
             * @static
             * @param {flyteidl.core.IVoid=} [properties] Properties to set
             * @returns {flyteidl.core.Void} Void instance
             */
            Void.create = function create(properties) {
                return new Void(properties);
            };

            /**
             * Encodes the specified Void message. Does not implicitly {@link flyteidl.core.Void.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.core.Void
             * @static
             * @param {flyteidl.core.IVoid} message Void message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Void.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Decodes a Void message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.core.Void
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.core.Void} Void
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Void.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.core.Void();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a Void message.
             * @function verify
             * @memberof flyteidl.core.Void
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Void.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            return Void;
        })();

        core.Blob = (function() {

            /**
             * Properties of a Blob.
             * @memberof flyteidl.core
             * @interface IBlob
             * @property {flyteidl.core.IBlobMetadata|null} [metadata] Blob metadata
             * @property {string|null} [uri] Blob uri
             */

            /**
             * Constructs a new Blob.
             * @memberof flyteidl.core
             * @classdesc Represents a Blob.
             * @implements IBlob
             * @constructor
             * @param {flyteidl.core.IBlob=} [properties] Properties to set
             */
            function Blob(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Blob metadata.
             * @member {flyteidl.core.IBlobMetadata|null|undefined} metadata
             * @memberof flyteidl.core.Blob
             * @instance
             */
            Blob.prototype.metadata = null;

            /**
             * Blob uri.
             * @member {string} uri
             * @memberof flyteidl.core.Blob
             * @instance
             */
            Blob.prototype.uri = "";

            /**
             * Creates a new Blob instance using the specified properties.
             * @function create
             * @memberof flyteidl.core.Blob
             * @static
             * @param {flyteidl.core.IBlob=} [properties] Properties to set
             * @returns {flyteidl.core.Blob} Blob instance
             */
            Blob.create = function create(properties) {
                return new Blob(properties);
            };

            /**
             * Encodes the specified Blob message. Does not implicitly {@link flyteidl.core.Blob.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.core.Blob
             * @static
             * @param {flyteidl.core.IBlob} message Blob message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Blob.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    $root.flyteidl.core.BlobMetadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.uri != null && message.hasOwnProperty("uri"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.uri);
                return writer;
            };

            /**
             * Decodes a Blob message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.core.Blob
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.core.Blob} Blob
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Blob.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.core.Blob();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.metadata = $root.flyteidl.core.BlobMetadata.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.uri = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a Blob message.
             * @function verify
             * @memberof flyteidl.core.Blob
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Blob.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.metadata != null && message.hasOwnProperty("metadata")) {
                    let error = $root.flyteidl.core.BlobMetadata.verify(message.metadata);
                    if (error)
                        return "metadata." + error;
                }
                if (message.uri != null && message.hasOwnProperty("uri"))
                    if (!$util.isString(message.uri))
                        return "uri: string expected";
                return null;
            };

            return Blob;
        })();

        core.BlobMetadata = (function() {

            /**
             * Properties of a BlobMetadata.
             * @memberof flyteidl.core
             * @interface IBlobMetadata
             * @property {flyteidl.core.IBlobType|null} [type] BlobMetadata type
             */

            /**
             * Constructs a new BlobMetadata.
             * @memberof flyteidl.core
             * @classdesc Represents a BlobMetadata.
             * @implements IBlobMetadata
             * @constructor
             * @param {flyteidl.core.IBlobMetadata=} [properties] Properties to set
             */
            function BlobMetadata(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BlobMetadata type.
             * @member {flyteidl.core.IBlobType|null|undefined} type
             * @memberof flyteidl.core.BlobMetadata
             * @instance
             */
            BlobMetadata.prototype.type = null;

            /**
             * Creates a new BlobMetadata instance using the specified properties.
             * @function create
             * @memberof flyteidl.core.BlobMetadata
             * @static
             * @param {flyteidl.core.IBlobMetadata=} [properties] Properties to set
             * @returns {flyteidl.core.BlobMetadata} BlobMetadata instance
             */
            BlobMetadata.create = function create(properties) {
                return new BlobMetadata(properties);
            };

            /**
             * Encodes the specified BlobMetadata message. Does not implicitly {@link flyteidl.core.BlobMetadata.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.core.BlobMetadata
             * @static
             * @param {flyteidl.core.IBlobMetadata} message BlobMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BlobMetadata.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && message.hasOwnProperty("type"))
                    $root.flyteidl.core.BlobType.encode(message.type, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a BlobMetadata message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.core.BlobMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.core.BlobMetadata} BlobMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BlobMetadata.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.core.BlobMetadata();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = $root.flyteidl.core.BlobType.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a BlobMetadata message.
             * @function verify
             * @memberof flyteidl.core.BlobMetadata
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BlobMetadata.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type")) {
                    let error = $root.flyteidl.core.BlobType.verify(message.type);
                    if (error)
                        return "type." + error;
                }
                return null;
            };

            return BlobMetadata;
        })();

        core.Binary = (function() {

            /**
             * Properties of a Binary.
             * @memberof flyteidl.core
             * @interface IBinary
             * @property {Uint8Array|null} [value] Binary value
             * @property {string|null} [tag] Binary tag
             */

            /**
             * Constructs a new Binary.
             * @memberof flyteidl.core
             * @classdesc Represents a Binary.
             * @implements IBinary
             * @constructor
             * @param {flyteidl.core.IBinary=} [properties] Properties to set
             */
            function Binary(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Binary value.
             * @member {Uint8Array} value
             * @memberof flyteidl.core.Binary
             * @instance
             */
            Binary.prototype.value = $util.newBuffer([]);

            /**
             * Binary tag.
             * @member {string} tag
             * @memberof flyteidl.core.Binary
             * @instance
             */
            Binary.prototype.tag = "";

            /**
             * Creates a new Binary instance using the specified properties.
             * @function create
             * @memberof flyteidl.core.Binary
             * @static
             * @param {flyteidl.core.IBinary=} [properties] Properties to set
             * @returns {flyteidl.core.Binary} Binary instance
             */
            Binary.create = function create(properties) {
                return new Binary(properties);
            };

            /**
             * Encodes the specified Binary message. Does not implicitly {@link flyteidl.core.Binary.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.core.Binary
             * @static
             * @param {flyteidl.core.IBinary} message Binary message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Binary.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && message.hasOwnProperty("value"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.value);
                if (message.tag != null && message.hasOwnProperty("tag"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.tag);
                return writer;
            };

            /**
             * Decodes a Binary message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.core.Binary
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.core.Binary} Binary
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Binary.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.core.Binary();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.value = reader.bytes();
                        break;
                    case 2:
                        message.tag = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a Binary message.
             * @function verify
             * @memberof flyteidl.core.Binary
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Binary.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                if (message.tag != null && message.hasOwnProperty("tag"))
                    if (!$util.isString(message.tag))
                        return "tag: string expected";
                return null;
            };

            return Binary;
        })();

        core.Schema = (function() {

            /**
             * Properties of a Schema.
             * @memberof flyteidl.core
             * @interface ISchema
             * @property {string|null} [uri] Schema uri
             * @property {flyteidl.core.ISchemaType|null} [type] Schema type
             */

            /**
             * Constructs a new Schema.
             * @memberof flyteidl.core
             * @classdesc Represents a Schema.
             * @implements ISchema
             * @constructor
             * @param {flyteidl.core.ISchema=} [properties] Properties to set
             */
            function Schema(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Schema uri.
             * @member {string} uri
             * @memberof flyteidl.core.Schema
             * @instance
             */
            Schema.prototype.uri = "";

            /**
             * Schema type.
             * @member {flyteidl.core.ISchemaType|null|undefined} type
             * @memberof flyteidl.core.Schema
             * @instance
             */
            Schema.prototype.type = null;

            /**
             * Creates a new Schema instance using the specified properties.
             * @function create
             * @memberof flyteidl.core.Schema
             * @static
             * @param {flyteidl.core.ISchema=} [properties] Properties to set
             * @returns {flyteidl.core.Schema} Schema instance
             */
            Schema.create = function create(properties) {
                return new Schema(properties);
            };

            /**
             * Encodes the specified Schema message. Does not implicitly {@link flyteidl.core.Schema.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.core.Schema
             * @static
             * @param {flyteidl.core.ISchema} message Schema message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Schema.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uri != null && message.hasOwnProperty("uri"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.uri);
                if (message.type != null && message.hasOwnProperty("type"))
                    $root.flyteidl.core.SchemaType.encode(message.type, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a Schema message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.core.Schema
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.core.Schema} Schema
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Schema.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.core.Schema();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.uri = reader.string();
                        break;
                    case 3:
                        message.type = $root.flyteidl.core.SchemaType.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a Schema message.
             * @function verify
             * @memberof flyteidl.core.Schema
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Schema.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.uri != null && message.hasOwnProperty("uri"))
                    if (!$util.isString(message.uri))
                        return "uri: string expected";
                if (message.type != null && message.hasOwnProperty("type")) {
                    let error = $root.flyteidl.core.SchemaType.verify(message.type);
                    if (error)
                        return "type." + error;
                }
                return null;
            };

            return Schema;
        })();

        core.Scalar = (function() {

            /**
             * Properties of a Scalar.
             * @memberof flyteidl.core
             * @interface IScalar
             * @property {flyteidl.core.IPrimitive|null} [primitive] Scalar primitive
             * @property {flyteidl.core.IBlob|null} [blob] Scalar blob
             * @property {flyteidl.core.IBinary|null} [binary] Scalar binary
             * @property {flyteidl.core.ISchema|null} [schema] Scalar schema
             * @property {flyteidl.core.IVoid|null} [noneType] Scalar noneType
             * @property {flyteidl.core.IError|null} [error] Scalar error
             * @property {google.protobuf.IStruct|null} [generic] Scalar generic
             */

            /**
             * Constructs a new Scalar.
             * @memberof flyteidl.core
             * @classdesc Represents a Scalar.
             * @implements IScalar
             * @constructor
             * @param {flyteidl.core.IScalar=} [properties] Properties to set
             */
            function Scalar(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Scalar primitive.
             * @member {flyteidl.core.IPrimitive|null|undefined} primitive
             * @memberof flyteidl.core.Scalar
             * @instance
             */
            Scalar.prototype.primitive = null;

            /**
             * Scalar blob.
             * @member {flyteidl.core.IBlob|null|undefined} blob
             * @memberof flyteidl.core.Scalar
             * @instance
             */
            Scalar.prototype.blob = null;

            /**
             * Scalar binary.
             * @member {flyteidl.core.IBinary|null|undefined} binary
             * @memberof flyteidl.core.Scalar
             * @instance
             */
            Scalar.prototype.binary = null;

            /**
             * Scalar schema.
             * @member {flyteidl.core.ISchema|null|undefined} schema
             * @memberof flyteidl.core.Scalar
             * @instance
             */
            Scalar.prototype.schema = null;

            /**
             * Scalar noneType.
             * @member {flyteidl.core.IVoid|null|undefined} noneType
             * @memberof flyteidl.core.Scalar
             * @instance
             */
            Scalar.prototype.noneType = null;

            /**
             * Scalar error.
             * @member {flyteidl.core.IError|null|undefined} error
             * @memberof flyteidl.core.Scalar
             * @instance
             */
            Scalar.prototype.error = null;

            /**
             * Scalar generic.
             * @member {google.protobuf.IStruct|null|undefined} generic
             * @memberof flyteidl.core.Scalar
             * @instance
             */
            Scalar.prototype.generic = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * Scalar value.
             * @member {"primitive"|"blob"|"binary"|"schema"|"noneType"|"error"|"generic"|undefined} value
             * @memberof flyteidl.core.Scalar
             * @instance
             */
            Object.defineProperty(Scalar.prototype, "value", {
                get: $util.oneOfGetter($oneOfFields = ["primitive", "blob", "binary", "schema", "noneType", "error", "generic"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new Scalar instance using the specified properties.
             * @function create
             * @memberof flyteidl.core.Scalar
             * @static
             * @param {flyteidl.core.IScalar=} [properties] Properties to set
             * @returns {flyteidl.core.Scalar} Scalar instance
             */
            Scalar.create = function create(properties) {
                return new Scalar(properties);
            };

            /**
             * Encodes the specified Scalar message. Does not implicitly {@link flyteidl.core.Scalar.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.core.Scalar
             * @static
             * @param {flyteidl.core.IScalar} message Scalar message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Scalar.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.primitive != null && message.hasOwnProperty("primitive"))
                    $root.flyteidl.core.Primitive.encode(message.primitive, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.blob != null && message.hasOwnProperty("blob"))
                    $root.flyteidl.core.Blob.encode(message.blob, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.binary != null && message.hasOwnProperty("binary"))
                    $root.flyteidl.core.Binary.encode(message.binary, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.schema != null && message.hasOwnProperty("schema"))
                    $root.flyteidl.core.Schema.encode(message.schema, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.noneType != null && message.hasOwnProperty("noneType"))
                    $root.flyteidl.core.Void.encode(message.noneType, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.error != null && message.hasOwnProperty("error"))
                    $root.flyteidl.core.Error.encode(message.error, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.generic != null && message.hasOwnProperty("generic"))
                    $root.google.protobuf.Struct.encode(message.generic, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a Scalar message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.core.Scalar
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.core.Scalar} Scalar
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Scalar.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.core.Scalar();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.primitive = $root.flyteidl.core.Primitive.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.blob = $root.flyteidl.core.Blob.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.binary = $root.flyteidl.core.Binary.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.schema = $root.flyteidl.core.Schema.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.noneType = $root.flyteidl.core.Void.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.error = $root.flyteidl.core.Error.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.generic = $root.google.protobuf.Struct.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a Scalar message.
             * @function verify
             * @memberof flyteidl.core.Scalar
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Scalar.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.primitive != null && message.hasOwnProperty("primitive")) {
                    properties.value = 1;
                    {
                        let error = $root.flyteidl.core.Primitive.verify(message.primitive);
                        if (error)
                            return "primitive." + error;
                    }
                }
                if (message.blob != null && message.hasOwnProperty("blob")) {
                    if (properties.value === 1)
                        return "value: multiple values";
                    properties.value = 1;
                    {
                        let error = $root.flyteidl.core.Blob.verify(message.blob);
                        if (error)
                            return "blob." + error;
                    }
                }
                if (message.binary != null && message.hasOwnProperty("binary")) {
                    if (properties.value === 1)
                        return "value: multiple values";
                    properties.value = 1;
                    {
                        let error = $root.flyteidl.core.Binary.verify(message.binary);
                        if (error)
                            return "binary." + error;
                    }
                }
                if (message.schema != null && message.hasOwnProperty("schema")) {
                    if (properties.value === 1)
                        return "value: multiple values";
                    properties.value = 1;
                    {
                        let error = $root.flyteidl.core.Schema.verify(message.schema);
                        if (error)
                            return "schema." + error;
                    }
                }
                if (message.noneType != null && message.hasOwnProperty("noneType")) {
                    if (properties.value === 1)
                        return "value: multiple values";
                    properties.value = 1;
                    {
                        let error = $root.flyteidl.core.Void.verify(message.noneType);
                        if (error)
                            return "noneType." + error;
                    }
                }
                if (message.error != null && message.hasOwnProperty("error")) {
                    if (properties.value === 1)
                        return "value: multiple values";
                    properties.value = 1;
                    {
                        let error = $root.flyteidl.core.Error.verify(message.error);
                        if (error)
                            return "error." + error;
                    }
                }
                if (message.generic != null && message.hasOwnProperty("generic")) {
                    if (properties.value === 1)
                        return "value: multiple values";
                    properties.value = 1;
                    {
                        let error = $root.google.protobuf.Struct.verify(message.generic);
                        if (error)
                            return "generic." + error;
                    }
                }
                return null;
            };

            return Scalar;
        })();

        core.Literal = (function() {

            /**
             * Properties of a Literal.
             * @memberof flyteidl.core
             * @interface ILiteral
             * @property {flyteidl.core.IScalar|null} [scalar] Literal scalar
             * @property {flyteidl.core.ILiteralCollection|null} [collection] Literal collection
             * @property {flyteidl.core.ILiteralMap|null} [map] Literal map
             */

            /**
             * Constructs a new Literal.
             * @memberof flyteidl.core
             * @classdesc Represents a Literal.
             * @implements ILiteral
             * @constructor
             * @param {flyteidl.core.ILiteral=} [properties] Properties to set
             */
            function Literal(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Literal scalar.
             * @member {flyteidl.core.IScalar|null|undefined} scalar
             * @memberof flyteidl.core.Literal
             * @instance
             */
            Literal.prototype.scalar = null;

            /**
             * Literal collection.
             * @member {flyteidl.core.ILiteralCollection|null|undefined} collection
             * @memberof flyteidl.core.Literal
             * @instance
             */
            Literal.prototype.collection = null;

            /**
             * Literal map.
             * @member {flyteidl.core.ILiteralMap|null|undefined} map
             * @memberof flyteidl.core.Literal
             * @instance
             */
            Literal.prototype.map = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * Literal value.
             * @member {"scalar"|"collection"|"map"|undefined} value
             * @memberof flyteidl.core.Literal
             * @instance
             */
            Object.defineProperty(Literal.prototype, "value", {
                get: $util.oneOfGetter($oneOfFields = ["scalar", "collection", "map"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new Literal instance using the specified properties.
             * @function create
             * @memberof flyteidl.core.Literal
             * @static
             * @param {flyteidl.core.ILiteral=} [properties] Properties to set
             * @returns {flyteidl.core.Literal} Literal instance
             */
            Literal.create = function create(properties) {
                return new Literal(properties);
            };

            /**
             * Encodes the specified Literal message. Does not implicitly {@link flyteidl.core.Literal.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.core.Literal
             * @static
             * @param {flyteidl.core.ILiteral} message Literal message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Literal.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.scalar != null && message.hasOwnProperty("scalar"))
                    $root.flyteidl.core.Scalar.encode(message.scalar, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.collection != null && message.hasOwnProperty("collection"))
                    $root.flyteidl.core.LiteralCollection.encode(message.collection, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.map != null && message.hasOwnProperty("map"))
                    $root.flyteidl.core.LiteralMap.encode(message.map, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a Literal message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.core.Literal
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.core.Literal} Literal
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Literal.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.core.Literal();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.scalar = $root.flyteidl.core.Scalar.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.collection = $root.flyteidl.core.LiteralCollection.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.map = $root.flyteidl.core.LiteralMap.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a Literal message.
             * @function verify
             * @memberof flyteidl.core.Literal
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Literal.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.scalar != null && message.hasOwnProperty("scalar")) {
                    properties.value = 1;
                    {
                        let error = $root.flyteidl.core.Scalar.verify(message.scalar);
                        if (error)
                            return "scalar." + error;
                    }
                }
                if (message.collection != null && message.hasOwnProperty("collection")) {
                    if (properties.value === 1)
                        return "value: multiple values";
                    properties.value = 1;
                    {
                        let error = $root.flyteidl.core.LiteralCollection.verify(message.collection);
                        if (error)
                            return "collection." + error;
                    }
                }
                if (message.map != null && message.hasOwnProperty("map")) {
                    if (properties.value === 1)
                        return "value: multiple values";
                    properties.value = 1;
                    {
                        let error = $root.flyteidl.core.LiteralMap.verify(message.map);
                        if (error)
                            return "map." + error;
                    }
                }
                return null;
            };

            return Literal;
        })();

        core.LiteralCollection = (function() {

            /**
             * Properties of a LiteralCollection.
             * @memberof flyteidl.core
             * @interface ILiteralCollection
             * @property {Array.<flyteidl.core.ILiteral>|null} [literals] LiteralCollection literals
             */

            /**
             * Constructs a new LiteralCollection.
             * @memberof flyteidl.core
             * @classdesc Represents a LiteralCollection.
             * @implements ILiteralCollection
             * @constructor
             * @param {flyteidl.core.ILiteralCollection=} [properties] Properties to set
             */
            function LiteralCollection(properties) {
                this.literals = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LiteralCollection literals.
             * @member {Array.<flyteidl.core.ILiteral>} literals
             * @memberof flyteidl.core.LiteralCollection
             * @instance
             */
            LiteralCollection.prototype.literals = $util.emptyArray;

            /**
             * Creates a new LiteralCollection instance using the specified properties.
             * @function create
             * @memberof flyteidl.core.LiteralCollection
             * @static
             * @param {flyteidl.core.ILiteralCollection=} [properties] Properties to set
             * @returns {flyteidl.core.LiteralCollection} LiteralCollection instance
             */
            LiteralCollection.create = function create(properties) {
                return new LiteralCollection(properties);
            };

            /**
             * Encodes the specified LiteralCollection message. Does not implicitly {@link flyteidl.core.LiteralCollection.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.core.LiteralCollection
             * @static
             * @param {flyteidl.core.ILiteralCollection} message LiteralCollection message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LiteralCollection.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.literals != null && message.literals.length)
                    for (let i = 0; i < message.literals.length; ++i)
                        $root.flyteidl.core.Literal.encode(message.literals[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a LiteralCollection message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.core.LiteralCollection
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.core.LiteralCollection} LiteralCollection
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LiteralCollection.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.core.LiteralCollection();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.literals && message.literals.length))
                            message.literals = [];
                        message.literals.push($root.flyteidl.core.Literal.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a LiteralCollection message.
             * @function verify
             * @memberof flyteidl.core.LiteralCollection
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LiteralCollection.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.literals != null && message.hasOwnProperty("literals")) {
                    if (!Array.isArray(message.literals))
                        return "literals: array expected";
                    for (let i = 0; i < message.literals.length; ++i) {
                        let error = $root.flyteidl.core.Literal.verify(message.literals[i]);
                        if (error)
                            return "literals." + error;
                    }
                }
                return null;
            };

            return LiteralCollection;
        })();

        core.LiteralMap = (function() {

            /**
             * Properties of a LiteralMap.
             * @memberof flyteidl.core
             * @interface ILiteralMap
             * @property {Object.<string,flyteidl.core.ILiteral>|null} [literals] LiteralMap literals
             */

            /**
             * Constructs a new LiteralMap.
             * @memberof flyteidl.core
             * @classdesc Represents a LiteralMap.
             * @implements ILiteralMap
             * @constructor
             * @param {flyteidl.core.ILiteralMap=} [properties] Properties to set
             */
            function LiteralMap(properties) {
                this.literals = {};
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LiteralMap literals.
             * @member {Object.<string,flyteidl.core.ILiteral>} literals
             * @memberof flyteidl.core.LiteralMap
             * @instance
             */
            LiteralMap.prototype.literals = $util.emptyObject;

            /**
             * Creates a new LiteralMap instance using the specified properties.
             * @function create
             * @memberof flyteidl.core.LiteralMap
             * @static
             * @param {flyteidl.core.ILiteralMap=} [properties] Properties to set
             * @returns {flyteidl.core.LiteralMap} LiteralMap instance
             */
            LiteralMap.create = function create(properties) {
                return new LiteralMap(properties);
            };

            /**
             * Encodes the specified LiteralMap message. Does not implicitly {@link flyteidl.core.LiteralMap.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.core.LiteralMap
             * @static
             * @param {flyteidl.core.ILiteralMap} message LiteralMap message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LiteralMap.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.literals != null && message.hasOwnProperty("literals"))
                    for (let keys = Object.keys(message.literals), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.flyteidl.core.Literal.encode(message.literals[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                return writer;
            };

            /**
             * Decodes a LiteralMap message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.core.LiteralMap
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.core.LiteralMap} LiteralMap
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LiteralMap.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.core.LiteralMap(), key;
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        reader.skip().pos++;
                        if (message.literals === $util.emptyObject)
                            message.literals = {};
                        key = reader.string();
                        reader.pos++;
                        message.literals[key] = $root.flyteidl.core.Literal.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a LiteralMap message.
             * @function verify
             * @memberof flyteidl.core.LiteralMap
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LiteralMap.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.literals != null && message.hasOwnProperty("literals")) {
                    if (!$util.isObject(message.literals))
                        return "literals: object expected";
                    let key = Object.keys(message.literals);
                    for (let i = 0; i < key.length; ++i) {
                        let error = $root.flyteidl.core.Literal.verify(message.literals[key[i]]);
                        if (error)
                            return "literals." + error;
                    }
                }
                return null;
            };

            return LiteralMap;
        })();

        core.BindingDataCollection = (function() {

            /**
             * Properties of a BindingDataCollection.
             * @memberof flyteidl.core
             * @interface IBindingDataCollection
             * @property {Array.<flyteidl.core.IBindingData>|null} [bindings] BindingDataCollection bindings
             */

            /**
             * Constructs a new BindingDataCollection.
             * @memberof flyteidl.core
             * @classdesc Represents a BindingDataCollection.
             * @implements IBindingDataCollection
             * @constructor
             * @param {flyteidl.core.IBindingDataCollection=} [properties] Properties to set
             */
            function BindingDataCollection(properties) {
                this.bindings = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BindingDataCollection bindings.
             * @member {Array.<flyteidl.core.IBindingData>} bindings
             * @memberof flyteidl.core.BindingDataCollection
             * @instance
             */
            BindingDataCollection.prototype.bindings = $util.emptyArray;

            /**
             * Creates a new BindingDataCollection instance using the specified properties.
             * @function create
             * @memberof flyteidl.core.BindingDataCollection
             * @static
             * @param {flyteidl.core.IBindingDataCollection=} [properties] Properties to set
             * @returns {flyteidl.core.BindingDataCollection} BindingDataCollection instance
             */
            BindingDataCollection.create = function create(properties) {
                return new BindingDataCollection(properties);
            };

            /**
             * Encodes the specified BindingDataCollection message. Does not implicitly {@link flyteidl.core.BindingDataCollection.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.core.BindingDataCollection
             * @static
             * @param {flyteidl.core.IBindingDataCollection} message BindingDataCollection message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BindingDataCollection.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.bindings != null && message.bindings.length)
                    for (let i = 0; i < message.bindings.length; ++i)
                        $root.flyteidl.core.BindingData.encode(message.bindings[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a BindingDataCollection message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.core.BindingDataCollection
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.core.BindingDataCollection} BindingDataCollection
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BindingDataCollection.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.core.BindingDataCollection();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.bindings && message.bindings.length))
                            message.bindings = [];
                        message.bindings.push($root.flyteidl.core.BindingData.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a BindingDataCollection message.
             * @function verify
             * @memberof flyteidl.core.BindingDataCollection
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BindingDataCollection.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.bindings != null && message.hasOwnProperty("bindings")) {
                    if (!Array.isArray(message.bindings))
                        return "bindings: array expected";
                    for (let i = 0; i < message.bindings.length; ++i) {
                        let error = $root.flyteidl.core.BindingData.verify(message.bindings[i]);
                        if (error)
                            return "bindings." + error;
                    }
                }
                return null;
            };

            return BindingDataCollection;
        })();

        core.BindingDataMap = (function() {

            /**
             * Properties of a BindingDataMap.
             * @memberof flyteidl.core
             * @interface IBindingDataMap
             * @property {Object.<string,flyteidl.core.IBindingData>|null} [bindings] BindingDataMap bindings
             */

            /**
             * Constructs a new BindingDataMap.
             * @memberof flyteidl.core
             * @classdesc Represents a BindingDataMap.
             * @implements IBindingDataMap
             * @constructor
             * @param {flyteidl.core.IBindingDataMap=} [properties] Properties to set
             */
            function BindingDataMap(properties) {
                this.bindings = {};
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BindingDataMap bindings.
             * @member {Object.<string,flyteidl.core.IBindingData>} bindings
             * @memberof flyteidl.core.BindingDataMap
             * @instance
             */
            BindingDataMap.prototype.bindings = $util.emptyObject;

            /**
             * Creates a new BindingDataMap instance using the specified properties.
             * @function create
             * @memberof flyteidl.core.BindingDataMap
             * @static
             * @param {flyteidl.core.IBindingDataMap=} [properties] Properties to set
             * @returns {flyteidl.core.BindingDataMap} BindingDataMap instance
             */
            BindingDataMap.create = function create(properties) {
                return new BindingDataMap(properties);
            };

            /**
             * Encodes the specified BindingDataMap message. Does not implicitly {@link flyteidl.core.BindingDataMap.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.core.BindingDataMap
             * @static
             * @param {flyteidl.core.IBindingDataMap} message BindingDataMap message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BindingDataMap.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.bindings != null && message.hasOwnProperty("bindings"))
                    for (let keys = Object.keys(message.bindings), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.flyteidl.core.BindingData.encode(message.bindings[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                return writer;
            };

            /**
             * Decodes a BindingDataMap message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.core.BindingDataMap
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.core.BindingDataMap} BindingDataMap
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BindingDataMap.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.core.BindingDataMap(), key;
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        reader.skip().pos++;
                        if (message.bindings === $util.emptyObject)
                            message.bindings = {};
                        key = reader.string();
                        reader.pos++;
                        message.bindings[key] = $root.flyteidl.core.BindingData.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a BindingDataMap message.
             * @function verify
             * @memberof flyteidl.core.BindingDataMap
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BindingDataMap.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.bindings != null && message.hasOwnProperty("bindings")) {
                    if (!$util.isObject(message.bindings))
                        return "bindings: object expected";
                    let key = Object.keys(message.bindings);
                    for (let i = 0; i < key.length; ++i) {
                        let error = $root.flyteidl.core.BindingData.verify(message.bindings[key[i]]);
                        if (error)
                            return "bindings." + error;
                    }
                }
                return null;
            };

            return BindingDataMap;
        })();

        core.BindingData = (function() {

            /**
             * Properties of a BindingData.
             * @memberof flyteidl.core
             * @interface IBindingData
             * @property {flyteidl.core.IScalar|null} [scalar] BindingData scalar
             * @property {flyteidl.core.IBindingDataCollection|null} [collection] BindingData collection
             * @property {flyteidl.core.IOutputReference|null} [promise] BindingData promise
             * @property {flyteidl.core.IBindingDataMap|null} [map] BindingData map
             */

            /**
             * Constructs a new BindingData.
             * @memberof flyteidl.core
             * @classdesc Represents a BindingData.
             * @implements IBindingData
             * @constructor
             * @param {flyteidl.core.IBindingData=} [properties] Properties to set
             */
            function BindingData(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BindingData scalar.
             * @member {flyteidl.core.IScalar|null|undefined} scalar
             * @memberof flyteidl.core.BindingData
             * @instance
             */
            BindingData.prototype.scalar = null;

            /**
             * BindingData collection.
             * @member {flyteidl.core.IBindingDataCollection|null|undefined} collection
             * @memberof flyteidl.core.BindingData
             * @instance
             */
            BindingData.prototype.collection = null;

            /**
             * BindingData promise.
             * @member {flyteidl.core.IOutputReference|null|undefined} promise
             * @memberof flyteidl.core.BindingData
             * @instance
             */
            BindingData.prototype.promise = null;

            /**
             * BindingData map.
             * @member {flyteidl.core.IBindingDataMap|null|undefined} map
             * @memberof flyteidl.core.BindingData
             * @instance
             */
            BindingData.prototype.map = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * BindingData value.
             * @member {"scalar"|"collection"|"promise"|"map"|undefined} value
             * @memberof flyteidl.core.BindingData
             * @instance
             */
            Object.defineProperty(BindingData.prototype, "value", {
                get: $util.oneOfGetter($oneOfFields = ["scalar", "collection", "promise", "map"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new BindingData instance using the specified properties.
             * @function create
             * @memberof flyteidl.core.BindingData
             * @static
             * @param {flyteidl.core.IBindingData=} [properties] Properties to set
             * @returns {flyteidl.core.BindingData} BindingData instance
             */
            BindingData.create = function create(properties) {
                return new BindingData(properties);
            };

            /**
             * Encodes the specified BindingData message. Does not implicitly {@link flyteidl.core.BindingData.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.core.BindingData
             * @static
             * @param {flyteidl.core.IBindingData} message BindingData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BindingData.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.scalar != null && message.hasOwnProperty("scalar"))
                    $root.flyteidl.core.Scalar.encode(message.scalar, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.collection != null && message.hasOwnProperty("collection"))
                    $root.flyteidl.core.BindingDataCollection.encode(message.collection, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.promise != null && message.hasOwnProperty("promise"))
                    $root.flyteidl.core.OutputReference.encode(message.promise, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.map != null && message.hasOwnProperty("map"))
                    $root.flyteidl.core.BindingDataMap.encode(message.map, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a BindingData message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.core.BindingData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.core.BindingData} BindingData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BindingData.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.core.BindingData();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.scalar = $root.flyteidl.core.Scalar.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.collection = $root.flyteidl.core.BindingDataCollection.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.promise = $root.flyteidl.core.OutputReference.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.map = $root.flyteidl.core.BindingDataMap.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a BindingData message.
             * @function verify
             * @memberof flyteidl.core.BindingData
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BindingData.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.scalar != null && message.hasOwnProperty("scalar")) {
                    properties.value = 1;
                    {
                        let error = $root.flyteidl.core.Scalar.verify(message.scalar);
                        if (error)
                            return "scalar." + error;
                    }
                }
                if (message.collection != null && message.hasOwnProperty("collection")) {
                    if (properties.value === 1)
                        return "value: multiple values";
                    properties.value = 1;
                    {
                        let error = $root.flyteidl.core.BindingDataCollection.verify(message.collection);
                        if (error)
                            return "collection." + error;
                    }
                }
                if (message.promise != null && message.hasOwnProperty("promise")) {
                    if (properties.value === 1)
                        return "value: multiple values";
                    properties.value = 1;
                    {
                        let error = $root.flyteidl.core.OutputReference.verify(message.promise);
                        if (error)
                            return "promise." + error;
                    }
                }
                if (message.map != null && message.hasOwnProperty("map")) {
                    if (properties.value === 1)
                        return "value: multiple values";
                    properties.value = 1;
                    {
                        let error = $root.flyteidl.core.BindingDataMap.verify(message.map);
                        if (error)
                            return "map." + error;
                    }
                }
                return null;
            };

            return BindingData;
        })();

        core.Binding = (function() {

            /**
             * Properties of a Binding.
             * @memberof flyteidl.core
             * @interface IBinding
             * @property {string|null} ["var"] Binding var
             * @property {flyteidl.core.IBindingData|null} [binding] Binding binding
             */

            /**
             * Constructs a new Binding.
             * @memberof flyteidl.core
             * @classdesc Represents a Binding.
             * @implements IBinding
             * @constructor
             * @param {flyteidl.core.IBinding=} [properties] Properties to set
             */
            function Binding(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Binding var.
             * @member {string} var
             * @memberof flyteidl.core.Binding
             * @instance
             */
            Binding.prototype["var"] = "";

            /**
             * Binding binding.
             * @member {flyteidl.core.IBindingData|null|undefined} binding
             * @memberof flyteidl.core.Binding
             * @instance
             */
            Binding.prototype.binding = null;

            /**
             * Creates a new Binding instance using the specified properties.
             * @function create
             * @memberof flyteidl.core.Binding
             * @static
             * @param {flyteidl.core.IBinding=} [properties] Properties to set
             * @returns {flyteidl.core.Binding} Binding instance
             */
            Binding.create = function create(properties) {
                return new Binding(properties);
            };

            /**
             * Encodes the specified Binding message. Does not implicitly {@link flyteidl.core.Binding.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.core.Binding
             * @static
             * @param {flyteidl.core.IBinding} message Binding message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Binding.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message["var"] != null && message.hasOwnProperty("var"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message["var"]);
                if (message.binding != null && message.hasOwnProperty("binding"))
                    $root.flyteidl.core.BindingData.encode(message.binding, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a Binding message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.core.Binding
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.core.Binding} Binding
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Binding.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.core.Binding();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message["var"] = reader.string();
                        break;
                    case 2:
                        message.binding = $root.flyteidl.core.BindingData.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a Binding message.
             * @function verify
             * @memberof flyteidl.core.Binding
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Binding.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message["var"] != null && message.hasOwnProperty("var"))
                    if (!$util.isString(message["var"]))
                        return "var: string expected";
                if (message.binding != null && message.hasOwnProperty("binding")) {
                    let error = $root.flyteidl.core.BindingData.verify(message.binding);
                    if (error)
                        return "binding." + error;
                }
                return null;
            };

            return Binding;
        })();

        core.KeyValuePair = (function() {

            /**
             * Properties of a KeyValuePair.
             * @memberof flyteidl.core
             * @interface IKeyValuePair
             * @property {string|null} [key] KeyValuePair key
             * @property {string|null} [value] KeyValuePair value
             */

            /**
             * Constructs a new KeyValuePair.
             * @memberof flyteidl.core
             * @classdesc Represents a KeyValuePair.
             * @implements IKeyValuePair
             * @constructor
             * @param {flyteidl.core.IKeyValuePair=} [properties] Properties to set
             */
            function KeyValuePair(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KeyValuePair key.
             * @member {string} key
             * @memberof flyteidl.core.KeyValuePair
             * @instance
             */
            KeyValuePair.prototype.key = "";

            /**
             * KeyValuePair value.
             * @member {string} value
             * @memberof flyteidl.core.KeyValuePair
             * @instance
             */
            KeyValuePair.prototype.value = "";

            /**
             * Creates a new KeyValuePair instance using the specified properties.
             * @function create
             * @memberof flyteidl.core.KeyValuePair
             * @static
             * @param {flyteidl.core.IKeyValuePair=} [properties] Properties to set
             * @returns {flyteidl.core.KeyValuePair} KeyValuePair instance
             */
            KeyValuePair.create = function create(properties) {
                return new KeyValuePair(properties);
            };

            /**
             * Encodes the specified KeyValuePair message. Does not implicitly {@link flyteidl.core.KeyValuePair.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.core.KeyValuePair
             * @static
             * @param {flyteidl.core.IKeyValuePair} message KeyValuePair message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KeyValuePair.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && message.hasOwnProperty("key"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
                if (message.value != null && message.hasOwnProperty("value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
                return writer;
            };

            /**
             * Decodes a KeyValuePair message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.core.KeyValuePair
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.core.KeyValuePair} KeyValuePair
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KeyValuePair.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.core.KeyValuePair();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.key = reader.string();
                        break;
                    case 2:
                        message.value = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a KeyValuePair message.
             * @function verify
             * @memberof flyteidl.core.KeyValuePair
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KeyValuePair.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isString(message.key))
                        return "key: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isString(message.value))
                        return "value: string expected";
                return null;
            };

            return KeyValuePair;
        })();

        core.RetryStrategy = (function() {

            /**
             * Properties of a RetryStrategy.
             * @memberof flyteidl.core
             * @interface IRetryStrategy
             * @property {number|null} [retries] RetryStrategy retries
             */

            /**
             * Constructs a new RetryStrategy.
             * @memberof flyteidl.core
             * @classdesc Represents a RetryStrategy.
             * @implements IRetryStrategy
             * @constructor
             * @param {flyteidl.core.IRetryStrategy=} [properties] Properties to set
             */
            function RetryStrategy(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RetryStrategy retries.
             * @member {number} retries
             * @memberof flyteidl.core.RetryStrategy
             * @instance
             */
            RetryStrategy.prototype.retries = 0;

            /**
             * Creates a new RetryStrategy instance using the specified properties.
             * @function create
             * @memberof flyteidl.core.RetryStrategy
             * @static
             * @param {flyteidl.core.IRetryStrategy=} [properties] Properties to set
             * @returns {flyteidl.core.RetryStrategy} RetryStrategy instance
             */
            RetryStrategy.create = function create(properties) {
                return new RetryStrategy(properties);
            };

            /**
             * Encodes the specified RetryStrategy message. Does not implicitly {@link flyteidl.core.RetryStrategy.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.core.RetryStrategy
             * @static
             * @param {flyteidl.core.IRetryStrategy} message RetryStrategy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RetryStrategy.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.retries != null && message.hasOwnProperty("retries"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.retries);
                return writer;
            };

            /**
             * Decodes a RetryStrategy message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.core.RetryStrategy
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.core.RetryStrategy} RetryStrategy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RetryStrategy.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.core.RetryStrategy();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 5:
                        message.retries = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a RetryStrategy message.
             * @function verify
             * @memberof flyteidl.core.RetryStrategy
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RetryStrategy.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.retries != null && message.hasOwnProperty("retries"))
                    if (!$util.isInteger(message.retries))
                        return "retries: integer expected";
                return null;
            };

            return RetryStrategy;
        })();

        /**
         * SimpleType enum.
         * @name flyteidl.core.SimpleType
         * @enum {string}
         * @property {number} NONE=0 NONE value
         * @property {number} INTEGER=1 INTEGER value
         * @property {number} FLOAT=2 FLOAT value
         * @property {number} STRING=3 STRING value
         * @property {number} BOOLEAN=4 BOOLEAN value
         * @property {number} DATETIME=5 DATETIME value
         * @property {number} DURATION=6 DURATION value
         * @property {number} BINARY=7 BINARY value
         * @property {number} ERROR=8 ERROR value
         * @property {number} STRUCT=9 STRUCT value
         */
        core.SimpleType = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "NONE"] = 0;
            values[valuesById[1] = "INTEGER"] = 1;
            values[valuesById[2] = "FLOAT"] = 2;
            values[valuesById[3] = "STRING"] = 3;
            values[valuesById[4] = "BOOLEAN"] = 4;
            values[valuesById[5] = "DATETIME"] = 5;
            values[valuesById[6] = "DURATION"] = 6;
            values[valuesById[7] = "BINARY"] = 7;
            values[valuesById[8] = "ERROR"] = 8;
            values[valuesById[9] = "STRUCT"] = 9;
            return values;
        })();

        core.SchemaType = (function() {

            /**
             * Properties of a SchemaType.
             * @memberof flyteidl.core
             * @interface ISchemaType
             * @property {Array.<flyteidl.core.SchemaType.ISchemaColumn>|null} [columns] SchemaType columns
             */

            /**
             * Constructs a new SchemaType.
             * @memberof flyteidl.core
             * @classdesc Represents a SchemaType.
             * @implements ISchemaType
             * @constructor
             * @param {flyteidl.core.ISchemaType=} [properties] Properties to set
             */
            function SchemaType(properties) {
                this.columns = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SchemaType columns.
             * @member {Array.<flyteidl.core.SchemaType.ISchemaColumn>} columns
             * @memberof flyteidl.core.SchemaType
             * @instance
             */
            SchemaType.prototype.columns = $util.emptyArray;

            /**
             * Creates a new SchemaType instance using the specified properties.
             * @function create
             * @memberof flyteidl.core.SchemaType
             * @static
             * @param {flyteidl.core.ISchemaType=} [properties] Properties to set
             * @returns {flyteidl.core.SchemaType} SchemaType instance
             */
            SchemaType.create = function create(properties) {
                return new SchemaType(properties);
            };

            /**
             * Encodes the specified SchemaType message. Does not implicitly {@link flyteidl.core.SchemaType.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.core.SchemaType
             * @static
             * @param {flyteidl.core.ISchemaType} message SchemaType message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SchemaType.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.columns != null && message.columns.length)
                    for (let i = 0; i < message.columns.length; ++i)
                        $root.flyteidl.core.SchemaType.SchemaColumn.encode(message.columns[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a SchemaType message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.core.SchemaType
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.core.SchemaType} SchemaType
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SchemaType.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.core.SchemaType();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 3:
                        if (!(message.columns && message.columns.length))
                            message.columns = [];
                        message.columns.push($root.flyteidl.core.SchemaType.SchemaColumn.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a SchemaType message.
             * @function verify
             * @memberof flyteidl.core.SchemaType
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SchemaType.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.columns != null && message.hasOwnProperty("columns")) {
                    if (!Array.isArray(message.columns))
                        return "columns: array expected";
                    for (let i = 0; i < message.columns.length; ++i) {
                        let error = $root.flyteidl.core.SchemaType.SchemaColumn.verify(message.columns[i]);
                        if (error)
                            return "columns." + error;
                    }
                }
                return null;
            };

            SchemaType.SchemaColumn = (function() {

                /**
                 * Properties of a SchemaColumn.
                 * @memberof flyteidl.core.SchemaType
                 * @interface ISchemaColumn
                 * @property {string|null} [name] SchemaColumn name
                 * @property {flyteidl.core.SchemaType.SchemaColumn.SchemaColumnType|null} [type] SchemaColumn type
                 */

                /**
                 * Constructs a new SchemaColumn.
                 * @memberof flyteidl.core.SchemaType
                 * @classdesc Represents a SchemaColumn.
                 * @implements ISchemaColumn
                 * @constructor
                 * @param {flyteidl.core.SchemaType.ISchemaColumn=} [properties] Properties to set
                 */
                function SchemaColumn(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SchemaColumn name.
                 * @member {string} name
                 * @memberof flyteidl.core.SchemaType.SchemaColumn
                 * @instance
                 */
                SchemaColumn.prototype.name = "";

                /**
                 * SchemaColumn type.
                 * @member {flyteidl.core.SchemaType.SchemaColumn.SchemaColumnType} type
                 * @memberof flyteidl.core.SchemaType.SchemaColumn
                 * @instance
                 */
                SchemaColumn.prototype.type = 0;

                /**
                 * Creates a new SchemaColumn instance using the specified properties.
                 * @function create
                 * @memberof flyteidl.core.SchemaType.SchemaColumn
                 * @static
                 * @param {flyteidl.core.SchemaType.ISchemaColumn=} [properties] Properties to set
                 * @returns {flyteidl.core.SchemaType.SchemaColumn} SchemaColumn instance
                 */
                SchemaColumn.create = function create(properties) {
                    return new SchemaColumn(properties);
                };

                /**
                 * Encodes the specified SchemaColumn message. Does not implicitly {@link flyteidl.core.SchemaType.SchemaColumn.verify|verify} messages.
                 * @function encode
                 * @memberof flyteidl.core.SchemaType.SchemaColumn
                 * @static
                 * @param {flyteidl.core.SchemaType.ISchemaColumn} message SchemaColumn message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SchemaColumn.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && message.hasOwnProperty("name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.type != null && message.hasOwnProperty("type"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
                    return writer;
                };

                /**
                 * Decodes a SchemaColumn message from the specified reader or buffer.
                 * @function decode
                 * @memberof flyteidl.core.SchemaType.SchemaColumn
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {flyteidl.core.SchemaType.SchemaColumn} SchemaColumn
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SchemaColumn.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.core.SchemaType.SchemaColumn();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.type = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Verifies a SchemaColumn message.
                 * @function verify
                 * @memberof flyteidl.core.SchemaType.SchemaColumn
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SchemaColumn.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.type != null && message.hasOwnProperty("type"))
                        switch (message.type) {
                        default:
                            return "type: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    return null;
                };

                /**
                 * SchemaColumnType enum.
                 * @name flyteidl.core.SchemaType.SchemaColumn.SchemaColumnType
                 * @enum {string}
                 * @property {number} INTEGER=0 INTEGER value
                 * @property {number} FLOAT=1 FLOAT value
                 * @property {number} STRING=2 STRING value
                 * @property {number} BOOLEAN=3 BOOLEAN value
                 * @property {number} DATETIME=4 DATETIME value
                 * @property {number} DURATION=5 DURATION value
                 */
                SchemaColumn.SchemaColumnType = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "INTEGER"] = 0;
                    values[valuesById[1] = "FLOAT"] = 1;
                    values[valuesById[2] = "STRING"] = 2;
                    values[valuesById[3] = "BOOLEAN"] = 3;
                    values[valuesById[4] = "DATETIME"] = 4;
                    values[valuesById[5] = "DURATION"] = 5;
                    return values;
                })();

                return SchemaColumn;
            })();

            return SchemaType;
        })();

        core.BlobType = (function() {

            /**
             * Properties of a BlobType.
             * @memberof flyteidl.core
             * @interface IBlobType
             * @property {string|null} [format] BlobType format
             * @property {flyteidl.core.BlobType.BlobDimensionality|null} [dimensionality] BlobType dimensionality
             */

            /**
             * Constructs a new BlobType.
             * @memberof flyteidl.core
             * @classdesc Represents a BlobType.
             * @implements IBlobType
             * @constructor
             * @param {flyteidl.core.IBlobType=} [properties] Properties to set
             */
            function BlobType(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BlobType format.
             * @member {string} format
             * @memberof flyteidl.core.BlobType
             * @instance
             */
            BlobType.prototype.format = "";

            /**
             * BlobType dimensionality.
             * @member {flyteidl.core.BlobType.BlobDimensionality} dimensionality
             * @memberof flyteidl.core.BlobType
             * @instance
             */
            BlobType.prototype.dimensionality = 0;

            /**
             * Creates a new BlobType instance using the specified properties.
             * @function create
             * @memberof flyteidl.core.BlobType
             * @static
             * @param {flyteidl.core.IBlobType=} [properties] Properties to set
             * @returns {flyteidl.core.BlobType} BlobType instance
             */
            BlobType.create = function create(properties) {
                return new BlobType(properties);
            };

            /**
             * Encodes the specified BlobType message. Does not implicitly {@link flyteidl.core.BlobType.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.core.BlobType
             * @static
             * @param {flyteidl.core.IBlobType} message BlobType message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BlobType.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.format != null && message.hasOwnProperty("format"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.format);
                if (message.dimensionality != null && message.hasOwnProperty("dimensionality"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.dimensionality);
                return writer;
            };

            /**
             * Decodes a BlobType message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.core.BlobType
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.core.BlobType} BlobType
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BlobType.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.core.BlobType();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.format = reader.string();
                        break;
                    case 2:
                        message.dimensionality = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a BlobType message.
             * @function verify
             * @memberof flyteidl.core.BlobType
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BlobType.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.format != null && message.hasOwnProperty("format"))
                    if (!$util.isString(message.format))
                        return "format: string expected";
                if (message.dimensionality != null && message.hasOwnProperty("dimensionality"))
                    switch (message.dimensionality) {
                    default:
                        return "dimensionality: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                return null;
            };

            /**
             * BlobDimensionality enum.
             * @name flyteidl.core.BlobType.BlobDimensionality
             * @enum {string}
             * @property {number} SINGLE=0 SINGLE value
             * @property {number} MULTIPART=1 MULTIPART value
             */
            BlobType.BlobDimensionality = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "SINGLE"] = 0;
                values[valuesById[1] = "MULTIPART"] = 1;
                return values;
            })();

            return BlobType;
        })();

        core.LiteralType = (function() {

            /**
             * Properties of a LiteralType.
             * @memberof flyteidl.core
             * @interface ILiteralType
             * @property {flyteidl.core.SimpleType|null} [simple] LiteralType simple
             * @property {flyteidl.core.ISchemaType|null} [schema] LiteralType schema
             * @property {flyteidl.core.ILiteralType|null} [collectionType] LiteralType collectionType
             * @property {flyteidl.core.ILiteralType|null} [mapValueType] LiteralType mapValueType
             * @property {flyteidl.core.IBlobType|null} [blob] LiteralType blob
             * @property {google.protobuf.IStruct|null} [metadata] LiteralType metadata
             */

            /**
             * Constructs a new LiteralType.
             * @memberof flyteidl.core
             * @classdesc Represents a LiteralType.
             * @implements ILiteralType
             * @constructor
             * @param {flyteidl.core.ILiteralType=} [properties] Properties to set
             */
            function LiteralType(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LiteralType simple.
             * @member {flyteidl.core.SimpleType} simple
             * @memberof flyteidl.core.LiteralType
             * @instance
             */
            LiteralType.prototype.simple = 0;

            /**
             * LiteralType schema.
             * @member {flyteidl.core.ISchemaType|null|undefined} schema
             * @memberof flyteidl.core.LiteralType
             * @instance
             */
            LiteralType.prototype.schema = null;

            /**
             * LiteralType collectionType.
             * @member {flyteidl.core.ILiteralType|null|undefined} collectionType
             * @memberof flyteidl.core.LiteralType
             * @instance
             */
            LiteralType.prototype.collectionType = null;

            /**
             * LiteralType mapValueType.
             * @member {flyteidl.core.ILiteralType|null|undefined} mapValueType
             * @memberof flyteidl.core.LiteralType
             * @instance
             */
            LiteralType.prototype.mapValueType = null;

            /**
             * LiteralType blob.
             * @member {flyteidl.core.IBlobType|null|undefined} blob
             * @memberof flyteidl.core.LiteralType
             * @instance
             */
            LiteralType.prototype.blob = null;

            /**
             * LiteralType metadata.
             * @member {google.protobuf.IStruct|null|undefined} metadata
             * @memberof flyteidl.core.LiteralType
             * @instance
             */
            LiteralType.prototype.metadata = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * LiteralType type.
             * @member {"simple"|"schema"|"collectionType"|"mapValueType"|"blob"|undefined} type
             * @memberof flyteidl.core.LiteralType
             * @instance
             */
            Object.defineProperty(LiteralType.prototype, "type", {
                get: $util.oneOfGetter($oneOfFields = ["simple", "schema", "collectionType", "mapValueType", "blob"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new LiteralType instance using the specified properties.
             * @function create
             * @memberof flyteidl.core.LiteralType
             * @static
             * @param {flyteidl.core.ILiteralType=} [properties] Properties to set
             * @returns {flyteidl.core.LiteralType} LiteralType instance
             */
            LiteralType.create = function create(properties) {
                return new LiteralType(properties);
            };

            /**
             * Encodes the specified LiteralType message. Does not implicitly {@link flyteidl.core.LiteralType.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.core.LiteralType
             * @static
             * @param {flyteidl.core.ILiteralType} message LiteralType message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LiteralType.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.simple != null && message.hasOwnProperty("simple"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.simple);
                if (message.schema != null && message.hasOwnProperty("schema"))
                    $root.flyteidl.core.SchemaType.encode(message.schema, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.collectionType != null && message.hasOwnProperty("collectionType"))
                    $root.flyteidl.core.LiteralType.encode(message.collectionType, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.mapValueType != null && message.hasOwnProperty("mapValueType"))
                    $root.flyteidl.core.LiteralType.encode(message.mapValueType, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.blob != null && message.hasOwnProperty("blob"))
                    $root.flyteidl.core.BlobType.encode(message.blob, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    $root.google.protobuf.Struct.encode(message.metadata, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a LiteralType message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.core.LiteralType
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.core.LiteralType} LiteralType
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LiteralType.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.core.LiteralType();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.simple = reader.int32();
                        break;
                    case 2:
                        message.schema = $root.flyteidl.core.SchemaType.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.collectionType = $root.flyteidl.core.LiteralType.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.mapValueType = $root.flyteidl.core.LiteralType.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.blob = $root.flyteidl.core.BlobType.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.metadata = $root.google.protobuf.Struct.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a LiteralType message.
             * @function verify
             * @memberof flyteidl.core.LiteralType
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LiteralType.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.simple != null && message.hasOwnProperty("simple")) {
                    properties.type = 1;
                    switch (message.simple) {
                    default:
                        return "simple: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                        break;
                    }
                }
                if (message.schema != null && message.hasOwnProperty("schema")) {
                    if (properties.type === 1)
                        return "type: multiple values";
                    properties.type = 1;
                    {
                        let error = $root.flyteidl.core.SchemaType.verify(message.schema);
                        if (error)
                            return "schema." + error;
                    }
                }
                if (message.collectionType != null && message.hasOwnProperty("collectionType")) {
                    if (properties.type === 1)
                        return "type: multiple values";
                    properties.type = 1;
                    {
                        let error = $root.flyteidl.core.LiteralType.verify(message.collectionType);
                        if (error)
                            return "collectionType." + error;
                    }
                }
                if (message.mapValueType != null && message.hasOwnProperty("mapValueType")) {
                    if (properties.type === 1)
                        return "type: multiple values";
                    properties.type = 1;
                    {
                        let error = $root.flyteidl.core.LiteralType.verify(message.mapValueType);
                        if (error)
                            return "mapValueType." + error;
                    }
                }
                if (message.blob != null && message.hasOwnProperty("blob")) {
                    if (properties.type === 1)
                        return "type: multiple values";
                    properties.type = 1;
                    {
                        let error = $root.flyteidl.core.BlobType.verify(message.blob);
                        if (error)
                            return "blob." + error;
                    }
                }
                if (message.metadata != null && message.hasOwnProperty("metadata")) {
                    let error = $root.google.protobuf.Struct.verify(message.metadata);
                    if (error)
                        return "metadata." + error;
                }
                return null;
            };

            return LiteralType;
        })();

        core.OutputReference = (function() {

            /**
             * Properties of an OutputReference.
             * @memberof flyteidl.core
             * @interface IOutputReference
             * @property {string|null} [nodeId] OutputReference nodeId
             * @property {string|null} ["var"] OutputReference var
             */

            /**
             * Constructs a new OutputReference.
             * @memberof flyteidl.core
             * @classdesc Represents an OutputReference.
             * @implements IOutputReference
             * @constructor
             * @param {flyteidl.core.IOutputReference=} [properties] Properties to set
             */
            function OutputReference(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * OutputReference nodeId.
             * @member {string} nodeId
             * @memberof flyteidl.core.OutputReference
             * @instance
             */
            OutputReference.prototype.nodeId = "";

            /**
             * OutputReference var.
             * @member {string} var
             * @memberof flyteidl.core.OutputReference
             * @instance
             */
            OutputReference.prototype["var"] = "";

            /**
             * Creates a new OutputReference instance using the specified properties.
             * @function create
             * @memberof flyteidl.core.OutputReference
             * @static
             * @param {flyteidl.core.IOutputReference=} [properties] Properties to set
             * @returns {flyteidl.core.OutputReference} OutputReference instance
             */
            OutputReference.create = function create(properties) {
                return new OutputReference(properties);
            };

            /**
             * Encodes the specified OutputReference message. Does not implicitly {@link flyteidl.core.OutputReference.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.core.OutputReference
             * @static
             * @param {flyteidl.core.IOutputReference} message OutputReference message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OutputReference.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.nodeId);
                if (message["var"] != null && message.hasOwnProperty("var"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message["var"]);
                return writer;
            };

            /**
             * Decodes an OutputReference message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.core.OutputReference
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.core.OutputReference} OutputReference
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OutputReference.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.core.OutputReference();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.nodeId = reader.string();
                        break;
                    case 2:
                        message["var"] = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies an OutputReference message.
             * @function verify
             * @memberof flyteidl.core.OutputReference
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OutputReference.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                    if (!$util.isString(message.nodeId))
                        return "nodeId: string expected";
                if (message["var"] != null && message.hasOwnProperty("var"))
                    if (!$util.isString(message["var"]))
                        return "var: string expected";
                return null;
            };

            return OutputReference;
        })();

        core.Error = (function() {

            /**
             * Properties of an Error.
             * @memberof flyteidl.core
             * @interface IError
             * @property {string|null} [failedNodeId] Error failedNodeId
             * @property {string|null} [message] Error message
             */

            /**
             * Constructs a new Error.
             * @memberof flyteidl.core
             * @classdesc Represents an Error.
             * @implements IError
             * @constructor
             * @param {flyteidl.core.IError=} [properties] Properties to set
             */
            function Error(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Error failedNodeId.
             * @member {string} failedNodeId
             * @memberof flyteidl.core.Error
             * @instance
             */
            Error.prototype.failedNodeId = "";

            /**
             * Error message.
             * @member {string} message
             * @memberof flyteidl.core.Error
             * @instance
             */
            Error.prototype.message = "";

            /**
             * Creates a new Error instance using the specified properties.
             * @function create
             * @memberof flyteidl.core.Error
             * @static
             * @param {flyteidl.core.IError=} [properties] Properties to set
             * @returns {flyteidl.core.Error} Error instance
             */
            Error.create = function create(properties) {
                return new Error(properties);
            };

            /**
             * Encodes the specified Error message. Does not implicitly {@link flyteidl.core.Error.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.core.Error
             * @static
             * @param {flyteidl.core.IError} message Error message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Error.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.failedNodeId != null && message.hasOwnProperty("failedNodeId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.failedNodeId);
                if (message.message != null && message.hasOwnProperty("message"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.message);
                return writer;
            };

            /**
             * Decodes an Error message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.core.Error
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.core.Error} Error
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Error.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.core.Error();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.failedNodeId = reader.string();
                        break;
                    case 2:
                        message.message = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies an Error message.
             * @function verify
             * @memberof flyteidl.core.Error
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Error.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.failedNodeId != null && message.hasOwnProperty("failedNodeId"))
                    if (!$util.isString(message.failedNodeId))
                        return "failedNodeId: string expected";
                if (message.message != null && message.hasOwnProperty("message"))
                    if (!$util.isString(message.message))
                        return "message: string expected";
                return null;
            };

            return Error;
        })();

        /**
         * ResourceType enum.
         * @name flyteidl.core.ResourceType
         * @enum {string}
         * @property {number} UNSPECIFIED=0 UNSPECIFIED value
         * @property {number} TASK=1 TASK value
         * @property {number} WORKFLOW=2 WORKFLOW value
         * @property {number} LAUNCH_PLAN=3 LAUNCH_PLAN value
         */
        core.ResourceType = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNSPECIFIED"] = 0;
            values[valuesById[1] = "TASK"] = 1;
            values[valuesById[2] = "WORKFLOW"] = 2;
            values[valuesById[3] = "LAUNCH_PLAN"] = 3;
            return values;
        })();

        core.Identifier = (function() {

            /**
             * Properties of an Identifier.
             * @memberof flyteidl.core
             * @interface IIdentifier
             * @property {flyteidl.core.ResourceType|null} [resourceType] Identifier resourceType
             * @property {string|null} [project] Identifier project
             * @property {string|null} [domain] Identifier domain
             * @property {string|null} [name] Identifier name
             * @property {string|null} [version] Identifier version
             */

            /**
             * Constructs a new Identifier.
             * @memberof flyteidl.core
             * @classdesc Represents an Identifier.
             * @implements IIdentifier
             * @constructor
             * @param {flyteidl.core.IIdentifier=} [properties] Properties to set
             */
            function Identifier(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Identifier resourceType.
             * @member {flyteidl.core.ResourceType} resourceType
             * @memberof flyteidl.core.Identifier
             * @instance
             */
            Identifier.prototype.resourceType = 0;

            /**
             * Identifier project.
             * @member {string} project
             * @memberof flyteidl.core.Identifier
             * @instance
             */
            Identifier.prototype.project = "";

            /**
             * Identifier domain.
             * @member {string} domain
             * @memberof flyteidl.core.Identifier
             * @instance
             */
            Identifier.prototype.domain = "";

            /**
             * Identifier name.
             * @member {string} name
             * @memberof flyteidl.core.Identifier
             * @instance
             */
            Identifier.prototype.name = "";

            /**
             * Identifier version.
             * @member {string} version
             * @memberof flyteidl.core.Identifier
             * @instance
             */
            Identifier.prototype.version = "";

            /**
             * Creates a new Identifier instance using the specified properties.
             * @function create
             * @memberof flyteidl.core.Identifier
             * @static
             * @param {flyteidl.core.IIdentifier=} [properties] Properties to set
             * @returns {flyteidl.core.Identifier} Identifier instance
             */
            Identifier.create = function create(properties) {
                return new Identifier(properties);
            };

            /**
             * Encodes the specified Identifier message. Does not implicitly {@link flyteidl.core.Identifier.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.core.Identifier
             * @static
             * @param {flyteidl.core.IIdentifier} message Identifier message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Identifier.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.resourceType != null && message.hasOwnProperty("resourceType"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.resourceType);
                if (message.project != null && message.hasOwnProperty("project"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.project);
                if (message.domain != null && message.hasOwnProperty("domain"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.domain);
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.name);
                if (message.version != null && message.hasOwnProperty("version"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.version);
                return writer;
            };

            /**
             * Decodes an Identifier message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.core.Identifier
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.core.Identifier} Identifier
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Identifier.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.core.Identifier();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.resourceType = reader.int32();
                        break;
                    case 2:
                        message.project = reader.string();
                        break;
                    case 3:
                        message.domain = reader.string();
                        break;
                    case 4:
                        message.name = reader.string();
                        break;
                    case 5:
                        message.version = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies an Identifier message.
             * @function verify
             * @memberof flyteidl.core.Identifier
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Identifier.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.resourceType != null && message.hasOwnProperty("resourceType"))
                    switch (message.resourceType) {
                    default:
                        return "resourceType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.project != null && message.hasOwnProperty("project"))
                    if (!$util.isString(message.project))
                        return "project: string expected";
                if (message.domain != null && message.hasOwnProperty("domain"))
                    if (!$util.isString(message.domain))
                        return "domain: string expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.version != null && message.hasOwnProperty("version"))
                    if (!$util.isString(message.version))
                        return "version: string expected";
                return null;
            };

            return Identifier;
        })();

        core.WorkflowExecutionIdentifier = (function() {

            /**
             * Properties of a WorkflowExecutionIdentifier.
             * @memberof flyteidl.core
             * @interface IWorkflowExecutionIdentifier
             * @property {string|null} [project] WorkflowExecutionIdentifier project
             * @property {string|null} [domain] WorkflowExecutionIdentifier domain
             * @property {string|null} [name] WorkflowExecutionIdentifier name
             */

            /**
             * Constructs a new WorkflowExecutionIdentifier.
             * @memberof flyteidl.core
             * @classdesc Represents a WorkflowExecutionIdentifier.
             * @implements IWorkflowExecutionIdentifier
             * @constructor
             * @param {flyteidl.core.IWorkflowExecutionIdentifier=} [properties] Properties to set
             */
            function WorkflowExecutionIdentifier(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WorkflowExecutionIdentifier project.
             * @member {string} project
             * @memberof flyteidl.core.WorkflowExecutionIdentifier
             * @instance
             */
            WorkflowExecutionIdentifier.prototype.project = "";

            /**
             * WorkflowExecutionIdentifier domain.
             * @member {string} domain
             * @memberof flyteidl.core.WorkflowExecutionIdentifier
             * @instance
             */
            WorkflowExecutionIdentifier.prototype.domain = "";

            /**
             * WorkflowExecutionIdentifier name.
             * @member {string} name
             * @memberof flyteidl.core.WorkflowExecutionIdentifier
             * @instance
             */
            WorkflowExecutionIdentifier.prototype.name = "";

            /**
             * Creates a new WorkflowExecutionIdentifier instance using the specified properties.
             * @function create
             * @memberof flyteidl.core.WorkflowExecutionIdentifier
             * @static
             * @param {flyteidl.core.IWorkflowExecutionIdentifier=} [properties] Properties to set
             * @returns {flyteidl.core.WorkflowExecutionIdentifier} WorkflowExecutionIdentifier instance
             */
            WorkflowExecutionIdentifier.create = function create(properties) {
                return new WorkflowExecutionIdentifier(properties);
            };

            /**
             * Encodes the specified WorkflowExecutionIdentifier message. Does not implicitly {@link flyteidl.core.WorkflowExecutionIdentifier.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.core.WorkflowExecutionIdentifier
             * @static
             * @param {flyteidl.core.IWorkflowExecutionIdentifier} message WorkflowExecutionIdentifier message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WorkflowExecutionIdentifier.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.project != null && message.hasOwnProperty("project"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.project);
                if (message.domain != null && message.hasOwnProperty("domain"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.domain);
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.name);
                return writer;
            };

            /**
             * Decodes a WorkflowExecutionIdentifier message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.core.WorkflowExecutionIdentifier
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.core.WorkflowExecutionIdentifier} WorkflowExecutionIdentifier
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WorkflowExecutionIdentifier.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.core.WorkflowExecutionIdentifier();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.project = reader.string();
                        break;
                    case 2:
                        message.domain = reader.string();
                        break;
                    case 4:
                        message.name = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a WorkflowExecutionIdentifier message.
             * @function verify
             * @memberof flyteidl.core.WorkflowExecutionIdentifier
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WorkflowExecutionIdentifier.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.project != null && message.hasOwnProperty("project"))
                    if (!$util.isString(message.project))
                        return "project: string expected";
                if (message.domain != null && message.hasOwnProperty("domain"))
                    if (!$util.isString(message.domain))
                        return "domain: string expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                return null;
            };

            return WorkflowExecutionIdentifier;
        })();

        core.NodeExecutionIdentifier = (function() {

            /**
             * Properties of a NodeExecutionIdentifier.
             * @memberof flyteidl.core
             * @interface INodeExecutionIdentifier
             * @property {string|null} [nodeId] NodeExecutionIdentifier nodeId
             * @property {flyteidl.core.IWorkflowExecutionIdentifier|null} [executionId] NodeExecutionIdentifier executionId
             */

            /**
             * Constructs a new NodeExecutionIdentifier.
             * @memberof flyteidl.core
             * @classdesc Represents a NodeExecutionIdentifier.
             * @implements INodeExecutionIdentifier
             * @constructor
             * @param {flyteidl.core.INodeExecutionIdentifier=} [properties] Properties to set
             */
            function NodeExecutionIdentifier(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NodeExecutionIdentifier nodeId.
             * @member {string} nodeId
             * @memberof flyteidl.core.NodeExecutionIdentifier
             * @instance
             */
            NodeExecutionIdentifier.prototype.nodeId = "";

            /**
             * NodeExecutionIdentifier executionId.
             * @member {flyteidl.core.IWorkflowExecutionIdentifier|null|undefined} executionId
             * @memberof flyteidl.core.NodeExecutionIdentifier
             * @instance
             */
            NodeExecutionIdentifier.prototype.executionId = null;

            /**
             * Creates a new NodeExecutionIdentifier instance using the specified properties.
             * @function create
             * @memberof flyteidl.core.NodeExecutionIdentifier
             * @static
             * @param {flyteidl.core.INodeExecutionIdentifier=} [properties] Properties to set
             * @returns {flyteidl.core.NodeExecutionIdentifier} NodeExecutionIdentifier instance
             */
            NodeExecutionIdentifier.create = function create(properties) {
                return new NodeExecutionIdentifier(properties);
            };

            /**
             * Encodes the specified NodeExecutionIdentifier message. Does not implicitly {@link flyteidl.core.NodeExecutionIdentifier.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.core.NodeExecutionIdentifier
             * @static
             * @param {flyteidl.core.INodeExecutionIdentifier} message NodeExecutionIdentifier message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NodeExecutionIdentifier.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.nodeId);
                if (message.executionId != null && message.hasOwnProperty("executionId"))
                    $root.flyteidl.core.WorkflowExecutionIdentifier.encode(message.executionId, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a NodeExecutionIdentifier message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.core.NodeExecutionIdentifier
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.core.NodeExecutionIdentifier} NodeExecutionIdentifier
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NodeExecutionIdentifier.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.core.NodeExecutionIdentifier();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.nodeId = reader.string();
                        break;
                    case 2:
                        message.executionId = $root.flyteidl.core.WorkflowExecutionIdentifier.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a NodeExecutionIdentifier message.
             * @function verify
             * @memberof flyteidl.core.NodeExecutionIdentifier
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NodeExecutionIdentifier.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                    if (!$util.isString(message.nodeId))
                        return "nodeId: string expected";
                if (message.executionId != null && message.hasOwnProperty("executionId")) {
                    let error = $root.flyteidl.core.WorkflowExecutionIdentifier.verify(message.executionId);
                    if (error)
                        return "executionId." + error;
                }
                return null;
            };

            return NodeExecutionIdentifier;
        })();

        core.TaskExecutionIdentifier = (function() {

            /**
             * Properties of a TaskExecutionIdentifier.
             * @memberof flyteidl.core
             * @interface ITaskExecutionIdentifier
             * @property {flyteidl.core.IIdentifier|null} [taskId] TaskExecutionIdentifier taskId
             * @property {flyteidl.core.INodeExecutionIdentifier|null} [nodeExecutionId] TaskExecutionIdentifier nodeExecutionId
             * @property {number|null} [retryAttempt] TaskExecutionIdentifier retryAttempt
             */

            /**
             * Constructs a new TaskExecutionIdentifier.
             * @memberof flyteidl.core
             * @classdesc Represents a TaskExecutionIdentifier.
             * @implements ITaskExecutionIdentifier
             * @constructor
             * @param {flyteidl.core.ITaskExecutionIdentifier=} [properties] Properties to set
             */
            function TaskExecutionIdentifier(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TaskExecutionIdentifier taskId.
             * @member {flyteidl.core.IIdentifier|null|undefined} taskId
             * @memberof flyteidl.core.TaskExecutionIdentifier
             * @instance
             */
            TaskExecutionIdentifier.prototype.taskId = null;

            /**
             * TaskExecutionIdentifier nodeExecutionId.
             * @member {flyteidl.core.INodeExecutionIdentifier|null|undefined} nodeExecutionId
             * @memberof flyteidl.core.TaskExecutionIdentifier
             * @instance
             */
            TaskExecutionIdentifier.prototype.nodeExecutionId = null;

            /**
             * TaskExecutionIdentifier retryAttempt.
             * @member {number} retryAttempt
             * @memberof flyteidl.core.TaskExecutionIdentifier
             * @instance
             */
            TaskExecutionIdentifier.prototype.retryAttempt = 0;

            /**
             * Creates a new TaskExecutionIdentifier instance using the specified properties.
             * @function create
             * @memberof flyteidl.core.TaskExecutionIdentifier
             * @static
             * @param {flyteidl.core.ITaskExecutionIdentifier=} [properties] Properties to set
             * @returns {flyteidl.core.TaskExecutionIdentifier} TaskExecutionIdentifier instance
             */
            TaskExecutionIdentifier.create = function create(properties) {
                return new TaskExecutionIdentifier(properties);
            };

            /**
             * Encodes the specified TaskExecutionIdentifier message. Does not implicitly {@link flyteidl.core.TaskExecutionIdentifier.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.core.TaskExecutionIdentifier
             * @static
             * @param {flyteidl.core.ITaskExecutionIdentifier} message TaskExecutionIdentifier message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TaskExecutionIdentifier.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.taskId != null && message.hasOwnProperty("taskId"))
                    $root.flyteidl.core.Identifier.encode(message.taskId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.nodeExecutionId != null && message.hasOwnProperty("nodeExecutionId"))
                    $root.flyteidl.core.NodeExecutionIdentifier.encode(message.nodeExecutionId, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.retryAttempt != null && message.hasOwnProperty("retryAttempt"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.retryAttempt);
                return writer;
            };

            /**
             * Decodes a TaskExecutionIdentifier message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.core.TaskExecutionIdentifier
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.core.TaskExecutionIdentifier} TaskExecutionIdentifier
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TaskExecutionIdentifier.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.core.TaskExecutionIdentifier();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.taskId = $root.flyteidl.core.Identifier.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.nodeExecutionId = $root.flyteidl.core.NodeExecutionIdentifier.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.retryAttempt = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a TaskExecutionIdentifier message.
             * @function verify
             * @memberof flyteidl.core.TaskExecutionIdentifier
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TaskExecutionIdentifier.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.taskId != null && message.hasOwnProperty("taskId")) {
                    let error = $root.flyteidl.core.Identifier.verify(message.taskId);
                    if (error)
                        return "taskId." + error;
                }
                if (message.nodeExecutionId != null && message.hasOwnProperty("nodeExecutionId")) {
                    let error = $root.flyteidl.core.NodeExecutionIdentifier.verify(message.nodeExecutionId);
                    if (error)
                        return "nodeExecutionId." + error;
                }
                if (message.retryAttempt != null && message.hasOwnProperty("retryAttempt"))
                    if (!$util.isInteger(message.retryAttempt))
                        return "retryAttempt: integer expected";
                return null;
            };

            return TaskExecutionIdentifier;
        })();

        core.Variable = (function() {

            /**
             * Properties of a Variable.
             * @memberof flyteidl.core
             * @interface IVariable
             * @property {flyteidl.core.ILiteralType|null} [type] Variable type
             * @property {string|null} [description] Variable description
             */

            /**
             * Constructs a new Variable.
             * @memberof flyteidl.core
             * @classdesc Represents a Variable.
             * @implements IVariable
             * @constructor
             * @param {flyteidl.core.IVariable=} [properties] Properties to set
             */
            function Variable(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Variable type.
             * @member {flyteidl.core.ILiteralType|null|undefined} type
             * @memberof flyteidl.core.Variable
             * @instance
             */
            Variable.prototype.type = null;

            /**
             * Variable description.
             * @member {string} description
             * @memberof flyteidl.core.Variable
             * @instance
             */
            Variable.prototype.description = "";

            /**
             * Creates a new Variable instance using the specified properties.
             * @function create
             * @memberof flyteidl.core.Variable
             * @static
             * @param {flyteidl.core.IVariable=} [properties] Properties to set
             * @returns {flyteidl.core.Variable} Variable instance
             */
            Variable.create = function create(properties) {
                return new Variable(properties);
            };

            /**
             * Encodes the specified Variable message. Does not implicitly {@link flyteidl.core.Variable.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.core.Variable
             * @static
             * @param {flyteidl.core.IVariable} message Variable message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Variable.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && message.hasOwnProperty("type"))
                    $root.flyteidl.core.LiteralType.encode(message.type, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.description != null && message.hasOwnProperty("description"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
                return writer;
            };

            /**
             * Decodes a Variable message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.core.Variable
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.core.Variable} Variable
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Variable.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.core.Variable();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = $root.flyteidl.core.LiteralType.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.description = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a Variable message.
             * @function verify
             * @memberof flyteidl.core.Variable
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Variable.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type")) {
                    let error = $root.flyteidl.core.LiteralType.verify(message.type);
                    if (error)
                        return "type." + error;
                }
                if (message.description != null && message.hasOwnProperty("description"))
                    if (!$util.isString(message.description))
                        return "description: string expected";
                return null;
            };

            return Variable;
        })();

        core.VariableMap = (function() {

            /**
             * Properties of a VariableMap.
             * @memberof flyteidl.core
             * @interface IVariableMap
             * @property {Object.<string,flyteidl.core.IVariable>|null} [variables] VariableMap variables
             */

            /**
             * Constructs a new VariableMap.
             * @memberof flyteidl.core
             * @classdesc Represents a VariableMap.
             * @implements IVariableMap
             * @constructor
             * @param {flyteidl.core.IVariableMap=} [properties] Properties to set
             */
            function VariableMap(properties) {
                this.variables = {};
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * VariableMap variables.
             * @member {Object.<string,flyteidl.core.IVariable>} variables
             * @memberof flyteidl.core.VariableMap
             * @instance
             */
            VariableMap.prototype.variables = $util.emptyObject;

            /**
             * Creates a new VariableMap instance using the specified properties.
             * @function create
             * @memberof flyteidl.core.VariableMap
             * @static
             * @param {flyteidl.core.IVariableMap=} [properties] Properties to set
             * @returns {flyteidl.core.VariableMap} VariableMap instance
             */
            VariableMap.create = function create(properties) {
                return new VariableMap(properties);
            };

            /**
             * Encodes the specified VariableMap message. Does not implicitly {@link flyteidl.core.VariableMap.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.core.VariableMap
             * @static
             * @param {flyteidl.core.IVariableMap} message VariableMap message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VariableMap.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.variables != null && message.hasOwnProperty("variables"))
                    for (let keys = Object.keys(message.variables), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.flyteidl.core.Variable.encode(message.variables[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                return writer;
            };

            /**
             * Decodes a VariableMap message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.core.VariableMap
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.core.VariableMap} VariableMap
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VariableMap.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.core.VariableMap(), key;
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        reader.skip().pos++;
                        if (message.variables === $util.emptyObject)
                            message.variables = {};
                        key = reader.string();
                        reader.pos++;
                        message.variables[key] = $root.flyteidl.core.Variable.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a VariableMap message.
             * @function verify
             * @memberof flyteidl.core.VariableMap
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            VariableMap.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.variables != null && message.hasOwnProperty("variables")) {
                    if (!$util.isObject(message.variables))
                        return "variables: object expected";
                    let key = Object.keys(message.variables);
                    for (let i = 0; i < key.length; ++i) {
                        let error = $root.flyteidl.core.Variable.verify(message.variables[key[i]]);
                        if (error)
                            return "variables." + error;
                    }
                }
                return null;
            };

            return VariableMap;
        })();

        core.TypedInterface = (function() {

            /**
             * Properties of a TypedInterface.
             * @memberof flyteidl.core
             * @interface ITypedInterface
             * @property {flyteidl.core.IVariableMap|null} [inputs] TypedInterface inputs
             * @property {flyteidl.core.IVariableMap|null} [outputs] TypedInterface outputs
             */

            /**
             * Constructs a new TypedInterface.
             * @memberof flyteidl.core
             * @classdesc Represents a TypedInterface.
             * @implements ITypedInterface
             * @constructor
             * @param {flyteidl.core.ITypedInterface=} [properties] Properties to set
             */
            function TypedInterface(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TypedInterface inputs.
             * @member {flyteidl.core.IVariableMap|null|undefined} inputs
             * @memberof flyteidl.core.TypedInterface
             * @instance
             */
            TypedInterface.prototype.inputs = null;

            /**
             * TypedInterface outputs.
             * @member {flyteidl.core.IVariableMap|null|undefined} outputs
             * @memberof flyteidl.core.TypedInterface
             * @instance
             */
            TypedInterface.prototype.outputs = null;

            /**
             * Creates a new TypedInterface instance using the specified properties.
             * @function create
             * @memberof flyteidl.core.TypedInterface
             * @static
             * @param {flyteidl.core.ITypedInterface=} [properties] Properties to set
             * @returns {flyteidl.core.TypedInterface} TypedInterface instance
             */
            TypedInterface.create = function create(properties) {
                return new TypedInterface(properties);
            };

            /**
             * Encodes the specified TypedInterface message. Does not implicitly {@link flyteidl.core.TypedInterface.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.core.TypedInterface
             * @static
             * @param {flyteidl.core.ITypedInterface} message TypedInterface message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TypedInterface.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.inputs != null && message.hasOwnProperty("inputs"))
                    $root.flyteidl.core.VariableMap.encode(message.inputs, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.outputs != null && message.hasOwnProperty("outputs"))
                    $root.flyteidl.core.VariableMap.encode(message.outputs, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a TypedInterface message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.core.TypedInterface
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.core.TypedInterface} TypedInterface
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TypedInterface.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.core.TypedInterface();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.inputs = $root.flyteidl.core.VariableMap.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.outputs = $root.flyteidl.core.VariableMap.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a TypedInterface message.
             * @function verify
             * @memberof flyteidl.core.TypedInterface
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TypedInterface.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.inputs != null && message.hasOwnProperty("inputs")) {
                    let error = $root.flyteidl.core.VariableMap.verify(message.inputs);
                    if (error)
                        return "inputs." + error;
                }
                if (message.outputs != null && message.hasOwnProperty("outputs")) {
                    let error = $root.flyteidl.core.VariableMap.verify(message.outputs);
                    if (error)
                        return "outputs." + error;
                }
                return null;
            };

            return TypedInterface;
        })();

        core.Parameter = (function() {

            /**
             * Properties of a Parameter.
             * @memberof flyteidl.core
             * @interface IParameter
             * @property {flyteidl.core.IVariable|null} ["var"] Parameter var
             * @property {flyteidl.core.ILiteral|null} ["default"] Parameter default
             * @property {boolean|null} [required] Parameter required
             */

            /**
             * Constructs a new Parameter.
             * @memberof flyteidl.core
             * @classdesc Represents a Parameter.
             * @implements IParameter
             * @constructor
             * @param {flyteidl.core.IParameter=} [properties] Properties to set
             */
            function Parameter(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Parameter var.
             * @member {flyteidl.core.IVariable|null|undefined} var
             * @memberof flyteidl.core.Parameter
             * @instance
             */
            Parameter.prototype["var"] = null;

            /**
             * Parameter default.
             * @member {flyteidl.core.ILiteral|null|undefined} default
             * @memberof flyteidl.core.Parameter
             * @instance
             */
            Parameter.prototype["default"] = null;

            /**
             * Parameter required.
             * @member {boolean} required
             * @memberof flyteidl.core.Parameter
             * @instance
             */
            Parameter.prototype.required = false;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * Parameter behavior.
             * @member {"default"|"required"|undefined} behavior
             * @memberof flyteidl.core.Parameter
             * @instance
             */
            Object.defineProperty(Parameter.prototype, "behavior", {
                get: $util.oneOfGetter($oneOfFields = ["default", "required"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new Parameter instance using the specified properties.
             * @function create
             * @memberof flyteidl.core.Parameter
             * @static
             * @param {flyteidl.core.IParameter=} [properties] Properties to set
             * @returns {flyteidl.core.Parameter} Parameter instance
             */
            Parameter.create = function create(properties) {
                return new Parameter(properties);
            };

            /**
             * Encodes the specified Parameter message. Does not implicitly {@link flyteidl.core.Parameter.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.core.Parameter
             * @static
             * @param {flyteidl.core.IParameter} message Parameter message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Parameter.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message["var"] != null && message.hasOwnProperty("var"))
                    $root.flyteidl.core.Variable.encode(message["var"], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message["default"] != null && message.hasOwnProperty("default"))
                    $root.flyteidl.core.Literal.encode(message["default"], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.required != null && message.hasOwnProperty("required"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.required);
                return writer;
            };

            /**
             * Decodes a Parameter message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.core.Parameter
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.core.Parameter} Parameter
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Parameter.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.core.Parameter();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message["var"] = $root.flyteidl.core.Variable.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message["default"] = $root.flyteidl.core.Literal.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.required = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a Parameter message.
             * @function verify
             * @memberof flyteidl.core.Parameter
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Parameter.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message["var"] != null && message.hasOwnProperty("var")) {
                    let error = $root.flyteidl.core.Variable.verify(message["var"]);
                    if (error)
                        return "var." + error;
                }
                if (message["default"] != null && message.hasOwnProperty("default")) {
                    properties.behavior = 1;
                    {
                        let error = $root.flyteidl.core.Literal.verify(message["default"]);
                        if (error)
                            return "default." + error;
                    }
                }
                if (message.required != null && message.hasOwnProperty("required")) {
                    if (properties.behavior === 1)
                        return "behavior: multiple values";
                    properties.behavior = 1;
                    if (typeof message.required !== "boolean")
                        return "required: boolean expected";
                }
                return null;
            };

            return Parameter;
        })();

        core.ParameterMap = (function() {

            /**
             * Properties of a ParameterMap.
             * @memberof flyteidl.core
             * @interface IParameterMap
             * @property {Object.<string,flyteidl.core.IParameter>|null} [parameters] ParameterMap parameters
             */

            /**
             * Constructs a new ParameterMap.
             * @memberof flyteidl.core
             * @classdesc Represents a ParameterMap.
             * @implements IParameterMap
             * @constructor
             * @param {flyteidl.core.IParameterMap=} [properties] Properties to set
             */
            function ParameterMap(properties) {
                this.parameters = {};
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ParameterMap parameters.
             * @member {Object.<string,flyteidl.core.IParameter>} parameters
             * @memberof flyteidl.core.ParameterMap
             * @instance
             */
            ParameterMap.prototype.parameters = $util.emptyObject;

            /**
             * Creates a new ParameterMap instance using the specified properties.
             * @function create
             * @memberof flyteidl.core.ParameterMap
             * @static
             * @param {flyteidl.core.IParameterMap=} [properties] Properties to set
             * @returns {flyteidl.core.ParameterMap} ParameterMap instance
             */
            ParameterMap.create = function create(properties) {
                return new ParameterMap(properties);
            };

            /**
             * Encodes the specified ParameterMap message. Does not implicitly {@link flyteidl.core.ParameterMap.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.core.ParameterMap
             * @static
             * @param {flyteidl.core.IParameterMap} message ParameterMap message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ParameterMap.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.parameters != null && message.hasOwnProperty("parameters"))
                    for (let keys = Object.keys(message.parameters), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.flyteidl.core.Parameter.encode(message.parameters[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                return writer;
            };

            /**
             * Decodes a ParameterMap message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.core.ParameterMap
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.core.ParameterMap} ParameterMap
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ParameterMap.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.core.ParameterMap(), key;
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        reader.skip().pos++;
                        if (message.parameters === $util.emptyObject)
                            message.parameters = {};
                        key = reader.string();
                        reader.pos++;
                        message.parameters[key] = $root.flyteidl.core.Parameter.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a ParameterMap message.
             * @function verify
             * @memberof flyteidl.core.ParameterMap
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ParameterMap.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.parameters != null && message.hasOwnProperty("parameters")) {
                    if (!$util.isObject(message.parameters))
                        return "parameters: object expected";
                    let key = Object.keys(message.parameters);
                    for (let i = 0; i < key.length; ++i) {
                        let error = $root.flyteidl.core.Parameter.verify(message.parameters[key[i]]);
                        if (error)
                            return "parameters." + error;
                    }
                }
                return null;
            };

            return ParameterMap;
        })();

        core.Resources = (function() {

            /**
             * Properties of a Resources.
             * @memberof flyteidl.core
             * @interface IResources
             * @property {Array.<flyteidl.core.Resources.IResourceEntry>|null} [requests] Resources requests
             * @property {Array.<flyteidl.core.Resources.IResourceEntry>|null} [limits] Resources limits
             */

            /**
             * Constructs a new Resources.
             * @memberof flyteidl.core
             * @classdesc Represents a Resources.
             * @implements IResources
             * @constructor
             * @param {flyteidl.core.IResources=} [properties] Properties to set
             */
            function Resources(properties) {
                this.requests = [];
                this.limits = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Resources requests.
             * @member {Array.<flyteidl.core.Resources.IResourceEntry>} requests
             * @memberof flyteidl.core.Resources
             * @instance
             */
            Resources.prototype.requests = $util.emptyArray;

            /**
             * Resources limits.
             * @member {Array.<flyteidl.core.Resources.IResourceEntry>} limits
             * @memberof flyteidl.core.Resources
             * @instance
             */
            Resources.prototype.limits = $util.emptyArray;

            /**
             * Creates a new Resources instance using the specified properties.
             * @function create
             * @memberof flyteidl.core.Resources
             * @static
             * @param {flyteidl.core.IResources=} [properties] Properties to set
             * @returns {flyteidl.core.Resources} Resources instance
             */
            Resources.create = function create(properties) {
                return new Resources(properties);
            };

            /**
             * Encodes the specified Resources message. Does not implicitly {@link flyteidl.core.Resources.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.core.Resources
             * @static
             * @param {flyteidl.core.IResources} message Resources message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Resources.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.requests != null && message.requests.length)
                    for (let i = 0; i < message.requests.length; ++i)
                        $root.flyteidl.core.Resources.ResourceEntry.encode(message.requests[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.limits != null && message.limits.length)
                    for (let i = 0; i < message.limits.length; ++i)
                        $root.flyteidl.core.Resources.ResourceEntry.encode(message.limits[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a Resources message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.core.Resources
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.core.Resources} Resources
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Resources.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.core.Resources();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.requests && message.requests.length))
                            message.requests = [];
                        message.requests.push($root.flyteidl.core.Resources.ResourceEntry.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        if (!(message.limits && message.limits.length))
                            message.limits = [];
                        message.limits.push($root.flyteidl.core.Resources.ResourceEntry.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a Resources message.
             * @function verify
             * @memberof flyteidl.core.Resources
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Resources.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.requests != null && message.hasOwnProperty("requests")) {
                    if (!Array.isArray(message.requests))
                        return "requests: array expected";
                    for (let i = 0; i < message.requests.length; ++i) {
                        let error = $root.flyteidl.core.Resources.ResourceEntry.verify(message.requests[i]);
                        if (error)
                            return "requests." + error;
                    }
                }
                if (message.limits != null && message.hasOwnProperty("limits")) {
                    if (!Array.isArray(message.limits))
                        return "limits: array expected";
                    for (let i = 0; i < message.limits.length; ++i) {
                        let error = $root.flyteidl.core.Resources.ResourceEntry.verify(message.limits[i]);
                        if (error)
                            return "limits." + error;
                    }
                }
                return null;
            };

            /**
             * ResourceName enum.
             * @name flyteidl.core.Resources.ResourceName
             * @enum {string}
             * @property {number} UNKNOWN=0 UNKNOWN value
             * @property {number} CPU=1 CPU value
             * @property {number} GPU=2 GPU value
             * @property {number} MEMORY=3 MEMORY value
             * @property {number} STORAGE=4 STORAGE value
             */
            Resources.ResourceName = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN"] = 0;
                values[valuesById[1] = "CPU"] = 1;
                values[valuesById[2] = "GPU"] = 2;
                values[valuesById[3] = "MEMORY"] = 3;
                values[valuesById[4] = "STORAGE"] = 4;
                return values;
            })();

            Resources.ResourceEntry = (function() {

                /**
                 * Properties of a ResourceEntry.
                 * @memberof flyteidl.core.Resources
                 * @interface IResourceEntry
                 * @property {flyteidl.core.Resources.ResourceName|null} [name] ResourceEntry name
                 * @property {string|null} [value] ResourceEntry value
                 */

                /**
                 * Constructs a new ResourceEntry.
                 * @memberof flyteidl.core.Resources
                 * @classdesc Represents a ResourceEntry.
                 * @implements IResourceEntry
                 * @constructor
                 * @param {flyteidl.core.Resources.IResourceEntry=} [properties] Properties to set
                 */
                function ResourceEntry(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ResourceEntry name.
                 * @member {flyteidl.core.Resources.ResourceName} name
                 * @memberof flyteidl.core.Resources.ResourceEntry
                 * @instance
                 */
                ResourceEntry.prototype.name = 0;

                /**
                 * ResourceEntry value.
                 * @member {string} value
                 * @memberof flyteidl.core.Resources.ResourceEntry
                 * @instance
                 */
                ResourceEntry.prototype.value = "";

                /**
                 * Creates a new ResourceEntry instance using the specified properties.
                 * @function create
                 * @memberof flyteidl.core.Resources.ResourceEntry
                 * @static
                 * @param {flyteidl.core.Resources.IResourceEntry=} [properties] Properties to set
                 * @returns {flyteidl.core.Resources.ResourceEntry} ResourceEntry instance
                 */
                ResourceEntry.create = function create(properties) {
                    return new ResourceEntry(properties);
                };

                /**
                 * Encodes the specified ResourceEntry message. Does not implicitly {@link flyteidl.core.Resources.ResourceEntry.verify|verify} messages.
                 * @function encode
                 * @memberof flyteidl.core.Resources.ResourceEntry
                 * @static
                 * @param {flyteidl.core.Resources.IResourceEntry} message ResourceEntry message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ResourceEntry.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && message.hasOwnProperty("name"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.name);
                    if (message.value != null && message.hasOwnProperty("value"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
                    return writer;
                };

                /**
                 * Decodes a ResourceEntry message from the specified reader or buffer.
                 * @function decode
                 * @memberof flyteidl.core.Resources.ResourceEntry
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {flyteidl.core.Resources.ResourceEntry} ResourceEntry
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ResourceEntry.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.core.Resources.ResourceEntry();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.int32();
                            break;
                        case 2:
                            message.value = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Verifies a ResourceEntry message.
                 * @function verify
                 * @memberof flyteidl.core.Resources.ResourceEntry
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ResourceEntry.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        switch (message.name) {
                        default:
                            return "name: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                            break;
                        }
                    if (message.value != null && message.hasOwnProperty("value"))
                        if (!$util.isString(message.value))
                            return "value: string expected";
                    return null;
                };

                return ResourceEntry;
            })();

            return Resources;
        })();

        core.RuntimeMetadata = (function() {

            /**
             * Properties of a RuntimeMetadata.
             * @memberof flyteidl.core
             * @interface IRuntimeMetadata
             * @property {flyteidl.core.RuntimeMetadata.RuntimeType|null} [type] RuntimeMetadata type
             * @property {string|null} [version] RuntimeMetadata version
             * @property {string|null} [flavor] RuntimeMetadata flavor
             */

            /**
             * Constructs a new RuntimeMetadata.
             * @memberof flyteidl.core
             * @classdesc Represents a RuntimeMetadata.
             * @implements IRuntimeMetadata
             * @constructor
             * @param {flyteidl.core.IRuntimeMetadata=} [properties] Properties to set
             */
            function RuntimeMetadata(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RuntimeMetadata type.
             * @member {flyteidl.core.RuntimeMetadata.RuntimeType} type
             * @memberof flyteidl.core.RuntimeMetadata
             * @instance
             */
            RuntimeMetadata.prototype.type = 0;

            /**
             * RuntimeMetadata version.
             * @member {string} version
             * @memberof flyteidl.core.RuntimeMetadata
             * @instance
             */
            RuntimeMetadata.prototype.version = "";

            /**
             * RuntimeMetadata flavor.
             * @member {string} flavor
             * @memberof flyteidl.core.RuntimeMetadata
             * @instance
             */
            RuntimeMetadata.prototype.flavor = "";

            /**
             * Creates a new RuntimeMetadata instance using the specified properties.
             * @function create
             * @memberof flyteidl.core.RuntimeMetadata
             * @static
             * @param {flyteidl.core.IRuntimeMetadata=} [properties] Properties to set
             * @returns {flyteidl.core.RuntimeMetadata} RuntimeMetadata instance
             */
            RuntimeMetadata.create = function create(properties) {
                return new RuntimeMetadata(properties);
            };

            /**
             * Encodes the specified RuntimeMetadata message. Does not implicitly {@link flyteidl.core.RuntimeMetadata.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.core.RuntimeMetadata
             * @static
             * @param {flyteidl.core.IRuntimeMetadata} message RuntimeMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RuntimeMetadata.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && message.hasOwnProperty("type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.version != null && message.hasOwnProperty("version"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.version);
                if (message.flavor != null && message.hasOwnProperty("flavor"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.flavor);
                return writer;
            };

            /**
             * Decodes a RuntimeMetadata message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.core.RuntimeMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.core.RuntimeMetadata} RuntimeMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RuntimeMetadata.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.core.RuntimeMetadata();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.version = reader.string();
                        break;
                    case 3:
                        message.flavor = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a RuntimeMetadata message.
             * @function verify
             * @memberof flyteidl.core.RuntimeMetadata
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RuntimeMetadata.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                if (message.version != null && message.hasOwnProperty("version"))
                    if (!$util.isString(message.version))
                        return "version: string expected";
                if (message.flavor != null && message.hasOwnProperty("flavor"))
                    if (!$util.isString(message.flavor))
                        return "flavor: string expected";
                return null;
            };

            /**
             * RuntimeType enum.
             * @name flyteidl.core.RuntimeMetadata.RuntimeType
             * @enum {string}
             * @property {number} OTHER=0 OTHER value
             * @property {number} FLYTE_SDK=1 FLYTE_SDK value
             */
            RuntimeMetadata.RuntimeType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "OTHER"] = 0;
                values[valuesById[1] = "FLYTE_SDK"] = 1;
                return values;
            })();

            return RuntimeMetadata;
        })();

        core.TaskMetadata = (function() {

            /**
             * Properties of a TaskMetadata.
             * @memberof flyteidl.core
             * @interface ITaskMetadata
             * @property {boolean|null} [discoverable] TaskMetadata discoverable
             * @property {flyteidl.core.IRuntimeMetadata|null} [runtime] TaskMetadata runtime
             * @property {google.protobuf.IDuration|null} [timeout] TaskMetadata timeout
             * @property {flyteidl.core.IRetryStrategy|null} [retries] TaskMetadata retries
             * @property {string|null} [discoveryVersion] TaskMetadata discoveryVersion
             * @property {string|null} [deprecatedErrorMessage] TaskMetadata deprecatedErrorMessage
             * @property {boolean|null} [interruptible] TaskMetadata interruptible
             */

            /**
             * Constructs a new TaskMetadata.
             * @memberof flyteidl.core
             * @classdesc Represents a TaskMetadata.
             * @implements ITaskMetadata
             * @constructor
             * @param {flyteidl.core.ITaskMetadata=} [properties] Properties to set
             */
            function TaskMetadata(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TaskMetadata discoverable.
             * @member {boolean} discoverable
             * @memberof flyteidl.core.TaskMetadata
             * @instance
             */
            TaskMetadata.prototype.discoverable = false;

            /**
             * TaskMetadata runtime.
             * @member {flyteidl.core.IRuntimeMetadata|null|undefined} runtime
             * @memberof flyteidl.core.TaskMetadata
             * @instance
             */
            TaskMetadata.prototype.runtime = null;

            /**
             * TaskMetadata timeout.
             * @member {google.protobuf.IDuration|null|undefined} timeout
             * @memberof flyteidl.core.TaskMetadata
             * @instance
             */
            TaskMetadata.prototype.timeout = null;

            /**
             * TaskMetadata retries.
             * @member {flyteidl.core.IRetryStrategy|null|undefined} retries
             * @memberof flyteidl.core.TaskMetadata
             * @instance
             */
            TaskMetadata.prototype.retries = null;

            /**
             * TaskMetadata discoveryVersion.
             * @member {string} discoveryVersion
             * @memberof flyteidl.core.TaskMetadata
             * @instance
             */
            TaskMetadata.prototype.discoveryVersion = "";

            /**
             * TaskMetadata deprecatedErrorMessage.
             * @member {string} deprecatedErrorMessage
             * @memberof flyteidl.core.TaskMetadata
             * @instance
             */
            TaskMetadata.prototype.deprecatedErrorMessage = "";

            /**
             * TaskMetadata interruptible.
             * @member {boolean} interruptible
             * @memberof flyteidl.core.TaskMetadata
             * @instance
             */
            TaskMetadata.prototype.interruptible = false;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * TaskMetadata interruptibleValue.
             * @member {"interruptible"|undefined} interruptibleValue
             * @memberof flyteidl.core.TaskMetadata
             * @instance
             */
            Object.defineProperty(TaskMetadata.prototype, "interruptibleValue", {
                get: $util.oneOfGetter($oneOfFields = ["interruptible"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new TaskMetadata instance using the specified properties.
             * @function create
             * @memberof flyteidl.core.TaskMetadata
             * @static
             * @param {flyteidl.core.ITaskMetadata=} [properties] Properties to set
             * @returns {flyteidl.core.TaskMetadata} TaskMetadata instance
             */
            TaskMetadata.create = function create(properties) {
                return new TaskMetadata(properties);
            };

            /**
             * Encodes the specified TaskMetadata message. Does not implicitly {@link flyteidl.core.TaskMetadata.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.core.TaskMetadata
             * @static
             * @param {flyteidl.core.ITaskMetadata} message TaskMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TaskMetadata.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.discoverable != null && message.hasOwnProperty("discoverable"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.discoverable);
                if (message.runtime != null && message.hasOwnProperty("runtime"))
                    $root.flyteidl.core.RuntimeMetadata.encode(message.runtime, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.timeout != null && message.hasOwnProperty("timeout"))
                    $root.google.protobuf.Duration.encode(message.timeout, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.retries != null && message.hasOwnProperty("retries"))
                    $root.flyteidl.core.RetryStrategy.encode(message.retries, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.discoveryVersion != null && message.hasOwnProperty("discoveryVersion"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.discoveryVersion);
                if (message.deprecatedErrorMessage != null && message.hasOwnProperty("deprecatedErrorMessage"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.deprecatedErrorMessage);
                if (message.interruptible != null && message.hasOwnProperty("interruptible"))
                    writer.uint32(/* id 8, wireType 0 =*/64).bool(message.interruptible);
                return writer;
            };

            /**
             * Decodes a TaskMetadata message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.core.TaskMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.core.TaskMetadata} TaskMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TaskMetadata.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.core.TaskMetadata();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.discoverable = reader.bool();
                        break;
                    case 2:
                        message.runtime = $root.flyteidl.core.RuntimeMetadata.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.timeout = $root.google.protobuf.Duration.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.retries = $root.flyteidl.core.RetryStrategy.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.discoveryVersion = reader.string();
                        break;
                    case 7:
                        message.deprecatedErrorMessage = reader.string();
                        break;
                    case 8:
                        message.interruptible = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a TaskMetadata message.
             * @function verify
             * @memberof flyteidl.core.TaskMetadata
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TaskMetadata.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.discoverable != null && message.hasOwnProperty("discoverable"))
                    if (typeof message.discoverable !== "boolean")
                        return "discoverable: boolean expected";
                if (message.runtime != null && message.hasOwnProperty("runtime")) {
                    let error = $root.flyteidl.core.RuntimeMetadata.verify(message.runtime);
                    if (error)
                        return "runtime." + error;
                }
                if (message.timeout != null && message.hasOwnProperty("timeout")) {
                    let error = $root.google.protobuf.Duration.verify(message.timeout);
                    if (error)
                        return "timeout." + error;
                }
                if (message.retries != null && message.hasOwnProperty("retries")) {
                    let error = $root.flyteidl.core.RetryStrategy.verify(message.retries);
                    if (error)
                        return "retries." + error;
                }
                if (message.discoveryVersion != null && message.hasOwnProperty("discoveryVersion"))
                    if (!$util.isString(message.discoveryVersion))
                        return "discoveryVersion: string expected";
                if (message.deprecatedErrorMessage != null && message.hasOwnProperty("deprecatedErrorMessage"))
                    if (!$util.isString(message.deprecatedErrorMessage))
                        return "deprecatedErrorMessage: string expected";
                if (message.interruptible != null && message.hasOwnProperty("interruptible")) {
                    properties.interruptibleValue = 1;
                    if (typeof message.interruptible !== "boolean")
                        return "interruptible: boolean expected";
                }
                return null;
            };

            return TaskMetadata;
        })();

        core.TaskTemplate = (function() {

            /**
             * Properties of a TaskTemplate.
             * @memberof flyteidl.core
             * @interface ITaskTemplate
             * @property {flyteidl.core.IIdentifier|null} [id] TaskTemplate id
             * @property {string|null} [type] TaskTemplate type
             * @property {flyteidl.core.ITaskMetadata|null} [metadata] TaskTemplate metadata
             * @property {flyteidl.core.ITypedInterface|null} ["interface"] TaskTemplate interface
             * @property {google.protobuf.IStruct|null} [custom] TaskTemplate custom
             * @property {flyteidl.core.IContainer|null} [container] TaskTemplate container
             */

            /**
             * Constructs a new TaskTemplate.
             * @memberof flyteidl.core
             * @classdesc Represents a TaskTemplate.
             * @implements ITaskTemplate
             * @constructor
             * @param {flyteidl.core.ITaskTemplate=} [properties] Properties to set
             */
            function TaskTemplate(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TaskTemplate id.
             * @member {flyteidl.core.IIdentifier|null|undefined} id
             * @memberof flyteidl.core.TaskTemplate
             * @instance
             */
            TaskTemplate.prototype.id = null;

            /**
             * TaskTemplate type.
             * @member {string} type
             * @memberof flyteidl.core.TaskTemplate
             * @instance
             */
            TaskTemplate.prototype.type = "";

            /**
             * TaskTemplate metadata.
             * @member {flyteidl.core.ITaskMetadata|null|undefined} metadata
             * @memberof flyteidl.core.TaskTemplate
             * @instance
             */
            TaskTemplate.prototype.metadata = null;

            /**
             * TaskTemplate interface.
             * @member {flyteidl.core.ITypedInterface|null|undefined} interface
             * @memberof flyteidl.core.TaskTemplate
             * @instance
             */
            TaskTemplate.prototype["interface"] = null;

            /**
             * TaskTemplate custom.
             * @member {google.protobuf.IStruct|null|undefined} custom
             * @memberof flyteidl.core.TaskTemplate
             * @instance
             */
            TaskTemplate.prototype.custom = null;

            /**
             * TaskTemplate container.
             * @member {flyteidl.core.IContainer|null|undefined} container
             * @memberof flyteidl.core.TaskTemplate
             * @instance
             */
            TaskTemplate.prototype.container = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * TaskTemplate target.
             * @member {"container"|undefined} target
             * @memberof flyteidl.core.TaskTemplate
             * @instance
             */
            Object.defineProperty(TaskTemplate.prototype, "target", {
                get: $util.oneOfGetter($oneOfFields = ["container"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new TaskTemplate instance using the specified properties.
             * @function create
             * @memberof flyteidl.core.TaskTemplate
             * @static
             * @param {flyteidl.core.ITaskTemplate=} [properties] Properties to set
             * @returns {flyteidl.core.TaskTemplate} TaskTemplate instance
             */
            TaskTemplate.create = function create(properties) {
                return new TaskTemplate(properties);
            };

            /**
             * Encodes the specified TaskTemplate message. Does not implicitly {@link flyteidl.core.TaskTemplate.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.core.TaskTemplate
             * @static
             * @param {flyteidl.core.ITaskTemplate} message TaskTemplate message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TaskTemplate.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    $root.flyteidl.core.Identifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.type != null && message.hasOwnProperty("type"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.type);
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    $root.flyteidl.core.TaskMetadata.encode(message.metadata, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message["interface"] != null && message.hasOwnProperty("interface"))
                    $root.flyteidl.core.TypedInterface.encode(message["interface"], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.custom != null && message.hasOwnProperty("custom"))
                    $root.google.protobuf.Struct.encode(message.custom, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.container != null && message.hasOwnProperty("container"))
                    $root.flyteidl.core.Container.encode(message.container, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a TaskTemplate message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.core.TaskTemplate
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.core.TaskTemplate} TaskTemplate
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TaskTemplate.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.core.TaskTemplate();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = $root.flyteidl.core.Identifier.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.type = reader.string();
                        break;
                    case 3:
                        message.metadata = $root.flyteidl.core.TaskMetadata.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message["interface"] = $root.flyteidl.core.TypedInterface.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.custom = $root.google.protobuf.Struct.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.container = $root.flyteidl.core.Container.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a TaskTemplate message.
             * @function verify
             * @memberof flyteidl.core.TaskTemplate
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TaskTemplate.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.id != null && message.hasOwnProperty("id")) {
                    let error = $root.flyteidl.core.Identifier.verify(message.id);
                    if (error)
                        return "id." + error;
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    if (!$util.isString(message.type))
                        return "type: string expected";
                if (message.metadata != null && message.hasOwnProperty("metadata")) {
                    let error = $root.flyteidl.core.TaskMetadata.verify(message.metadata);
                    if (error)
                        return "metadata." + error;
                }
                if (message["interface"] != null && message.hasOwnProperty("interface")) {
                    let error = $root.flyteidl.core.TypedInterface.verify(message["interface"]);
                    if (error)
                        return "interface." + error;
                }
                if (message.custom != null && message.hasOwnProperty("custom")) {
                    let error = $root.google.protobuf.Struct.verify(message.custom);
                    if (error)
                        return "custom." + error;
                }
                if (message.container != null && message.hasOwnProperty("container")) {
                    properties.target = 1;
                    {
                        let error = $root.flyteidl.core.Container.verify(message.container);
                        if (error)
                            return "container." + error;
                    }
                }
                return null;
            };

            return TaskTemplate;
        })();

        core.ContainerPort = (function() {

            /**
             * Properties of a ContainerPort.
             * @memberof flyteidl.core
             * @interface IContainerPort
             * @property {number|null} [containerPort] ContainerPort containerPort
             */

            /**
             * Constructs a new ContainerPort.
             * @memberof flyteidl.core
             * @classdesc Represents a ContainerPort.
             * @implements IContainerPort
             * @constructor
             * @param {flyteidl.core.IContainerPort=} [properties] Properties to set
             */
            function ContainerPort(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ContainerPort containerPort.
             * @member {number} containerPort
             * @memberof flyteidl.core.ContainerPort
             * @instance
             */
            ContainerPort.prototype.containerPort = 0;

            /**
             * Creates a new ContainerPort instance using the specified properties.
             * @function create
             * @memberof flyteidl.core.ContainerPort
             * @static
             * @param {flyteidl.core.IContainerPort=} [properties] Properties to set
             * @returns {flyteidl.core.ContainerPort} ContainerPort instance
             */
            ContainerPort.create = function create(properties) {
                return new ContainerPort(properties);
            };

            /**
             * Encodes the specified ContainerPort message. Does not implicitly {@link flyteidl.core.ContainerPort.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.core.ContainerPort
             * @static
             * @param {flyteidl.core.IContainerPort} message ContainerPort message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ContainerPort.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.containerPort != null && message.hasOwnProperty("containerPort"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.containerPort);
                return writer;
            };

            /**
             * Decodes a ContainerPort message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.core.ContainerPort
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.core.ContainerPort} ContainerPort
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ContainerPort.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.core.ContainerPort();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.containerPort = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a ContainerPort message.
             * @function verify
             * @memberof flyteidl.core.ContainerPort
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ContainerPort.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.containerPort != null && message.hasOwnProperty("containerPort"))
                    if (!$util.isInteger(message.containerPort))
                        return "containerPort: integer expected";
                return null;
            };

            return ContainerPort;
        })();

        core.Container = (function() {

            /**
             * Properties of a Container.
             * @memberof flyteidl.core
             * @interface IContainer
             * @property {string|null} [image] Container image
             * @property {Array.<string>|null} [command] Container command
             * @property {Array.<string>|null} [args] Container args
             * @property {flyteidl.core.IResources|null} [resources] Container resources
             * @property {Array.<flyteidl.core.IKeyValuePair>|null} [env] Container env
             * @property {Array.<flyteidl.core.IKeyValuePair>|null} [config] Container config
             * @property {Array.<flyteidl.core.IContainerPort>|null} [ports] Container ports
             */

            /**
             * Constructs a new Container.
             * @memberof flyteidl.core
             * @classdesc Represents a Container.
             * @implements IContainer
             * @constructor
             * @param {flyteidl.core.IContainer=} [properties] Properties to set
             */
            function Container(properties) {
                this.command = [];
                this.args = [];
                this.env = [];
                this.config = [];
                this.ports = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Container image.
             * @member {string} image
             * @memberof flyteidl.core.Container
             * @instance
             */
            Container.prototype.image = "";

            /**
             * Container command.
             * @member {Array.<string>} command
             * @memberof flyteidl.core.Container
             * @instance
             */
            Container.prototype.command = $util.emptyArray;

            /**
             * Container args.
             * @member {Array.<string>} args
             * @memberof flyteidl.core.Container
             * @instance
             */
            Container.prototype.args = $util.emptyArray;

            /**
             * Container resources.
             * @member {flyteidl.core.IResources|null|undefined} resources
             * @memberof flyteidl.core.Container
             * @instance
             */
            Container.prototype.resources = null;

            /**
             * Container env.
             * @member {Array.<flyteidl.core.IKeyValuePair>} env
             * @memberof flyteidl.core.Container
             * @instance
             */
            Container.prototype.env = $util.emptyArray;

            /**
             * Container config.
             * @member {Array.<flyteidl.core.IKeyValuePair>} config
             * @memberof flyteidl.core.Container
             * @instance
             */
            Container.prototype.config = $util.emptyArray;

            /**
             * Container ports.
             * @member {Array.<flyteidl.core.IContainerPort>} ports
             * @memberof flyteidl.core.Container
             * @instance
             */
            Container.prototype.ports = $util.emptyArray;

            /**
             * Creates a new Container instance using the specified properties.
             * @function create
             * @memberof flyteidl.core.Container
             * @static
             * @param {flyteidl.core.IContainer=} [properties] Properties to set
             * @returns {flyteidl.core.Container} Container instance
             */
            Container.create = function create(properties) {
                return new Container(properties);
            };

            /**
             * Encodes the specified Container message. Does not implicitly {@link flyteidl.core.Container.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.core.Container
             * @static
             * @param {flyteidl.core.IContainer} message Container message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Container.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.image != null && message.hasOwnProperty("image"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.image);
                if (message.command != null && message.command.length)
                    for (let i = 0; i < message.command.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.command[i]);
                if (message.args != null && message.args.length)
                    for (let i = 0; i < message.args.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.args[i]);
                if (message.resources != null && message.hasOwnProperty("resources"))
                    $root.flyteidl.core.Resources.encode(message.resources, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.env != null && message.env.length)
                    for (let i = 0; i < message.env.length; ++i)
                        $root.flyteidl.core.KeyValuePair.encode(message.env[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.config != null && message.config.length)
                    for (let i = 0; i < message.config.length; ++i)
                        $root.flyteidl.core.KeyValuePair.encode(message.config[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.ports != null && message.ports.length)
                    for (let i = 0; i < message.ports.length; ++i)
                        $root.flyteidl.core.ContainerPort.encode(message.ports[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a Container message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.core.Container
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.core.Container} Container
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Container.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.core.Container();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.image = reader.string();
                        break;
                    case 2:
                        if (!(message.command && message.command.length))
                            message.command = [];
                        message.command.push(reader.string());
                        break;
                    case 3:
                        if (!(message.args && message.args.length))
                            message.args = [];
                        message.args.push(reader.string());
                        break;
                    case 4:
                        message.resources = $root.flyteidl.core.Resources.decode(reader, reader.uint32());
                        break;
                    case 5:
                        if (!(message.env && message.env.length))
                            message.env = [];
                        message.env.push($root.flyteidl.core.KeyValuePair.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        if (!(message.config && message.config.length))
                            message.config = [];
                        message.config.push($root.flyteidl.core.KeyValuePair.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        if (!(message.ports && message.ports.length))
                            message.ports = [];
                        message.ports.push($root.flyteidl.core.ContainerPort.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a Container message.
             * @function verify
             * @memberof flyteidl.core.Container
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Container.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.image != null && message.hasOwnProperty("image"))
                    if (!$util.isString(message.image))
                        return "image: string expected";
                if (message.command != null && message.hasOwnProperty("command")) {
                    if (!Array.isArray(message.command))
                        return "command: array expected";
                    for (let i = 0; i < message.command.length; ++i)
                        if (!$util.isString(message.command[i]))
                            return "command: string[] expected";
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    if (!Array.isArray(message.args))
                        return "args: array expected";
                    for (let i = 0; i < message.args.length; ++i)
                        if (!$util.isString(message.args[i]))
                            return "args: string[] expected";
                }
                if (message.resources != null && message.hasOwnProperty("resources")) {
                    let error = $root.flyteidl.core.Resources.verify(message.resources);
                    if (error)
                        return "resources." + error;
                }
                if (message.env != null && message.hasOwnProperty("env")) {
                    if (!Array.isArray(message.env))
                        return "env: array expected";
                    for (let i = 0; i < message.env.length; ++i) {
                        let error = $root.flyteidl.core.KeyValuePair.verify(message.env[i]);
                        if (error)
                            return "env." + error;
                    }
                }
                if (message.config != null && message.hasOwnProperty("config")) {
                    if (!Array.isArray(message.config))
                        return "config: array expected";
                    for (let i = 0; i < message.config.length; ++i) {
                        let error = $root.flyteidl.core.KeyValuePair.verify(message.config[i]);
                        if (error)
                            return "config." + error;
                    }
                }
                if (message.ports != null && message.hasOwnProperty("ports")) {
                    if (!Array.isArray(message.ports))
                        return "ports: array expected";
                    for (let i = 0; i < message.ports.length; ++i) {
                        let error = $root.flyteidl.core.ContainerPort.verify(message.ports[i]);
                        if (error)
                            return "ports." + error;
                    }
                }
                return null;
            };

            return Container;
        })();

        core.DynamicJobSpec = (function() {

            /**
             * Properties of a DynamicJobSpec.
             * @memberof flyteidl.core
             * @interface IDynamicJobSpec
             * @property {Array.<flyteidl.core.INode>|null} [nodes] DynamicJobSpec nodes
             * @property {Long|null} [minSuccesses] DynamicJobSpec minSuccesses
             * @property {Array.<flyteidl.core.IBinding>|null} [outputs] DynamicJobSpec outputs
             * @property {Array.<flyteidl.core.ITaskTemplate>|null} [tasks] DynamicJobSpec tasks
             * @property {Array.<flyteidl.core.IWorkflowTemplate>|null} [subworkflows] DynamicJobSpec subworkflows
             */

            /**
             * Constructs a new DynamicJobSpec.
             * @memberof flyteidl.core
             * @classdesc Represents a DynamicJobSpec.
             * @implements IDynamicJobSpec
             * @constructor
             * @param {flyteidl.core.IDynamicJobSpec=} [properties] Properties to set
             */
            function DynamicJobSpec(properties) {
                this.nodes = [];
                this.outputs = [];
                this.tasks = [];
                this.subworkflows = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DynamicJobSpec nodes.
             * @member {Array.<flyteidl.core.INode>} nodes
             * @memberof flyteidl.core.DynamicJobSpec
             * @instance
             */
            DynamicJobSpec.prototype.nodes = $util.emptyArray;

            /**
             * DynamicJobSpec minSuccesses.
             * @member {Long} minSuccesses
             * @memberof flyteidl.core.DynamicJobSpec
             * @instance
             */
            DynamicJobSpec.prototype.minSuccesses = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * DynamicJobSpec outputs.
             * @member {Array.<flyteidl.core.IBinding>} outputs
             * @memberof flyteidl.core.DynamicJobSpec
             * @instance
             */
            DynamicJobSpec.prototype.outputs = $util.emptyArray;

            /**
             * DynamicJobSpec tasks.
             * @member {Array.<flyteidl.core.ITaskTemplate>} tasks
             * @memberof flyteidl.core.DynamicJobSpec
             * @instance
             */
            DynamicJobSpec.prototype.tasks = $util.emptyArray;

            /**
             * DynamicJobSpec subworkflows.
             * @member {Array.<flyteidl.core.IWorkflowTemplate>} subworkflows
             * @memberof flyteidl.core.DynamicJobSpec
             * @instance
             */
            DynamicJobSpec.prototype.subworkflows = $util.emptyArray;

            /**
             * Creates a new DynamicJobSpec instance using the specified properties.
             * @function create
             * @memberof flyteidl.core.DynamicJobSpec
             * @static
             * @param {flyteidl.core.IDynamicJobSpec=} [properties] Properties to set
             * @returns {flyteidl.core.DynamicJobSpec} DynamicJobSpec instance
             */
            DynamicJobSpec.create = function create(properties) {
                return new DynamicJobSpec(properties);
            };

            /**
             * Encodes the specified DynamicJobSpec message. Does not implicitly {@link flyteidl.core.DynamicJobSpec.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.core.DynamicJobSpec
             * @static
             * @param {flyteidl.core.IDynamicJobSpec} message DynamicJobSpec message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicJobSpec.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.nodes != null && message.nodes.length)
                    for (let i = 0; i < message.nodes.length; ++i)
                        $root.flyteidl.core.Node.encode(message.nodes[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.minSuccesses != null && message.hasOwnProperty("minSuccesses"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.minSuccesses);
                if (message.outputs != null && message.outputs.length)
                    for (let i = 0; i < message.outputs.length; ++i)
                        $root.flyteidl.core.Binding.encode(message.outputs[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.tasks != null && message.tasks.length)
                    for (let i = 0; i < message.tasks.length; ++i)
                        $root.flyteidl.core.TaskTemplate.encode(message.tasks[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.subworkflows != null && message.subworkflows.length)
                    for (let i = 0; i < message.subworkflows.length; ++i)
                        $root.flyteidl.core.WorkflowTemplate.encode(message.subworkflows[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a DynamicJobSpec message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.core.DynamicJobSpec
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.core.DynamicJobSpec} DynamicJobSpec
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicJobSpec.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.core.DynamicJobSpec();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.nodes && message.nodes.length))
                            message.nodes = [];
                        message.nodes.push($root.flyteidl.core.Node.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        message.minSuccesses = reader.int64();
                        break;
                    case 3:
                        if (!(message.outputs && message.outputs.length))
                            message.outputs = [];
                        message.outputs.push($root.flyteidl.core.Binding.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        if (!(message.tasks && message.tasks.length))
                            message.tasks = [];
                        message.tasks.push($root.flyteidl.core.TaskTemplate.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        if (!(message.subworkflows && message.subworkflows.length))
                            message.subworkflows = [];
                        message.subworkflows.push($root.flyteidl.core.WorkflowTemplate.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a DynamicJobSpec message.
             * @function verify
             * @memberof flyteidl.core.DynamicJobSpec
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DynamicJobSpec.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.nodes != null && message.hasOwnProperty("nodes")) {
                    if (!Array.isArray(message.nodes))
                        return "nodes: array expected";
                    for (let i = 0; i < message.nodes.length; ++i) {
                        let error = $root.flyteidl.core.Node.verify(message.nodes[i]);
                        if (error)
                            return "nodes." + error;
                    }
                }
                if (message.minSuccesses != null && message.hasOwnProperty("minSuccesses"))
                    if (!$util.isInteger(message.minSuccesses) && !(message.minSuccesses && $util.isInteger(message.minSuccesses.low) && $util.isInteger(message.minSuccesses.high)))
                        return "minSuccesses: integer|Long expected";
                if (message.outputs != null && message.hasOwnProperty("outputs")) {
                    if (!Array.isArray(message.outputs))
                        return "outputs: array expected";
                    for (let i = 0; i < message.outputs.length; ++i) {
                        let error = $root.flyteidl.core.Binding.verify(message.outputs[i]);
                        if (error)
                            return "outputs." + error;
                    }
                }
                if (message.tasks != null && message.hasOwnProperty("tasks")) {
                    if (!Array.isArray(message.tasks))
                        return "tasks: array expected";
                    for (let i = 0; i < message.tasks.length; ++i) {
                        let error = $root.flyteidl.core.TaskTemplate.verify(message.tasks[i]);
                        if (error)
                            return "tasks." + error;
                    }
                }
                if (message.subworkflows != null && message.hasOwnProperty("subworkflows")) {
                    if (!Array.isArray(message.subworkflows))
                        return "subworkflows: array expected";
                    for (let i = 0; i < message.subworkflows.length; ++i) {
                        let error = $root.flyteidl.core.WorkflowTemplate.verify(message.subworkflows[i]);
                        if (error)
                            return "subworkflows." + error;
                    }
                }
                return null;
            };

            return DynamicJobSpec;
        })();

        core.ContainerError = (function() {

            /**
             * Properties of a ContainerError.
             * @memberof flyteidl.core
             * @interface IContainerError
             * @property {string|null} [code] ContainerError code
             * @property {string|null} [message] ContainerError message
             * @property {flyteidl.core.ContainerError.Kind|null} [kind] ContainerError kind
             * @property {flyteidl.core.ExecutionError.ErrorKind|null} [origin] ContainerError origin
             */

            /**
             * Constructs a new ContainerError.
             * @memberof flyteidl.core
             * @classdesc Represents a ContainerError.
             * @implements IContainerError
             * @constructor
             * @param {flyteidl.core.IContainerError=} [properties] Properties to set
             */
            function ContainerError(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ContainerError code.
             * @member {string} code
             * @memberof flyteidl.core.ContainerError
             * @instance
             */
            ContainerError.prototype.code = "";

            /**
             * ContainerError message.
             * @member {string} message
             * @memberof flyteidl.core.ContainerError
             * @instance
             */
            ContainerError.prototype.message = "";

            /**
             * ContainerError kind.
             * @member {flyteidl.core.ContainerError.Kind} kind
             * @memberof flyteidl.core.ContainerError
             * @instance
             */
            ContainerError.prototype.kind = 0;

            /**
             * ContainerError origin.
             * @member {flyteidl.core.ExecutionError.ErrorKind} origin
             * @memberof flyteidl.core.ContainerError
             * @instance
             */
            ContainerError.prototype.origin = 0;

            /**
             * Creates a new ContainerError instance using the specified properties.
             * @function create
             * @memberof flyteidl.core.ContainerError
             * @static
             * @param {flyteidl.core.IContainerError=} [properties] Properties to set
             * @returns {flyteidl.core.ContainerError} ContainerError instance
             */
            ContainerError.create = function create(properties) {
                return new ContainerError(properties);
            };

            /**
             * Encodes the specified ContainerError message. Does not implicitly {@link flyteidl.core.ContainerError.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.core.ContainerError
             * @static
             * @param {flyteidl.core.IContainerError} message ContainerError message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ContainerError.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.code != null && message.hasOwnProperty("code"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.code);
                if (message.message != null && message.hasOwnProperty("message"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.message);
                if (message.kind != null && message.hasOwnProperty("kind"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.kind);
                if (message.origin != null && message.hasOwnProperty("origin"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.origin);
                return writer;
            };

            /**
             * Decodes a ContainerError message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.core.ContainerError
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.core.ContainerError} ContainerError
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ContainerError.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.core.ContainerError();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.code = reader.string();
                        break;
                    case 2:
                        message.message = reader.string();
                        break;
                    case 3:
                        message.kind = reader.int32();
                        break;
                    case 4:
                        message.origin = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a ContainerError message.
             * @function verify
             * @memberof flyteidl.core.ContainerError
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ContainerError.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.code != null && message.hasOwnProperty("code"))
                    if (!$util.isString(message.code))
                        return "code: string expected";
                if (message.message != null && message.hasOwnProperty("message"))
                    if (!$util.isString(message.message))
                        return "message: string expected";
                if (message.kind != null && message.hasOwnProperty("kind"))
                    switch (message.kind) {
                    default:
                        return "kind: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                if (message.origin != null && message.hasOwnProperty("origin"))
                    switch (message.origin) {
                    default:
                        return "origin: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                return null;
            };

            /**
             * Kind enum.
             * @name flyteidl.core.ContainerError.Kind
             * @enum {string}
             * @property {number} NON_RECOVERABLE=0 NON_RECOVERABLE value
             * @property {number} RECOVERABLE=1 RECOVERABLE value
             */
            ContainerError.Kind = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "NON_RECOVERABLE"] = 0;
                values[valuesById[1] = "RECOVERABLE"] = 1;
                return values;
            })();

            return ContainerError;
        })();

        core.ErrorDocument = (function() {

            /**
             * Properties of an ErrorDocument.
             * @memberof flyteidl.core
             * @interface IErrorDocument
             * @property {flyteidl.core.IContainerError|null} [error] ErrorDocument error
             */

            /**
             * Constructs a new ErrorDocument.
             * @memberof flyteidl.core
             * @classdesc Represents an ErrorDocument.
             * @implements IErrorDocument
             * @constructor
             * @param {flyteidl.core.IErrorDocument=} [properties] Properties to set
             */
            function ErrorDocument(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ErrorDocument error.
             * @member {flyteidl.core.IContainerError|null|undefined} error
             * @memberof flyteidl.core.ErrorDocument
             * @instance
             */
            ErrorDocument.prototype.error = null;

            /**
             * Creates a new ErrorDocument instance using the specified properties.
             * @function create
             * @memberof flyteidl.core.ErrorDocument
             * @static
             * @param {flyteidl.core.IErrorDocument=} [properties] Properties to set
             * @returns {flyteidl.core.ErrorDocument} ErrorDocument instance
             */
            ErrorDocument.create = function create(properties) {
                return new ErrorDocument(properties);
            };

            /**
             * Encodes the specified ErrorDocument message. Does not implicitly {@link flyteidl.core.ErrorDocument.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.core.ErrorDocument
             * @static
             * @param {flyteidl.core.IErrorDocument} message ErrorDocument message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ErrorDocument.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.error != null && message.hasOwnProperty("error"))
                    $root.flyteidl.core.ContainerError.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes an ErrorDocument message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.core.ErrorDocument
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.core.ErrorDocument} ErrorDocument
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ErrorDocument.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.core.ErrorDocument();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.error = $root.flyteidl.core.ContainerError.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies an ErrorDocument message.
             * @function verify
             * @memberof flyteidl.core.ErrorDocument
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ErrorDocument.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.error != null && message.hasOwnProperty("error")) {
                    let error = $root.flyteidl.core.ContainerError.verify(message.error);
                    if (error)
                        return "error." + error;
                }
                return null;
            };

            return ErrorDocument;
        })();

        core.WorkflowExecution = (function() {

            /**
             * Properties of a WorkflowExecution.
             * @memberof flyteidl.core
             * @interface IWorkflowExecution
             */

            /**
             * Constructs a new WorkflowExecution.
             * @memberof flyteidl.core
             * @classdesc Represents a WorkflowExecution.
             * @implements IWorkflowExecution
             * @constructor
             * @param {flyteidl.core.IWorkflowExecution=} [properties] Properties to set
             */
            function WorkflowExecution(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new WorkflowExecution instance using the specified properties.
             * @function create
             * @memberof flyteidl.core.WorkflowExecution
             * @static
             * @param {flyteidl.core.IWorkflowExecution=} [properties] Properties to set
             * @returns {flyteidl.core.WorkflowExecution} WorkflowExecution instance
             */
            WorkflowExecution.create = function create(properties) {
                return new WorkflowExecution(properties);
            };

            /**
             * Encodes the specified WorkflowExecution message. Does not implicitly {@link flyteidl.core.WorkflowExecution.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.core.WorkflowExecution
             * @static
             * @param {flyteidl.core.IWorkflowExecution} message WorkflowExecution message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WorkflowExecution.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Decodes a WorkflowExecution message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.core.WorkflowExecution
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.core.WorkflowExecution} WorkflowExecution
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WorkflowExecution.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.core.WorkflowExecution();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a WorkflowExecution message.
             * @function verify
             * @memberof flyteidl.core.WorkflowExecution
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WorkflowExecution.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Phase enum.
             * @name flyteidl.core.WorkflowExecution.Phase
             * @enum {string}
             * @property {number} UNDEFINED=0 UNDEFINED value
             * @property {number} QUEUED=1 QUEUED value
             * @property {number} RUNNING=2 RUNNING value
             * @property {number} SUCCEEDING=3 SUCCEEDING value
             * @property {number} SUCCEEDED=4 SUCCEEDED value
             * @property {number} FAILING=5 FAILING value
             * @property {number} FAILED=6 FAILED value
             * @property {number} ABORTED=7 ABORTED value
             * @property {number} TIMED_OUT=8 TIMED_OUT value
             */
            WorkflowExecution.Phase = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNDEFINED"] = 0;
                values[valuesById[1] = "QUEUED"] = 1;
                values[valuesById[2] = "RUNNING"] = 2;
                values[valuesById[3] = "SUCCEEDING"] = 3;
                values[valuesById[4] = "SUCCEEDED"] = 4;
                values[valuesById[5] = "FAILING"] = 5;
                values[valuesById[6] = "FAILED"] = 6;
                values[valuesById[7] = "ABORTED"] = 7;
                values[valuesById[8] = "TIMED_OUT"] = 8;
                return values;
            })();

            return WorkflowExecution;
        })();

        core.NodeExecution = (function() {

            /**
             * Properties of a NodeExecution.
             * @memberof flyteidl.core
             * @interface INodeExecution
             */

            /**
             * Constructs a new NodeExecution.
             * @memberof flyteidl.core
             * @classdesc Represents a NodeExecution.
             * @implements INodeExecution
             * @constructor
             * @param {flyteidl.core.INodeExecution=} [properties] Properties to set
             */
            function NodeExecution(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new NodeExecution instance using the specified properties.
             * @function create
             * @memberof flyteidl.core.NodeExecution
             * @static
             * @param {flyteidl.core.INodeExecution=} [properties] Properties to set
             * @returns {flyteidl.core.NodeExecution} NodeExecution instance
             */
            NodeExecution.create = function create(properties) {
                return new NodeExecution(properties);
            };

            /**
             * Encodes the specified NodeExecution message. Does not implicitly {@link flyteidl.core.NodeExecution.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.core.NodeExecution
             * @static
             * @param {flyteidl.core.INodeExecution} message NodeExecution message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NodeExecution.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Decodes a NodeExecution message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.core.NodeExecution
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.core.NodeExecution} NodeExecution
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NodeExecution.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.core.NodeExecution();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a NodeExecution message.
             * @function verify
             * @memberof flyteidl.core.NodeExecution
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NodeExecution.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Phase enum.
             * @name flyteidl.core.NodeExecution.Phase
             * @enum {string}
             * @property {number} UNDEFINED=0 UNDEFINED value
             * @property {number} QUEUED=1 QUEUED value
             * @property {number} RUNNING=2 RUNNING value
             * @property {number} SUCCEEDED=3 SUCCEEDED value
             * @property {number} FAILING=4 FAILING value
             * @property {number} FAILED=5 FAILED value
             * @property {number} ABORTED=6 ABORTED value
             * @property {number} SKIPPED=7 SKIPPED value
             * @property {number} TIMED_OUT=8 TIMED_OUT value
             */
            NodeExecution.Phase = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNDEFINED"] = 0;
                values[valuesById[1] = "QUEUED"] = 1;
                values[valuesById[2] = "RUNNING"] = 2;
                values[valuesById[3] = "SUCCEEDED"] = 3;
                values[valuesById[4] = "FAILING"] = 4;
                values[valuesById[5] = "FAILED"] = 5;
                values[valuesById[6] = "ABORTED"] = 6;
                values[valuesById[7] = "SKIPPED"] = 7;
                values[valuesById[8] = "TIMED_OUT"] = 8;
                return values;
            })();

            return NodeExecution;
        })();

        core.TaskExecution = (function() {

            /**
             * Properties of a TaskExecution.
             * @memberof flyteidl.core
             * @interface ITaskExecution
             */

            /**
             * Constructs a new TaskExecution.
             * @memberof flyteidl.core
             * @classdesc Represents a TaskExecution.
             * @implements ITaskExecution
             * @constructor
             * @param {flyteidl.core.ITaskExecution=} [properties] Properties to set
             */
            function TaskExecution(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new TaskExecution instance using the specified properties.
             * @function create
             * @memberof flyteidl.core.TaskExecution
             * @static
             * @param {flyteidl.core.ITaskExecution=} [properties] Properties to set
             * @returns {flyteidl.core.TaskExecution} TaskExecution instance
             */
            TaskExecution.create = function create(properties) {
                return new TaskExecution(properties);
            };

            /**
             * Encodes the specified TaskExecution message. Does not implicitly {@link flyteidl.core.TaskExecution.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.core.TaskExecution
             * @static
             * @param {flyteidl.core.ITaskExecution} message TaskExecution message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TaskExecution.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Decodes a TaskExecution message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.core.TaskExecution
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.core.TaskExecution} TaskExecution
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TaskExecution.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.core.TaskExecution();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a TaskExecution message.
             * @function verify
             * @memberof flyteidl.core.TaskExecution
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TaskExecution.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Phase enum.
             * @name flyteidl.core.TaskExecution.Phase
             * @enum {string}
             * @property {number} UNDEFINED=0 UNDEFINED value
             * @property {number} QUEUED=1 QUEUED value
             * @property {number} RUNNING=2 RUNNING value
             * @property {number} SUCCEEDED=3 SUCCEEDED value
             * @property {number} ABORTED=4 ABORTED value
             * @property {number} FAILED=5 FAILED value
             * @property {number} INITIALIZING=6 INITIALIZING value
             * @property {number} WAITING_FOR_RESOURCES=7 WAITING_FOR_RESOURCES value
             */
            TaskExecution.Phase = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNDEFINED"] = 0;
                values[valuesById[1] = "QUEUED"] = 1;
                values[valuesById[2] = "RUNNING"] = 2;
                values[valuesById[3] = "SUCCEEDED"] = 3;
                values[valuesById[4] = "ABORTED"] = 4;
                values[valuesById[5] = "FAILED"] = 5;
                values[valuesById[6] = "INITIALIZING"] = 6;
                values[valuesById[7] = "WAITING_FOR_RESOURCES"] = 7;
                return values;
            })();

            return TaskExecution;
        })();

        core.ExecutionError = (function() {

            /**
             * Properties of an ExecutionError.
             * @memberof flyteidl.core
             * @interface IExecutionError
             * @property {string|null} [code] ExecutionError code
             * @property {string|null} [message] ExecutionError message
             * @property {string|null} [errorUri] ExecutionError errorUri
             * @property {flyteidl.core.ExecutionError.ErrorKind|null} [kind] ExecutionError kind
             */

            /**
             * Constructs a new ExecutionError.
             * @memberof flyteidl.core
             * @classdesc Represents an ExecutionError.
             * @implements IExecutionError
             * @constructor
             * @param {flyteidl.core.IExecutionError=} [properties] Properties to set
             */
            function ExecutionError(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExecutionError code.
             * @member {string} code
             * @memberof flyteidl.core.ExecutionError
             * @instance
             */
            ExecutionError.prototype.code = "";

            /**
             * ExecutionError message.
             * @member {string} message
             * @memberof flyteidl.core.ExecutionError
             * @instance
             */
            ExecutionError.prototype.message = "";

            /**
             * ExecutionError errorUri.
             * @member {string} errorUri
             * @memberof flyteidl.core.ExecutionError
             * @instance
             */
            ExecutionError.prototype.errorUri = "";

            /**
             * ExecutionError kind.
             * @member {flyteidl.core.ExecutionError.ErrorKind} kind
             * @memberof flyteidl.core.ExecutionError
             * @instance
             */
            ExecutionError.prototype.kind = 0;

            /**
             * Creates a new ExecutionError instance using the specified properties.
             * @function create
             * @memberof flyteidl.core.ExecutionError
             * @static
             * @param {flyteidl.core.IExecutionError=} [properties] Properties to set
             * @returns {flyteidl.core.ExecutionError} ExecutionError instance
             */
            ExecutionError.create = function create(properties) {
                return new ExecutionError(properties);
            };

            /**
             * Encodes the specified ExecutionError message. Does not implicitly {@link flyteidl.core.ExecutionError.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.core.ExecutionError
             * @static
             * @param {flyteidl.core.IExecutionError} message ExecutionError message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecutionError.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.code != null && message.hasOwnProperty("code"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.code);
                if (message.message != null && message.hasOwnProperty("message"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.message);
                if (message.errorUri != null && message.hasOwnProperty("errorUri"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.errorUri);
                if (message.kind != null && message.hasOwnProperty("kind"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.kind);
                return writer;
            };

            /**
             * Decodes an ExecutionError message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.core.ExecutionError
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.core.ExecutionError} ExecutionError
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecutionError.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.core.ExecutionError();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.code = reader.string();
                        break;
                    case 2:
                        message.message = reader.string();
                        break;
                    case 3:
                        message.errorUri = reader.string();
                        break;
                    case 4:
                        message.kind = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies an ExecutionError message.
             * @function verify
             * @memberof flyteidl.core.ExecutionError
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExecutionError.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.code != null && message.hasOwnProperty("code"))
                    if (!$util.isString(message.code))
                        return "code: string expected";
                if (message.message != null && message.hasOwnProperty("message"))
                    if (!$util.isString(message.message))
                        return "message: string expected";
                if (message.errorUri != null && message.hasOwnProperty("errorUri"))
                    if (!$util.isString(message.errorUri))
                        return "errorUri: string expected";
                if (message.kind != null && message.hasOwnProperty("kind"))
                    switch (message.kind) {
                    default:
                        return "kind: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                return null;
            };

            /**
             * ErrorKind enum.
             * @name flyteidl.core.ExecutionError.ErrorKind
             * @enum {string}
             * @property {number} UNKNOWN=0 UNKNOWN value
             * @property {number} USER=1 USER value
             * @property {number} SYSTEM=2 SYSTEM value
             */
            ExecutionError.ErrorKind = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN"] = 0;
                values[valuesById[1] = "USER"] = 1;
                values[valuesById[2] = "SYSTEM"] = 2;
                return values;
            })();

            return ExecutionError;
        })();

        core.TaskLog = (function() {

            /**
             * Properties of a TaskLog.
             * @memberof flyteidl.core
             * @interface ITaskLog
             * @property {string|null} [uri] TaskLog uri
             * @property {string|null} [name] TaskLog name
             * @property {flyteidl.core.TaskLog.MessageFormat|null} [messageFormat] TaskLog messageFormat
             * @property {google.protobuf.IDuration|null} [ttl] TaskLog ttl
             */

            /**
             * Constructs a new TaskLog.
             * @memberof flyteidl.core
             * @classdesc Represents a TaskLog.
             * @implements ITaskLog
             * @constructor
             * @param {flyteidl.core.ITaskLog=} [properties] Properties to set
             */
            function TaskLog(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TaskLog uri.
             * @member {string} uri
             * @memberof flyteidl.core.TaskLog
             * @instance
             */
            TaskLog.prototype.uri = "";

            /**
             * TaskLog name.
             * @member {string} name
             * @memberof flyteidl.core.TaskLog
             * @instance
             */
            TaskLog.prototype.name = "";

            /**
             * TaskLog messageFormat.
             * @member {flyteidl.core.TaskLog.MessageFormat} messageFormat
             * @memberof flyteidl.core.TaskLog
             * @instance
             */
            TaskLog.prototype.messageFormat = 0;

            /**
             * TaskLog ttl.
             * @member {google.protobuf.IDuration|null|undefined} ttl
             * @memberof flyteidl.core.TaskLog
             * @instance
             */
            TaskLog.prototype.ttl = null;

            /**
             * Creates a new TaskLog instance using the specified properties.
             * @function create
             * @memberof flyteidl.core.TaskLog
             * @static
             * @param {flyteidl.core.ITaskLog=} [properties] Properties to set
             * @returns {flyteidl.core.TaskLog} TaskLog instance
             */
            TaskLog.create = function create(properties) {
                return new TaskLog(properties);
            };

            /**
             * Encodes the specified TaskLog message. Does not implicitly {@link flyteidl.core.TaskLog.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.core.TaskLog
             * @static
             * @param {flyteidl.core.ITaskLog} message TaskLog message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TaskLog.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uri != null && message.hasOwnProperty("uri"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.uri);
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                if (message.messageFormat != null && message.hasOwnProperty("messageFormat"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.messageFormat);
                if (message.ttl != null && message.hasOwnProperty("ttl"))
                    $root.google.protobuf.Duration.encode(message.ttl, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a TaskLog message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.core.TaskLog
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.core.TaskLog} TaskLog
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TaskLog.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.core.TaskLog();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.uri = reader.string();
                        break;
                    case 2:
                        message.name = reader.string();
                        break;
                    case 3:
                        message.messageFormat = reader.int32();
                        break;
                    case 4:
                        message.ttl = $root.google.protobuf.Duration.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a TaskLog message.
             * @function verify
             * @memberof flyteidl.core.TaskLog
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TaskLog.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.uri != null && message.hasOwnProperty("uri"))
                    if (!$util.isString(message.uri))
                        return "uri: string expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.messageFormat != null && message.hasOwnProperty("messageFormat"))
                    switch (message.messageFormat) {
                    default:
                        return "messageFormat: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.ttl != null && message.hasOwnProperty("ttl")) {
                    let error = $root.google.protobuf.Duration.verify(message.ttl);
                    if (error)
                        return "ttl." + error;
                }
                return null;
            };

            /**
             * MessageFormat enum.
             * @name flyteidl.core.TaskLog.MessageFormat
             * @enum {string}
             * @property {number} UNKNOWN=0 UNKNOWN value
             * @property {number} CSV=1 CSV value
             * @property {number} JSON=2 JSON value
             */
            TaskLog.MessageFormat = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN"] = 0;
                values[valuesById[1] = "CSV"] = 1;
                values[valuesById[2] = "JSON"] = 2;
                return values;
            })();

            return TaskLog;
        })();

        core.WorkflowClosure = (function() {

            /**
             * Properties of a WorkflowClosure.
             * @memberof flyteidl.core
             * @interface IWorkflowClosure
             * @property {flyteidl.core.IWorkflowTemplate|null} [workflow] WorkflowClosure workflow
             * @property {Array.<flyteidl.core.ITaskTemplate>|null} [tasks] WorkflowClosure tasks
             */

            /**
             * Constructs a new WorkflowClosure.
             * @memberof flyteidl.core
             * @classdesc Represents a WorkflowClosure.
             * @implements IWorkflowClosure
             * @constructor
             * @param {flyteidl.core.IWorkflowClosure=} [properties] Properties to set
             */
            function WorkflowClosure(properties) {
                this.tasks = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WorkflowClosure workflow.
             * @member {flyteidl.core.IWorkflowTemplate|null|undefined} workflow
             * @memberof flyteidl.core.WorkflowClosure
             * @instance
             */
            WorkflowClosure.prototype.workflow = null;

            /**
             * WorkflowClosure tasks.
             * @member {Array.<flyteidl.core.ITaskTemplate>} tasks
             * @memberof flyteidl.core.WorkflowClosure
             * @instance
             */
            WorkflowClosure.prototype.tasks = $util.emptyArray;

            /**
             * Creates a new WorkflowClosure instance using the specified properties.
             * @function create
             * @memberof flyteidl.core.WorkflowClosure
             * @static
             * @param {flyteidl.core.IWorkflowClosure=} [properties] Properties to set
             * @returns {flyteidl.core.WorkflowClosure} WorkflowClosure instance
             */
            WorkflowClosure.create = function create(properties) {
                return new WorkflowClosure(properties);
            };

            /**
             * Encodes the specified WorkflowClosure message. Does not implicitly {@link flyteidl.core.WorkflowClosure.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.core.WorkflowClosure
             * @static
             * @param {flyteidl.core.IWorkflowClosure} message WorkflowClosure message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WorkflowClosure.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.workflow != null && message.hasOwnProperty("workflow"))
                    $root.flyteidl.core.WorkflowTemplate.encode(message.workflow, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.tasks != null && message.tasks.length)
                    for (let i = 0; i < message.tasks.length; ++i)
                        $root.flyteidl.core.TaskTemplate.encode(message.tasks[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a WorkflowClosure message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.core.WorkflowClosure
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.core.WorkflowClosure} WorkflowClosure
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WorkflowClosure.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.core.WorkflowClosure();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.workflow = $root.flyteidl.core.WorkflowTemplate.decode(reader, reader.uint32());
                        break;
                    case 2:
                        if (!(message.tasks && message.tasks.length))
                            message.tasks = [];
                        message.tasks.push($root.flyteidl.core.TaskTemplate.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a WorkflowClosure message.
             * @function verify
             * @memberof flyteidl.core.WorkflowClosure
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WorkflowClosure.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.workflow != null && message.hasOwnProperty("workflow")) {
                    let error = $root.flyteidl.core.WorkflowTemplate.verify(message.workflow);
                    if (error)
                        return "workflow." + error;
                }
                if (message.tasks != null && message.hasOwnProperty("tasks")) {
                    if (!Array.isArray(message.tasks))
                        return "tasks: array expected";
                    for (let i = 0; i < message.tasks.length; ++i) {
                        let error = $root.flyteidl.core.TaskTemplate.verify(message.tasks[i]);
                        if (error)
                            return "tasks." + error;
                    }
                }
                return null;
            };

            return WorkflowClosure;
        })();

        return core;
    })();

    flyteidl.event = (function() {

        /**
         * Namespace event.
         * @memberof flyteidl
         * @namespace
         */
        const event = {};

        event.WorkflowExecutionEvent = (function() {

            /**
             * Properties of a WorkflowExecutionEvent.
             * @memberof flyteidl.event
             * @interface IWorkflowExecutionEvent
             * @property {flyteidl.core.IWorkflowExecutionIdentifier|null} [executionId] WorkflowExecutionEvent executionId
             * @property {string|null} [producerId] WorkflowExecutionEvent producerId
             * @property {flyteidl.core.WorkflowExecution.Phase|null} [phase] WorkflowExecutionEvent phase
             * @property {google.protobuf.ITimestamp|null} [occurredAt] WorkflowExecutionEvent occurredAt
             * @property {string|null} [outputUri] WorkflowExecutionEvent outputUri
             * @property {flyteidl.core.IExecutionError|null} [error] WorkflowExecutionEvent error
             */

            /**
             * Constructs a new WorkflowExecutionEvent.
             * @memberof flyteidl.event
             * @classdesc Represents a WorkflowExecutionEvent.
             * @implements IWorkflowExecutionEvent
             * @constructor
             * @param {flyteidl.event.IWorkflowExecutionEvent=} [properties] Properties to set
             */
            function WorkflowExecutionEvent(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WorkflowExecutionEvent executionId.
             * @member {flyteidl.core.IWorkflowExecutionIdentifier|null|undefined} executionId
             * @memberof flyteidl.event.WorkflowExecutionEvent
             * @instance
             */
            WorkflowExecutionEvent.prototype.executionId = null;

            /**
             * WorkflowExecutionEvent producerId.
             * @member {string} producerId
             * @memberof flyteidl.event.WorkflowExecutionEvent
             * @instance
             */
            WorkflowExecutionEvent.prototype.producerId = "";

            /**
             * WorkflowExecutionEvent phase.
             * @member {flyteidl.core.WorkflowExecution.Phase} phase
             * @memberof flyteidl.event.WorkflowExecutionEvent
             * @instance
             */
            WorkflowExecutionEvent.prototype.phase = 0;

            /**
             * WorkflowExecutionEvent occurredAt.
             * @member {google.protobuf.ITimestamp|null|undefined} occurredAt
             * @memberof flyteidl.event.WorkflowExecutionEvent
             * @instance
             */
            WorkflowExecutionEvent.prototype.occurredAt = null;

            /**
             * WorkflowExecutionEvent outputUri.
             * @member {string} outputUri
             * @memberof flyteidl.event.WorkflowExecutionEvent
             * @instance
             */
            WorkflowExecutionEvent.prototype.outputUri = "";

            /**
             * WorkflowExecutionEvent error.
             * @member {flyteidl.core.IExecutionError|null|undefined} error
             * @memberof flyteidl.event.WorkflowExecutionEvent
             * @instance
             */
            WorkflowExecutionEvent.prototype.error = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * WorkflowExecutionEvent outputResult.
             * @member {"outputUri"|"error"|undefined} outputResult
             * @memberof flyteidl.event.WorkflowExecutionEvent
             * @instance
             */
            Object.defineProperty(WorkflowExecutionEvent.prototype, "outputResult", {
                get: $util.oneOfGetter($oneOfFields = ["outputUri", "error"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new WorkflowExecutionEvent instance using the specified properties.
             * @function create
             * @memberof flyteidl.event.WorkflowExecutionEvent
             * @static
             * @param {flyteidl.event.IWorkflowExecutionEvent=} [properties] Properties to set
             * @returns {flyteidl.event.WorkflowExecutionEvent} WorkflowExecutionEvent instance
             */
            WorkflowExecutionEvent.create = function create(properties) {
                return new WorkflowExecutionEvent(properties);
            };

            /**
             * Encodes the specified WorkflowExecutionEvent message. Does not implicitly {@link flyteidl.event.WorkflowExecutionEvent.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.event.WorkflowExecutionEvent
             * @static
             * @param {flyteidl.event.IWorkflowExecutionEvent} message WorkflowExecutionEvent message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WorkflowExecutionEvent.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.executionId != null && message.hasOwnProperty("executionId"))
                    $root.flyteidl.core.WorkflowExecutionIdentifier.encode(message.executionId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.producerId != null && message.hasOwnProperty("producerId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.producerId);
                if (message.phase != null && message.hasOwnProperty("phase"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.phase);
                if (message.occurredAt != null && message.hasOwnProperty("occurredAt"))
                    $root.google.protobuf.Timestamp.encode(message.occurredAt, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.outputUri != null && message.hasOwnProperty("outputUri"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.outputUri);
                if (message.error != null && message.hasOwnProperty("error"))
                    $root.flyteidl.core.ExecutionError.encode(message.error, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a WorkflowExecutionEvent message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.event.WorkflowExecutionEvent
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.event.WorkflowExecutionEvent} WorkflowExecutionEvent
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WorkflowExecutionEvent.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.event.WorkflowExecutionEvent();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.executionId = $root.flyteidl.core.WorkflowExecutionIdentifier.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.producerId = reader.string();
                        break;
                    case 3:
                        message.phase = reader.int32();
                        break;
                    case 4:
                        message.occurredAt = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.outputUri = reader.string();
                        break;
                    case 6:
                        message.error = $root.flyteidl.core.ExecutionError.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a WorkflowExecutionEvent message.
             * @function verify
             * @memberof flyteidl.event.WorkflowExecutionEvent
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WorkflowExecutionEvent.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.executionId != null && message.hasOwnProperty("executionId")) {
                    let error = $root.flyteidl.core.WorkflowExecutionIdentifier.verify(message.executionId);
                    if (error)
                        return "executionId." + error;
                }
                if (message.producerId != null && message.hasOwnProperty("producerId"))
                    if (!$util.isString(message.producerId))
                        return "producerId: string expected";
                if (message.phase != null && message.hasOwnProperty("phase"))
                    switch (message.phase) {
                    default:
                        return "phase: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                        break;
                    }
                if (message.occurredAt != null && message.hasOwnProperty("occurredAt")) {
                    let error = $root.google.protobuf.Timestamp.verify(message.occurredAt);
                    if (error)
                        return "occurredAt." + error;
                }
                if (message.outputUri != null && message.hasOwnProperty("outputUri")) {
                    properties.outputResult = 1;
                    if (!$util.isString(message.outputUri))
                        return "outputUri: string expected";
                }
                if (message.error != null && message.hasOwnProperty("error")) {
                    if (properties.outputResult === 1)
                        return "outputResult: multiple values";
                    properties.outputResult = 1;
                    {
                        let error = $root.flyteidl.core.ExecutionError.verify(message.error);
                        if (error)
                            return "error." + error;
                    }
                }
                return null;
            };

            return WorkflowExecutionEvent;
        })();

        event.NodeExecutionEvent = (function() {

            /**
             * Properties of a NodeExecutionEvent.
             * @memberof flyteidl.event
             * @interface INodeExecutionEvent
             * @property {flyteidl.core.INodeExecutionIdentifier|null} [id] NodeExecutionEvent id
             * @property {string|null} [producerId] NodeExecutionEvent producerId
             * @property {flyteidl.core.NodeExecution.Phase|null} [phase] NodeExecutionEvent phase
             * @property {google.protobuf.ITimestamp|null} [occurredAt] NodeExecutionEvent occurredAt
             * @property {string|null} [inputUri] NodeExecutionEvent inputUri
             * @property {string|null} [outputUri] NodeExecutionEvent outputUri
             * @property {flyteidl.core.IExecutionError|null} [error] NodeExecutionEvent error
             * @property {flyteidl.event.IWorkflowNodeMetadata|null} [workflowNodeMetadata] NodeExecutionEvent workflowNodeMetadata
             * @property {flyteidl.event.IParentTaskExecutionMetadata|null} [parentTaskMetadata] NodeExecutionEvent parentTaskMetadata
             */

            /**
             * Constructs a new NodeExecutionEvent.
             * @memberof flyteidl.event
             * @classdesc Represents a NodeExecutionEvent.
             * @implements INodeExecutionEvent
             * @constructor
             * @param {flyteidl.event.INodeExecutionEvent=} [properties] Properties to set
             */
            function NodeExecutionEvent(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NodeExecutionEvent id.
             * @member {flyteidl.core.INodeExecutionIdentifier|null|undefined} id
             * @memberof flyteidl.event.NodeExecutionEvent
             * @instance
             */
            NodeExecutionEvent.prototype.id = null;

            /**
             * NodeExecutionEvent producerId.
             * @member {string} producerId
             * @memberof flyteidl.event.NodeExecutionEvent
             * @instance
             */
            NodeExecutionEvent.prototype.producerId = "";

            /**
             * NodeExecutionEvent phase.
             * @member {flyteidl.core.NodeExecution.Phase} phase
             * @memberof flyteidl.event.NodeExecutionEvent
             * @instance
             */
            NodeExecutionEvent.prototype.phase = 0;

            /**
             * NodeExecutionEvent occurredAt.
             * @member {google.protobuf.ITimestamp|null|undefined} occurredAt
             * @memberof flyteidl.event.NodeExecutionEvent
             * @instance
             */
            NodeExecutionEvent.prototype.occurredAt = null;

            /**
             * NodeExecutionEvent inputUri.
             * @member {string} inputUri
             * @memberof flyteidl.event.NodeExecutionEvent
             * @instance
             */
            NodeExecutionEvent.prototype.inputUri = "";

            /**
             * NodeExecutionEvent outputUri.
             * @member {string} outputUri
             * @memberof flyteidl.event.NodeExecutionEvent
             * @instance
             */
            NodeExecutionEvent.prototype.outputUri = "";

            /**
             * NodeExecutionEvent error.
             * @member {flyteidl.core.IExecutionError|null|undefined} error
             * @memberof flyteidl.event.NodeExecutionEvent
             * @instance
             */
            NodeExecutionEvent.prototype.error = null;

            /**
             * NodeExecutionEvent workflowNodeMetadata.
             * @member {flyteidl.event.IWorkflowNodeMetadata|null|undefined} workflowNodeMetadata
             * @memberof flyteidl.event.NodeExecutionEvent
             * @instance
             */
            NodeExecutionEvent.prototype.workflowNodeMetadata = null;

            /**
             * NodeExecutionEvent parentTaskMetadata.
             * @member {flyteidl.event.IParentTaskExecutionMetadata|null|undefined} parentTaskMetadata
             * @memberof flyteidl.event.NodeExecutionEvent
             * @instance
             */
            NodeExecutionEvent.prototype.parentTaskMetadata = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * NodeExecutionEvent outputResult.
             * @member {"outputUri"|"error"|undefined} outputResult
             * @memberof flyteidl.event.NodeExecutionEvent
             * @instance
             */
            Object.defineProperty(NodeExecutionEvent.prototype, "outputResult", {
                get: $util.oneOfGetter($oneOfFields = ["outputUri", "error"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * NodeExecutionEvent targetMetadata.
             * @member {"workflowNodeMetadata"|undefined} targetMetadata
             * @memberof flyteidl.event.NodeExecutionEvent
             * @instance
             */
            Object.defineProperty(NodeExecutionEvent.prototype, "targetMetadata", {
                get: $util.oneOfGetter($oneOfFields = ["workflowNodeMetadata"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new NodeExecutionEvent instance using the specified properties.
             * @function create
             * @memberof flyteidl.event.NodeExecutionEvent
             * @static
             * @param {flyteidl.event.INodeExecutionEvent=} [properties] Properties to set
             * @returns {flyteidl.event.NodeExecutionEvent} NodeExecutionEvent instance
             */
            NodeExecutionEvent.create = function create(properties) {
                return new NodeExecutionEvent(properties);
            };

            /**
             * Encodes the specified NodeExecutionEvent message. Does not implicitly {@link flyteidl.event.NodeExecutionEvent.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.event.NodeExecutionEvent
             * @static
             * @param {flyteidl.event.INodeExecutionEvent} message NodeExecutionEvent message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NodeExecutionEvent.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    $root.flyteidl.core.NodeExecutionIdentifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.producerId != null && message.hasOwnProperty("producerId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.producerId);
                if (message.phase != null && message.hasOwnProperty("phase"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.phase);
                if (message.occurredAt != null && message.hasOwnProperty("occurredAt"))
                    $root.google.protobuf.Timestamp.encode(message.occurredAt, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.inputUri != null && message.hasOwnProperty("inputUri"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.inputUri);
                if (message.outputUri != null && message.hasOwnProperty("outputUri"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.outputUri);
                if (message.error != null && message.hasOwnProperty("error"))
                    $root.flyteidl.core.ExecutionError.encode(message.error, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.workflowNodeMetadata != null && message.hasOwnProperty("workflowNodeMetadata"))
                    $root.flyteidl.event.WorkflowNodeMetadata.encode(message.workflowNodeMetadata, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.parentTaskMetadata != null && message.hasOwnProperty("parentTaskMetadata"))
                    $root.flyteidl.event.ParentTaskExecutionMetadata.encode(message.parentTaskMetadata, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a NodeExecutionEvent message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.event.NodeExecutionEvent
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.event.NodeExecutionEvent} NodeExecutionEvent
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NodeExecutionEvent.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.event.NodeExecutionEvent();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = $root.flyteidl.core.NodeExecutionIdentifier.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.producerId = reader.string();
                        break;
                    case 3:
                        message.phase = reader.int32();
                        break;
                    case 4:
                        message.occurredAt = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.inputUri = reader.string();
                        break;
                    case 6:
                        message.outputUri = reader.string();
                        break;
                    case 7:
                        message.error = $root.flyteidl.core.ExecutionError.decode(reader, reader.uint32());
                        break;
                    case 8:
                        message.workflowNodeMetadata = $root.flyteidl.event.WorkflowNodeMetadata.decode(reader, reader.uint32());
                        break;
                    case 9:
                        message.parentTaskMetadata = $root.flyteidl.event.ParentTaskExecutionMetadata.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a NodeExecutionEvent message.
             * @function verify
             * @memberof flyteidl.event.NodeExecutionEvent
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NodeExecutionEvent.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.id != null && message.hasOwnProperty("id")) {
                    let error = $root.flyteidl.core.NodeExecutionIdentifier.verify(message.id);
                    if (error)
                        return "id." + error;
                }
                if (message.producerId != null && message.hasOwnProperty("producerId"))
                    if (!$util.isString(message.producerId))
                        return "producerId: string expected";
                if (message.phase != null && message.hasOwnProperty("phase"))
                    switch (message.phase) {
                    default:
                        return "phase: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                        break;
                    }
                if (message.occurredAt != null && message.hasOwnProperty("occurredAt")) {
                    let error = $root.google.protobuf.Timestamp.verify(message.occurredAt);
                    if (error)
                        return "occurredAt." + error;
                }
                if (message.inputUri != null && message.hasOwnProperty("inputUri"))
                    if (!$util.isString(message.inputUri))
                        return "inputUri: string expected";
                if (message.outputUri != null && message.hasOwnProperty("outputUri")) {
                    properties.outputResult = 1;
                    if (!$util.isString(message.outputUri))
                        return "outputUri: string expected";
                }
                if (message.error != null && message.hasOwnProperty("error")) {
                    if (properties.outputResult === 1)
                        return "outputResult: multiple values";
                    properties.outputResult = 1;
                    {
                        let error = $root.flyteidl.core.ExecutionError.verify(message.error);
                        if (error)
                            return "error." + error;
                    }
                }
                if (message.workflowNodeMetadata != null && message.hasOwnProperty("workflowNodeMetadata")) {
                    properties.targetMetadata = 1;
                    {
                        let error = $root.flyteidl.event.WorkflowNodeMetadata.verify(message.workflowNodeMetadata);
                        if (error)
                            return "workflowNodeMetadata." + error;
                    }
                }
                if (message.parentTaskMetadata != null && message.hasOwnProperty("parentTaskMetadata")) {
                    let error = $root.flyteidl.event.ParentTaskExecutionMetadata.verify(message.parentTaskMetadata);
                    if (error)
                        return "parentTaskMetadata." + error;
                }
                return null;
            };

            return NodeExecutionEvent;
        })();

        event.WorkflowNodeMetadata = (function() {

            /**
             * Properties of a WorkflowNodeMetadata.
             * @memberof flyteidl.event
             * @interface IWorkflowNodeMetadata
             * @property {flyteidl.core.IWorkflowExecutionIdentifier|null} [executionId] WorkflowNodeMetadata executionId
             */

            /**
             * Constructs a new WorkflowNodeMetadata.
             * @memberof flyteidl.event
             * @classdesc Represents a WorkflowNodeMetadata.
             * @implements IWorkflowNodeMetadata
             * @constructor
             * @param {flyteidl.event.IWorkflowNodeMetadata=} [properties] Properties to set
             */
            function WorkflowNodeMetadata(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WorkflowNodeMetadata executionId.
             * @member {flyteidl.core.IWorkflowExecutionIdentifier|null|undefined} executionId
             * @memberof flyteidl.event.WorkflowNodeMetadata
             * @instance
             */
            WorkflowNodeMetadata.prototype.executionId = null;

            /**
             * Creates a new WorkflowNodeMetadata instance using the specified properties.
             * @function create
             * @memberof flyteidl.event.WorkflowNodeMetadata
             * @static
             * @param {flyteidl.event.IWorkflowNodeMetadata=} [properties] Properties to set
             * @returns {flyteidl.event.WorkflowNodeMetadata} WorkflowNodeMetadata instance
             */
            WorkflowNodeMetadata.create = function create(properties) {
                return new WorkflowNodeMetadata(properties);
            };

            /**
             * Encodes the specified WorkflowNodeMetadata message. Does not implicitly {@link flyteidl.event.WorkflowNodeMetadata.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.event.WorkflowNodeMetadata
             * @static
             * @param {flyteidl.event.IWorkflowNodeMetadata} message WorkflowNodeMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WorkflowNodeMetadata.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.executionId != null && message.hasOwnProperty("executionId"))
                    $root.flyteidl.core.WorkflowExecutionIdentifier.encode(message.executionId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a WorkflowNodeMetadata message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.event.WorkflowNodeMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.event.WorkflowNodeMetadata} WorkflowNodeMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WorkflowNodeMetadata.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.event.WorkflowNodeMetadata();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.executionId = $root.flyteidl.core.WorkflowExecutionIdentifier.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a WorkflowNodeMetadata message.
             * @function verify
             * @memberof flyteidl.event.WorkflowNodeMetadata
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WorkflowNodeMetadata.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.executionId != null && message.hasOwnProperty("executionId")) {
                    let error = $root.flyteidl.core.WorkflowExecutionIdentifier.verify(message.executionId);
                    if (error)
                        return "executionId." + error;
                }
                return null;
            };

            return WorkflowNodeMetadata;
        })();

        event.ParentTaskExecutionMetadata = (function() {

            /**
             * Properties of a ParentTaskExecutionMetadata.
             * @memberof flyteidl.event
             * @interface IParentTaskExecutionMetadata
             * @property {flyteidl.core.ITaskExecutionIdentifier|null} [id] ParentTaskExecutionMetadata id
             */

            /**
             * Constructs a new ParentTaskExecutionMetadata.
             * @memberof flyteidl.event
             * @classdesc Represents a ParentTaskExecutionMetadata.
             * @implements IParentTaskExecutionMetadata
             * @constructor
             * @param {flyteidl.event.IParentTaskExecutionMetadata=} [properties] Properties to set
             */
            function ParentTaskExecutionMetadata(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ParentTaskExecutionMetadata id.
             * @member {flyteidl.core.ITaskExecutionIdentifier|null|undefined} id
             * @memberof flyteidl.event.ParentTaskExecutionMetadata
             * @instance
             */
            ParentTaskExecutionMetadata.prototype.id = null;

            /**
             * Creates a new ParentTaskExecutionMetadata instance using the specified properties.
             * @function create
             * @memberof flyteidl.event.ParentTaskExecutionMetadata
             * @static
             * @param {flyteidl.event.IParentTaskExecutionMetadata=} [properties] Properties to set
             * @returns {flyteidl.event.ParentTaskExecutionMetadata} ParentTaskExecutionMetadata instance
             */
            ParentTaskExecutionMetadata.create = function create(properties) {
                return new ParentTaskExecutionMetadata(properties);
            };

            /**
             * Encodes the specified ParentTaskExecutionMetadata message. Does not implicitly {@link flyteidl.event.ParentTaskExecutionMetadata.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.event.ParentTaskExecutionMetadata
             * @static
             * @param {flyteidl.event.IParentTaskExecutionMetadata} message ParentTaskExecutionMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ParentTaskExecutionMetadata.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    $root.flyteidl.core.TaskExecutionIdentifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a ParentTaskExecutionMetadata message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.event.ParentTaskExecutionMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.event.ParentTaskExecutionMetadata} ParentTaskExecutionMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ParentTaskExecutionMetadata.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.event.ParentTaskExecutionMetadata();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = $root.flyteidl.core.TaskExecutionIdentifier.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a ParentTaskExecutionMetadata message.
             * @function verify
             * @memberof flyteidl.event.ParentTaskExecutionMetadata
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ParentTaskExecutionMetadata.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id")) {
                    let error = $root.flyteidl.core.TaskExecutionIdentifier.verify(message.id);
                    if (error)
                        return "id." + error;
                }
                return null;
            };

            return ParentTaskExecutionMetadata;
        })();

        event.TaskExecutionEvent = (function() {

            /**
             * Properties of a TaskExecutionEvent.
             * @memberof flyteidl.event
             * @interface ITaskExecutionEvent
             * @property {flyteidl.core.IIdentifier|null} [taskId] TaskExecutionEvent taskId
             * @property {flyteidl.core.INodeExecutionIdentifier|null} [parentNodeExecutionId] TaskExecutionEvent parentNodeExecutionId
             * @property {number|null} [retryAttempt] TaskExecutionEvent retryAttempt
             * @property {flyteidl.core.TaskExecution.Phase|null} [phase] TaskExecutionEvent phase
             * @property {string|null} [producerId] TaskExecutionEvent producerId
             * @property {Array.<flyteidl.core.ITaskLog>|null} [logs] TaskExecutionEvent logs
             * @property {google.protobuf.ITimestamp|null} [occurredAt] TaskExecutionEvent occurredAt
             * @property {string|null} [inputUri] TaskExecutionEvent inputUri
             * @property {string|null} [outputUri] TaskExecutionEvent outputUri
             * @property {flyteidl.core.IExecutionError|null} [error] TaskExecutionEvent error
             * @property {google.protobuf.IStruct|null} [customInfo] TaskExecutionEvent customInfo
             * @property {number|null} [phaseVersion] TaskExecutionEvent phaseVersion
             */

            /**
             * Constructs a new TaskExecutionEvent.
             * @memberof flyteidl.event
             * @classdesc Represents a TaskExecutionEvent.
             * @implements ITaskExecutionEvent
             * @constructor
             * @param {flyteidl.event.ITaskExecutionEvent=} [properties] Properties to set
             */
            function TaskExecutionEvent(properties) {
                this.logs = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TaskExecutionEvent taskId.
             * @member {flyteidl.core.IIdentifier|null|undefined} taskId
             * @memberof flyteidl.event.TaskExecutionEvent
             * @instance
             */
            TaskExecutionEvent.prototype.taskId = null;

            /**
             * TaskExecutionEvent parentNodeExecutionId.
             * @member {flyteidl.core.INodeExecutionIdentifier|null|undefined} parentNodeExecutionId
             * @memberof flyteidl.event.TaskExecutionEvent
             * @instance
             */
            TaskExecutionEvent.prototype.parentNodeExecutionId = null;

            /**
             * TaskExecutionEvent retryAttempt.
             * @member {number} retryAttempt
             * @memberof flyteidl.event.TaskExecutionEvent
             * @instance
             */
            TaskExecutionEvent.prototype.retryAttempt = 0;

            /**
             * TaskExecutionEvent phase.
             * @member {flyteidl.core.TaskExecution.Phase} phase
             * @memberof flyteidl.event.TaskExecutionEvent
             * @instance
             */
            TaskExecutionEvent.prototype.phase = 0;

            /**
             * TaskExecutionEvent producerId.
             * @member {string} producerId
             * @memberof flyteidl.event.TaskExecutionEvent
             * @instance
             */
            TaskExecutionEvent.prototype.producerId = "";

            /**
             * TaskExecutionEvent logs.
             * @member {Array.<flyteidl.core.ITaskLog>} logs
             * @memberof flyteidl.event.TaskExecutionEvent
             * @instance
             */
            TaskExecutionEvent.prototype.logs = $util.emptyArray;

            /**
             * TaskExecutionEvent occurredAt.
             * @member {google.protobuf.ITimestamp|null|undefined} occurredAt
             * @memberof flyteidl.event.TaskExecutionEvent
             * @instance
             */
            TaskExecutionEvent.prototype.occurredAt = null;

            /**
             * TaskExecutionEvent inputUri.
             * @member {string} inputUri
             * @memberof flyteidl.event.TaskExecutionEvent
             * @instance
             */
            TaskExecutionEvent.prototype.inputUri = "";

            /**
             * TaskExecutionEvent outputUri.
             * @member {string} outputUri
             * @memberof flyteidl.event.TaskExecutionEvent
             * @instance
             */
            TaskExecutionEvent.prototype.outputUri = "";

            /**
             * TaskExecutionEvent error.
             * @member {flyteidl.core.IExecutionError|null|undefined} error
             * @memberof flyteidl.event.TaskExecutionEvent
             * @instance
             */
            TaskExecutionEvent.prototype.error = null;

            /**
             * TaskExecutionEvent customInfo.
             * @member {google.protobuf.IStruct|null|undefined} customInfo
             * @memberof flyteidl.event.TaskExecutionEvent
             * @instance
             */
            TaskExecutionEvent.prototype.customInfo = null;

            /**
             * TaskExecutionEvent phaseVersion.
             * @member {number} phaseVersion
             * @memberof flyteidl.event.TaskExecutionEvent
             * @instance
             */
            TaskExecutionEvent.prototype.phaseVersion = 0;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * TaskExecutionEvent outputResult.
             * @member {"outputUri"|"error"|undefined} outputResult
             * @memberof flyteidl.event.TaskExecutionEvent
             * @instance
             */
            Object.defineProperty(TaskExecutionEvent.prototype, "outputResult", {
                get: $util.oneOfGetter($oneOfFields = ["outputUri", "error"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new TaskExecutionEvent instance using the specified properties.
             * @function create
             * @memberof flyteidl.event.TaskExecutionEvent
             * @static
             * @param {flyteidl.event.ITaskExecutionEvent=} [properties] Properties to set
             * @returns {flyteidl.event.TaskExecutionEvent} TaskExecutionEvent instance
             */
            TaskExecutionEvent.create = function create(properties) {
                return new TaskExecutionEvent(properties);
            };

            /**
             * Encodes the specified TaskExecutionEvent message. Does not implicitly {@link flyteidl.event.TaskExecutionEvent.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.event.TaskExecutionEvent
             * @static
             * @param {flyteidl.event.ITaskExecutionEvent} message TaskExecutionEvent message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TaskExecutionEvent.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.taskId != null && message.hasOwnProperty("taskId"))
                    $root.flyteidl.core.Identifier.encode(message.taskId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.parentNodeExecutionId != null && message.hasOwnProperty("parentNodeExecutionId"))
                    $root.flyteidl.core.NodeExecutionIdentifier.encode(message.parentNodeExecutionId, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.retryAttempt != null && message.hasOwnProperty("retryAttempt"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.retryAttempt);
                if (message.phase != null && message.hasOwnProperty("phase"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.phase);
                if (message.producerId != null && message.hasOwnProperty("producerId"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.producerId);
                if (message.logs != null && message.logs.length)
                    for (let i = 0; i < message.logs.length; ++i)
                        $root.flyteidl.core.TaskLog.encode(message.logs[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.occurredAt != null && message.hasOwnProperty("occurredAt"))
                    $root.google.protobuf.Timestamp.encode(message.occurredAt, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.inputUri != null && message.hasOwnProperty("inputUri"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.inputUri);
                if (message.outputUri != null && message.hasOwnProperty("outputUri"))
                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.outputUri);
                if (message.error != null && message.hasOwnProperty("error"))
                    $root.flyteidl.core.ExecutionError.encode(message.error, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                if (message.customInfo != null && message.hasOwnProperty("customInfo"))
                    $root.google.protobuf.Struct.encode(message.customInfo, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                if (message.phaseVersion != null && message.hasOwnProperty("phaseVersion"))
                    writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.phaseVersion);
                return writer;
            };

            /**
             * Decodes a TaskExecutionEvent message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.event.TaskExecutionEvent
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.event.TaskExecutionEvent} TaskExecutionEvent
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TaskExecutionEvent.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.event.TaskExecutionEvent();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.taskId = $root.flyteidl.core.Identifier.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.parentNodeExecutionId = $root.flyteidl.core.NodeExecutionIdentifier.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.retryAttempt = reader.uint32();
                        break;
                    case 4:
                        message.phase = reader.int32();
                        break;
                    case 5:
                        message.producerId = reader.string();
                        break;
                    case 6:
                        if (!(message.logs && message.logs.length))
                            message.logs = [];
                        message.logs.push($root.flyteidl.core.TaskLog.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        message.occurredAt = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                        break;
                    case 8:
                        message.inputUri = reader.string();
                        break;
                    case 9:
                        message.outputUri = reader.string();
                        break;
                    case 10:
                        message.error = $root.flyteidl.core.ExecutionError.decode(reader, reader.uint32());
                        break;
                    case 11:
                        message.customInfo = $root.google.protobuf.Struct.decode(reader, reader.uint32());
                        break;
                    case 12:
                        message.phaseVersion = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a TaskExecutionEvent message.
             * @function verify
             * @memberof flyteidl.event.TaskExecutionEvent
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TaskExecutionEvent.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.taskId != null && message.hasOwnProperty("taskId")) {
                    let error = $root.flyteidl.core.Identifier.verify(message.taskId);
                    if (error)
                        return "taskId." + error;
                }
                if (message.parentNodeExecutionId != null && message.hasOwnProperty("parentNodeExecutionId")) {
                    let error = $root.flyteidl.core.NodeExecutionIdentifier.verify(message.parentNodeExecutionId);
                    if (error)
                        return "parentNodeExecutionId." + error;
                }
                if (message.retryAttempt != null && message.hasOwnProperty("retryAttempt"))
                    if (!$util.isInteger(message.retryAttempt))
                        return "retryAttempt: integer expected";
                if (message.phase != null && message.hasOwnProperty("phase"))
                    switch (message.phase) {
                    default:
                        return "phase: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                        break;
                    }
                if (message.producerId != null && message.hasOwnProperty("producerId"))
                    if (!$util.isString(message.producerId))
                        return "producerId: string expected";
                if (message.logs != null && message.hasOwnProperty("logs")) {
                    if (!Array.isArray(message.logs))
                        return "logs: array expected";
                    for (let i = 0; i < message.logs.length; ++i) {
                        let error = $root.flyteidl.core.TaskLog.verify(message.logs[i]);
                        if (error)
                            return "logs." + error;
                    }
                }
                if (message.occurredAt != null && message.hasOwnProperty("occurredAt")) {
                    let error = $root.google.protobuf.Timestamp.verify(message.occurredAt);
                    if (error)
                        return "occurredAt." + error;
                }
                if (message.inputUri != null && message.hasOwnProperty("inputUri"))
                    if (!$util.isString(message.inputUri))
                        return "inputUri: string expected";
                if (message.outputUri != null && message.hasOwnProperty("outputUri")) {
                    properties.outputResult = 1;
                    if (!$util.isString(message.outputUri))
                        return "outputUri: string expected";
                }
                if (message.error != null && message.hasOwnProperty("error")) {
                    if (properties.outputResult === 1)
                        return "outputResult: multiple values";
                    properties.outputResult = 1;
                    {
                        let error = $root.flyteidl.core.ExecutionError.verify(message.error);
                        if (error)
                            return "error." + error;
                    }
                }
                if (message.customInfo != null && message.hasOwnProperty("customInfo")) {
                    let error = $root.google.protobuf.Struct.verify(message.customInfo);
                    if (error)
                        return "customInfo." + error;
                }
                if (message.phaseVersion != null && message.hasOwnProperty("phaseVersion"))
                    if (!$util.isInteger(message.phaseVersion))
                        return "phaseVersion: integer expected";
                return null;
            };

            return TaskExecutionEvent;
        })();

        return event;
    })();

    flyteidl.admin = (function() {

        /**
         * Namespace admin.
         * @memberof flyteidl
         * @namespace
         */
        const admin = {};

        admin.NamedEntityIdentifier = (function() {

            /**
             * Properties of a NamedEntityIdentifier.
             * @memberof flyteidl.admin
             * @interface INamedEntityIdentifier
             * @property {string|null} [project] NamedEntityIdentifier project
             * @property {string|null} [domain] NamedEntityIdentifier domain
             * @property {string|null} [name] NamedEntityIdentifier name
             */

            /**
             * Constructs a new NamedEntityIdentifier.
             * @memberof flyteidl.admin
             * @classdesc Represents a NamedEntityIdentifier.
             * @implements INamedEntityIdentifier
             * @constructor
             * @param {flyteidl.admin.INamedEntityIdentifier=} [properties] Properties to set
             */
            function NamedEntityIdentifier(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NamedEntityIdentifier project.
             * @member {string} project
             * @memberof flyteidl.admin.NamedEntityIdentifier
             * @instance
             */
            NamedEntityIdentifier.prototype.project = "";

            /**
             * NamedEntityIdentifier domain.
             * @member {string} domain
             * @memberof flyteidl.admin.NamedEntityIdentifier
             * @instance
             */
            NamedEntityIdentifier.prototype.domain = "";

            /**
             * NamedEntityIdentifier name.
             * @member {string} name
             * @memberof flyteidl.admin.NamedEntityIdentifier
             * @instance
             */
            NamedEntityIdentifier.prototype.name = "";

            /**
             * Creates a new NamedEntityIdentifier instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.NamedEntityIdentifier
             * @static
             * @param {flyteidl.admin.INamedEntityIdentifier=} [properties] Properties to set
             * @returns {flyteidl.admin.NamedEntityIdentifier} NamedEntityIdentifier instance
             */
            NamedEntityIdentifier.create = function create(properties) {
                return new NamedEntityIdentifier(properties);
            };

            /**
             * Encodes the specified NamedEntityIdentifier message. Does not implicitly {@link flyteidl.admin.NamedEntityIdentifier.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.NamedEntityIdentifier
             * @static
             * @param {flyteidl.admin.INamedEntityIdentifier} message NamedEntityIdentifier message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NamedEntityIdentifier.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.project != null && message.hasOwnProperty("project"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.project);
                if (message.domain != null && message.hasOwnProperty("domain"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.domain);
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
                return writer;
            };

            /**
             * Decodes a NamedEntityIdentifier message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.NamedEntityIdentifier
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.NamedEntityIdentifier} NamedEntityIdentifier
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NamedEntityIdentifier.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.NamedEntityIdentifier();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.project = reader.string();
                        break;
                    case 2:
                        message.domain = reader.string();
                        break;
                    case 3:
                        message.name = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a NamedEntityIdentifier message.
             * @function verify
             * @memberof flyteidl.admin.NamedEntityIdentifier
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NamedEntityIdentifier.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.project != null && message.hasOwnProperty("project"))
                    if (!$util.isString(message.project))
                        return "project: string expected";
                if (message.domain != null && message.hasOwnProperty("domain"))
                    if (!$util.isString(message.domain))
                        return "domain: string expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                return null;
            };

            return NamedEntityIdentifier;
        })();

        /**
         * NamedEntityState enum.
         * @name flyteidl.admin.NamedEntityState
         * @enum {string}
         * @property {number} NAMED_ENTITY_ACTIVE=0 NAMED_ENTITY_ACTIVE value
         * @property {number} NAMED_ENTITY_ARCHIVED=1 NAMED_ENTITY_ARCHIVED value
         * @property {number} SYSTEM_GENERATED=2 SYSTEM_GENERATED value
         */
        admin.NamedEntityState = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "NAMED_ENTITY_ACTIVE"] = 0;
            values[valuesById[1] = "NAMED_ENTITY_ARCHIVED"] = 1;
            values[valuesById[2] = "SYSTEM_GENERATED"] = 2;
            return values;
        })();

        admin.NamedEntityMetadata = (function() {

            /**
             * Properties of a NamedEntityMetadata.
             * @memberof flyteidl.admin
             * @interface INamedEntityMetadata
             * @property {string|null} [description] NamedEntityMetadata description
             * @property {flyteidl.admin.NamedEntityState|null} [state] NamedEntityMetadata state
             */

            /**
             * Constructs a new NamedEntityMetadata.
             * @memberof flyteidl.admin
             * @classdesc Represents a NamedEntityMetadata.
             * @implements INamedEntityMetadata
             * @constructor
             * @param {flyteidl.admin.INamedEntityMetadata=} [properties] Properties to set
             */
            function NamedEntityMetadata(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NamedEntityMetadata description.
             * @member {string} description
             * @memberof flyteidl.admin.NamedEntityMetadata
             * @instance
             */
            NamedEntityMetadata.prototype.description = "";

            /**
             * NamedEntityMetadata state.
             * @member {flyteidl.admin.NamedEntityState} state
             * @memberof flyteidl.admin.NamedEntityMetadata
             * @instance
             */
            NamedEntityMetadata.prototype.state = 0;

            /**
             * Creates a new NamedEntityMetadata instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.NamedEntityMetadata
             * @static
             * @param {flyteidl.admin.INamedEntityMetadata=} [properties] Properties to set
             * @returns {flyteidl.admin.NamedEntityMetadata} NamedEntityMetadata instance
             */
            NamedEntityMetadata.create = function create(properties) {
                return new NamedEntityMetadata(properties);
            };

            /**
             * Encodes the specified NamedEntityMetadata message. Does not implicitly {@link flyteidl.admin.NamedEntityMetadata.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.NamedEntityMetadata
             * @static
             * @param {flyteidl.admin.INamedEntityMetadata} message NamedEntityMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NamedEntityMetadata.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.description != null && message.hasOwnProperty("description"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.description);
                if (message.state != null && message.hasOwnProperty("state"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.state);
                return writer;
            };

            /**
             * Decodes a NamedEntityMetadata message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.NamedEntityMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.NamedEntityMetadata} NamedEntityMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NamedEntityMetadata.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.NamedEntityMetadata();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.description = reader.string();
                        break;
                    case 2:
                        message.state = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a NamedEntityMetadata message.
             * @function verify
             * @memberof flyteidl.admin.NamedEntityMetadata
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NamedEntityMetadata.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.description != null && message.hasOwnProperty("description"))
                    if (!$util.isString(message.description))
                        return "description: string expected";
                if (message.state != null && message.hasOwnProperty("state"))
                    switch (message.state) {
                    default:
                        return "state: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                return null;
            };

            return NamedEntityMetadata;
        })();

        admin.NamedEntity = (function() {

            /**
             * Properties of a NamedEntity.
             * @memberof flyteidl.admin
             * @interface INamedEntity
             * @property {flyteidl.core.ResourceType|null} [resourceType] NamedEntity resourceType
             * @property {flyteidl.admin.INamedEntityIdentifier|null} [id] NamedEntity id
             * @property {flyteidl.admin.INamedEntityMetadata|null} [metadata] NamedEntity metadata
             */

            /**
             * Constructs a new NamedEntity.
             * @memberof flyteidl.admin
             * @classdesc Represents a NamedEntity.
             * @implements INamedEntity
             * @constructor
             * @param {flyteidl.admin.INamedEntity=} [properties] Properties to set
             */
            function NamedEntity(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NamedEntity resourceType.
             * @member {flyteidl.core.ResourceType} resourceType
             * @memberof flyteidl.admin.NamedEntity
             * @instance
             */
            NamedEntity.prototype.resourceType = 0;

            /**
             * NamedEntity id.
             * @member {flyteidl.admin.INamedEntityIdentifier|null|undefined} id
             * @memberof flyteidl.admin.NamedEntity
             * @instance
             */
            NamedEntity.prototype.id = null;

            /**
             * NamedEntity metadata.
             * @member {flyteidl.admin.INamedEntityMetadata|null|undefined} metadata
             * @memberof flyteidl.admin.NamedEntity
             * @instance
             */
            NamedEntity.prototype.metadata = null;

            /**
             * Creates a new NamedEntity instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.NamedEntity
             * @static
             * @param {flyteidl.admin.INamedEntity=} [properties] Properties to set
             * @returns {flyteidl.admin.NamedEntity} NamedEntity instance
             */
            NamedEntity.create = function create(properties) {
                return new NamedEntity(properties);
            };

            /**
             * Encodes the specified NamedEntity message. Does not implicitly {@link flyteidl.admin.NamedEntity.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.NamedEntity
             * @static
             * @param {flyteidl.admin.INamedEntity} message NamedEntity message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NamedEntity.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.resourceType != null && message.hasOwnProperty("resourceType"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.resourceType);
                if (message.id != null && message.hasOwnProperty("id"))
                    $root.flyteidl.admin.NamedEntityIdentifier.encode(message.id, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    $root.flyteidl.admin.NamedEntityMetadata.encode(message.metadata, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a NamedEntity message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.NamedEntity
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.NamedEntity} NamedEntity
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NamedEntity.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.NamedEntity();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.resourceType = reader.int32();
                        break;
                    case 2:
                        message.id = $root.flyteidl.admin.NamedEntityIdentifier.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.metadata = $root.flyteidl.admin.NamedEntityMetadata.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a NamedEntity message.
             * @function verify
             * @memberof flyteidl.admin.NamedEntity
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NamedEntity.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.resourceType != null && message.hasOwnProperty("resourceType"))
                    switch (message.resourceType) {
                    default:
                        return "resourceType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.id != null && message.hasOwnProperty("id")) {
                    let error = $root.flyteidl.admin.NamedEntityIdentifier.verify(message.id);
                    if (error)
                        return "id." + error;
                }
                if (message.metadata != null && message.hasOwnProperty("metadata")) {
                    let error = $root.flyteidl.admin.NamedEntityMetadata.verify(message.metadata);
                    if (error)
                        return "metadata." + error;
                }
                return null;
            };

            return NamedEntity;
        })();

        admin.Sort = (function() {

            /**
             * Properties of a Sort.
             * @memberof flyteidl.admin
             * @interface ISort
             * @property {string|null} [key] Sort key
             * @property {flyteidl.admin.Sort.Direction|null} [direction] Sort direction
             */

            /**
             * Constructs a new Sort.
             * @memberof flyteidl.admin
             * @classdesc Represents a Sort.
             * @implements ISort
             * @constructor
             * @param {flyteidl.admin.ISort=} [properties] Properties to set
             */
            function Sort(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Sort key.
             * @member {string} key
             * @memberof flyteidl.admin.Sort
             * @instance
             */
            Sort.prototype.key = "";

            /**
             * Sort direction.
             * @member {flyteidl.admin.Sort.Direction} direction
             * @memberof flyteidl.admin.Sort
             * @instance
             */
            Sort.prototype.direction = 0;

            /**
             * Creates a new Sort instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.Sort
             * @static
             * @param {flyteidl.admin.ISort=} [properties] Properties to set
             * @returns {flyteidl.admin.Sort} Sort instance
             */
            Sort.create = function create(properties) {
                return new Sort(properties);
            };

            /**
             * Encodes the specified Sort message. Does not implicitly {@link flyteidl.admin.Sort.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.Sort
             * @static
             * @param {flyteidl.admin.ISort} message Sort message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Sort.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && message.hasOwnProperty("key"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
                if (message.direction != null && message.hasOwnProperty("direction"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.direction);
                return writer;
            };

            /**
             * Decodes a Sort message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.Sort
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.Sort} Sort
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Sort.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.Sort();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.key = reader.string();
                        break;
                    case 2:
                        message.direction = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a Sort message.
             * @function verify
             * @memberof flyteidl.admin.Sort
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Sort.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isString(message.key))
                        return "key: string expected";
                if (message.direction != null && message.hasOwnProperty("direction"))
                    switch (message.direction) {
                    default:
                        return "direction: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                return null;
            };

            /**
             * Direction enum.
             * @name flyteidl.admin.Sort.Direction
             * @enum {string}
             * @property {number} DESCENDING=0 DESCENDING value
             * @property {number} ASCENDING=1 ASCENDING value
             */
            Sort.Direction = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "DESCENDING"] = 0;
                values[valuesById[1] = "ASCENDING"] = 1;
                return values;
            })();

            return Sort;
        })();

        admin.NamedEntityIdentifierListRequest = (function() {

            /**
             * Properties of a NamedEntityIdentifierListRequest.
             * @memberof flyteidl.admin
             * @interface INamedEntityIdentifierListRequest
             * @property {string|null} [project] NamedEntityIdentifierListRequest project
             * @property {string|null} [domain] NamedEntityIdentifierListRequest domain
             * @property {number|null} [limit] NamedEntityIdentifierListRequest limit
             * @property {string|null} [token] NamedEntityIdentifierListRequest token
             * @property {flyteidl.admin.ISort|null} [sortBy] NamedEntityIdentifierListRequest sortBy
             * @property {string|null} [filters] NamedEntityIdentifierListRequest filters
             */

            /**
             * Constructs a new NamedEntityIdentifierListRequest.
             * @memberof flyteidl.admin
             * @classdesc Represents a NamedEntityIdentifierListRequest.
             * @implements INamedEntityIdentifierListRequest
             * @constructor
             * @param {flyteidl.admin.INamedEntityIdentifierListRequest=} [properties] Properties to set
             */
            function NamedEntityIdentifierListRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NamedEntityIdentifierListRequest project.
             * @member {string} project
             * @memberof flyteidl.admin.NamedEntityIdentifierListRequest
             * @instance
             */
            NamedEntityIdentifierListRequest.prototype.project = "";

            /**
             * NamedEntityIdentifierListRequest domain.
             * @member {string} domain
             * @memberof flyteidl.admin.NamedEntityIdentifierListRequest
             * @instance
             */
            NamedEntityIdentifierListRequest.prototype.domain = "";

            /**
             * NamedEntityIdentifierListRequest limit.
             * @member {number} limit
             * @memberof flyteidl.admin.NamedEntityIdentifierListRequest
             * @instance
             */
            NamedEntityIdentifierListRequest.prototype.limit = 0;

            /**
             * NamedEntityIdentifierListRequest token.
             * @member {string} token
             * @memberof flyteidl.admin.NamedEntityIdentifierListRequest
             * @instance
             */
            NamedEntityIdentifierListRequest.prototype.token = "";

            /**
             * NamedEntityIdentifierListRequest sortBy.
             * @member {flyteidl.admin.ISort|null|undefined} sortBy
             * @memberof flyteidl.admin.NamedEntityIdentifierListRequest
             * @instance
             */
            NamedEntityIdentifierListRequest.prototype.sortBy = null;

            /**
             * NamedEntityIdentifierListRequest filters.
             * @member {string} filters
             * @memberof flyteidl.admin.NamedEntityIdentifierListRequest
             * @instance
             */
            NamedEntityIdentifierListRequest.prototype.filters = "";

            /**
             * Creates a new NamedEntityIdentifierListRequest instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.NamedEntityIdentifierListRequest
             * @static
             * @param {flyteidl.admin.INamedEntityIdentifierListRequest=} [properties] Properties to set
             * @returns {flyteidl.admin.NamedEntityIdentifierListRequest} NamedEntityIdentifierListRequest instance
             */
            NamedEntityIdentifierListRequest.create = function create(properties) {
                return new NamedEntityIdentifierListRequest(properties);
            };

            /**
             * Encodes the specified NamedEntityIdentifierListRequest message. Does not implicitly {@link flyteidl.admin.NamedEntityIdentifierListRequest.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.NamedEntityIdentifierListRequest
             * @static
             * @param {flyteidl.admin.INamedEntityIdentifierListRequest} message NamedEntityIdentifierListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NamedEntityIdentifierListRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.project != null && message.hasOwnProperty("project"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.project);
                if (message.domain != null && message.hasOwnProperty("domain"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.domain);
                if (message.limit != null && message.hasOwnProperty("limit"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.limit);
                if (message.token != null && message.hasOwnProperty("token"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.token);
                if (message.sortBy != null && message.hasOwnProperty("sortBy"))
                    $root.flyteidl.admin.Sort.encode(message.sortBy, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.filters != null && message.hasOwnProperty("filters"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.filters);
                return writer;
            };

            /**
             * Decodes a NamedEntityIdentifierListRequest message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.NamedEntityIdentifierListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.NamedEntityIdentifierListRequest} NamedEntityIdentifierListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NamedEntityIdentifierListRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.NamedEntityIdentifierListRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.project = reader.string();
                        break;
                    case 2:
                        message.domain = reader.string();
                        break;
                    case 3:
                        message.limit = reader.uint32();
                        break;
                    case 4:
                        message.token = reader.string();
                        break;
                    case 5:
                        message.sortBy = $root.flyteidl.admin.Sort.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.filters = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a NamedEntityIdentifierListRequest message.
             * @function verify
             * @memberof flyteidl.admin.NamedEntityIdentifierListRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NamedEntityIdentifierListRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.project != null && message.hasOwnProperty("project"))
                    if (!$util.isString(message.project))
                        return "project: string expected";
                if (message.domain != null && message.hasOwnProperty("domain"))
                    if (!$util.isString(message.domain))
                        return "domain: string expected";
                if (message.limit != null && message.hasOwnProperty("limit"))
                    if (!$util.isInteger(message.limit))
                        return "limit: integer expected";
                if (message.token != null && message.hasOwnProperty("token"))
                    if (!$util.isString(message.token))
                        return "token: string expected";
                if (message.sortBy != null && message.hasOwnProperty("sortBy")) {
                    let error = $root.flyteidl.admin.Sort.verify(message.sortBy);
                    if (error)
                        return "sortBy." + error;
                }
                if (message.filters != null && message.hasOwnProperty("filters"))
                    if (!$util.isString(message.filters))
                        return "filters: string expected";
                return null;
            };

            return NamedEntityIdentifierListRequest;
        })();

        admin.NamedEntityListRequest = (function() {

            /**
             * Properties of a NamedEntityListRequest.
             * @memberof flyteidl.admin
             * @interface INamedEntityListRequest
             * @property {flyteidl.core.ResourceType|null} [resourceType] NamedEntityListRequest resourceType
             * @property {string|null} [project] NamedEntityListRequest project
             * @property {string|null} [domain] NamedEntityListRequest domain
             * @property {number|null} [limit] NamedEntityListRequest limit
             * @property {string|null} [token] NamedEntityListRequest token
             * @property {flyteidl.admin.ISort|null} [sortBy] NamedEntityListRequest sortBy
             * @property {string|null} [filters] NamedEntityListRequest filters
             */

            /**
             * Constructs a new NamedEntityListRequest.
             * @memberof flyteidl.admin
             * @classdesc Represents a NamedEntityListRequest.
             * @implements INamedEntityListRequest
             * @constructor
             * @param {flyteidl.admin.INamedEntityListRequest=} [properties] Properties to set
             */
            function NamedEntityListRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NamedEntityListRequest resourceType.
             * @member {flyteidl.core.ResourceType} resourceType
             * @memberof flyteidl.admin.NamedEntityListRequest
             * @instance
             */
            NamedEntityListRequest.prototype.resourceType = 0;

            /**
             * NamedEntityListRequest project.
             * @member {string} project
             * @memberof flyteidl.admin.NamedEntityListRequest
             * @instance
             */
            NamedEntityListRequest.prototype.project = "";

            /**
             * NamedEntityListRequest domain.
             * @member {string} domain
             * @memberof flyteidl.admin.NamedEntityListRequest
             * @instance
             */
            NamedEntityListRequest.prototype.domain = "";

            /**
             * NamedEntityListRequest limit.
             * @member {number} limit
             * @memberof flyteidl.admin.NamedEntityListRequest
             * @instance
             */
            NamedEntityListRequest.prototype.limit = 0;

            /**
             * NamedEntityListRequest token.
             * @member {string} token
             * @memberof flyteidl.admin.NamedEntityListRequest
             * @instance
             */
            NamedEntityListRequest.prototype.token = "";

            /**
             * NamedEntityListRequest sortBy.
             * @member {flyteidl.admin.ISort|null|undefined} sortBy
             * @memberof flyteidl.admin.NamedEntityListRequest
             * @instance
             */
            NamedEntityListRequest.prototype.sortBy = null;

            /**
             * NamedEntityListRequest filters.
             * @member {string} filters
             * @memberof flyteidl.admin.NamedEntityListRequest
             * @instance
             */
            NamedEntityListRequest.prototype.filters = "";

            /**
             * Creates a new NamedEntityListRequest instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.NamedEntityListRequest
             * @static
             * @param {flyteidl.admin.INamedEntityListRequest=} [properties] Properties to set
             * @returns {flyteidl.admin.NamedEntityListRequest} NamedEntityListRequest instance
             */
            NamedEntityListRequest.create = function create(properties) {
                return new NamedEntityListRequest(properties);
            };

            /**
             * Encodes the specified NamedEntityListRequest message. Does not implicitly {@link flyteidl.admin.NamedEntityListRequest.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.NamedEntityListRequest
             * @static
             * @param {flyteidl.admin.INamedEntityListRequest} message NamedEntityListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NamedEntityListRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.resourceType != null && message.hasOwnProperty("resourceType"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.resourceType);
                if (message.project != null && message.hasOwnProperty("project"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.project);
                if (message.domain != null && message.hasOwnProperty("domain"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.domain);
                if (message.limit != null && message.hasOwnProperty("limit"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.limit);
                if (message.token != null && message.hasOwnProperty("token"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.token);
                if (message.sortBy != null && message.hasOwnProperty("sortBy"))
                    $root.flyteidl.admin.Sort.encode(message.sortBy, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.filters != null && message.hasOwnProperty("filters"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.filters);
                return writer;
            };

            /**
             * Decodes a NamedEntityListRequest message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.NamedEntityListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.NamedEntityListRequest} NamedEntityListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NamedEntityListRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.NamedEntityListRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.resourceType = reader.int32();
                        break;
                    case 2:
                        message.project = reader.string();
                        break;
                    case 3:
                        message.domain = reader.string();
                        break;
                    case 4:
                        message.limit = reader.uint32();
                        break;
                    case 5:
                        message.token = reader.string();
                        break;
                    case 6:
                        message.sortBy = $root.flyteidl.admin.Sort.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.filters = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a NamedEntityListRequest message.
             * @function verify
             * @memberof flyteidl.admin.NamedEntityListRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NamedEntityListRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.resourceType != null && message.hasOwnProperty("resourceType"))
                    switch (message.resourceType) {
                    default:
                        return "resourceType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.project != null && message.hasOwnProperty("project"))
                    if (!$util.isString(message.project))
                        return "project: string expected";
                if (message.domain != null && message.hasOwnProperty("domain"))
                    if (!$util.isString(message.domain))
                        return "domain: string expected";
                if (message.limit != null && message.hasOwnProperty("limit"))
                    if (!$util.isInteger(message.limit))
                        return "limit: integer expected";
                if (message.token != null && message.hasOwnProperty("token"))
                    if (!$util.isString(message.token))
                        return "token: string expected";
                if (message.sortBy != null && message.hasOwnProperty("sortBy")) {
                    let error = $root.flyteidl.admin.Sort.verify(message.sortBy);
                    if (error)
                        return "sortBy." + error;
                }
                if (message.filters != null && message.hasOwnProperty("filters"))
                    if (!$util.isString(message.filters))
                        return "filters: string expected";
                return null;
            };

            return NamedEntityListRequest;
        })();

        admin.NamedEntityIdentifierList = (function() {

            /**
             * Properties of a NamedEntityIdentifierList.
             * @memberof flyteidl.admin
             * @interface INamedEntityIdentifierList
             * @property {Array.<flyteidl.admin.INamedEntityIdentifier>|null} [entities] NamedEntityIdentifierList entities
             * @property {string|null} [token] NamedEntityIdentifierList token
             */

            /**
             * Constructs a new NamedEntityIdentifierList.
             * @memberof flyteidl.admin
             * @classdesc Represents a NamedEntityIdentifierList.
             * @implements INamedEntityIdentifierList
             * @constructor
             * @param {flyteidl.admin.INamedEntityIdentifierList=} [properties] Properties to set
             */
            function NamedEntityIdentifierList(properties) {
                this.entities = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NamedEntityIdentifierList entities.
             * @member {Array.<flyteidl.admin.INamedEntityIdentifier>} entities
             * @memberof flyteidl.admin.NamedEntityIdentifierList
             * @instance
             */
            NamedEntityIdentifierList.prototype.entities = $util.emptyArray;

            /**
             * NamedEntityIdentifierList token.
             * @member {string} token
             * @memberof flyteidl.admin.NamedEntityIdentifierList
             * @instance
             */
            NamedEntityIdentifierList.prototype.token = "";

            /**
             * Creates a new NamedEntityIdentifierList instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.NamedEntityIdentifierList
             * @static
             * @param {flyteidl.admin.INamedEntityIdentifierList=} [properties] Properties to set
             * @returns {flyteidl.admin.NamedEntityIdentifierList} NamedEntityIdentifierList instance
             */
            NamedEntityIdentifierList.create = function create(properties) {
                return new NamedEntityIdentifierList(properties);
            };

            /**
             * Encodes the specified NamedEntityIdentifierList message. Does not implicitly {@link flyteidl.admin.NamedEntityIdentifierList.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.NamedEntityIdentifierList
             * @static
             * @param {flyteidl.admin.INamedEntityIdentifierList} message NamedEntityIdentifierList message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NamedEntityIdentifierList.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.entities != null && message.entities.length)
                    for (let i = 0; i < message.entities.length; ++i)
                        $root.flyteidl.admin.NamedEntityIdentifier.encode(message.entities[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.token != null && message.hasOwnProperty("token"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.token);
                return writer;
            };

            /**
             * Decodes a NamedEntityIdentifierList message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.NamedEntityIdentifierList
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.NamedEntityIdentifierList} NamedEntityIdentifierList
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NamedEntityIdentifierList.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.NamedEntityIdentifierList();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.entities && message.entities.length))
                            message.entities = [];
                        message.entities.push($root.flyteidl.admin.NamedEntityIdentifier.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        message.token = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a NamedEntityIdentifierList message.
             * @function verify
             * @memberof flyteidl.admin.NamedEntityIdentifierList
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NamedEntityIdentifierList.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.entities != null && message.hasOwnProperty("entities")) {
                    if (!Array.isArray(message.entities))
                        return "entities: array expected";
                    for (let i = 0; i < message.entities.length; ++i) {
                        let error = $root.flyteidl.admin.NamedEntityIdentifier.verify(message.entities[i]);
                        if (error)
                            return "entities." + error;
                    }
                }
                if (message.token != null && message.hasOwnProperty("token"))
                    if (!$util.isString(message.token))
                        return "token: string expected";
                return null;
            };

            return NamedEntityIdentifierList;
        })();

        admin.NamedEntityList = (function() {

            /**
             * Properties of a NamedEntityList.
             * @memberof flyteidl.admin
             * @interface INamedEntityList
             * @property {Array.<flyteidl.admin.INamedEntity>|null} [entities] NamedEntityList entities
             * @property {string|null} [token] NamedEntityList token
             */

            /**
             * Constructs a new NamedEntityList.
             * @memberof flyteidl.admin
             * @classdesc Represents a NamedEntityList.
             * @implements INamedEntityList
             * @constructor
             * @param {flyteidl.admin.INamedEntityList=} [properties] Properties to set
             */
            function NamedEntityList(properties) {
                this.entities = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NamedEntityList entities.
             * @member {Array.<flyteidl.admin.INamedEntity>} entities
             * @memberof flyteidl.admin.NamedEntityList
             * @instance
             */
            NamedEntityList.prototype.entities = $util.emptyArray;

            /**
             * NamedEntityList token.
             * @member {string} token
             * @memberof flyteidl.admin.NamedEntityList
             * @instance
             */
            NamedEntityList.prototype.token = "";

            /**
             * Creates a new NamedEntityList instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.NamedEntityList
             * @static
             * @param {flyteidl.admin.INamedEntityList=} [properties] Properties to set
             * @returns {flyteidl.admin.NamedEntityList} NamedEntityList instance
             */
            NamedEntityList.create = function create(properties) {
                return new NamedEntityList(properties);
            };

            /**
             * Encodes the specified NamedEntityList message. Does not implicitly {@link flyteidl.admin.NamedEntityList.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.NamedEntityList
             * @static
             * @param {flyteidl.admin.INamedEntityList} message NamedEntityList message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NamedEntityList.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.entities != null && message.entities.length)
                    for (let i = 0; i < message.entities.length; ++i)
                        $root.flyteidl.admin.NamedEntity.encode(message.entities[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.token != null && message.hasOwnProperty("token"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.token);
                return writer;
            };

            /**
             * Decodes a NamedEntityList message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.NamedEntityList
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.NamedEntityList} NamedEntityList
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NamedEntityList.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.NamedEntityList();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.entities && message.entities.length))
                            message.entities = [];
                        message.entities.push($root.flyteidl.admin.NamedEntity.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        message.token = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a NamedEntityList message.
             * @function verify
             * @memberof flyteidl.admin.NamedEntityList
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NamedEntityList.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.entities != null && message.hasOwnProperty("entities")) {
                    if (!Array.isArray(message.entities))
                        return "entities: array expected";
                    for (let i = 0; i < message.entities.length; ++i) {
                        let error = $root.flyteidl.admin.NamedEntity.verify(message.entities[i]);
                        if (error)
                            return "entities." + error;
                    }
                }
                if (message.token != null && message.hasOwnProperty("token"))
                    if (!$util.isString(message.token))
                        return "token: string expected";
                return null;
            };

            return NamedEntityList;
        })();

        admin.NamedEntityGetRequest = (function() {

            /**
             * Properties of a NamedEntityGetRequest.
             * @memberof flyteidl.admin
             * @interface INamedEntityGetRequest
             * @property {flyteidl.core.ResourceType|null} [resourceType] NamedEntityGetRequest resourceType
             * @property {flyteidl.admin.INamedEntityIdentifier|null} [id] NamedEntityGetRequest id
             */

            /**
             * Constructs a new NamedEntityGetRequest.
             * @memberof flyteidl.admin
             * @classdesc Represents a NamedEntityGetRequest.
             * @implements INamedEntityGetRequest
             * @constructor
             * @param {flyteidl.admin.INamedEntityGetRequest=} [properties] Properties to set
             */
            function NamedEntityGetRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NamedEntityGetRequest resourceType.
             * @member {flyteidl.core.ResourceType} resourceType
             * @memberof flyteidl.admin.NamedEntityGetRequest
             * @instance
             */
            NamedEntityGetRequest.prototype.resourceType = 0;

            /**
             * NamedEntityGetRequest id.
             * @member {flyteidl.admin.INamedEntityIdentifier|null|undefined} id
             * @memberof flyteidl.admin.NamedEntityGetRequest
             * @instance
             */
            NamedEntityGetRequest.prototype.id = null;

            /**
             * Creates a new NamedEntityGetRequest instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.NamedEntityGetRequest
             * @static
             * @param {flyteidl.admin.INamedEntityGetRequest=} [properties] Properties to set
             * @returns {flyteidl.admin.NamedEntityGetRequest} NamedEntityGetRequest instance
             */
            NamedEntityGetRequest.create = function create(properties) {
                return new NamedEntityGetRequest(properties);
            };

            /**
             * Encodes the specified NamedEntityGetRequest message. Does not implicitly {@link flyteidl.admin.NamedEntityGetRequest.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.NamedEntityGetRequest
             * @static
             * @param {flyteidl.admin.INamedEntityGetRequest} message NamedEntityGetRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NamedEntityGetRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.resourceType != null && message.hasOwnProperty("resourceType"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.resourceType);
                if (message.id != null && message.hasOwnProperty("id"))
                    $root.flyteidl.admin.NamedEntityIdentifier.encode(message.id, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a NamedEntityGetRequest message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.NamedEntityGetRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.NamedEntityGetRequest} NamedEntityGetRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NamedEntityGetRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.NamedEntityGetRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.resourceType = reader.int32();
                        break;
                    case 2:
                        message.id = $root.flyteidl.admin.NamedEntityIdentifier.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a NamedEntityGetRequest message.
             * @function verify
             * @memberof flyteidl.admin.NamedEntityGetRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NamedEntityGetRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.resourceType != null && message.hasOwnProperty("resourceType"))
                    switch (message.resourceType) {
                    default:
                        return "resourceType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.id != null && message.hasOwnProperty("id")) {
                    let error = $root.flyteidl.admin.NamedEntityIdentifier.verify(message.id);
                    if (error)
                        return "id." + error;
                }
                return null;
            };

            return NamedEntityGetRequest;
        })();

        admin.NamedEntityUpdateRequest = (function() {

            /**
             * Properties of a NamedEntityUpdateRequest.
             * @memberof flyteidl.admin
             * @interface INamedEntityUpdateRequest
             * @property {flyteidl.core.ResourceType|null} [resourceType] NamedEntityUpdateRequest resourceType
             * @property {flyteidl.admin.INamedEntityIdentifier|null} [id] NamedEntityUpdateRequest id
             * @property {flyteidl.admin.INamedEntityMetadata|null} [metadata] NamedEntityUpdateRequest metadata
             */

            /**
             * Constructs a new NamedEntityUpdateRequest.
             * @memberof flyteidl.admin
             * @classdesc Represents a NamedEntityUpdateRequest.
             * @implements INamedEntityUpdateRequest
             * @constructor
             * @param {flyteidl.admin.INamedEntityUpdateRequest=} [properties] Properties to set
             */
            function NamedEntityUpdateRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NamedEntityUpdateRequest resourceType.
             * @member {flyteidl.core.ResourceType} resourceType
             * @memberof flyteidl.admin.NamedEntityUpdateRequest
             * @instance
             */
            NamedEntityUpdateRequest.prototype.resourceType = 0;

            /**
             * NamedEntityUpdateRequest id.
             * @member {flyteidl.admin.INamedEntityIdentifier|null|undefined} id
             * @memberof flyteidl.admin.NamedEntityUpdateRequest
             * @instance
             */
            NamedEntityUpdateRequest.prototype.id = null;

            /**
             * NamedEntityUpdateRequest metadata.
             * @member {flyteidl.admin.INamedEntityMetadata|null|undefined} metadata
             * @memberof flyteidl.admin.NamedEntityUpdateRequest
             * @instance
             */
            NamedEntityUpdateRequest.prototype.metadata = null;

            /**
             * Creates a new NamedEntityUpdateRequest instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.NamedEntityUpdateRequest
             * @static
             * @param {flyteidl.admin.INamedEntityUpdateRequest=} [properties] Properties to set
             * @returns {flyteidl.admin.NamedEntityUpdateRequest} NamedEntityUpdateRequest instance
             */
            NamedEntityUpdateRequest.create = function create(properties) {
                return new NamedEntityUpdateRequest(properties);
            };

            /**
             * Encodes the specified NamedEntityUpdateRequest message. Does not implicitly {@link flyteidl.admin.NamedEntityUpdateRequest.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.NamedEntityUpdateRequest
             * @static
             * @param {flyteidl.admin.INamedEntityUpdateRequest} message NamedEntityUpdateRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NamedEntityUpdateRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.resourceType != null && message.hasOwnProperty("resourceType"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.resourceType);
                if (message.id != null && message.hasOwnProperty("id"))
                    $root.flyteidl.admin.NamedEntityIdentifier.encode(message.id, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    $root.flyteidl.admin.NamedEntityMetadata.encode(message.metadata, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a NamedEntityUpdateRequest message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.NamedEntityUpdateRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.NamedEntityUpdateRequest} NamedEntityUpdateRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NamedEntityUpdateRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.NamedEntityUpdateRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.resourceType = reader.int32();
                        break;
                    case 2:
                        message.id = $root.flyteidl.admin.NamedEntityIdentifier.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.metadata = $root.flyteidl.admin.NamedEntityMetadata.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a NamedEntityUpdateRequest message.
             * @function verify
             * @memberof flyteidl.admin.NamedEntityUpdateRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NamedEntityUpdateRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.resourceType != null && message.hasOwnProperty("resourceType"))
                    switch (message.resourceType) {
                    default:
                        return "resourceType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.id != null && message.hasOwnProperty("id")) {
                    let error = $root.flyteidl.admin.NamedEntityIdentifier.verify(message.id);
                    if (error)
                        return "id." + error;
                }
                if (message.metadata != null && message.hasOwnProperty("metadata")) {
                    let error = $root.flyteidl.admin.NamedEntityMetadata.verify(message.metadata);
                    if (error)
                        return "metadata." + error;
                }
                return null;
            };

            return NamedEntityUpdateRequest;
        })();

        admin.NamedEntityUpdateResponse = (function() {

            /**
             * Properties of a NamedEntityUpdateResponse.
             * @memberof flyteidl.admin
             * @interface INamedEntityUpdateResponse
             */

            /**
             * Constructs a new NamedEntityUpdateResponse.
             * @memberof flyteidl.admin
             * @classdesc Represents a NamedEntityUpdateResponse.
             * @implements INamedEntityUpdateResponse
             * @constructor
             * @param {flyteidl.admin.INamedEntityUpdateResponse=} [properties] Properties to set
             */
            function NamedEntityUpdateResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new NamedEntityUpdateResponse instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.NamedEntityUpdateResponse
             * @static
             * @param {flyteidl.admin.INamedEntityUpdateResponse=} [properties] Properties to set
             * @returns {flyteidl.admin.NamedEntityUpdateResponse} NamedEntityUpdateResponse instance
             */
            NamedEntityUpdateResponse.create = function create(properties) {
                return new NamedEntityUpdateResponse(properties);
            };

            /**
             * Encodes the specified NamedEntityUpdateResponse message. Does not implicitly {@link flyteidl.admin.NamedEntityUpdateResponse.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.NamedEntityUpdateResponse
             * @static
             * @param {flyteidl.admin.INamedEntityUpdateResponse} message NamedEntityUpdateResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NamedEntityUpdateResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Decodes a NamedEntityUpdateResponse message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.NamedEntityUpdateResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.NamedEntityUpdateResponse} NamedEntityUpdateResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NamedEntityUpdateResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.NamedEntityUpdateResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a NamedEntityUpdateResponse message.
             * @function verify
             * @memberof flyteidl.admin.NamedEntityUpdateResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NamedEntityUpdateResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            return NamedEntityUpdateResponse;
        })();

        admin.ObjectGetRequest = (function() {

            /**
             * Properties of an ObjectGetRequest.
             * @memberof flyteidl.admin
             * @interface IObjectGetRequest
             * @property {flyteidl.core.IIdentifier|null} [id] ObjectGetRequest id
             */

            /**
             * Constructs a new ObjectGetRequest.
             * @memberof flyteidl.admin
             * @classdesc Represents an ObjectGetRequest.
             * @implements IObjectGetRequest
             * @constructor
             * @param {flyteidl.admin.IObjectGetRequest=} [properties] Properties to set
             */
            function ObjectGetRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ObjectGetRequest id.
             * @member {flyteidl.core.IIdentifier|null|undefined} id
             * @memberof flyteidl.admin.ObjectGetRequest
             * @instance
             */
            ObjectGetRequest.prototype.id = null;

            /**
             * Creates a new ObjectGetRequest instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.ObjectGetRequest
             * @static
             * @param {flyteidl.admin.IObjectGetRequest=} [properties] Properties to set
             * @returns {flyteidl.admin.ObjectGetRequest} ObjectGetRequest instance
             */
            ObjectGetRequest.create = function create(properties) {
                return new ObjectGetRequest(properties);
            };

            /**
             * Encodes the specified ObjectGetRequest message. Does not implicitly {@link flyteidl.admin.ObjectGetRequest.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.ObjectGetRequest
             * @static
             * @param {flyteidl.admin.IObjectGetRequest} message ObjectGetRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ObjectGetRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    $root.flyteidl.core.Identifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes an ObjectGetRequest message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.ObjectGetRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.ObjectGetRequest} ObjectGetRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ObjectGetRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.ObjectGetRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = $root.flyteidl.core.Identifier.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies an ObjectGetRequest message.
             * @function verify
             * @memberof flyteidl.admin.ObjectGetRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ObjectGetRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id")) {
                    let error = $root.flyteidl.core.Identifier.verify(message.id);
                    if (error)
                        return "id." + error;
                }
                return null;
            };

            return ObjectGetRequest;
        })();

        admin.ResourceListRequest = (function() {

            /**
             * Properties of a ResourceListRequest.
             * @memberof flyteidl.admin
             * @interface IResourceListRequest
             * @property {flyteidl.admin.INamedEntityIdentifier|null} [id] ResourceListRequest id
             * @property {number|null} [limit] ResourceListRequest limit
             * @property {string|null} [token] ResourceListRequest token
             * @property {string|null} [filters] ResourceListRequest filters
             * @property {flyteidl.admin.ISort|null} [sortBy] ResourceListRequest sortBy
             */

            /**
             * Constructs a new ResourceListRequest.
             * @memberof flyteidl.admin
             * @classdesc Represents a ResourceListRequest.
             * @implements IResourceListRequest
             * @constructor
             * @param {flyteidl.admin.IResourceListRequest=} [properties] Properties to set
             */
            function ResourceListRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ResourceListRequest id.
             * @member {flyteidl.admin.INamedEntityIdentifier|null|undefined} id
             * @memberof flyteidl.admin.ResourceListRequest
             * @instance
             */
            ResourceListRequest.prototype.id = null;

            /**
             * ResourceListRequest limit.
             * @member {number} limit
             * @memberof flyteidl.admin.ResourceListRequest
             * @instance
             */
            ResourceListRequest.prototype.limit = 0;

            /**
             * ResourceListRequest token.
             * @member {string} token
             * @memberof flyteidl.admin.ResourceListRequest
             * @instance
             */
            ResourceListRequest.prototype.token = "";

            /**
             * ResourceListRequest filters.
             * @member {string} filters
             * @memberof flyteidl.admin.ResourceListRequest
             * @instance
             */
            ResourceListRequest.prototype.filters = "";

            /**
             * ResourceListRequest sortBy.
             * @member {flyteidl.admin.ISort|null|undefined} sortBy
             * @memberof flyteidl.admin.ResourceListRequest
             * @instance
             */
            ResourceListRequest.prototype.sortBy = null;

            /**
             * Creates a new ResourceListRequest instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.ResourceListRequest
             * @static
             * @param {flyteidl.admin.IResourceListRequest=} [properties] Properties to set
             * @returns {flyteidl.admin.ResourceListRequest} ResourceListRequest instance
             */
            ResourceListRequest.create = function create(properties) {
                return new ResourceListRequest(properties);
            };

            /**
             * Encodes the specified ResourceListRequest message. Does not implicitly {@link flyteidl.admin.ResourceListRequest.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.ResourceListRequest
             * @static
             * @param {flyteidl.admin.IResourceListRequest} message ResourceListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ResourceListRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    $root.flyteidl.admin.NamedEntityIdentifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.limit != null && message.hasOwnProperty("limit"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.limit);
                if (message.token != null && message.hasOwnProperty("token"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.token);
                if (message.filters != null && message.hasOwnProperty("filters"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.filters);
                if (message.sortBy != null && message.hasOwnProperty("sortBy"))
                    $root.flyteidl.admin.Sort.encode(message.sortBy, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a ResourceListRequest message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.ResourceListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.ResourceListRequest} ResourceListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ResourceListRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.ResourceListRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = $root.flyteidl.admin.NamedEntityIdentifier.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.limit = reader.uint32();
                        break;
                    case 3:
                        message.token = reader.string();
                        break;
                    case 4:
                        message.filters = reader.string();
                        break;
                    case 5:
                        message.sortBy = $root.flyteidl.admin.Sort.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a ResourceListRequest message.
             * @function verify
             * @memberof flyteidl.admin.ResourceListRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ResourceListRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id")) {
                    let error = $root.flyteidl.admin.NamedEntityIdentifier.verify(message.id);
                    if (error)
                        return "id." + error;
                }
                if (message.limit != null && message.hasOwnProperty("limit"))
                    if (!$util.isInteger(message.limit))
                        return "limit: integer expected";
                if (message.token != null && message.hasOwnProperty("token"))
                    if (!$util.isString(message.token))
                        return "token: string expected";
                if (message.filters != null && message.hasOwnProperty("filters"))
                    if (!$util.isString(message.filters))
                        return "filters: string expected";
                if (message.sortBy != null && message.hasOwnProperty("sortBy")) {
                    let error = $root.flyteidl.admin.Sort.verify(message.sortBy);
                    if (error)
                        return "sortBy." + error;
                }
                return null;
            };

            return ResourceListRequest;
        })();

        admin.EmailNotification = (function() {

            /**
             * Properties of an EmailNotification.
             * @memberof flyteidl.admin
             * @interface IEmailNotification
             * @property {Array.<string>|null} [recipientsEmail] EmailNotification recipientsEmail
             */

            /**
             * Constructs a new EmailNotification.
             * @memberof flyteidl.admin
             * @classdesc Represents an EmailNotification.
             * @implements IEmailNotification
             * @constructor
             * @param {flyteidl.admin.IEmailNotification=} [properties] Properties to set
             */
            function EmailNotification(properties) {
                this.recipientsEmail = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EmailNotification recipientsEmail.
             * @member {Array.<string>} recipientsEmail
             * @memberof flyteidl.admin.EmailNotification
             * @instance
             */
            EmailNotification.prototype.recipientsEmail = $util.emptyArray;

            /**
             * Creates a new EmailNotification instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.EmailNotification
             * @static
             * @param {flyteidl.admin.IEmailNotification=} [properties] Properties to set
             * @returns {flyteidl.admin.EmailNotification} EmailNotification instance
             */
            EmailNotification.create = function create(properties) {
                return new EmailNotification(properties);
            };

            /**
             * Encodes the specified EmailNotification message. Does not implicitly {@link flyteidl.admin.EmailNotification.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.EmailNotification
             * @static
             * @param {flyteidl.admin.IEmailNotification} message EmailNotification message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EmailNotification.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.recipientsEmail != null && message.recipientsEmail.length)
                    for (let i = 0; i < message.recipientsEmail.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.recipientsEmail[i]);
                return writer;
            };

            /**
             * Decodes an EmailNotification message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.EmailNotification
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.EmailNotification} EmailNotification
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EmailNotification.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.EmailNotification();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.recipientsEmail && message.recipientsEmail.length))
                            message.recipientsEmail = [];
                        message.recipientsEmail.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies an EmailNotification message.
             * @function verify
             * @memberof flyteidl.admin.EmailNotification
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EmailNotification.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.recipientsEmail != null && message.hasOwnProperty("recipientsEmail")) {
                    if (!Array.isArray(message.recipientsEmail))
                        return "recipientsEmail: array expected";
                    for (let i = 0; i < message.recipientsEmail.length; ++i)
                        if (!$util.isString(message.recipientsEmail[i]))
                            return "recipientsEmail: string[] expected";
                }
                return null;
            };

            return EmailNotification;
        })();

        admin.PagerDutyNotification = (function() {

            /**
             * Properties of a PagerDutyNotification.
             * @memberof flyteidl.admin
             * @interface IPagerDutyNotification
             * @property {Array.<string>|null} [recipientsEmail] PagerDutyNotification recipientsEmail
             */

            /**
             * Constructs a new PagerDutyNotification.
             * @memberof flyteidl.admin
             * @classdesc Represents a PagerDutyNotification.
             * @implements IPagerDutyNotification
             * @constructor
             * @param {flyteidl.admin.IPagerDutyNotification=} [properties] Properties to set
             */
            function PagerDutyNotification(properties) {
                this.recipientsEmail = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PagerDutyNotification recipientsEmail.
             * @member {Array.<string>} recipientsEmail
             * @memberof flyteidl.admin.PagerDutyNotification
             * @instance
             */
            PagerDutyNotification.prototype.recipientsEmail = $util.emptyArray;

            /**
             * Creates a new PagerDutyNotification instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.PagerDutyNotification
             * @static
             * @param {flyteidl.admin.IPagerDutyNotification=} [properties] Properties to set
             * @returns {flyteidl.admin.PagerDutyNotification} PagerDutyNotification instance
             */
            PagerDutyNotification.create = function create(properties) {
                return new PagerDutyNotification(properties);
            };

            /**
             * Encodes the specified PagerDutyNotification message. Does not implicitly {@link flyteidl.admin.PagerDutyNotification.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.PagerDutyNotification
             * @static
             * @param {flyteidl.admin.IPagerDutyNotification} message PagerDutyNotification message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PagerDutyNotification.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.recipientsEmail != null && message.recipientsEmail.length)
                    for (let i = 0; i < message.recipientsEmail.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.recipientsEmail[i]);
                return writer;
            };

            /**
             * Decodes a PagerDutyNotification message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.PagerDutyNotification
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.PagerDutyNotification} PagerDutyNotification
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PagerDutyNotification.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.PagerDutyNotification();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.recipientsEmail && message.recipientsEmail.length))
                            message.recipientsEmail = [];
                        message.recipientsEmail.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a PagerDutyNotification message.
             * @function verify
             * @memberof flyteidl.admin.PagerDutyNotification
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PagerDutyNotification.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.recipientsEmail != null && message.hasOwnProperty("recipientsEmail")) {
                    if (!Array.isArray(message.recipientsEmail))
                        return "recipientsEmail: array expected";
                    for (let i = 0; i < message.recipientsEmail.length; ++i)
                        if (!$util.isString(message.recipientsEmail[i]))
                            return "recipientsEmail: string[] expected";
                }
                return null;
            };

            return PagerDutyNotification;
        })();

        admin.SlackNotification = (function() {

            /**
             * Properties of a SlackNotification.
             * @memberof flyteidl.admin
             * @interface ISlackNotification
             * @property {Array.<string>|null} [recipientsEmail] SlackNotification recipientsEmail
             */

            /**
             * Constructs a new SlackNotification.
             * @memberof flyteidl.admin
             * @classdesc Represents a SlackNotification.
             * @implements ISlackNotification
             * @constructor
             * @param {flyteidl.admin.ISlackNotification=} [properties] Properties to set
             */
            function SlackNotification(properties) {
                this.recipientsEmail = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SlackNotification recipientsEmail.
             * @member {Array.<string>} recipientsEmail
             * @memberof flyteidl.admin.SlackNotification
             * @instance
             */
            SlackNotification.prototype.recipientsEmail = $util.emptyArray;

            /**
             * Creates a new SlackNotification instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.SlackNotification
             * @static
             * @param {flyteidl.admin.ISlackNotification=} [properties] Properties to set
             * @returns {flyteidl.admin.SlackNotification} SlackNotification instance
             */
            SlackNotification.create = function create(properties) {
                return new SlackNotification(properties);
            };

            /**
             * Encodes the specified SlackNotification message. Does not implicitly {@link flyteidl.admin.SlackNotification.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.SlackNotification
             * @static
             * @param {flyteidl.admin.ISlackNotification} message SlackNotification message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SlackNotification.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.recipientsEmail != null && message.recipientsEmail.length)
                    for (let i = 0; i < message.recipientsEmail.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.recipientsEmail[i]);
                return writer;
            };

            /**
             * Decodes a SlackNotification message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.SlackNotification
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.SlackNotification} SlackNotification
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SlackNotification.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.SlackNotification();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.recipientsEmail && message.recipientsEmail.length))
                            message.recipientsEmail = [];
                        message.recipientsEmail.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a SlackNotification message.
             * @function verify
             * @memberof flyteidl.admin.SlackNotification
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SlackNotification.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.recipientsEmail != null && message.hasOwnProperty("recipientsEmail")) {
                    if (!Array.isArray(message.recipientsEmail))
                        return "recipientsEmail: array expected";
                    for (let i = 0; i < message.recipientsEmail.length; ++i)
                        if (!$util.isString(message.recipientsEmail[i]))
                            return "recipientsEmail: string[] expected";
                }
                return null;
            };

            return SlackNotification;
        })();

        admin.Notification = (function() {

            /**
             * Properties of a Notification.
             * @memberof flyteidl.admin
             * @interface INotification
             * @property {Array.<flyteidl.core.WorkflowExecution.Phase>|null} [phases] Notification phases
             * @property {flyteidl.admin.IEmailNotification|null} [email] Notification email
             * @property {flyteidl.admin.IPagerDutyNotification|null} [pagerDuty] Notification pagerDuty
             * @property {flyteidl.admin.ISlackNotification|null} [slack] Notification slack
             */

            /**
             * Constructs a new Notification.
             * @memberof flyteidl.admin
             * @classdesc Represents a Notification.
             * @implements INotification
             * @constructor
             * @param {flyteidl.admin.INotification=} [properties] Properties to set
             */
            function Notification(properties) {
                this.phases = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Notification phases.
             * @member {Array.<flyteidl.core.WorkflowExecution.Phase>} phases
             * @memberof flyteidl.admin.Notification
             * @instance
             */
            Notification.prototype.phases = $util.emptyArray;

            /**
             * Notification email.
             * @member {flyteidl.admin.IEmailNotification|null|undefined} email
             * @memberof flyteidl.admin.Notification
             * @instance
             */
            Notification.prototype.email = null;

            /**
             * Notification pagerDuty.
             * @member {flyteidl.admin.IPagerDutyNotification|null|undefined} pagerDuty
             * @memberof flyteidl.admin.Notification
             * @instance
             */
            Notification.prototype.pagerDuty = null;

            /**
             * Notification slack.
             * @member {flyteidl.admin.ISlackNotification|null|undefined} slack
             * @memberof flyteidl.admin.Notification
             * @instance
             */
            Notification.prototype.slack = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * Notification type.
             * @member {"email"|"pagerDuty"|"slack"|undefined} type
             * @memberof flyteidl.admin.Notification
             * @instance
             */
            Object.defineProperty(Notification.prototype, "type", {
                get: $util.oneOfGetter($oneOfFields = ["email", "pagerDuty", "slack"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new Notification instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.Notification
             * @static
             * @param {flyteidl.admin.INotification=} [properties] Properties to set
             * @returns {flyteidl.admin.Notification} Notification instance
             */
            Notification.create = function create(properties) {
                return new Notification(properties);
            };

            /**
             * Encodes the specified Notification message. Does not implicitly {@link flyteidl.admin.Notification.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.Notification
             * @static
             * @param {flyteidl.admin.INotification} message Notification message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Notification.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.phases != null && message.phases.length) {
                    writer.uint32(/* id 1, wireType 2 =*/10).fork();
                    for (let i = 0; i < message.phases.length; ++i)
                        writer.int32(message.phases[i]);
                    writer.ldelim();
                }
                if (message.email != null && message.hasOwnProperty("email"))
                    $root.flyteidl.admin.EmailNotification.encode(message.email, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.pagerDuty != null && message.hasOwnProperty("pagerDuty"))
                    $root.flyteidl.admin.PagerDutyNotification.encode(message.pagerDuty, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.slack != null && message.hasOwnProperty("slack"))
                    $root.flyteidl.admin.SlackNotification.encode(message.slack, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a Notification message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.Notification
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.Notification} Notification
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Notification.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.Notification();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.phases && message.phases.length))
                            message.phases = [];
                        if ((tag & 7) === 2) {
                            let end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.phases.push(reader.int32());
                        } else
                            message.phases.push(reader.int32());
                        break;
                    case 2:
                        message.email = $root.flyteidl.admin.EmailNotification.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.pagerDuty = $root.flyteidl.admin.PagerDutyNotification.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.slack = $root.flyteidl.admin.SlackNotification.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a Notification message.
             * @function verify
             * @memberof flyteidl.admin.Notification
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Notification.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.phases != null && message.hasOwnProperty("phases")) {
                    if (!Array.isArray(message.phases))
                        return "phases: array expected";
                    for (let i = 0; i < message.phases.length; ++i)
                        switch (message.phases[i]) {
                        default:
                            return "phases: enum value[] expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                            break;
                        }
                }
                if (message.email != null && message.hasOwnProperty("email")) {
                    properties.type = 1;
                    {
                        let error = $root.flyteidl.admin.EmailNotification.verify(message.email);
                        if (error)
                            return "email." + error;
                    }
                }
                if (message.pagerDuty != null && message.hasOwnProperty("pagerDuty")) {
                    if (properties.type === 1)
                        return "type: multiple values";
                    properties.type = 1;
                    {
                        let error = $root.flyteidl.admin.PagerDutyNotification.verify(message.pagerDuty);
                        if (error)
                            return "pagerDuty." + error;
                    }
                }
                if (message.slack != null && message.hasOwnProperty("slack")) {
                    if (properties.type === 1)
                        return "type: multiple values";
                    properties.type = 1;
                    {
                        let error = $root.flyteidl.admin.SlackNotification.verify(message.slack);
                        if (error)
                            return "slack." + error;
                    }
                }
                return null;
            };

            return Notification;
        })();

        admin.UrlBlob = (function() {

            /**
             * Properties of an UrlBlob.
             * @memberof flyteidl.admin
             * @interface IUrlBlob
             * @property {string|null} [url] UrlBlob url
             * @property {Long|null} [bytes] UrlBlob bytes
             */

            /**
             * Constructs a new UrlBlob.
             * @memberof flyteidl.admin
             * @classdesc Represents an UrlBlob.
             * @implements IUrlBlob
             * @constructor
             * @param {flyteidl.admin.IUrlBlob=} [properties] Properties to set
             */
            function UrlBlob(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UrlBlob url.
             * @member {string} url
             * @memberof flyteidl.admin.UrlBlob
             * @instance
             */
            UrlBlob.prototype.url = "";

            /**
             * UrlBlob bytes.
             * @member {Long} bytes
             * @memberof flyteidl.admin.UrlBlob
             * @instance
             */
            UrlBlob.prototype.bytes = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new UrlBlob instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.UrlBlob
             * @static
             * @param {flyteidl.admin.IUrlBlob=} [properties] Properties to set
             * @returns {flyteidl.admin.UrlBlob} UrlBlob instance
             */
            UrlBlob.create = function create(properties) {
                return new UrlBlob(properties);
            };

            /**
             * Encodes the specified UrlBlob message. Does not implicitly {@link flyteidl.admin.UrlBlob.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.UrlBlob
             * @static
             * @param {flyteidl.admin.IUrlBlob} message UrlBlob message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UrlBlob.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.url != null && message.hasOwnProperty("url"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.url);
                if (message.bytes != null && message.hasOwnProperty("bytes"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.bytes);
                return writer;
            };

            /**
             * Decodes an UrlBlob message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.UrlBlob
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.UrlBlob} UrlBlob
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UrlBlob.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.UrlBlob();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.url = reader.string();
                        break;
                    case 2:
                        message.bytes = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies an UrlBlob message.
             * @function verify
             * @memberof flyteidl.admin.UrlBlob
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UrlBlob.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.url != null && message.hasOwnProperty("url"))
                    if (!$util.isString(message.url))
                        return "url: string expected";
                if (message.bytes != null && message.hasOwnProperty("bytes"))
                    if (!$util.isInteger(message.bytes) && !(message.bytes && $util.isInteger(message.bytes.low) && $util.isInteger(message.bytes.high)))
                        return "bytes: integer|Long expected";
                return null;
            };

            return UrlBlob;
        })();

        admin.Labels = (function() {

            /**
             * Properties of a Labels.
             * @memberof flyteidl.admin
             * @interface ILabels
             * @property {Object.<string,string>|null} [values] Labels values
             */

            /**
             * Constructs a new Labels.
             * @memberof flyteidl.admin
             * @classdesc Represents a Labels.
             * @implements ILabels
             * @constructor
             * @param {flyteidl.admin.ILabels=} [properties] Properties to set
             */
            function Labels(properties) {
                this.values = {};
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Labels values.
             * @member {Object.<string,string>} values
             * @memberof flyteidl.admin.Labels
             * @instance
             */
            Labels.prototype.values = $util.emptyObject;

            /**
             * Creates a new Labels instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.Labels
             * @static
             * @param {flyteidl.admin.ILabels=} [properties] Properties to set
             * @returns {flyteidl.admin.Labels} Labels instance
             */
            Labels.create = function create(properties) {
                return new Labels(properties);
            };

            /**
             * Encodes the specified Labels message. Does not implicitly {@link flyteidl.admin.Labels.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.Labels
             * @static
             * @param {flyteidl.admin.ILabels} message Labels message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Labels.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.values != null && message.hasOwnProperty("values"))
                    for (let keys = Object.keys(message.values), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.values[keys[i]]).ldelim();
                return writer;
            };

            /**
             * Decodes a Labels message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.Labels
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.Labels} Labels
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Labels.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.Labels(), key;
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        reader.skip().pos++;
                        if (message.values === $util.emptyObject)
                            message.values = {};
                        key = reader.string();
                        reader.pos++;
                        message.values[key] = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a Labels message.
             * @function verify
             * @memberof flyteidl.admin.Labels
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Labels.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.values != null && message.hasOwnProperty("values")) {
                    if (!$util.isObject(message.values))
                        return "values: object expected";
                    let key = Object.keys(message.values);
                    for (let i = 0; i < key.length; ++i)
                        if (!$util.isString(message.values[key[i]]))
                            return "values: string{k:string} expected";
                }
                return null;
            };

            return Labels;
        })();

        admin.Annotations = (function() {

            /**
             * Properties of an Annotations.
             * @memberof flyteidl.admin
             * @interface IAnnotations
             * @property {Object.<string,string>|null} [values] Annotations values
             */

            /**
             * Constructs a new Annotations.
             * @memberof flyteidl.admin
             * @classdesc Represents an Annotations.
             * @implements IAnnotations
             * @constructor
             * @param {flyteidl.admin.IAnnotations=} [properties] Properties to set
             */
            function Annotations(properties) {
                this.values = {};
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Annotations values.
             * @member {Object.<string,string>} values
             * @memberof flyteidl.admin.Annotations
             * @instance
             */
            Annotations.prototype.values = $util.emptyObject;

            /**
             * Creates a new Annotations instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.Annotations
             * @static
             * @param {flyteidl.admin.IAnnotations=} [properties] Properties to set
             * @returns {flyteidl.admin.Annotations} Annotations instance
             */
            Annotations.create = function create(properties) {
                return new Annotations(properties);
            };

            /**
             * Encodes the specified Annotations message. Does not implicitly {@link flyteidl.admin.Annotations.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.Annotations
             * @static
             * @param {flyteidl.admin.IAnnotations} message Annotations message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Annotations.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.values != null && message.hasOwnProperty("values"))
                    for (let keys = Object.keys(message.values), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.values[keys[i]]).ldelim();
                return writer;
            };

            /**
             * Decodes an Annotations message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.Annotations
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.Annotations} Annotations
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Annotations.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.Annotations(), key;
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        reader.skip().pos++;
                        if (message.values === $util.emptyObject)
                            message.values = {};
                        key = reader.string();
                        reader.pos++;
                        message.values[key] = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies an Annotations message.
             * @function verify
             * @memberof flyteidl.admin.Annotations
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Annotations.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.values != null && message.hasOwnProperty("values")) {
                    if (!$util.isObject(message.values))
                        return "values: object expected";
                    let key = Object.keys(message.values);
                    for (let i = 0; i < key.length; ++i)
                        if (!$util.isString(message.values[key[i]]))
                            return "values: string{k:string} expected";
                }
                return null;
            };

            return Annotations;
        })();

        admin.AuthRole = (function() {

            /**
             * Properties of an AuthRole.
             * @memberof flyteidl.admin
             * @interface IAuthRole
             * @property {string|null} [assumableIamRole] AuthRole assumableIamRole
             * @property {string|null} [kubernetesServiceAccount] AuthRole kubernetesServiceAccount
             */

            /**
             * Constructs a new AuthRole.
             * @memberof flyteidl.admin
             * @classdesc Represents an AuthRole.
             * @implements IAuthRole
             * @constructor
             * @param {flyteidl.admin.IAuthRole=} [properties] Properties to set
             */
            function AuthRole(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AuthRole assumableIamRole.
             * @member {string} assumableIamRole
             * @memberof flyteidl.admin.AuthRole
             * @instance
             */
            AuthRole.prototype.assumableIamRole = "";

            /**
             * AuthRole kubernetesServiceAccount.
             * @member {string} kubernetesServiceAccount
             * @memberof flyteidl.admin.AuthRole
             * @instance
             */
            AuthRole.prototype.kubernetesServiceAccount = "";

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * AuthRole method.
             * @member {"assumableIamRole"|"kubernetesServiceAccount"|undefined} method
             * @memberof flyteidl.admin.AuthRole
             * @instance
             */
            Object.defineProperty(AuthRole.prototype, "method", {
                get: $util.oneOfGetter($oneOfFields = ["assumableIamRole", "kubernetesServiceAccount"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new AuthRole instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.AuthRole
             * @static
             * @param {flyteidl.admin.IAuthRole=} [properties] Properties to set
             * @returns {flyteidl.admin.AuthRole} AuthRole instance
             */
            AuthRole.create = function create(properties) {
                return new AuthRole(properties);
            };

            /**
             * Encodes the specified AuthRole message. Does not implicitly {@link flyteidl.admin.AuthRole.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.AuthRole
             * @static
             * @param {flyteidl.admin.IAuthRole} message AuthRole message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AuthRole.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.assumableIamRole != null && message.hasOwnProperty("assumableIamRole"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.assumableIamRole);
                if (message.kubernetesServiceAccount != null && message.hasOwnProperty("kubernetesServiceAccount"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.kubernetesServiceAccount);
                return writer;
            };

            /**
             * Decodes an AuthRole message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.AuthRole
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.AuthRole} AuthRole
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AuthRole.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.AuthRole();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.assumableIamRole = reader.string();
                        break;
                    case 2:
                        message.kubernetesServiceAccount = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies an AuthRole message.
             * @function verify
             * @memberof flyteidl.admin.AuthRole
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AuthRole.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.assumableIamRole != null && message.hasOwnProperty("assumableIamRole")) {
                    properties.method = 1;
                    if (!$util.isString(message.assumableIamRole))
                        return "assumableIamRole: string expected";
                }
                if (message.kubernetesServiceAccount != null && message.hasOwnProperty("kubernetesServiceAccount")) {
                    if (properties.method === 1)
                        return "method: multiple values";
                    properties.method = 1;
                    if (!$util.isString(message.kubernetesServiceAccount))
                        return "kubernetesServiceAccount: string expected";
                }
                return null;
            };

            return AuthRole;
        })();

        admin.EventErrorAlreadyInTerminalState = (function() {

            /**
             * Properties of an EventErrorAlreadyInTerminalState.
             * @memberof flyteidl.admin
             * @interface IEventErrorAlreadyInTerminalState
             * @property {string|null} [currentPhase] EventErrorAlreadyInTerminalState currentPhase
             */

            /**
             * Constructs a new EventErrorAlreadyInTerminalState.
             * @memberof flyteidl.admin
             * @classdesc Represents an EventErrorAlreadyInTerminalState.
             * @implements IEventErrorAlreadyInTerminalState
             * @constructor
             * @param {flyteidl.admin.IEventErrorAlreadyInTerminalState=} [properties] Properties to set
             */
            function EventErrorAlreadyInTerminalState(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EventErrorAlreadyInTerminalState currentPhase.
             * @member {string} currentPhase
             * @memberof flyteidl.admin.EventErrorAlreadyInTerminalState
             * @instance
             */
            EventErrorAlreadyInTerminalState.prototype.currentPhase = "";

            /**
             * Creates a new EventErrorAlreadyInTerminalState instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.EventErrorAlreadyInTerminalState
             * @static
             * @param {flyteidl.admin.IEventErrorAlreadyInTerminalState=} [properties] Properties to set
             * @returns {flyteidl.admin.EventErrorAlreadyInTerminalState} EventErrorAlreadyInTerminalState instance
             */
            EventErrorAlreadyInTerminalState.create = function create(properties) {
                return new EventErrorAlreadyInTerminalState(properties);
            };

            /**
             * Encodes the specified EventErrorAlreadyInTerminalState message. Does not implicitly {@link flyteidl.admin.EventErrorAlreadyInTerminalState.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.EventErrorAlreadyInTerminalState
             * @static
             * @param {flyteidl.admin.IEventErrorAlreadyInTerminalState} message EventErrorAlreadyInTerminalState message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EventErrorAlreadyInTerminalState.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.currentPhase != null && message.hasOwnProperty("currentPhase"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.currentPhase);
                return writer;
            };

            /**
             * Decodes an EventErrorAlreadyInTerminalState message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.EventErrorAlreadyInTerminalState
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.EventErrorAlreadyInTerminalState} EventErrorAlreadyInTerminalState
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EventErrorAlreadyInTerminalState.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.EventErrorAlreadyInTerminalState();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.currentPhase = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies an EventErrorAlreadyInTerminalState message.
             * @function verify
             * @memberof flyteidl.admin.EventErrorAlreadyInTerminalState
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EventErrorAlreadyInTerminalState.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.currentPhase != null && message.hasOwnProperty("currentPhase"))
                    if (!$util.isString(message.currentPhase))
                        return "currentPhase: string expected";
                return null;
            };

            return EventErrorAlreadyInTerminalState;
        })();

        admin.EventFailureReason = (function() {

            /**
             * Properties of an EventFailureReason.
             * @memberof flyteidl.admin
             * @interface IEventFailureReason
             * @property {flyteidl.admin.IEventErrorAlreadyInTerminalState|null} [alreadyInTerminalState] EventFailureReason alreadyInTerminalState
             */

            /**
             * Constructs a new EventFailureReason.
             * @memberof flyteidl.admin
             * @classdesc Represents an EventFailureReason.
             * @implements IEventFailureReason
             * @constructor
             * @param {flyteidl.admin.IEventFailureReason=} [properties] Properties to set
             */
            function EventFailureReason(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EventFailureReason alreadyInTerminalState.
             * @member {flyteidl.admin.IEventErrorAlreadyInTerminalState|null|undefined} alreadyInTerminalState
             * @memberof flyteidl.admin.EventFailureReason
             * @instance
             */
            EventFailureReason.prototype.alreadyInTerminalState = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * EventFailureReason reason.
             * @member {"alreadyInTerminalState"|undefined} reason
             * @memberof flyteidl.admin.EventFailureReason
             * @instance
             */
            Object.defineProperty(EventFailureReason.prototype, "reason", {
                get: $util.oneOfGetter($oneOfFields = ["alreadyInTerminalState"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new EventFailureReason instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.EventFailureReason
             * @static
             * @param {flyteidl.admin.IEventFailureReason=} [properties] Properties to set
             * @returns {flyteidl.admin.EventFailureReason} EventFailureReason instance
             */
            EventFailureReason.create = function create(properties) {
                return new EventFailureReason(properties);
            };

            /**
             * Encodes the specified EventFailureReason message. Does not implicitly {@link flyteidl.admin.EventFailureReason.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.EventFailureReason
             * @static
             * @param {flyteidl.admin.IEventFailureReason} message EventFailureReason message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EventFailureReason.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.alreadyInTerminalState != null && message.hasOwnProperty("alreadyInTerminalState"))
                    $root.flyteidl.admin.EventErrorAlreadyInTerminalState.encode(message.alreadyInTerminalState, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes an EventFailureReason message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.EventFailureReason
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.EventFailureReason} EventFailureReason
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EventFailureReason.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.EventFailureReason();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.alreadyInTerminalState = $root.flyteidl.admin.EventErrorAlreadyInTerminalState.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies an EventFailureReason message.
             * @function verify
             * @memberof flyteidl.admin.EventFailureReason
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EventFailureReason.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.alreadyInTerminalState != null && message.hasOwnProperty("alreadyInTerminalState")) {
                    properties.reason = 1;
                    {
                        let error = $root.flyteidl.admin.EventErrorAlreadyInTerminalState.verify(message.alreadyInTerminalState);
                        if (error)
                            return "alreadyInTerminalState." + error;
                    }
                }
                return null;
            };

            return EventFailureReason;
        })();

        admin.WorkflowExecutionEventRequest = (function() {

            /**
             * Properties of a WorkflowExecutionEventRequest.
             * @memberof flyteidl.admin
             * @interface IWorkflowExecutionEventRequest
             * @property {string|null} [requestId] WorkflowExecutionEventRequest requestId
             * @property {flyteidl.event.IWorkflowExecutionEvent|null} [event] WorkflowExecutionEventRequest event
             */

            /**
             * Constructs a new WorkflowExecutionEventRequest.
             * @memberof flyteidl.admin
             * @classdesc Represents a WorkflowExecutionEventRequest.
             * @implements IWorkflowExecutionEventRequest
             * @constructor
             * @param {flyteidl.admin.IWorkflowExecutionEventRequest=} [properties] Properties to set
             */
            function WorkflowExecutionEventRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WorkflowExecutionEventRequest requestId.
             * @member {string} requestId
             * @memberof flyteidl.admin.WorkflowExecutionEventRequest
             * @instance
             */
            WorkflowExecutionEventRequest.prototype.requestId = "";

            /**
             * WorkflowExecutionEventRequest event.
             * @member {flyteidl.event.IWorkflowExecutionEvent|null|undefined} event
             * @memberof flyteidl.admin.WorkflowExecutionEventRequest
             * @instance
             */
            WorkflowExecutionEventRequest.prototype.event = null;

            /**
             * Creates a new WorkflowExecutionEventRequest instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.WorkflowExecutionEventRequest
             * @static
             * @param {flyteidl.admin.IWorkflowExecutionEventRequest=} [properties] Properties to set
             * @returns {flyteidl.admin.WorkflowExecutionEventRequest} WorkflowExecutionEventRequest instance
             */
            WorkflowExecutionEventRequest.create = function create(properties) {
                return new WorkflowExecutionEventRequest(properties);
            };

            /**
             * Encodes the specified WorkflowExecutionEventRequest message. Does not implicitly {@link flyteidl.admin.WorkflowExecutionEventRequest.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.WorkflowExecutionEventRequest
             * @static
             * @param {flyteidl.admin.IWorkflowExecutionEventRequest} message WorkflowExecutionEventRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WorkflowExecutionEventRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.requestId != null && message.hasOwnProperty("requestId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.requestId);
                if (message.event != null && message.hasOwnProperty("event"))
                    $root.flyteidl.event.WorkflowExecutionEvent.encode(message.event, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a WorkflowExecutionEventRequest message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.WorkflowExecutionEventRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.WorkflowExecutionEventRequest} WorkflowExecutionEventRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WorkflowExecutionEventRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.WorkflowExecutionEventRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.requestId = reader.string();
                        break;
                    case 2:
                        message.event = $root.flyteidl.event.WorkflowExecutionEvent.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a WorkflowExecutionEventRequest message.
             * @function verify
             * @memberof flyteidl.admin.WorkflowExecutionEventRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WorkflowExecutionEventRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.requestId != null && message.hasOwnProperty("requestId"))
                    if (!$util.isString(message.requestId))
                        return "requestId: string expected";
                if (message.event != null && message.hasOwnProperty("event")) {
                    let error = $root.flyteidl.event.WorkflowExecutionEvent.verify(message.event);
                    if (error)
                        return "event." + error;
                }
                return null;
            };

            return WorkflowExecutionEventRequest;
        })();

        admin.WorkflowExecutionEventResponse = (function() {

            /**
             * Properties of a WorkflowExecutionEventResponse.
             * @memberof flyteidl.admin
             * @interface IWorkflowExecutionEventResponse
             */

            /**
             * Constructs a new WorkflowExecutionEventResponse.
             * @memberof flyteidl.admin
             * @classdesc Represents a WorkflowExecutionEventResponse.
             * @implements IWorkflowExecutionEventResponse
             * @constructor
             * @param {flyteidl.admin.IWorkflowExecutionEventResponse=} [properties] Properties to set
             */
            function WorkflowExecutionEventResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new WorkflowExecutionEventResponse instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.WorkflowExecutionEventResponse
             * @static
             * @param {flyteidl.admin.IWorkflowExecutionEventResponse=} [properties] Properties to set
             * @returns {flyteidl.admin.WorkflowExecutionEventResponse} WorkflowExecutionEventResponse instance
             */
            WorkflowExecutionEventResponse.create = function create(properties) {
                return new WorkflowExecutionEventResponse(properties);
            };

            /**
             * Encodes the specified WorkflowExecutionEventResponse message. Does not implicitly {@link flyteidl.admin.WorkflowExecutionEventResponse.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.WorkflowExecutionEventResponse
             * @static
             * @param {flyteidl.admin.IWorkflowExecutionEventResponse} message WorkflowExecutionEventResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WorkflowExecutionEventResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Decodes a WorkflowExecutionEventResponse message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.WorkflowExecutionEventResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.WorkflowExecutionEventResponse} WorkflowExecutionEventResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WorkflowExecutionEventResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.WorkflowExecutionEventResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a WorkflowExecutionEventResponse message.
             * @function verify
             * @memberof flyteidl.admin.WorkflowExecutionEventResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WorkflowExecutionEventResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            return WorkflowExecutionEventResponse;
        })();

        admin.NodeExecutionEventRequest = (function() {

            /**
             * Properties of a NodeExecutionEventRequest.
             * @memberof flyteidl.admin
             * @interface INodeExecutionEventRequest
             * @property {string|null} [requestId] NodeExecutionEventRequest requestId
             * @property {flyteidl.event.INodeExecutionEvent|null} [event] NodeExecutionEventRequest event
             */

            /**
             * Constructs a new NodeExecutionEventRequest.
             * @memberof flyteidl.admin
             * @classdesc Represents a NodeExecutionEventRequest.
             * @implements INodeExecutionEventRequest
             * @constructor
             * @param {flyteidl.admin.INodeExecutionEventRequest=} [properties] Properties to set
             */
            function NodeExecutionEventRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NodeExecutionEventRequest requestId.
             * @member {string} requestId
             * @memberof flyteidl.admin.NodeExecutionEventRequest
             * @instance
             */
            NodeExecutionEventRequest.prototype.requestId = "";

            /**
             * NodeExecutionEventRequest event.
             * @member {flyteidl.event.INodeExecutionEvent|null|undefined} event
             * @memberof flyteidl.admin.NodeExecutionEventRequest
             * @instance
             */
            NodeExecutionEventRequest.prototype.event = null;

            /**
             * Creates a new NodeExecutionEventRequest instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.NodeExecutionEventRequest
             * @static
             * @param {flyteidl.admin.INodeExecutionEventRequest=} [properties] Properties to set
             * @returns {flyteidl.admin.NodeExecutionEventRequest} NodeExecutionEventRequest instance
             */
            NodeExecutionEventRequest.create = function create(properties) {
                return new NodeExecutionEventRequest(properties);
            };

            /**
             * Encodes the specified NodeExecutionEventRequest message. Does not implicitly {@link flyteidl.admin.NodeExecutionEventRequest.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.NodeExecutionEventRequest
             * @static
             * @param {flyteidl.admin.INodeExecutionEventRequest} message NodeExecutionEventRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NodeExecutionEventRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.requestId != null && message.hasOwnProperty("requestId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.requestId);
                if (message.event != null && message.hasOwnProperty("event"))
                    $root.flyteidl.event.NodeExecutionEvent.encode(message.event, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a NodeExecutionEventRequest message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.NodeExecutionEventRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.NodeExecutionEventRequest} NodeExecutionEventRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NodeExecutionEventRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.NodeExecutionEventRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.requestId = reader.string();
                        break;
                    case 2:
                        message.event = $root.flyteidl.event.NodeExecutionEvent.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a NodeExecutionEventRequest message.
             * @function verify
             * @memberof flyteidl.admin.NodeExecutionEventRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NodeExecutionEventRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.requestId != null && message.hasOwnProperty("requestId"))
                    if (!$util.isString(message.requestId))
                        return "requestId: string expected";
                if (message.event != null && message.hasOwnProperty("event")) {
                    let error = $root.flyteidl.event.NodeExecutionEvent.verify(message.event);
                    if (error)
                        return "event." + error;
                }
                return null;
            };

            return NodeExecutionEventRequest;
        })();

        admin.NodeExecutionEventResponse = (function() {

            /**
             * Properties of a NodeExecutionEventResponse.
             * @memberof flyteidl.admin
             * @interface INodeExecutionEventResponse
             */

            /**
             * Constructs a new NodeExecutionEventResponse.
             * @memberof flyteidl.admin
             * @classdesc Represents a NodeExecutionEventResponse.
             * @implements INodeExecutionEventResponse
             * @constructor
             * @param {flyteidl.admin.INodeExecutionEventResponse=} [properties] Properties to set
             */
            function NodeExecutionEventResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new NodeExecutionEventResponse instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.NodeExecutionEventResponse
             * @static
             * @param {flyteidl.admin.INodeExecutionEventResponse=} [properties] Properties to set
             * @returns {flyteidl.admin.NodeExecutionEventResponse} NodeExecutionEventResponse instance
             */
            NodeExecutionEventResponse.create = function create(properties) {
                return new NodeExecutionEventResponse(properties);
            };

            /**
             * Encodes the specified NodeExecutionEventResponse message. Does not implicitly {@link flyteidl.admin.NodeExecutionEventResponse.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.NodeExecutionEventResponse
             * @static
             * @param {flyteidl.admin.INodeExecutionEventResponse} message NodeExecutionEventResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NodeExecutionEventResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Decodes a NodeExecutionEventResponse message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.NodeExecutionEventResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.NodeExecutionEventResponse} NodeExecutionEventResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NodeExecutionEventResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.NodeExecutionEventResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a NodeExecutionEventResponse message.
             * @function verify
             * @memberof flyteidl.admin.NodeExecutionEventResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NodeExecutionEventResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            return NodeExecutionEventResponse;
        })();

        admin.TaskExecutionEventRequest = (function() {

            /**
             * Properties of a TaskExecutionEventRequest.
             * @memberof flyteidl.admin
             * @interface ITaskExecutionEventRequest
             * @property {string|null} [requestId] TaskExecutionEventRequest requestId
             * @property {flyteidl.event.ITaskExecutionEvent|null} [event] TaskExecutionEventRequest event
             */

            /**
             * Constructs a new TaskExecutionEventRequest.
             * @memberof flyteidl.admin
             * @classdesc Represents a TaskExecutionEventRequest.
             * @implements ITaskExecutionEventRequest
             * @constructor
             * @param {flyteidl.admin.ITaskExecutionEventRequest=} [properties] Properties to set
             */
            function TaskExecutionEventRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TaskExecutionEventRequest requestId.
             * @member {string} requestId
             * @memberof flyteidl.admin.TaskExecutionEventRequest
             * @instance
             */
            TaskExecutionEventRequest.prototype.requestId = "";

            /**
             * TaskExecutionEventRequest event.
             * @member {flyteidl.event.ITaskExecutionEvent|null|undefined} event
             * @memberof flyteidl.admin.TaskExecutionEventRequest
             * @instance
             */
            TaskExecutionEventRequest.prototype.event = null;

            /**
             * Creates a new TaskExecutionEventRequest instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.TaskExecutionEventRequest
             * @static
             * @param {flyteidl.admin.ITaskExecutionEventRequest=} [properties] Properties to set
             * @returns {flyteidl.admin.TaskExecutionEventRequest} TaskExecutionEventRequest instance
             */
            TaskExecutionEventRequest.create = function create(properties) {
                return new TaskExecutionEventRequest(properties);
            };

            /**
             * Encodes the specified TaskExecutionEventRequest message. Does not implicitly {@link flyteidl.admin.TaskExecutionEventRequest.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.TaskExecutionEventRequest
             * @static
             * @param {flyteidl.admin.ITaskExecutionEventRequest} message TaskExecutionEventRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TaskExecutionEventRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.requestId != null && message.hasOwnProperty("requestId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.requestId);
                if (message.event != null && message.hasOwnProperty("event"))
                    $root.flyteidl.event.TaskExecutionEvent.encode(message.event, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a TaskExecutionEventRequest message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.TaskExecutionEventRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.TaskExecutionEventRequest} TaskExecutionEventRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TaskExecutionEventRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.TaskExecutionEventRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.requestId = reader.string();
                        break;
                    case 2:
                        message.event = $root.flyteidl.event.TaskExecutionEvent.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a TaskExecutionEventRequest message.
             * @function verify
             * @memberof flyteidl.admin.TaskExecutionEventRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TaskExecutionEventRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.requestId != null && message.hasOwnProperty("requestId"))
                    if (!$util.isString(message.requestId))
                        return "requestId: string expected";
                if (message.event != null && message.hasOwnProperty("event")) {
                    let error = $root.flyteidl.event.TaskExecutionEvent.verify(message.event);
                    if (error)
                        return "event." + error;
                }
                return null;
            };

            return TaskExecutionEventRequest;
        })();

        admin.TaskExecutionEventResponse = (function() {

            /**
             * Properties of a TaskExecutionEventResponse.
             * @memberof flyteidl.admin
             * @interface ITaskExecutionEventResponse
             */

            /**
             * Constructs a new TaskExecutionEventResponse.
             * @memberof flyteidl.admin
             * @classdesc Represents a TaskExecutionEventResponse.
             * @implements ITaskExecutionEventResponse
             * @constructor
             * @param {flyteidl.admin.ITaskExecutionEventResponse=} [properties] Properties to set
             */
            function TaskExecutionEventResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new TaskExecutionEventResponse instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.TaskExecutionEventResponse
             * @static
             * @param {flyteidl.admin.ITaskExecutionEventResponse=} [properties] Properties to set
             * @returns {flyteidl.admin.TaskExecutionEventResponse} TaskExecutionEventResponse instance
             */
            TaskExecutionEventResponse.create = function create(properties) {
                return new TaskExecutionEventResponse(properties);
            };

            /**
             * Encodes the specified TaskExecutionEventResponse message. Does not implicitly {@link flyteidl.admin.TaskExecutionEventResponse.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.TaskExecutionEventResponse
             * @static
             * @param {flyteidl.admin.ITaskExecutionEventResponse} message TaskExecutionEventResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TaskExecutionEventResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Decodes a TaskExecutionEventResponse message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.TaskExecutionEventResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.TaskExecutionEventResponse} TaskExecutionEventResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TaskExecutionEventResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.TaskExecutionEventResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a TaskExecutionEventResponse message.
             * @function verify
             * @memberof flyteidl.admin.TaskExecutionEventResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TaskExecutionEventResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            return TaskExecutionEventResponse;
        })();

        admin.ExecutionCreateRequest = (function() {

            /**
             * Properties of an ExecutionCreateRequest.
             * @memberof flyteidl.admin
             * @interface IExecutionCreateRequest
             * @property {string|null} [project] ExecutionCreateRequest project
             * @property {string|null} [domain] ExecutionCreateRequest domain
             * @property {string|null} [name] ExecutionCreateRequest name
             * @property {flyteidl.admin.IExecutionSpec|null} [spec] ExecutionCreateRequest spec
             * @property {flyteidl.core.ILiteralMap|null} [inputs] ExecutionCreateRequest inputs
             */

            /**
             * Constructs a new ExecutionCreateRequest.
             * @memberof flyteidl.admin
             * @classdesc Represents an ExecutionCreateRequest.
             * @implements IExecutionCreateRequest
             * @constructor
             * @param {flyteidl.admin.IExecutionCreateRequest=} [properties] Properties to set
             */
            function ExecutionCreateRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExecutionCreateRequest project.
             * @member {string} project
             * @memberof flyteidl.admin.ExecutionCreateRequest
             * @instance
             */
            ExecutionCreateRequest.prototype.project = "";

            /**
             * ExecutionCreateRequest domain.
             * @member {string} domain
             * @memberof flyteidl.admin.ExecutionCreateRequest
             * @instance
             */
            ExecutionCreateRequest.prototype.domain = "";

            /**
             * ExecutionCreateRequest name.
             * @member {string} name
             * @memberof flyteidl.admin.ExecutionCreateRequest
             * @instance
             */
            ExecutionCreateRequest.prototype.name = "";

            /**
             * ExecutionCreateRequest spec.
             * @member {flyteidl.admin.IExecutionSpec|null|undefined} spec
             * @memberof flyteidl.admin.ExecutionCreateRequest
             * @instance
             */
            ExecutionCreateRequest.prototype.spec = null;

            /**
             * ExecutionCreateRequest inputs.
             * @member {flyteidl.core.ILiteralMap|null|undefined} inputs
             * @memberof flyteidl.admin.ExecutionCreateRequest
             * @instance
             */
            ExecutionCreateRequest.prototype.inputs = null;

            /**
             * Creates a new ExecutionCreateRequest instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.ExecutionCreateRequest
             * @static
             * @param {flyteidl.admin.IExecutionCreateRequest=} [properties] Properties to set
             * @returns {flyteidl.admin.ExecutionCreateRequest} ExecutionCreateRequest instance
             */
            ExecutionCreateRequest.create = function create(properties) {
                return new ExecutionCreateRequest(properties);
            };

            /**
             * Encodes the specified ExecutionCreateRequest message. Does not implicitly {@link flyteidl.admin.ExecutionCreateRequest.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.ExecutionCreateRequest
             * @static
             * @param {flyteidl.admin.IExecutionCreateRequest} message ExecutionCreateRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecutionCreateRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.project != null && message.hasOwnProperty("project"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.project);
                if (message.domain != null && message.hasOwnProperty("domain"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.domain);
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
                if (message.spec != null && message.hasOwnProperty("spec"))
                    $root.flyteidl.admin.ExecutionSpec.encode(message.spec, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.inputs != null && message.hasOwnProperty("inputs"))
                    $root.flyteidl.core.LiteralMap.encode(message.inputs, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes an ExecutionCreateRequest message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.ExecutionCreateRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.ExecutionCreateRequest} ExecutionCreateRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecutionCreateRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.ExecutionCreateRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.project = reader.string();
                        break;
                    case 2:
                        message.domain = reader.string();
                        break;
                    case 3:
                        message.name = reader.string();
                        break;
                    case 4:
                        message.spec = $root.flyteidl.admin.ExecutionSpec.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.inputs = $root.flyteidl.core.LiteralMap.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies an ExecutionCreateRequest message.
             * @function verify
             * @memberof flyteidl.admin.ExecutionCreateRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExecutionCreateRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.project != null && message.hasOwnProperty("project"))
                    if (!$util.isString(message.project))
                        return "project: string expected";
                if (message.domain != null && message.hasOwnProperty("domain"))
                    if (!$util.isString(message.domain))
                        return "domain: string expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.spec != null && message.hasOwnProperty("spec")) {
                    let error = $root.flyteidl.admin.ExecutionSpec.verify(message.spec);
                    if (error)
                        return "spec." + error;
                }
                if (message.inputs != null && message.hasOwnProperty("inputs")) {
                    let error = $root.flyteidl.core.LiteralMap.verify(message.inputs);
                    if (error)
                        return "inputs." + error;
                }
                return null;
            };

            return ExecutionCreateRequest;
        })();

        admin.ExecutionRelaunchRequest = (function() {

            /**
             * Properties of an ExecutionRelaunchRequest.
             * @memberof flyteidl.admin
             * @interface IExecutionRelaunchRequest
             * @property {flyteidl.core.IWorkflowExecutionIdentifier|null} [id] ExecutionRelaunchRequest id
             * @property {string|null} [name] ExecutionRelaunchRequest name
             */

            /**
             * Constructs a new ExecutionRelaunchRequest.
             * @memberof flyteidl.admin
             * @classdesc Represents an ExecutionRelaunchRequest.
             * @implements IExecutionRelaunchRequest
             * @constructor
             * @param {flyteidl.admin.IExecutionRelaunchRequest=} [properties] Properties to set
             */
            function ExecutionRelaunchRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExecutionRelaunchRequest id.
             * @member {flyteidl.core.IWorkflowExecutionIdentifier|null|undefined} id
             * @memberof flyteidl.admin.ExecutionRelaunchRequest
             * @instance
             */
            ExecutionRelaunchRequest.prototype.id = null;

            /**
             * ExecutionRelaunchRequest name.
             * @member {string} name
             * @memberof flyteidl.admin.ExecutionRelaunchRequest
             * @instance
             */
            ExecutionRelaunchRequest.prototype.name = "";

            /**
             * Creates a new ExecutionRelaunchRequest instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.ExecutionRelaunchRequest
             * @static
             * @param {flyteidl.admin.IExecutionRelaunchRequest=} [properties] Properties to set
             * @returns {flyteidl.admin.ExecutionRelaunchRequest} ExecutionRelaunchRequest instance
             */
            ExecutionRelaunchRequest.create = function create(properties) {
                return new ExecutionRelaunchRequest(properties);
            };

            /**
             * Encodes the specified ExecutionRelaunchRequest message. Does not implicitly {@link flyteidl.admin.ExecutionRelaunchRequest.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.ExecutionRelaunchRequest
             * @static
             * @param {flyteidl.admin.IExecutionRelaunchRequest} message ExecutionRelaunchRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecutionRelaunchRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    $root.flyteidl.core.WorkflowExecutionIdentifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
                return writer;
            };

            /**
             * Decodes an ExecutionRelaunchRequest message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.ExecutionRelaunchRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.ExecutionRelaunchRequest} ExecutionRelaunchRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecutionRelaunchRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.ExecutionRelaunchRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = $root.flyteidl.core.WorkflowExecutionIdentifier.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.name = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies an ExecutionRelaunchRequest message.
             * @function verify
             * @memberof flyteidl.admin.ExecutionRelaunchRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExecutionRelaunchRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id")) {
                    let error = $root.flyteidl.core.WorkflowExecutionIdentifier.verify(message.id);
                    if (error)
                        return "id." + error;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                return null;
            };

            return ExecutionRelaunchRequest;
        })();

        admin.ExecutionCreateResponse = (function() {

            /**
             * Properties of an ExecutionCreateResponse.
             * @memberof flyteidl.admin
             * @interface IExecutionCreateResponse
             * @property {flyteidl.core.IWorkflowExecutionIdentifier|null} [id] ExecutionCreateResponse id
             */

            /**
             * Constructs a new ExecutionCreateResponse.
             * @memberof flyteidl.admin
             * @classdesc Represents an ExecutionCreateResponse.
             * @implements IExecutionCreateResponse
             * @constructor
             * @param {flyteidl.admin.IExecutionCreateResponse=} [properties] Properties to set
             */
            function ExecutionCreateResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExecutionCreateResponse id.
             * @member {flyteidl.core.IWorkflowExecutionIdentifier|null|undefined} id
             * @memberof flyteidl.admin.ExecutionCreateResponse
             * @instance
             */
            ExecutionCreateResponse.prototype.id = null;

            /**
             * Creates a new ExecutionCreateResponse instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.ExecutionCreateResponse
             * @static
             * @param {flyteidl.admin.IExecutionCreateResponse=} [properties] Properties to set
             * @returns {flyteidl.admin.ExecutionCreateResponse} ExecutionCreateResponse instance
             */
            ExecutionCreateResponse.create = function create(properties) {
                return new ExecutionCreateResponse(properties);
            };

            /**
             * Encodes the specified ExecutionCreateResponse message. Does not implicitly {@link flyteidl.admin.ExecutionCreateResponse.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.ExecutionCreateResponse
             * @static
             * @param {flyteidl.admin.IExecutionCreateResponse} message ExecutionCreateResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecutionCreateResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    $root.flyteidl.core.WorkflowExecutionIdentifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes an ExecutionCreateResponse message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.ExecutionCreateResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.ExecutionCreateResponse} ExecutionCreateResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecutionCreateResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.ExecutionCreateResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = $root.flyteidl.core.WorkflowExecutionIdentifier.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies an ExecutionCreateResponse message.
             * @function verify
             * @memberof flyteidl.admin.ExecutionCreateResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExecutionCreateResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id")) {
                    let error = $root.flyteidl.core.WorkflowExecutionIdentifier.verify(message.id);
                    if (error)
                        return "id." + error;
                }
                return null;
            };

            return ExecutionCreateResponse;
        })();

        admin.WorkflowExecutionGetRequest = (function() {

            /**
             * Properties of a WorkflowExecutionGetRequest.
             * @memberof flyteidl.admin
             * @interface IWorkflowExecutionGetRequest
             * @property {flyteidl.core.IWorkflowExecutionIdentifier|null} [id] WorkflowExecutionGetRequest id
             */

            /**
             * Constructs a new WorkflowExecutionGetRequest.
             * @memberof flyteidl.admin
             * @classdesc Represents a WorkflowExecutionGetRequest.
             * @implements IWorkflowExecutionGetRequest
             * @constructor
             * @param {flyteidl.admin.IWorkflowExecutionGetRequest=} [properties] Properties to set
             */
            function WorkflowExecutionGetRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WorkflowExecutionGetRequest id.
             * @member {flyteidl.core.IWorkflowExecutionIdentifier|null|undefined} id
             * @memberof flyteidl.admin.WorkflowExecutionGetRequest
             * @instance
             */
            WorkflowExecutionGetRequest.prototype.id = null;

            /**
             * Creates a new WorkflowExecutionGetRequest instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.WorkflowExecutionGetRequest
             * @static
             * @param {flyteidl.admin.IWorkflowExecutionGetRequest=} [properties] Properties to set
             * @returns {flyteidl.admin.WorkflowExecutionGetRequest} WorkflowExecutionGetRequest instance
             */
            WorkflowExecutionGetRequest.create = function create(properties) {
                return new WorkflowExecutionGetRequest(properties);
            };

            /**
             * Encodes the specified WorkflowExecutionGetRequest message. Does not implicitly {@link flyteidl.admin.WorkflowExecutionGetRequest.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.WorkflowExecutionGetRequest
             * @static
             * @param {flyteidl.admin.IWorkflowExecutionGetRequest} message WorkflowExecutionGetRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WorkflowExecutionGetRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    $root.flyteidl.core.WorkflowExecutionIdentifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a WorkflowExecutionGetRequest message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.WorkflowExecutionGetRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.WorkflowExecutionGetRequest} WorkflowExecutionGetRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WorkflowExecutionGetRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.WorkflowExecutionGetRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = $root.flyteidl.core.WorkflowExecutionIdentifier.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a WorkflowExecutionGetRequest message.
             * @function verify
             * @memberof flyteidl.admin.WorkflowExecutionGetRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WorkflowExecutionGetRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id")) {
                    let error = $root.flyteidl.core.WorkflowExecutionIdentifier.verify(message.id);
                    if (error)
                        return "id." + error;
                }
                return null;
            };

            return WorkflowExecutionGetRequest;
        })();

        admin.Execution = (function() {

            /**
             * Properties of an Execution.
             * @memberof flyteidl.admin
             * @interface IExecution
             * @property {flyteidl.core.IWorkflowExecutionIdentifier|null} [id] Execution id
             * @property {flyteidl.admin.IExecutionSpec|null} [spec] Execution spec
             * @property {flyteidl.admin.IExecutionClosure|null} [closure] Execution closure
             */

            /**
             * Constructs a new Execution.
             * @memberof flyteidl.admin
             * @classdesc Represents an Execution.
             * @implements IExecution
             * @constructor
             * @param {flyteidl.admin.IExecution=} [properties] Properties to set
             */
            function Execution(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Execution id.
             * @member {flyteidl.core.IWorkflowExecutionIdentifier|null|undefined} id
             * @memberof flyteidl.admin.Execution
             * @instance
             */
            Execution.prototype.id = null;

            /**
             * Execution spec.
             * @member {flyteidl.admin.IExecutionSpec|null|undefined} spec
             * @memberof flyteidl.admin.Execution
             * @instance
             */
            Execution.prototype.spec = null;

            /**
             * Execution closure.
             * @member {flyteidl.admin.IExecutionClosure|null|undefined} closure
             * @memberof flyteidl.admin.Execution
             * @instance
             */
            Execution.prototype.closure = null;

            /**
             * Creates a new Execution instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.Execution
             * @static
             * @param {flyteidl.admin.IExecution=} [properties] Properties to set
             * @returns {flyteidl.admin.Execution} Execution instance
             */
            Execution.create = function create(properties) {
                return new Execution(properties);
            };

            /**
             * Encodes the specified Execution message. Does not implicitly {@link flyteidl.admin.Execution.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.Execution
             * @static
             * @param {flyteidl.admin.IExecution} message Execution message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Execution.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    $root.flyteidl.core.WorkflowExecutionIdentifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.spec != null && message.hasOwnProperty("spec"))
                    $root.flyteidl.admin.ExecutionSpec.encode(message.spec, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.closure != null && message.hasOwnProperty("closure"))
                    $root.flyteidl.admin.ExecutionClosure.encode(message.closure, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes an Execution message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.Execution
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.Execution} Execution
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Execution.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.Execution();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = $root.flyteidl.core.WorkflowExecutionIdentifier.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.spec = $root.flyteidl.admin.ExecutionSpec.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.closure = $root.flyteidl.admin.ExecutionClosure.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies an Execution message.
             * @function verify
             * @memberof flyteidl.admin.Execution
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Execution.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id")) {
                    let error = $root.flyteidl.core.WorkflowExecutionIdentifier.verify(message.id);
                    if (error)
                        return "id." + error;
                }
                if (message.spec != null && message.hasOwnProperty("spec")) {
                    let error = $root.flyteidl.admin.ExecutionSpec.verify(message.spec);
                    if (error)
                        return "spec." + error;
                }
                if (message.closure != null && message.hasOwnProperty("closure")) {
                    let error = $root.flyteidl.admin.ExecutionClosure.verify(message.closure);
                    if (error)
                        return "closure." + error;
                }
                return null;
            };

            return Execution;
        })();

        admin.ExecutionList = (function() {

            /**
             * Properties of an ExecutionList.
             * @memberof flyteidl.admin
             * @interface IExecutionList
             * @property {Array.<flyteidl.admin.IExecution>|null} [executions] ExecutionList executions
             * @property {string|null} [token] ExecutionList token
             */

            /**
             * Constructs a new ExecutionList.
             * @memberof flyteidl.admin
             * @classdesc Represents an ExecutionList.
             * @implements IExecutionList
             * @constructor
             * @param {flyteidl.admin.IExecutionList=} [properties] Properties to set
             */
            function ExecutionList(properties) {
                this.executions = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExecutionList executions.
             * @member {Array.<flyteidl.admin.IExecution>} executions
             * @memberof flyteidl.admin.ExecutionList
             * @instance
             */
            ExecutionList.prototype.executions = $util.emptyArray;

            /**
             * ExecutionList token.
             * @member {string} token
             * @memberof flyteidl.admin.ExecutionList
             * @instance
             */
            ExecutionList.prototype.token = "";

            /**
             * Creates a new ExecutionList instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.ExecutionList
             * @static
             * @param {flyteidl.admin.IExecutionList=} [properties] Properties to set
             * @returns {flyteidl.admin.ExecutionList} ExecutionList instance
             */
            ExecutionList.create = function create(properties) {
                return new ExecutionList(properties);
            };

            /**
             * Encodes the specified ExecutionList message. Does not implicitly {@link flyteidl.admin.ExecutionList.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.ExecutionList
             * @static
             * @param {flyteidl.admin.IExecutionList} message ExecutionList message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecutionList.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.executions != null && message.executions.length)
                    for (let i = 0; i < message.executions.length; ++i)
                        $root.flyteidl.admin.Execution.encode(message.executions[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.token != null && message.hasOwnProperty("token"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.token);
                return writer;
            };

            /**
             * Decodes an ExecutionList message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.ExecutionList
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.ExecutionList} ExecutionList
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecutionList.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.ExecutionList();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.executions && message.executions.length))
                            message.executions = [];
                        message.executions.push($root.flyteidl.admin.Execution.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        message.token = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies an ExecutionList message.
             * @function verify
             * @memberof flyteidl.admin.ExecutionList
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExecutionList.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.executions != null && message.hasOwnProperty("executions")) {
                    if (!Array.isArray(message.executions))
                        return "executions: array expected";
                    for (let i = 0; i < message.executions.length; ++i) {
                        let error = $root.flyteidl.admin.Execution.verify(message.executions[i]);
                        if (error)
                            return "executions." + error;
                    }
                }
                if (message.token != null && message.hasOwnProperty("token"))
                    if (!$util.isString(message.token))
                        return "token: string expected";
                return null;
            };

            return ExecutionList;
        })();

        admin.LiteralMapBlob = (function() {

            /**
             * Properties of a LiteralMapBlob.
             * @memberof flyteidl.admin
             * @interface ILiteralMapBlob
             * @property {flyteidl.core.ILiteralMap|null} [values] LiteralMapBlob values
             * @property {string|null} [uri] LiteralMapBlob uri
             */

            /**
             * Constructs a new LiteralMapBlob.
             * @memberof flyteidl.admin
             * @classdesc Represents a LiteralMapBlob.
             * @implements ILiteralMapBlob
             * @constructor
             * @param {flyteidl.admin.ILiteralMapBlob=} [properties] Properties to set
             */
            function LiteralMapBlob(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LiteralMapBlob values.
             * @member {flyteidl.core.ILiteralMap|null|undefined} values
             * @memberof flyteidl.admin.LiteralMapBlob
             * @instance
             */
            LiteralMapBlob.prototype.values = null;

            /**
             * LiteralMapBlob uri.
             * @member {string} uri
             * @memberof flyteidl.admin.LiteralMapBlob
             * @instance
             */
            LiteralMapBlob.prototype.uri = "";

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * LiteralMapBlob data.
             * @member {"values"|"uri"|undefined} data
             * @memberof flyteidl.admin.LiteralMapBlob
             * @instance
             */
            Object.defineProperty(LiteralMapBlob.prototype, "data", {
                get: $util.oneOfGetter($oneOfFields = ["values", "uri"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new LiteralMapBlob instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.LiteralMapBlob
             * @static
             * @param {flyteidl.admin.ILiteralMapBlob=} [properties] Properties to set
             * @returns {flyteidl.admin.LiteralMapBlob} LiteralMapBlob instance
             */
            LiteralMapBlob.create = function create(properties) {
                return new LiteralMapBlob(properties);
            };

            /**
             * Encodes the specified LiteralMapBlob message. Does not implicitly {@link flyteidl.admin.LiteralMapBlob.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.LiteralMapBlob
             * @static
             * @param {flyteidl.admin.ILiteralMapBlob} message LiteralMapBlob message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LiteralMapBlob.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.values != null && message.hasOwnProperty("values"))
                    $root.flyteidl.core.LiteralMap.encode(message.values, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.uri != null && message.hasOwnProperty("uri"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.uri);
                return writer;
            };

            /**
             * Decodes a LiteralMapBlob message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.LiteralMapBlob
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.LiteralMapBlob} LiteralMapBlob
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LiteralMapBlob.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.LiteralMapBlob();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.values = $root.flyteidl.core.LiteralMap.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.uri = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a LiteralMapBlob message.
             * @function verify
             * @memberof flyteidl.admin.LiteralMapBlob
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LiteralMapBlob.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.values != null && message.hasOwnProperty("values")) {
                    properties.data = 1;
                    {
                        let error = $root.flyteidl.core.LiteralMap.verify(message.values);
                        if (error)
                            return "values." + error;
                    }
                }
                if (message.uri != null && message.hasOwnProperty("uri")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    if (!$util.isString(message.uri))
                        return "uri: string expected";
                }
                return null;
            };

            return LiteralMapBlob;
        })();

        admin.AbortMetadata = (function() {

            /**
             * Properties of an AbortMetadata.
             * @memberof flyteidl.admin
             * @interface IAbortMetadata
             * @property {string|null} [cause] AbortMetadata cause
             * @property {string|null} [principal] AbortMetadata principal
             */

            /**
             * Constructs a new AbortMetadata.
             * @memberof flyteidl.admin
             * @classdesc Represents an AbortMetadata.
             * @implements IAbortMetadata
             * @constructor
             * @param {flyteidl.admin.IAbortMetadata=} [properties] Properties to set
             */
            function AbortMetadata(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AbortMetadata cause.
             * @member {string} cause
             * @memberof flyteidl.admin.AbortMetadata
             * @instance
             */
            AbortMetadata.prototype.cause = "";

            /**
             * AbortMetadata principal.
             * @member {string} principal
             * @memberof flyteidl.admin.AbortMetadata
             * @instance
             */
            AbortMetadata.prototype.principal = "";

            /**
             * Creates a new AbortMetadata instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.AbortMetadata
             * @static
             * @param {flyteidl.admin.IAbortMetadata=} [properties] Properties to set
             * @returns {flyteidl.admin.AbortMetadata} AbortMetadata instance
             */
            AbortMetadata.create = function create(properties) {
                return new AbortMetadata(properties);
            };

            /**
             * Encodes the specified AbortMetadata message. Does not implicitly {@link flyteidl.admin.AbortMetadata.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.AbortMetadata
             * @static
             * @param {flyteidl.admin.IAbortMetadata} message AbortMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AbortMetadata.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.cause != null && message.hasOwnProperty("cause"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.cause);
                if (message.principal != null && message.hasOwnProperty("principal"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.principal);
                return writer;
            };

            /**
             * Decodes an AbortMetadata message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.AbortMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.AbortMetadata} AbortMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AbortMetadata.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.AbortMetadata();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.cause = reader.string();
                        break;
                    case 2:
                        message.principal = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies an AbortMetadata message.
             * @function verify
             * @memberof flyteidl.admin.AbortMetadata
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AbortMetadata.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.cause != null && message.hasOwnProperty("cause"))
                    if (!$util.isString(message.cause))
                        return "cause: string expected";
                if (message.principal != null && message.hasOwnProperty("principal"))
                    if (!$util.isString(message.principal))
                        return "principal: string expected";
                return null;
            };

            return AbortMetadata;
        })();

        admin.ExecutionClosure = (function() {

            /**
             * Properties of an ExecutionClosure.
             * @memberof flyteidl.admin
             * @interface IExecutionClosure
             * @property {flyteidl.admin.ILiteralMapBlob|null} [outputs] ExecutionClosure outputs
             * @property {flyteidl.core.IExecutionError|null} [error] ExecutionClosure error
             * @property {string|null} [abortCause] ExecutionClosure abortCause
             * @property {flyteidl.admin.IAbortMetadata|null} [abortMetadata] ExecutionClosure abortMetadata
             * @property {flyteidl.core.ILiteralMap|null} [computedInputs] ExecutionClosure computedInputs
             * @property {flyteidl.core.WorkflowExecution.Phase|null} [phase] ExecutionClosure phase
             * @property {google.protobuf.ITimestamp|null} [startedAt] ExecutionClosure startedAt
             * @property {google.protobuf.IDuration|null} [duration] ExecutionClosure duration
             * @property {google.protobuf.ITimestamp|null} [createdAt] ExecutionClosure createdAt
             * @property {google.protobuf.ITimestamp|null} [updatedAt] ExecutionClosure updatedAt
             * @property {Array.<flyteidl.admin.INotification>|null} [notifications] ExecutionClosure notifications
             * @property {flyteidl.core.IIdentifier|null} [workflowId] ExecutionClosure workflowId
             */

            /**
             * Constructs a new ExecutionClosure.
             * @memberof flyteidl.admin
             * @classdesc Represents an ExecutionClosure.
             * @implements IExecutionClosure
             * @constructor
             * @param {flyteidl.admin.IExecutionClosure=} [properties] Properties to set
             */
            function ExecutionClosure(properties) {
                this.notifications = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExecutionClosure outputs.
             * @member {flyteidl.admin.ILiteralMapBlob|null|undefined} outputs
             * @memberof flyteidl.admin.ExecutionClosure
             * @instance
             */
            ExecutionClosure.prototype.outputs = null;

            /**
             * ExecutionClosure error.
             * @member {flyteidl.core.IExecutionError|null|undefined} error
             * @memberof flyteidl.admin.ExecutionClosure
             * @instance
             */
            ExecutionClosure.prototype.error = null;

            /**
             * ExecutionClosure abortCause.
             * @member {string} abortCause
             * @memberof flyteidl.admin.ExecutionClosure
             * @instance
             */
            ExecutionClosure.prototype.abortCause = "";

            /**
             * ExecutionClosure abortMetadata.
             * @member {flyteidl.admin.IAbortMetadata|null|undefined} abortMetadata
             * @memberof flyteidl.admin.ExecutionClosure
             * @instance
             */
            ExecutionClosure.prototype.abortMetadata = null;

            /**
             * ExecutionClosure computedInputs.
             * @member {flyteidl.core.ILiteralMap|null|undefined} computedInputs
             * @memberof flyteidl.admin.ExecutionClosure
             * @instance
             */
            ExecutionClosure.prototype.computedInputs = null;

            /**
             * ExecutionClosure phase.
             * @member {flyteidl.core.WorkflowExecution.Phase} phase
             * @memberof flyteidl.admin.ExecutionClosure
             * @instance
             */
            ExecutionClosure.prototype.phase = 0;

            /**
             * ExecutionClosure startedAt.
             * @member {google.protobuf.ITimestamp|null|undefined} startedAt
             * @memberof flyteidl.admin.ExecutionClosure
             * @instance
             */
            ExecutionClosure.prototype.startedAt = null;

            /**
             * ExecutionClosure duration.
             * @member {google.protobuf.IDuration|null|undefined} duration
             * @memberof flyteidl.admin.ExecutionClosure
             * @instance
             */
            ExecutionClosure.prototype.duration = null;

            /**
             * ExecutionClosure createdAt.
             * @member {google.protobuf.ITimestamp|null|undefined} createdAt
             * @memberof flyteidl.admin.ExecutionClosure
             * @instance
             */
            ExecutionClosure.prototype.createdAt = null;

            /**
             * ExecutionClosure updatedAt.
             * @member {google.protobuf.ITimestamp|null|undefined} updatedAt
             * @memberof flyteidl.admin.ExecutionClosure
             * @instance
             */
            ExecutionClosure.prototype.updatedAt = null;

            /**
             * ExecutionClosure notifications.
             * @member {Array.<flyteidl.admin.INotification>} notifications
             * @memberof flyteidl.admin.ExecutionClosure
             * @instance
             */
            ExecutionClosure.prototype.notifications = $util.emptyArray;

            /**
             * ExecutionClosure workflowId.
             * @member {flyteidl.core.IIdentifier|null|undefined} workflowId
             * @memberof flyteidl.admin.ExecutionClosure
             * @instance
             */
            ExecutionClosure.prototype.workflowId = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * ExecutionClosure outputResult.
             * @member {"outputs"|"error"|"abortCause"|"abortMetadata"|undefined} outputResult
             * @memberof flyteidl.admin.ExecutionClosure
             * @instance
             */
            Object.defineProperty(ExecutionClosure.prototype, "outputResult", {
                get: $util.oneOfGetter($oneOfFields = ["outputs", "error", "abortCause", "abortMetadata"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new ExecutionClosure instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.ExecutionClosure
             * @static
             * @param {flyteidl.admin.IExecutionClosure=} [properties] Properties to set
             * @returns {flyteidl.admin.ExecutionClosure} ExecutionClosure instance
             */
            ExecutionClosure.create = function create(properties) {
                return new ExecutionClosure(properties);
            };

            /**
             * Encodes the specified ExecutionClosure message. Does not implicitly {@link flyteidl.admin.ExecutionClosure.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.ExecutionClosure
             * @static
             * @param {flyteidl.admin.IExecutionClosure} message ExecutionClosure message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecutionClosure.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.outputs != null && message.hasOwnProperty("outputs"))
                    $root.flyteidl.admin.LiteralMapBlob.encode(message.outputs, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.error != null && message.hasOwnProperty("error"))
                    $root.flyteidl.core.ExecutionError.encode(message.error, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.computedInputs != null && message.hasOwnProperty("computedInputs"))
                    $root.flyteidl.core.LiteralMap.encode(message.computedInputs, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.phase != null && message.hasOwnProperty("phase"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.phase);
                if (message.startedAt != null && message.hasOwnProperty("startedAt"))
                    $root.google.protobuf.Timestamp.encode(message.startedAt, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.duration != null && message.hasOwnProperty("duration"))
                    $root.google.protobuf.Duration.encode(message.duration, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.createdAt != null && message.hasOwnProperty("createdAt"))
                    $root.google.protobuf.Timestamp.encode(message.createdAt, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.updatedAt != null && message.hasOwnProperty("updatedAt"))
                    $root.google.protobuf.Timestamp.encode(message.updatedAt, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.notifications != null && message.notifications.length)
                    for (let i = 0; i < message.notifications.length; ++i)
                        $root.flyteidl.admin.Notification.encode(message.notifications[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.abortCause != null && message.hasOwnProperty("abortCause"))
                    writer.uint32(/* id 10, wireType 2 =*/82).string(message.abortCause);
                if (message.workflowId != null && message.hasOwnProperty("workflowId"))
                    $root.flyteidl.core.Identifier.encode(message.workflowId, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                if (message.abortMetadata != null && message.hasOwnProperty("abortMetadata"))
                    $root.flyteidl.admin.AbortMetadata.encode(message.abortMetadata, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes an ExecutionClosure message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.ExecutionClosure
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.ExecutionClosure} ExecutionClosure
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecutionClosure.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.ExecutionClosure();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.outputs = $root.flyteidl.admin.LiteralMapBlob.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.error = $root.flyteidl.core.ExecutionError.decode(reader, reader.uint32());
                        break;
                    case 10:
                        message.abortCause = reader.string();
                        break;
                    case 12:
                        message.abortMetadata = $root.flyteidl.admin.AbortMetadata.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.computedInputs = $root.flyteidl.core.LiteralMap.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.phase = reader.int32();
                        break;
                    case 5:
                        message.startedAt = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.duration = $root.google.protobuf.Duration.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.createdAt = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                        break;
                    case 8:
                        message.updatedAt = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                        break;
                    case 9:
                        if (!(message.notifications && message.notifications.length))
                            message.notifications = [];
                        message.notifications.push($root.flyteidl.admin.Notification.decode(reader, reader.uint32()));
                        break;
                    case 11:
                        message.workflowId = $root.flyteidl.core.Identifier.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies an ExecutionClosure message.
             * @function verify
             * @memberof flyteidl.admin.ExecutionClosure
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExecutionClosure.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.outputs != null && message.hasOwnProperty("outputs")) {
                    properties.outputResult = 1;
                    {
                        let error = $root.flyteidl.admin.LiteralMapBlob.verify(message.outputs);
                        if (error)
                            return "outputs." + error;
                    }
                }
                if (message.error != null && message.hasOwnProperty("error")) {
                    if (properties.outputResult === 1)
                        return "outputResult: multiple values";
                    properties.outputResult = 1;
                    {
                        let error = $root.flyteidl.core.ExecutionError.verify(message.error);
                        if (error)
                            return "error." + error;
                    }
                }
                if (message.abortCause != null && message.hasOwnProperty("abortCause")) {
                    if (properties.outputResult === 1)
                        return "outputResult: multiple values";
                    properties.outputResult = 1;
                    if (!$util.isString(message.abortCause))
                        return "abortCause: string expected";
                }
                if (message.abortMetadata != null && message.hasOwnProperty("abortMetadata")) {
                    if (properties.outputResult === 1)
                        return "outputResult: multiple values";
                    properties.outputResult = 1;
                    {
                        let error = $root.flyteidl.admin.AbortMetadata.verify(message.abortMetadata);
                        if (error)
                            return "abortMetadata." + error;
                    }
                }
                if (message.computedInputs != null && message.hasOwnProperty("computedInputs")) {
                    let error = $root.flyteidl.core.LiteralMap.verify(message.computedInputs);
                    if (error)
                        return "computedInputs." + error;
                }
                if (message.phase != null && message.hasOwnProperty("phase"))
                    switch (message.phase) {
                    default:
                        return "phase: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                        break;
                    }
                if (message.startedAt != null && message.hasOwnProperty("startedAt")) {
                    let error = $root.google.protobuf.Timestamp.verify(message.startedAt);
                    if (error)
                        return "startedAt." + error;
                }
                if (message.duration != null && message.hasOwnProperty("duration")) {
                    let error = $root.google.protobuf.Duration.verify(message.duration);
                    if (error)
                        return "duration." + error;
                }
                if (message.createdAt != null && message.hasOwnProperty("createdAt")) {
                    let error = $root.google.protobuf.Timestamp.verify(message.createdAt);
                    if (error)
                        return "createdAt." + error;
                }
                if (message.updatedAt != null && message.hasOwnProperty("updatedAt")) {
                    let error = $root.google.protobuf.Timestamp.verify(message.updatedAt);
                    if (error)
                        return "updatedAt." + error;
                }
                if (message.notifications != null && message.hasOwnProperty("notifications")) {
                    if (!Array.isArray(message.notifications))
                        return "notifications: array expected";
                    for (let i = 0; i < message.notifications.length; ++i) {
                        let error = $root.flyteidl.admin.Notification.verify(message.notifications[i]);
                        if (error)
                            return "notifications." + error;
                    }
                }
                if (message.workflowId != null && message.hasOwnProperty("workflowId")) {
                    let error = $root.flyteidl.core.Identifier.verify(message.workflowId);
                    if (error)
                        return "workflowId." + error;
                }
                return null;
            };

            return ExecutionClosure;
        })();

        admin.SystemMetadata = (function() {

            /**
             * Properties of a SystemMetadata.
             * @memberof flyteidl.admin
             * @interface ISystemMetadata
             * @property {string|null} [executionCluster] SystemMetadata executionCluster
             */

            /**
             * Constructs a new SystemMetadata.
             * @memberof flyteidl.admin
             * @classdesc Represents a SystemMetadata.
             * @implements ISystemMetadata
             * @constructor
             * @param {flyteidl.admin.ISystemMetadata=} [properties] Properties to set
             */
            function SystemMetadata(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SystemMetadata executionCluster.
             * @member {string} executionCluster
             * @memberof flyteidl.admin.SystemMetadata
             * @instance
             */
            SystemMetadata.prototype.executionCluster = "";

            /**
             * Creates a new SystemMetadata instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.SystemMetadata
             * @static
             * @param {flyteidl.admin.ISystemMetadata=} [properties] Properties to set
             * @returns {flyteidl.admin.SystemMetadata} SystemMetadata instance
             */
            SystemMetadata.create = function create(properties) {
                return new SystemMetadata(properties);
            };

            /**
             * Encodes the specified SystemMetadata message. Does not implicitly {@link flyteidl.admin.SystemMetadata.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.SystemMetadata
             * @static
             * @param {flyteidl.admin.ISystemMetadata} message SystemMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SystemMetadata.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.executionCluster != null && message.hasOwnProperty("executionCluster"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.executionCluster);
                return writer;
            };

            /**
             * Decodes a SystemMetadata message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.SystemMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.SystemMetadata} SystemMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SystemMetadata.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.SystemMetadata();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.executionCluster = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a SystemMetadata message.
             * @function verify
             * @memberof flyteidl.admin.SystemMetadata
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SystemMetadata.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.executionCluster != null && message.hasOwnProperty("executionCluster"))
                    if (!$util.isString(message.executionCluster))
                        return "executionCluster: string expected";
                return null;
            };

            return SystemMetadata;
        })();

        admin.ExecutionMetadata = (function() {

            /**
             * Properties of an ExecutionMetadata.
             * @memberof flyteidl.admin
             * @interface IExecutionMetadata
             * @property {flyteidl.admin.ExecutionMetadata.ExecutionMode|null} [mode] ExecutionMetadata mode
             * @property {string|null} [principal] ExecutionMetadata principal
             * @property {number|null} [nesting] ExecutionMetadata nesting
             * @property {google.protobuf.ITimestamp|null} [scheduledAt] ExecutionMetadata scheduledAt
             * @property {flyteidl.core.INodeExecutionIdentifier|null} [parentNodeExecution] ExecutionMetadata parentNodeExecution
             * @property {flyteidl.core.IWorkflowExecutionIdentifier|null} [referenceExecution] ExecutionMetadata referenceExecution
             * @property {flyteidl.admin.ISystemMetadata|null} [systemMetadata] ExecutionMetadata systemMetadata
             */

            /**
             * Constructs a new ExecutionMetadata.
             * @memberof flyteidl.admin
             * @classdesc Represents an ExecutionMetadata.
             * @implements IExecutionMetadata
             * @constructor
             * @param {flyteidl.admin.IExecutionMetadata=} [properties] Properties to set
             */
            function ExecutionMetadata(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExecutionMetadata mode.
             * @member {flyteidl.admin.ExecutionMetadata.ExecutionMode} mode
             * @memberof flyteidl.admin.ExecutionMetadata
             * @instance
             */
            ExecutionMetadata.prototype.mode = 0;

            /**
             * ExecutionMetadata principal.
             * @member {string} principal
             * @memberof flyteidl.admin.ExecutionMetadata
             * @instance
             */
            ExecutionMetadata.prototype.principal = "";

            /**
             * ExecutionMetadata nesting.
             * @member {number} nesting
             * @memberof flyteidl.admin.ExecutionMetadata
             * @instance
             */
            ExecutionMetadata.prototype.nesting = 0;

            /**
             * ExecutionMetadata scheduledAt.
             * @member {google.protobuf.ITimestamp|null|undefined} scheduledAt
             * @memberof flyteidl.admin.ExecutionMetadata
             * @instance
             */
            ExecutionMetadata.prototype.scheduledAt = null;

            /**
             * ExecutionMetadata parentNodeExecution.
             * @member {flyteidl.core.INodeExecutionIdentifier|null|undefined} parentNodeExecution
             * @memberof flyteidl.admin.ExecutionMetadata
             * @instance
             */
            ExecutionMetadata.prototype.parentNodeExecution = null;

            /**
             * ExecutionMetadata referenceExecution.
             * @member {flyteidl.core.IWorkflowExecutionIdentifier|null|undefined} referenceExecution
             * @memberof flyteidl.admin.ExecutionMetadata
             * @instance
             */
            ExecutionMetadata.prototype.referenceExecution = null;

            /**
             * ExecutionMetadata systemMetadata.
             * @member {flyteidl.admin.ISystemMetadata|null|undefined} systemMetadata
             * @memberof flyteidl.admin.ExecutionMetadata
             * @instance
             */
            ExecutionMetadata.prototype.systemMetadata = null;

            /**
             * Creates a new ExecutionMetadata instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.ExecutionMetadata
             * @static
             * @param {flyteidl.admin.IExecutionMetadata=} [properties] Properties to set
             * @returns {flyteidl.admin.ExecutionMetadata} ExecutionMetadata instance
             */
            ExecutionMetadata.create = function create(properties) {
                return new ExecutionMetadata(properties);
            };

            /**
             * Encodes the specified ExecutionMetadata message. Does not implicitly {@link flyteidl.admin.ExecutionMetadata.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.ExecutionMetadata
             * @static
             * @param {flyteidl.admin.IExecutionMetadata} message ExecutionMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecutionMetadata.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.mode != null && message.hasOwnProperty("mode"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.mode);
                if (message.principal != null && message.hasOwnProperty("principal"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.principal);
                if (message.nesting != null && message.hasOwnProperty("nesting"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.nesting);
                if (message.scheduledAt != null && message.hasOwnProperty("scheduledAt"))
                    $root.google.protobuf.Timestamp.encode(message.scheduledAt, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.parentNodeExecution != null && message.hasOwnProperty("parentNodeExecution"))
                    $root.flyteidl.core.NodeExecutionIdentifier.encode(message.parentNodeExecution, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.referenceExecution != null && message.hasOwnProperty("referenceExecution"))
                    $root.flyteidl.core.WorkflowExecutionIdentifier.encode(message.referenceExecution, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
                if (message.systemMetadata != null && message.hasOwnProperty("systemMetadata"))
                    $root.flyteidl.admin.SystemMetadata.encode(message.systemMetadata, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes an ExecutionMetadata message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.ExecutionMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.ExecutionMetadata} ExecutionMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecutionMetadata.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.ExecutionMetadata();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.mode = reader.int32();
                        break;
                    case 2:
                        message.principal = reader.string();
                        break;
                    case 3:
                        message.nesting = reader.uint32();
                        break;
                    case 4:
                        message.scheduledAt = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.parentNodeExecution = $root.flyteidl.core.NodeExecutionIdentifier.decode(reader, reader.uint32());
                        break;
                    case 16:
                        message.referenceExecution = $root.flyteidl.core.WorkflowExecutionIdentifier.decode(reader, reader.uint32());
                        break;
                    case 17:
                        message.systemMetadata = $root.flyteidl.admin.SystemMetadata.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies an ExecutionMetadata message.
             * @function verify
             * @memberof flyteidl.admin.ExecutionMetadata
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExecutionMetadata.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.mode != null && message.hasOwnProperty("mode"))
                    switch (message.mode) {
                    default:
                        return "mode: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                    }
                if (message.principal != null && message.hasOwnProperty("principal"))
                    if (!$util.isString(message.principal))
                        return "principal: string expected";
                if (message.nesting != null && message.hasOwnProperty("nesting"))
                    if (!$util.isInteger(message.nesting))
                        return "nesting: integer expected";
                if (message.scheduledAt != null && message.hasOwnProperty("scheduledAt")) {
                    let error = $root.google.protobuf.Timestamp.verify(message.scheduledAt);
                    if (error)
                        return "scheduledAt." + error;
                }
                if (message.parentNodeExecution != null && message.hasOwnProperty("parentNodeExecution")) {
                    let error = $root.flyteidl.core.NodeExecutionIdentifier.verify(message.parentNodeExecution);
                    if (error)
                        return "parentNodeExecution." + error;
                }
                if (message.referenceExecution != null && message.hasOwnProperty("referenceExecution")) {
                    let error = $root.flyteidl.core.WorkflowExecutionIdentifier.verify(message.referenceExecution);
                    if (error)
                        return "referenceExecution." + error;
                }
                if (message.systemMetadata != null && message.hasOwnProperty("systemMetadata")) {
                    let error = $root.flyteidl.admin.SystemMetadata.verify(message.systemMetadata);
                    if (error)
                        return "systemMetadata." + error;
                }
                return null;
            };

            /**
             * ExecutionMode enum.
             * @name flyteidl.admin.ExecutionMetadata.ExecutionMode
             * @enum {string}
             * @property {number} MANUAL=0 MANUAL value
             * @property {number} SCHEDULED=1 SCHEDULED value
             * @property {number} SYSTEM=2 SYSTEM value
             * @property {number} RELAUNCH=3 RELAUNCH value
             * @property {number} CHILD_WORKFLOW=4 CHILD_WORKFLOW value
             */
            ExecutionMetadata.ExecutionMode = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "MANUAL"] = 0;
                values[valuesById[1] = "SCHEDULED"] = 1;
                values[valuesById[2] = "SYSTEM"] = 2;
                values[valuesById[3] = "RELAUNCH"] = 3;
                values[valuesById[4] = "CHILD_WORKFLOW"] = 4;
                return values;
            })();

            return ExecutionMetadata;
        })();

        admin.NotificationList = (function() {

            /**
             * Properties of a NotificationList.
             * @memberof flyteidl.admin
             * @interface INotificationList
             * @property {Array.<flyteidl.admin.INotification>|null} [notifications] NotificationList notifications
             */

            /**
             * Constructs a new NotificationList.
             * @memberof flyteidl.admin
             * @classdesc Represents a NotificationList.
             * @implements INotificationList
             * @constructor
             * @param {flyteidl.admin.INotificationList=} [properties] Properties to set
             */
            function NotificationList(properties) {
                this.notifications = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NotificationList notifications.
             * @member {Array.<flyteidl.admin.INotification>} notifications
             * @memberof flyteidl.admin.NotificationList
             * @instance
             */
            NotificationList.prototype.notifications = $util.emptyArray;

            /**
             * Creates a new NotificationList instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.NotificationList
             * @static
             * @param {flyteidl.admin.INotificationList=} [properties] Properties to set
             * @returns {flyteidl.admin.NotificationList} NotificationList instance
             */
            NotificationList.create = function create(properties) {
                return new NotificationList(properties);
            };

            /**
             * Encodes the specified NotificationList message. Does not implicitly {@link flyteidl.admin.NotificationList.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.NotificationList
             * @static
             * @param {flyteidl.admin.INotificationList} message NotificationList message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NotificationList.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.notifications != null && message.notifications.length)
                    for (let i = 0; i < message.notifications.length; ++i)
                        $root.flyteidl.admin.Notification.encode(message.notifications[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a NotificationList message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.NotificationList
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.NotificationList} NotificationList
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NotificationList.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.NotificationList();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.notifications && message.notifications.length))
                            message.notifications = [];
                        message.notifications.push($root.flyteidl.admin.Notification.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a NotificationList message.
             * @function verify
             * @memberof flyteidl.admin.NotificationList
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NotificationList.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.notifications != null && message.hasOwnProperty("notifications")) {
                    if (!Array.isArray(message.notifications))
                        return "notifications: array expected";
                    for (let i = 0; i < message.notifications.length; ++i) {
                        let error = $root.flyteidl.admin.Notification.verify(message.notifications[i]);
                        if (error)
                            return "notifications." + error;
                    }
                }
                return null;
            };

            return NotificationList;
        })();

        admin.ExecutionSpec = (function() {

            /**
             * Properties of an ExecutionSpec.
             * @memberof flyteidl.admin
             * @interface IExecutionSpec
             * @property {flyteidl.core.IIdentifier|null} [launchPlan] ExecutionSpec launchPlan
             * @property {flyteidl.core.ILiteralMap|null} [inputs] ExecutionSpec inputs
             * @property {flyteidl.admin.IExecutionMetadata|null} [metadata] ExecutionSpec metadata
             * @property {flyteidl.admin.INotificationList|null} [notifications] ExecutionSpec notifications
             * @property {boolean|null} [disableAll] ExecutionSpec disableAll
             * @property {flyteidl.admin.ILabels|null} [labels] ExecutionSpec labels
             * @property {flyteidl.admin.IAnnotations|null} [annotations] ExecutionSpec annotations
             * @property {flyteidl.admin.IAuthRole|null} [authRole] ExecutionSpec authRole
             */

            /**
             * Constructs a new ExecutionSpec.
             * @memberof flyteidl.admin
             * @classdesc Represents an ExecutionSpec.
             * @implements IExecutionSpec
             * @constructor
             * @param {flyteidl.admin.IExecutionSpec=} [properties] Properties to set
             */
            function ExecutionSpec(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExecutionSpec launchPlan.
             * @member {flyteidl.core.IIdentifier|null|undefined} launchPlan
             * @memberof flyteidl.admin.ExecutionSpec
             * @instance
             */
            ExecutionSpec.prototype.launchPlan = null;

            /**
             * ExecutionSpec inputs.
             * @member {flyteidl.core.ILiteralMap|null|undefined} inputs
             * @memberof flyteidl.admin.ExecutionSpec
             * @instance
             */
            ExecutionSpec.prototype.inputs = null;

            /**
             * ExecutionSpec metadata.
             * @member {flyteidl.admin.IExecutionMetadata|null|undefined} metadata
             * @memberof flyteidl.admin.ExecutionSpec
             * @instance
             */
            ExecutionSpec.prototype.metadata = null;

            /**
             * ExecutionSpec notifications.
             * @member {flyteidl.admin.INotificationList|null|undefined} notifications
             * @memberof flyteidl.admin.ExecutionSpec
             * @instance
             */
            ExecutionSpec.prototype.notifications = null;

            /**
             * ExecutionSpec disableAll.
             * @member {boolean} disableAll
             * @memberof flyteidl.admin.ExecutionSpec
             * @instance
             */
            ExecutionSpec.prototype.disableAll = false;

            /**
             * ExecutionSpec labels.
             * @member {flyteidl.admin.ILabels|null|undefined} labels
             * @memberof flyteidl.admin.ExecutionSpec
             * @instance
             */
            ExecutionSpec.prototype.labels = null;

            /**
             * ExecutionSpec annotations.
             * @member {flyteidl.admin.IAnnotations|null|undefined} annotations
             * @memberof flyteidl.admin.ExecutionSpec
             * @instance
             */
            ExecutionSpec.prototype.annotations = null;

            /**
             * ExecutionSpec authRole.
             * @member {flyteidl.admin.IAuthRole|null|undefined} authRole
             * @memberof flyteidl.admin.ExecutionSpec
             * @instance
             */
            ExecutionSpec.prototype.authRole = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * ExecutionSpec notificationOverrides.
             * @member {"notifications"|"disableAll"|undefined} notificationOverrides
             * @memberof flyteidl.admin.ExecutionSpec
             * @instance
             */
            Object.defineProperty(ExecutionSpec.prototype, "notificationOverrides", {
                get: $util.oneOfGetter($oneOfFields = ["notifications", "disableAll"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new ExecutionSpec instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.ExecutionSpec
             * @static
             * @param {flyteidl.admin.IExecutionSpec=} [properties] Properties to set
             * @returns {flyteidl.admin.ExecutionSpec} ExecutionSpec instance
             */
            ExecutionSpec.create = function create(properties) {
                return new ExecutionSpec(properties);
            };

            /**
             * Encodes the specified ExecutionSpec message. Does not implicitly {@link flyteidl.admin.ExecutionSpec.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.ExecutionSpec
             * @static
             * @param {flyteidl.admin.IExecutionSpec} message ExecutionSpec message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecutionSpec.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.launchPlan != null && message.hasOwnProperty("launchPlan"))
                    $root.flyteidl.core.Identifier.encode(message.launchPlan, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.inputs != null && message.hasOwnProperty("inputs"))
                    $root.flyteidl.core.LiteralMap.encode(message.inputs, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    $root.flyteidl.admin.ExecutionMetadata.encode(message.metadata, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.notifications != null && message.hasOwnProperty("notifications"))
                    $root.flyteidl.admin.NotificationList.encode(message.notifications, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.disableAll != null && message.hasOwnProperty("disableAll"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.disableAll);
                if (message.labels != null && message.hasOwnProperty("labels"))
                    $root.flyteidl.admin.Labels.encode(message.labels, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.annotations != null && message.hasOwnProperty("annotations"))
                    $root.flyteidl.admin.Annotations.encode(message.annotations, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.authRole != null && message.hasOwnProperty("authRole"))
                    $root.flyteidl.admin.AuthRole.encode(message.authRole, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes an ExecutionSpec message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.ExecutionSpec
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.ExecutionSpec} ExecutionSpec
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecutionSpec.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.ExecutionSpec();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.launchPlan = $root.flyteidl.core.Identifier.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.inputs = $root.flyteidl.core.LiteralMap.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.metadata = $root.flyteidl.admin.ExecutionMetadata.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.notifications = $root.flyteidl.admin.NotificationList.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.disableAll = reader.bool();
                        break;
                    case 7:
                        message.labels = $root.flyteidl.admin.Labels.decode(reader, reader.uint32());
                        break;
                    case 8:
                        message.annotations = $root.flyteidl.admin.Annotations.decode(reader, reader.uint32());
                        break;
                    case 16:
                        message.authRole = $root.flyteidl.admin.AuthRole.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies an ExecutionSpec message.
             * @function verify
             * @memberof flyteidl.admin.ExecutionSpec
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExecutionSpec.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.launchPlan != null && message.hasOwnProperty("launchPlan")) {
                    let error = $root.flyteidl.core.Identifier.verify(message.launchPlan);
                    if (error)
                        return "launchPlan." + error;
                }
                if (message.inputs != null && message.hasOwnProperty("inputs")) {
                    let error = $root.flyteidl.core.LiteralMap.verify(message.inputs);
                    if (error)
                        return "inputs." + error;
                }
                if (message.metadata != null && message.hasOwnProperty("metadata")) {
                    let error = $root.flyteidl.admin.ExecutionMetadata.verify(message.metadata);
                    if (error)
                        return "metadata." + error;
                }
                if (message.notifications != null && message.hasOwnProperty("notifications")) {
                    properties.notificationOverrides = 1;
                    {
                        let error = $root.flyteidl.admin.NotificationList.verify(message.notifications);
                        if (error)
                            return "notifications." + error;
                    }
                }
                if (message.disableAll != null && message.hasOwnProperty("disableAll")) {
                    if (properties.notificationOverrides === 1)
                        return "notificationOverrides: multiple values";
                    properties.notificationOverrides = 1;
                    if (typeof message.disableAll !== "boolean")
                        return "disableAll: boolean expected";
                }
                if (message.labels != null && message.hasOwnProperty("labels")) {
                    let error = $root.flyteidl.admin.Labels.verify(message.labels);
                    if (error)
                        return "labels." + error;
                }
                if (message.annotations != null && message.hasOwnProperty("annotations")) {
                    let error = $root.flyteidl.admin.Annotations.verify(message.annotations);
                    if (error)
                        return "annotations." + error;
                }
                if (message.authRole != null && message.hasOwnProperty("authRole")) {
                    let error = $root.flyteidl.admin.AuthRole.verify(message.authRole);
                    if (error)
                        return "authRole." + error;
                }
                return null;
            };

            return ExecutionSpec;
        })();

        admin.ExecutionTerminateRequest = (function() {

            /**
             * Properties of an ExecutionTerminateRequest.
             * @memberof flyteidl.admin
             * @interface IExecutionTerminateRequest
             * @property {flyteidl.core.IWorkflowExecutionIdentifier|null} [id] ExecutionTerminateRequest id
             * @property {string|null} [cause] ExecutionTerminateRequest cause
             */

            /**
             * Constructs a new ExecutionTerminateRequest.
             * @memberof flyteidl.admin
             * @classdesc Represents an ExecutionTerminateRequest.
             * @implements IExecutionTerminateRequest
             * @constructor
             * @param {flyteidl.admin.IExecutionTerminateRequest=} [properties] Properties to set
             */
            function ExecutionTerminateRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExecutionTerminateRequest id.
             * @member {flyteidl.core.IWorkflowExecutionIdentifier|null|undefined} id
             * @memberof flyteidl.admin.ExecutionTerminateRequest
             * @instance
             */
            ExecutionTerminateRequest.prototype.id = null;

            /**
             * ExecutionTerminateRequest cause.
             * @member {string} cause
             * @memberof flyteidl.admin.ExecutionTerminateRequest
             * @instance
             */
            ExecutionTerminateRequest.prototype.cause = "";

            /**
             * Creates a new ExecutionTerminateRequest instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.ExecutionTerminateRequest
             * @static
             * @param {flyteidl.admin.IExecutionTerminateRequest=} [properties] Properties to set
             * @returns {flyteidl.admin.ExecutionTerminateRequest} ExecutionTerminateRequest instance
             */
            ExecutionTerminateRequest.create = function create(properties) {
                return new ExecutionTerminateRequest(properties);
            };

            /**
             * Encodes the specified ExecutionTerminateRequest message. Does not implicitly {@link flyteidl.admin.ExecutionTerminateRequest.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.ExecutionTerminateRequest
             * @static
             * @param {flyteidl.admin.IExecutionTerminateRequest} message ExecutionTerminateRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecutionTerminateRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    $root.flyteidl.core.WorkflowExecutionIdentifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.cause != null && message.hasOwnProperty("cause"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.cause);
                return writer;
            };

            /**
             * Decodes an ExecutionTerminateRequest message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.ExecutionTerminateRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.ExecutionTerminateRequest} ExecutionTerminateRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecutionTerminateRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.ExecutionTerminateRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = $root.flyteidl.core.WorkflowExecutionIdentifier.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.cause = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies an ExecutionTerminateRequest message.
             * @function verify
             * @memberof flyteidl.admin.ExecutionTerminateRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExecutionTerminateRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id")) {
                    let error = $root.flyteidl.core.WorkflowExecutionIdentifier.verify(message.id);
                    if (error)
                        return "id." + error;
                }
                if (message.cause != null && message.hasOwnProperty("cause"))
                    if (!$util.isString(message.cause))
                        return "cause: string expected";
                return null;
            };

            return ExecutionTerminateRequest;
        })();

        admin.ExecutionTerminateResponse = (function() {

            /**
             * Properties of an ExecutionTerminateResponse.
             * @memberof flyteidl.admin
             * @interface IExecutionTerminateResponse
             */

            /**
             * Constructs a new ExecutionTerminateResponse.
             * @memberof flyteidl.admin
             * @classdesc Represents an ExecutionTerminateResponse.
             * @implements IExecutionTerminateResponse
             * @constructor
             * @param {flyteidl.admin.IExecutionTerminateResponse=} [properties] Properties to set
             */
            function ExecutionTerminateResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new ExecutionTerminateResponse instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.ExecutionTerminateResponse
             * @static
             * @param {flyteidl.admin.IExecutionTerminateResponse=} [properties] Properties to set
             * @returns {flyteidl.admin.ExecutionTerminateResponse} ExecutionTerminateResponse instance
             */
            ExecutionTerminateResponse.create = function create(properties) {
                return new ExecutionTerminateResponse(properties);
            };

            /**
             * Encodes the specified ExecutionTerminateResponse message. Does not implicitly {@link flyteidl.admin.ExecutionTerminateResponse.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.ExecutionTerminateResponse
             * @static
             * @param {flyteidl.admin.IExecutionTerminateResponse} message ExecutionTerminateResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecutionTerminateResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Decodes an ExecutionTerminateResponse message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.ExecutionTerminateResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.ExecutionTerminateResponse} ExecutionTerminateResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecutionTerminateResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.ExecutionTerminateResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies an ExecutionTerminateResponse message.
             * @function verify
             * @memberof flyteidl.admin.ExecutionTerminateResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExecutionTerminateResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            return ExecutionTerminateResponse;
        })();

        admin.WorkflowExecutionGetDataRequest = (function() {

            /**
             * Properties of a WorkflowExecutionGetDataRequest.
             * @memberof flyteidl.admin
             * @interface IWorkflowExecutionGetDataRequest
             * @property {flyteidl.core.IWorkflowExecutionIdentifier|null} [id] WorkflowExecutionGetDataRequest id
             */

            /**
             * Constructs a new WorkflowExecutionGetDataRequest.
             * @memberof flyteidl.admin
             * @classdesc Represents a WorkflowExecutionGetDataRequest.
             * @implements IWorkflowExecutionGetDataRequest
             * @constructor
             * @param {flyteidl.admin.IWorkflowExecutionGetDataRequest=} [properties] Properties to set
             */
            function WorkflowExecutionGetDataRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WorkflowExecutionGetDataRequest id.
             * @member {flyteidl.core.IWorkflowExecutionIdentifier|null|undefined} id
             * @memberof flyteidl.admin.WorkflowExecutionGetDataRequest
             * @instance
             */
            WorkflowExecutionGetDataRequest.prototype.id = null;

            /**
             * Creates a new WorkflowExecutionGetDataRequest instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.WorkflowExecutionGetDataRequest
             * @static
             * @param {flyteidl.admin.IWorkflowExecutionGetDataRequest=} [properties] Properties to set
             * @returns {flyteidl.admin.WorkflowExecutionGetDataRequest} WorkflowExecutionGetDataRequest instance
             */
            WorkflowExecutionGetDataRequest.create = function create(properties) {
                return new WorkflowExecutionGetDataRequest(properties);
            };

            /**
             * Encodes the specified WorkflowExecutionGetDataRequest message. Does not implicitly {@link flyteidl.admin.WorkflowExecutionGetDataRequest.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.WorkflowExecutionGetDataRequest
             * @static
             * @param {flyteidl.admin.IWorkflowExecutionGetDataRequest} message WorkflowExecutionGetDataRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WorkflowExecutionGetDataRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    $root.flyteidl.core.WorkflowExecutionIdentifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a WorkflowExecutionGetDataRequest message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.WorkflowExecutionGetDataRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.WorkflowExecutionGetDataRequest} WorkflowExecutionGetDataRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WorkflowExecutionGetDataRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.WorkflowExecutionGetDataRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = $root.flyteidl.core.WorkflowExecutionIdentifier.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a WorkflowExecutionGetDataRequest message.
             * @function verify
             * @memberof flyteidl.admin.WorkflowExecutionGetDataRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WorkflowExecutionGetDataRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id")) {
                    let error = $root.flyteidl.core.WorkflowExecutionIdentifier.verify(message.id);
                    if (error)
                        return "id." + error;
                }
                return null;
            };

            return WorkflowExecutionGetDataRequest;
        })();

        admin.WorkflowExecutionGetDataResponse = (function() {

            /**
             * Properties of a WorkflowExecutionGetDataResponse.
             * @memberof flyteidl.admin
             * @interface IWorkflowExecutionGetDataResponse
             * @property {flyteidl.admin.IUrlBlob|null} [outputs] WorkflowExecutionGetDataResponse outputs
             * @property {flyteidl.admin.IUrlBlob|null} [inputs] WorkflowExecutionGetDataResponse inputs
             */

            /**
             * Constructs a new WorkflowExecutionGetDataResponse.
             * @memberof flyteidl.admin
             * @classdesc Represents a WorkflowExecutionGetDataResponse.
             * @implements IWorkflowExecutionGetDataResponse
             * @constructor
             * @param {flyteidl.admin.IWorkflowExecutionGetDataResponse=} [properties] Properties to set
             */
            function WorkflowExecutionGetDataResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WorkflowExecutionGetDataResponse outputs.
             * @member {flyteidl.admin.IUrlBlob|null|undefined} outputs
             * @memberof flyteidl.admin.WorkflowExecutionGetDataResponse
             * @instance
             */
            WorkflowExecutionGetDataResponse.prototype.outputs = null;

            /**
             * WorkflowExecutionGetDataResponse inputs.
             * @member {flyteidl.admin.IUrlBlob|null|undefined} inputs
             * @memberof flyteidl.admin.WorkflowExecutionGetDataResponse
             * @instance
             */
            WorkflowExecutionGetDataResponse.prototype.inputs = null;

            /**
             * Creates a new WorkflowExecutionGetDataResponse instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.WorkflowExecutionGetDataResponse
             * @static
             * @param {flyteidl.admin.IWorkflowExecutionGetDataResponse=} [properties] Properties to set
             * @returns {flyteidl.admin.WorkflowExecutionGetDataResponse} WorkflowExecutionGetDataResponse instance
             */
            WorkflowExecutionGetDataResponse.create = function create(properties) {
                return new WorkflowExecutionGetDataResponse(properties);
            };

            /**
             * Encodes the specified WorkflowExecutionGetDataResponse message. Does not implicitly {@link flyteidl.admin.WorkflowExecutionGetDataResponse.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.WorkflowExecutionGetDataResponse
             * @static
             * @param {flyteidl.admin.IWorkflowExecutionGetDataResponse} message WorkflowExecutionGetDataResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WorkflowExecutionGetDataResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.outputs != null && message.hasOwnProperty("outputs"))
                    $root.flyteidl.admin.UrlBlob.encode(message.outputs, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.inputs != null && message.hasOwnProperty("inputs"))
                    $root.flyteidl.admin.UrlBlob.encode(message.inputs, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a WorkflowExecutionGetDataResponse message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.WorkflowExecutionGetDataResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.WorkflowExecutionGetDataResponse} WorkflowExecutionGetDataResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WorkflowExecutionGetDataResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.WorkflowExecutionGetDataResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.outputs = $root.flyteidl.admin.UrlBlob.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.inputs = $root.flyteidl.admin.UrlBlob.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a WorkflowExecutionGetDataResponse message.
             * @function verify
             * @memberof flyteidl.admin.WorkflowExecutionGetDataResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WorkflowExecutionGetDataResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.outputs != null && message.hasOwnProperty("outputs")) {
                    let error = $root.flyteidl.admin.UrlBlob.verify(message.outputs);
                    if (error)
                        return "outputs." + error;
                }
                if (message.inputs != null && message.hasOwnProperty("inputs")) {
                    let error = $root.flyteidl.admin.UrlBlob.verify(message.inputs);
                    if (error)
                        return "inputs." + error;
                }
                return null;
            };

            return WorkflowExecutionGetDataResponse;
        })();

        admin.LaunchPlanCreateRequest = (function() {

            /**
             * Properties of a LaunchPlanCreateRequest.
             * @memberof flyteidl.admin
             * @interface ILaunchPlanCreateRequest
             * @property {flyteidl.core.IIdentifier|null} [id] LaunchPlanCreateRequest id
             * @property {flyteidl.admin.ILaunchPlanSpec|null} [spec] LaunchPlanCreateRequest spec
             */

            /**
             * Constructs a new LaunchPlanCreateRequest.
             * @memberof flyteidl.admin
             * @classdesc Represents a LaunchPlanCreateRequest.
             * @implements ILaunchPlanCreateRequest
             * @constructor
             * @param {flyteidl.admin.ILaunchPlanCreateRequest=} [properties] Properties to set
             */
            function LaunchPlanCreateRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LaunchPlanCreateRequest id.
             * @member {flyteidl.core.IIdentifier|null|undefined} id
             * @memberof flyteidl.admin.LaunchPlanCreateRequest
             * @instance
             */
            LaunchPlanCreateRequest.prototype.id = null;

            /**
             * LaunchPlanCreateRequest spec.
             * @member {flyteidl.admin.ILaunchPlanSpec|null|undefined} spec
             * @memberof flyteidl.admin.LaunchPlanCreateRequest
             * @instance
             */
            LaunchPlanCreateRequest.prototype.spec = null;

            /**
             * Creates a new LaunchPlanCreateRequest instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.LaunchPlanCreateRequest
             * @static
             * @param {flyteidl.admin.ILaunchPlanCreateRequest=} [properties] Properties to set
             * @returns {flyteidl.admin.LaunchPlanCreateRequest} LaunchPlanCreateRequest instance
             */
            LaunchPlanCreateRequest.create = function create(properties) {
                return new LaunchPlanCreateRequest(properties);
            };

            /**
             * Encodes the specified LaunchPlanCreateRequest message. Does not implicitly {@link flyteidl.admin.LaunchPlanCreateRequest.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.LaunchPlanCreateRequest
             * @static
             * @param {flyteidl.admin.ILaunchPlanCreateRequest} message LaunchPlanCreateRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LaunchPlanCreateRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    $root.flyteidl.core.Identifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.spec != null && message.hasOwnProperty("spec"))
                    $root.flyteidl.admin.LaunchPlanSpec.encode(message.spec, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a LaunchPlanCreateRequest message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.LaunchPlanCreateRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.LaunchPlanCreateRequest} LaunchPlanCreateRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LaunchPlanCreateRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.LaunchPlanCreateRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = $root.flyteidl.core.Identifier.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.spec = $root.flyteidl.admin.LaunchPlanSpec.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a LaunchPlanCreateRequest message.
             * @function verify
             * @memberof flyteidl.admin.LaunchPlanCreateRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LaunchPlanCreateRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id")) {
                    let error = $root.flyteidl.core.Identifier.verify(message.id);
                    if (error)
                        return "id." + error;
                }
                if (message.spec != null && message.hasOwnProperty("spec")) {
                    let error = $root.flyteidl.admin.LaunchPlanSpec.verify(message.spec);
                    if (error)
                        return "spec." + error;
                }
                return null;
            };

            return LaunchPlanCreateRequest;
        })();

        admin.LaunchPlanCreateResponse = (function() {

            /**
             * Properties of a LaunchPlanCreateResponse.
             * @memberof flyteidl.admin
             * @interface ILaunchPlanCreateResponse
             */

            /**
             * Constructs a new LaunchPlanCreateResponse.
             * @memberof flyteidl.admin
             * @classdesc Represents a LaunchPlanCreateResponse.
             * @implements ILaunchPlanCreateResponse
             * @constructor
             * @param {flyteidl.admin.ILaunchPlanCreateResponse=} [properties] Properties to set
             */
            function LaunchPlanCreateResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new LaunchPlanCreateResponse instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.LaunchPlanCreateResponse
             * @static
             * @param {flyteidl.admin.ILaunchPlanCreateResponse=} [properties] Properties to set
             * @returns {flyteidl.admin.LaunchPlanCreateResponse} LaunchPlanCreateResponse instance
             */
            LaunchPlanCreateResponse.create = function create(properties) {
                return new LaunchPlanCreateResponse(properties);
            };

            /**
             * Encodes the specified LaunchPlanCreateResponse message. Does not implicitly {@link flyteidl.admin.LaunchPlanCreateResponse.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.LaunchPlanCreateResponse
             * @static
             * @param {flyteidl.admin.ILaunchPlanCreateResponse} message LaunchPlanCreateResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LaunchPlanCreateResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Decodes a LaunchPlanCreateResponse message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.LaunchPlanCreateResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.LaunchPlanCreateResponse} LaunchPlanCreateResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LaunchPlanCreateResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.LaunchPlanCreateResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a LaunchPlanCreateResponse message.
             * @function verify
             * @memberof flyteidl.admin.LaunchPlanCreateResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LaunchPlanCreateResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            return LaunchPlanCreateResponse;
        })();

        /**
         * LaunchPlanState enum.
         * @name flyteidl.admin.LaunchPlanState
         * @enum {string}
         * @property {number} INACTIVE=0 INACTIVE value
         * @property {number} ACTIVE=1 ACTIVE value
         */
        admin.LaunchPlanState = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "INACTIVE"] = 0;
            values[valuesById[1] = "ACTIVE"] = 1;
            return values;
        })();

        admin.LaunchPlan = (function() {

            /**
             * Properties of a LaunchPlan.
             * @memberof flyteidl.admin
             * @interface ILaunchPlan
             * @property {flyteidl.core.IIdentifier|null} [id] LaunchPlan id
             * @property {flyteidl.admin.ILaunchPlanSpec|null} [spec] LaunchPlan spec
             * @property {flyteidl.admin.ILaunchPlanClosure|null} [closure] LaunchPlan closure
             */

            /**
             * Constructs a new LaunchPlan.
             * @memberof flyteidl.admin
             * @classdesc Represents a LaunchPlan.
             * @implements ILaunchPlan
             * @constructor
             * @param {flyteidl.admin.ILaunchPlan=} [properties] Properties to set
             */
            function LaunchPlan(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LaunchPlan id.
             * @member {flyteidl.core.IIdentifier|null|undefined} id
             * @memberof flyteidl.admin.LaunchPlan
             * @instance
             */
            LaunchPlan.prototype.id = null;

            /**
             * LaunchPlan spec.
             * @member {flyteidl.admin.ILaunchPlanSpec|null|undefined} spec
             * @memberof flyteidl.admin.LaunchPlan
             * @instance
             */
            LaunchPlan.prototype.spec = null;

            /**
             * LaunchPlan closure.
             * @member {flyteidl.admin.ILaunchPlanClosure|null|undefined} closure
             * @memberof flyteidl.admin.LaunchPlan
             * @instance
             */
            LaunchPlan.prototype.closure = null;

            /**
             * Creates a new LaunchPlan instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.LaunchPlan
             * @static
             * @param {flyteidl.admin.ILaunchPlan=} [properties] Properties to set
             * @returns {flyteidl.admin.LaunchPlan} LaunchPlan instance
             */
            LaunchPlan.create = function create(properties) {
                return new LaunchPlan(properties);
            };

            /**
             * Encodes the specified LaunchPlan message. Does not implicitly {@link flyteidl.admin.LaunchPlan.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.LaunchPlan
             * @static
             * @param {flyteidl.admin.ILaunchPlan} message LaunchPlan message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LaunchPlan.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    $root.flyteidl.core.Identifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.spec != null && message.hasOwnProperty("spec"))
                    $root.flyteidl.admin.LaunchPlanSpec.encode(message.spec, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.closure != null && message.hasOwnProperty("closure"))
                    $root.flyteidl.admin.LaunchPlanClosure.encode(message.closure, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a LaunchPlan message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.LaunchPlan
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.LaunchPlan} LaunchPlan
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LaunchPlan.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.LaunchPlan();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = $root.flyteidl.core.Identifier.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.spec = $root.flyteidl.admin.LaunchPlanSpec.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.closure = $root.flyteidl.admin.LaunchPlanClosure.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a LaunchPlan message.
             * @function verify
             * @memberof flyteidl.admin.LaunchPlan
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LaunchPlan.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id")) {
                    let error = $root.flyteidl.core.Identifier.verify(message.id);
                    if (error)
                        return "id." + error;
                }
                if (message.spec != null && message.hasOwnProperty("spec")) {
                    let error = $root.flyteidl.admin.LaunchPlanSpec.verify(message.spec);
                    if (error)
                        return "spec." + error;
                }
                if (message.closure != null && message.hasOwnProperty("closure")) {
                    let error = $root.flyteidl.admin.LaunchPlanClosure.verify(message.closure);
                    if (error)
                        return "closure." + error;
                }
                return null;
            };

            return LaunchPlan;
        })();

        admin.LaunchPlanList = (function() {

            /**
             * Properties of a LaunchPlanList.
             * @memberof flyteidl.admin
             * @interface ILaunchPlanList
             * @property {Array.<flyteidl.admin.ILaunchPlan>|null} [launchPlans] LaunchPlanList launchPlans
             * @property {string|null} [token] LaunchPlanList token
             */

            /**
             * Constructs a new LaunchPlanList.
             * @memberof flyteidl.admin
             * @classdesc Represents a LaunchPlanList.
             * @implements ILaunchPlanList
             * @constructor
             * @param {flyteidl.admin.ILaunchPlanList=} [properties] Properties to set
             */
            function LaunchPlanList(properties) {
                this.launchPlans = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LaunchPlanList launchPlans.
             * @member {Array.<flyteidl.admin.ILaunchPlan>} launchPlans
             * @memberof flyteidl.admin.LaunchPlanList
             * @instance
             */
            LaunchPlanList.prototype.launchPlans = $util.emptyArray;

            /**
             * LaunchPlanList token.
             * @member {string} token
             * @memberof flyteidl.admin.LaunchPlanList
             * @instance
             */
            LaunchPlanList.prototype.token = "";

            /**
             * Creates a new LaunchPlanList instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.LaunchPlanList
             * @static
             * @param {flyteidl.admin.ILaunchPlanList=} [properties] Properties to set
             * @returns {flyteidl.admin.LaunchPlanList} LaunchPlanList instance
             */
            LaunchPlanList.create = function create(properties) {
                return new LaunchPlanList(properties);
            };

            /**
             * Encodes the specified LaunchPlanList message. Does not implicitly {@link flyteidl.admin.LaunchPlanList.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.LaunchPlanList
             * @static
             * @param {flyteidl.admin.ILaunchPlanList} message LaunchPlanList message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LaunchPlanList.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.launchPlans != null && message.launchPlans.length)
                    for (let i = 0; i < message.launchPlans.length; ++i)
                        $root.flyteidl.admin.LaunchPlan.encode(message.launchPlans[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.token != null && message.hasOwnProperty("token"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.token);
                return writer;
            };

            /**
             * Decodes a LaunchPlanList message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.LaunchPlanList
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.LaunchPlanList} LaunchPlanList
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LaunchPlanList.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.LaunchPlanList();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.launchPlans && message.launchPlans.length))
                            message.launchPlans = [];
                        message.launchPlans.push($root.flyteidl.admin.LaunchPlan.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        message.token = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a LaunchPlanList message.
             * @function verify
             * @memberof flyteidl.admin.LaunchPlanList
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LaunchPlanList.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.launchPlans != null && message.hasOwnProperty("launchPlans")) {
                    if (!Array.isArray(message.launchPlans))
                        return "launchPlans: array expected";
                    for (let i = 0; i < message.launchPlans.length; ++i) {
                        let error = $root.flyteidl.admin.LaunchPlan.verify(message.launchPlans[i]);
                        if (error)
                            return "launchPlans." + error;
                    }
                }
                if (message.token != null && message.hasOwnProperty("token"))
                    if (!$util.isString(message.token))
                        return "token: string expected";
                return null;
            };

            return LaunchPlanList;
        })();

        admin.Auth = (function() {

            /**
             * Properties of an Auth.
             * @memberof flyteidl.admin
             * @interface IAuth
             * @property {string|null} [assumableIamRole] Auth assumableIamRole
             * @property {string|null} [kubernetesServiceAccount] Auth kubernetesServiceAccount
             */

            /**
             * Constructs a new Auth.
             * @memberof flyteidl.admin
             * @classdesc Represents an Auth.
             * @implements IAuth
             * @constructor
             * @param {flyteidl.admin.IAuth=} [properties] Properties to set
             */
            function Auth(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Auth assumableIamRole.
             * @member {string} assumableIamRole
             * @memberof flyteidl.admin.Auth
             * @instance
             */
            Auth.prototype.assumableIamRole = "";

            /**
             * Auth kubernetesServiceAccount.
             * @member {string} kubernetesServiceAccount
             * @memberof flyteidl.admin.Auth
             * @instance
             */
            Auth.prototype.kubernetesServiceAccount = "";

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * Auth method.
             * @member {"assumableIamRole"|"kubernetesServiceAccount"|undefined} method
             * @memberof flyteidl.admin.Auth
             * @instance
             */
            Object.defineProperty(Auth.prototype, "method", {
                get: $util.oneOfGetter($oneOfFields = ["assumableIamRole", "kubernetesServiceAccount"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new Auth instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.Auth
             * @static
             * @param {flyteidl.admin.IAuth=} [properties] Properties to set
             * @returns {flyteidl.admin.Auth} Auth instance
             */
            Auth.create = function create(properties) {
                return new Auth(properties);
            };

            /**
             * Encodes the specified Auth message. Does not implicitly {@link flyteidl.admin.Auth.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.Auth
             * @static
             * @param {flyteidl.admin.IAuth} message Auth message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Auth.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.assumableIamRole != null && message.hasOwnProperty("assumableIamRole"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.assumableIamRole);
                if (message.kubernetesServiceAccount != null && message.hasOwnProperty("kubernetesServiceAccount"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.kubernetesServiceAccount);
                return writer;
            };

            /**
             * Decodes an Auth message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.Auth
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.Auth} Auth
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Auth.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.Auth();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.assumableIamRole = reader.string();
                        break;
                    case 2:
                        message.kubernetesServiceAccount = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies an Auth message.
             * @function verify
             * @memberof flyteidl.admin.Auth
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Auth.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.assumableIamRole != null && message.hasOwnProperty("assumableIamRole")) {
                    properties.method = 1;
                    if (!$util.isString(message.assumableIamRole))
                        return "assumableIamRole: string expected";
                }
                if (message.kubernetesServiceAccount != null && message.hasOwnProperty("kubernetesServiceAccount")) {
                    if (properties.method === 1)
                        return "method: multiple values";
                    properties.method = 1;
                    if (!$util.isString(message.kubernetesServiceAccount))
                        return "kubernetesServiceAccount: string expected";
                }
                return null;
            };

            return Auth;
        })();

        admin.LaunchPlanSpec = (function() {

            /**
             * Properties of a LaunchPlanSpec.
             * @memberof flyteidl.admin
             * @interface ILaunchPlanSpec
             * @property {flyteidl.core.IIdentifier|null} [workflowId] LaunchPlanSpec workflowId
             * @property {flyteidl.admin.ILaunchPlanMetadata|null} [entityMetadata] LaunchPlanSpec entityMetadata
             * @property {flyteidl.core.IParameterMap|null} [defaultInputs] LaunchPlanSpec defaultInputs
             * @property {flyteidl.core.ILiteralMap|null} [fixedInputs] LaunchPlanSpec fixedInputs
             * @property {string|null} [role] LaunchPlanSpec role
             * @property {flyteidl.admin.ILabels|null} [labels] LaunchPlanSpec labels
             * @property {flyteidl.admin.IAnnotations|null} [annotations] LaunchPlanSpec annotations
             * @property {flyteidl.admin.IAuth|null} [auth] LaunchPlanSpec auth
             * @property {flyteidl.admin.IAuthRole|null} [authRole] LaunchPlanSpec authRole
             */

            /**
             * Constructs a new LaunchPlanSpec.
             * @memberof flyteidl.admin
             * @classdesc Represents a LaunchPlanSpec.
             * @implements ILaunchPlanSpec
             * @constructor
             * @param {flyteidl.admin.ILaunchPlanSpec=} [properties] Properties to set
             */
            function LaunchPlanSpec(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LaunchPlanSpec workflowId.
             * @member {flyteidl.core.IIdentifier|null|undefined} workflowId
             * @memberof flyteidl.admin.LaunchPlanSpec
             * @instance
             */
            LaunchPlanSpec.prototype.workflowId = null;

            /**
             * LaunchPlanSpec entityMetadata.
             * @member {flyteidl.admin.ILaunchPlanMetadata|null|undefined} entityMetadata
             * @memberof flyteidl.admin.LaunchPlanSpec
             * @instance
             */
            LaunchPlanSpec.prototype.entityMetadata = null;

            /**
             * LaunchPlanSpec defaultInputs.
             * @member {flyteidl.core.IParameterMap|null|undefined} defaultInputs
             * @memberof flyteidl.admin.LaunchPlanSpec
             * @instance
             */
            LaunchPlanSpec.prototype.defaultInputs = null;

            /**
             * LaunchPlanSpec fixedInputs.
             * @member {flyteidl.core.ILiteralMap|null|undefined} fixedInputs
             * @memberof flyteidl.admin.LaunchPlanSpec
             * @instance
             */
            LaunchPlanSpec.prototype.fixedInputs = null;

            /**
             * LaunchPlanSpec role.
             * @member {string} role
             * @memberof flyteidl.admin.LaunchPlanSpec
             * @instance
             */
            LaunchPlanSpec.prototype.role = "";

            /**
             * LaunchPlanSpec labels.
             * @member {flyteidl.admin.ILabels|null|undefined} labels
             * @memberof flyteidl.admin.LaunchPlanSpec
             * @instance
             */
            LaunchPlanSpec.prototype.labels = null;

            /**
             * LaunchPlanSpec annotations.
             * @member {flyteidl.admin.IAnnotations|null|undefined} annotations
             * @memberof flyteidl.admin.LaunchPlanSpec
             * @instance
             */
            LaunchPlanSpec.prototype.annotations = null;

            /**
             * LaunchPlanSpec auth.
             * @member {flyteidl.admin.IAuth|null|undefined} auth
             * @memberof flyteidl.admin.LaunchPlanSpec
             * @instance
             */
            LaunchPlanSpec.prototype.auth = null;

            /**
             * LaunchPlanSpec authRole.
             * @member {flyteidl.admin.IAuthRole|null|undefined} authRole
             * @memberof flyteidl.admin.LaunchPlanSpec
             * @instance
             */
            LaunchPlanSpec.prototype.authRole = null;

            /**
             * Creates a new LaunchPlanSpec instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.LaunchPlanSpec
             * @static
             * @param {flyteidl.admin.ILaunchPlanSpec=} [properties] Properties to set
             * @returns {flyteidl.admin.LaunchPlanSpec} LaunchPlanSpec instance
             */
            LaunchPlanSpec.create = function create(properties) {
                return new LaunchPlanSpec(properties);
            };

            /**
             * Encodes the specified LaunchPlanSpec message. Does not implicitly {@link flyteidl.admin.LaunchPlanSpec.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.LaunchPlanSpec
             * @static
             * @param {flyteidl.admin.ILaunchPlanSpec} message LaunchPlanSpec message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LaunchPlanSpec.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.workflowId != null && message.hasOwnProperty("workflowId"))
                    $root.flyteidl.core.Identifier.encode(message.workflowId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.entityMetadata != null && message.hasOwnProperty("entityMetadata"))
                    $root.flyteidl.admin.LaunchPlanMetadata.encode(message.entityMetadata, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.defaultInputs != null && message.hasOwnProperty("defaultInputs"))
                    $root.flyteidl.core.ParameterMap.encode(message.defaultInputs, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.fixedInputs != null && message.hasOwnProperty("fixedInputs"))
                    $root.flyteidl.core.LiteralMap.encode(message.fixedInputs, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.role != null && message.hasOwnProperty("role"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.role);
                if (message.labels != null && message.hasOwnProperty("labels"))
                    $root.flyteidl.admin.Labels.encode(message.labels, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.annotations != null && message.hasOwnProperty("annotations"))
                    $root.flyteidl.admin.Annotations.encode(message.annotations, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.auth != null && message.hasOwnProperty("auth"))
                    $root.flyteidl.admin.Auth.encode(message.auth, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.authRole != null && message.hasOwnProperty("authRole"))
                    $root.flyteidl.admin.AuthRole.encode(message.authRole, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a LaunchPlanSpec message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.LaunchPlanSpec
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.LaunchPlanSpec} LaunchPlanSpec
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LaunchPlanSpec.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.LaunchPlanSpec();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.workflowId = $root.flyteidl.core.Identifier.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.entityMetadata = $root.flyteidl.admin.LaunchPlanMetadata.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.defaultInputs = $root.flyteidl.core.ParameterMap.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.fixedInputs = $root.flyteidl.core.LiteralMap.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.role = reader.string();
                        break;
                    case 6:
                        message.labels = $root.flyteidl.admin.Labels.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.annotations = $root.flyteidl.admin.Annotations.decode(reader, reader.uint32());
                        break;
                    case 8:
                        message.auth = $root.flyteidl.admin.Auth.decode(reader, reader.uint32());
                        break;
                    case 9:
                        message.authRole = $root.flyteidl.admin.AuthRole.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a LaunchPlanSpec message.
             * @function verify
             * @memberof flyteidl.admin.LaunchPlanSpec
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LaunchPlanSpec.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.workflowId != null && message.hasOwnProperty("workflowId")) {
                    let error = $root.flyteidl.core.Identifier.verify(message.workflowId);
                    if (error)
                        return "workflowId." + error;
                }
                if (message.entityMetadata != null && message.hasOwnProperty("entityMetadata")) {
                    let error = $root.flyteidl.admin.LaunchPlanMetadata.verify(message.entityMetadata);
                    if (error)
                        return "entityMetadata." + error;
                }
                if (message.defaultInputs != null && message.hasOwnProperty("defaultInputs")) {
                    let error = $root.flyteidl.core.ParameterMap.verify(message.defaultInputs);
                    if (error)
                        return "defaultInputs." + error;
                }
                if (message.fixedInputs != null && message.hasOwnProperty("fixedInputs")) {
                    let error = $root.flyteidl.core.LiteralMap.verify(message.fixedInputs);
                    if (error)
                        return "fixedInputs." + error;
                }
                if (message.role != null && message.hasOwnProperty("role"))
                    if (!$util.isString(message.role))
                        return "role: string expected";
                if (message.labels != null && message.hasOwnProperty("labels")) {
                    let error = $root.flyteidl.admin.Labels.verify(message.labels);
                    if (error)
                        return "labels." + error;
                }
                if (message.annotations != null && message.hasOwnProperty("annotations")) {
                    let error = $root.flyteidl.admin.Annotations.verify(message.annotations);
                    if (error)
                        return "annotations." + error;
                }
                if (message.auth != null && message.hasOwnProperty("auth")) {
                    let error = $root.flyteidl.admin.Auth.verify(message.auth);
                    if (error)
                        return "auth." + error;
                }
                if (message.authRole != null && message.hasOwnProperty("authRole")) {
                    let error = $root.flyteidl.admin.AuthRole.verify(message.authRole);
                    if (error)
                        return "authRole." + error;
                }
                return null;
            };

            return LaunchPlanSpec;
        })();

        admin.LaunchPlanClosure = (function() {

            /**
             * Properties of a LaunchPlanClosure.
             * @memberof flyteidl.admin
             * @interface ILaunchPlanClosure
             * @property {flyteidl.admin.LaunchPlanState|null} [state] LaunchPlanClosure state
             * @property {flyteidl.core.IParameterMap|null} [expectedInputs] LaunchPlanClosure expectedInputs
             * @property {flyteidl.core.IVariableMap|null} [expectedOutputs] LaunchPlanClosure expectedOutputs
             * @property {google.protobuf.ITimestamp|null} [createdAt] LaunchPlanClosure createdAt
             * @property {google.protobuf.ITimestamp|null} [updatedAt] LaunchPlanClosure updatedAt
             */

            /**
             * Constructs a new LaunchPlanClosure.
             * @memberof flyteidl.admin
             * @classdesc Represents a LaunchPlanClosure.
             * @implements ILaunchPlanClosure
             * @constructor
             * @param {flyteidl.admin.ILaunchPlanClosure=} [properties] Properties to set
             */
            function LaunchPlanClosure(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LaunchPlanClosure state.
             * @member {flyteidl.admin.LaunchPlanState} state
             * @memberof flyteidl.admin.LaunchPlanClosure
             * @instance
             */
            LaunchPlanClosure.prototype.state = 0;

            /**
             * LaunchPlanClosure expectedInputs.
             * @member {flyteidl.core.IParameterMap|null|undefined} expectedInputs
             * @memberof flyteidl.admin.LaunchPlanClosure
             * @instance
             */
            LaunchPlanClosure.prototype.expectedInputs = null;

            /**
             * LaunchPlanClosure expectedOutputs.
             * @member {flyteidl.core.IVariableMap|null|undefined} expectedOutputs
             * @memberof flyteidl.admin.LaunchPlanClosure
             * @instance
             */
            LaunchPlanClosure.prototype.expectedOutputs = null;

            /**
             * LaunchPlanClosure createdAt.
             * @member {google.protobuf.ITimestamp|null|undefined} createdAt
             * @memberof flyteidl.admin.LaunchPlanClosure
             * @instance
             */
            LaunchPlanClosure.prototype.createdAt = null;

            /**
             * LaunchPlanClosure updatedAt.
             * @member {google.protobuf.ITimestamp|null|undefined} updatedAt
             * @memberof flyteidl.admin.LaunchPlanClosure
             * @instance
             */
            LaunchPlanClosure.prototype.updatedAt = null;

            /**
             * Creates a new LaunchPlanClosure instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.LaunchPlanClosure
             * @static
             * @param {flyteidl.admin.ILaunchPlanClosure=} [properties] Properties to set
             * @returns {flyteidl.admin.LaunchPlanClosure} LaunchPlanClosure instance
             */
            LaunchPlanClosure.create = function create(properties) {
                return new LaunchPlanClosure(properties);
            };

            /**
             * Encodes the specified LaunchPlanClosure message. Does not implicitly {@link flyteidl.admin.LaunchPlanClosure.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.LaunchPlanClosure
             * @static
             * @param {flyteidl.admin.ILaunchPlanClosure} message LaunchPlanClosure message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LaunchPlanClosure.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.state != null && message.hasOwnProperty("state"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.state);
                if (message.expectedInputs != null && message.hasOwnProperty("expectedInputs"))
                    $root.flyteidl.core.ParameterMap.encode(message.expectedInputs, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.expectedOutputs != null && message.hasOwnProperty("expectedOutputs"))
                    $root.flyteidl.core.VariableMap.encode(message.expectedOutputs, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.createdAt != null && message.hasOwnProperty("createdAt"))
                    $root.google.protobuf.Timestamp.encode(message.createdAt, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.updatedAt != null && message.hasOwnProperty("updatedAt"))
                    $root.google.protobuf.Timestamp.encode(message.updatedAt, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a LaunchPlanClosure message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.LaunchPlanClosure
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.LaunchPlanClosure} LaunchPlanClosure
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LaunchPlanClosure.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.LaunchPlanClosure();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.state = reader.int32();
                        break;
                    case 2:
                        message.expectedInputs = $root.flyteidl.core.ParameterMap.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.expectedOutputs = $root.flyteidl.core.VariableMap.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.createdAt = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.updatedAt = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a LaunchPlanClosure message.
             * @function verify
             * @memberof flyteidl.admin.LaunchPlanClosure
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LaunchPlanClosure.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.state != null && message.hasOwnProperty("state"))
                    switch (message.state) {
                    default:
                        return "state: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                if (message.expectedInputs != null && message.hasOwnProperty("expectedInputs")) {
                    let error = $root.flyteidl.core.ParameterMap.verify(message.expectedInputs);
                    if (error)
                        return "expectedInputs." + error;
                }
                if (message.expectedOutputs != null && message.hasOwnProperty("expectedOutputs")) {
                    let error = $root.flyteidl.core.VariableMap.verify(message.expectedOutputs);
                    if (error)
                        return "expectedOutputs." + error;
                }
                if (message.createdAt != null && message.hasOwnProperty("createdAt")) {
                    let error = $root.google.protobuf.Timestamp.verify(message.createdAt);
                    if (error)
                        return "createdAt." + error;
                }
                if (message.updatedAt != null && message.hasOwnProperty("updatedAt")) {
                    let error = $root.google.protobuf.Timestamp.verify(message.updatedAt);
                    if (error)
                        return "updatedAt." + error;
                }
                return null;
            };

            return LaunchPlanClosure;
        })();

        admin.LaunchPlanMetadata = (function() {

            /**
             * Properties of a LaunchPlanMetadata.
             * @memberof flyteidl.admin
             * @interface ILaunchPlanMetadata
             * @property {flyteidl.admin.ISchedule|null} [schedule] LaunchPlanMetadata schedule
             * @property {Array.<flyteidl.admin.INotification>|null} [notifications] LaunchPlanMetadata notifications
             */

            /**
             * Constructs a new LaunchPlanMetadata.
             * @memberof flyteidl.admin
             * @classdesc Represents a LaunchPlanMetadata.
             * @implements ILaunchPlanMetadata
             * @constructor
             * @param {flyteidl.admin.ILaunchPlanMetadata=} [properties] Properties to set
             */
            function LaunchPlanMetadata(properties) {
                this.notifications = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LaunchPlanMetadata schedule.
             * @member {flyteidl.admin.ISchedule|null|undefined} schedule
             * @memberof flyteidl.admin.LaunchPlanMetadata
             * @instance
             */
            LaunchPlanMetadata.prototype.schedule = null;

            /**
             * LaunchPlanMetadata notifications.
             * @member {Array.<flyteidl.admin.INotification>} notifications
             * @memberof flyteidl.admin.LaunchPlanMetadata
             * @instance
             */
            LaunchPlanMetadata.prototype.notifications = $util.emptyArray;

            /**
             * Creates a new LaunchPlanMetadata instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.LaunchPlanMetadata
             * @static
             * @param {flyteidl.admin.ILaunchPlanMetadata=} [properties] Properties to set
             * @returns {flyteidl.admin.LaunchPlanMetadata} LaunchPlanMetadata instance
             */
            LaunchPlanMetadata.create = function create(properties) {
                return new LaunchPlanMetadata(properties);
            };

            /**
             * Encodes the specified LaunchPlanMetadata message. Does not implicitly {@link flyteidl.admin.LaunchPlanMetadata.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.LaunchPlanMetadata
             * @static
             * @param {flyteidl.admin.ILaunchPlanMetadata} message LaunchPlanMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LaunchPlanMetadata.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.schedule != null && message.hasOwnProperty("schedule"))
                    $root.flyteidl.admin.Schedule.encode(message.schedule, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.notifications != null && message.notifications.length)
                    for (let i = 0; i < message.notifications.length; ++i)
                        $root.flyteidl.admin.Notification.encode(message.notifications[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a LaunchPlanMetadata message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.LaunchPlanMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.LaunchPlanMetadata} LaunchPlanMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LaunchPlanMetadata.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.LaunchPlanMetadata();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.schedule = $root.flyteidl.admin.Schedule.decode(reader, reader.uint32());
                        break;
                    case 2:
                        if (!(message.notifications && message.notifications.length))
                            message.notifications = [];
                        message.notifications.push($root.flyteidl.admin.Notification.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a LaunchPlanMetadata message.
             * @function verify
             * @memberof flyteidl.admin.LaunchPlanMetadata
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LaunchPlanMetadata.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.schedule != null && message.hasOwnProperty("schedule")) {
                    let error = $root.flyteidl.admin.Schedule.verify(message.schedule);
                    if (error)
                        return "schedule." + error;
                }
                if (message.notifications != null && message.hasOwnProperty("notifications")) {
                    if (!Array.isArray(message.notifications))
                        return "notifications: array expected";
                    for (let i = 0; i < message.notifications.length; ++i) {
                        let error = $root.flyteidl.admin.Notification.verify(message.notifications[i]);
                        if (error)
                            return "notifications." + error;
                    }
                }
                return null;
            };

            return LaunchPlanMetadata;
        })();

        admin.LaunchPlanUpdateRequest = (function() {

            /**
             * Properties of a LaunchPlanUpdateRequest.
             * @memberof flyteidl.admin
             * @interface ILaunchPlanUpdateRequest
             * @property {flyteidl.core.IIdentifier|null} [id] LaunchPlanUpdateRequest id
             * @property {flyteidl.admin.LaunchPlanState|null} [state] LaunchPlanUpdateRequest state
             */

            /**
             * Constructs a new LaunchPlanUpdateRequest.
             * @memberof flyteidl.admin
             * @classdesc Represents a LaunchPlanUpdateRequest.
             * @implements ILaunchPlanUpdateRequest
             * @constructor
             * @param {flyteidl.admin.ILaunchPlanUpdateRequest=} [properties] Properties to set
             */
            function LaunchPlanUpdateRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LaunchPlanUpdateRequest id.
             * @member {flyteidl.core.IIdentifier|null|undefined} id
             * @memberof flyteidl.admin.LaunchPlanUpdateRequest
             * @instance
             */
            LaunchPlanUpdateRequest.prototype.id = null;

            /**
             * LaunchPlanUpdateRequest state.
             * @member {flyteidl.admin.LaunchPlanState} state
             * @memberof flyteidl.admin.LaunchPlanUpdateRequest
             * @instance
             */
            LaunchPlanUpdateRequest.prototype.state = 0;

            /**
             * Creates a new LaunchPlanUpdateRequest instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.LaunchPlanUpdateRequest
             * @static
             * @param {flyteidl.admin.ILaunchPlanUpdateRequest=} [properties] Properties to set
             * @returns {flyteidl.admin.LaunchPlanUpdateRequest} LaunchPlanUpdateRequest instance
             */
            LaunchPlanUpdateRequest.create = function create(properties) {
                return new LaunchPlanUpdateRequest(properties);
            };

            /**
             * Encodes the specified LaunchPlanUpdateRequest message. Does not implicitly {@link flyteidl.admin.LaunchPlanUpdateRequest.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.LaunchPlanUpdateRequest
             * @static
             * @param {flyteidl.admin.ILaunchPlanUpdateRequest} message LaunchPlanUpdateRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LaunchPlanUpdateRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    $root.flyteidl.core.Identifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.state != null && message.hasOwnProperty("state"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.state);
                return writer;
            };

            /**
             * Decodes a LaunchPlanUpdateRequest message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.LaunchPlanUpdateRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.LaunchPlanUpdateRequest} LaunchPlanUpdateRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LaunchPlanUpdateRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.LaunchPlanUpdateRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = $root.flyteidl.core.Identifier.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.state = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a LaunchPlanUpdateRequest message.
             * @function verify
             * @memberof flyteidl.admin.LaunchPlanUpdateRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LaunchPlanUpdateRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id")) {
                    let error = $root.flyteidl.core.Identifier.verify(message.id);
                    if (error)
                        return "id." + error;
                }
                if (message.state != null && message.hasOwnProperty("state"))
                    switch (message.state) {
                    default:
                        return "state: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                return null;
            };

            return LaunchPlanUpdateRequest;
        })();

        admin.LaunchPlanUpdateResponse = (function() {

            /**
             * Properties of a LaunchPlanUpdateResponse.
             * @memberof flyteidl.admin
             * @interface ILaunchPlanUpdateResponse
             */

            /**
             * Constructs a new LaunchPlanUpdateResponse.
             * @memberof flyteidl.admin
             * @classdesc Represents a LaunchPlanUpdateResponse.
             * @implements ILaunchPlanUpdateResponse
             * @constructor
             * @param {flyteidl.admin.ILaunchPlanUpdateResponse=} [properties] Properties to set
             */
            function LaunchPlanUpdateResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new LaunchPlanUpdateResponse instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.LaunchPlanUpdateResponse
             * @static
             * @param {flyteidl.admin.ILaunchPlanUpdateResponse=} [properties] Properties to set
             * @returns {flyteidl.admin.LaunchPlanUpdateResponse} LaunchPlanUpdateResponse instance
             */
            LaunchPlanUpdateResponse.create = function create(properties) {
                return new LaunchPlanUpdateResponse(properties);
            };

            /**
             * Encodes the specified LaunchPlanUpdateResponse message. Does not implicitly {@link flyteidl.admin.LaunchPlanUpdateResponse.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.LaunchPlanUpdateResponse
             * @static
             * @param {flyteidl.admin.ILaunchPlanUpdateResponse} message LaunchPlanUpdateResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LaunchPlanUpdateResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Decodes a LaunchPlanUpdateResponse message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.LaunchPlanUpdateResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.LaunchPlanUpdateResponse} LaunchPlanUpdateResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LaunchPlanUpdateResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.LaunchPlanUpdateResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a LaunchPlanUpdateResponse message.
             * @function verify
             * @memberof flyteidl.admin.LaunchPlanUpdateResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LaunchPlanUpdateResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            return LaunchPlanUpdateResponse;
        })();

        admin.ActiveLaunchPlanRequest = (function() {

            /**
             * Properties of an ActiveLaunchPlanRequest.
             * @memberof flyteidl.admin
             * @interface IActiveLaunchPlanRequest
             * @property {flyteidl.admin.INamedEntityIdentifier|null} [id] ActiveLaunchPlanRequest id
             */

            /**
             * Constructs a new ActiveLaunchPlanRequest.
             * @memberof flyteidl.admin
             * @classdesc Represents an ActiveLaunchPlanRequest.
             * @implements IActiveLaunchPlanRequest
             * @constructor
             * @param {flyteidl.admin.IActiveLaunchPlanRequest=} [properties] Properties to set
             */
            function ActiveLaunchPlanRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ActiveLaunchPlanRequest id.
             * @member {flyteidl.admin.INamedEntityIdentifier|null|undefined} id
             * @memberof flyteidl.admin.ActiveLaunchPlanRequest
             * @instance
             */
            ActiveLaunchPlanRequest.prototype.id = null;

            /**
             * Creates a new ActiveLaunchPlanRequest instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.ActiveLaunchPlanRequest
             * @static
             * @param {flyteidl.admin.IActiveLaunchPlanRequest=} [properties] Properties to set
             * @returns {flyteidl.admin.ActiveLaunchPlanRequest} ActiveLaunchPlanRequest instance
             */
            ActiveLaunchPlanRequest.create = function create(properties) {
                return new ActiveLaunchPlanRequest(properties);
            };

            /**
             * Encodes the specified ActiveLaunchPlanRequest message. Does not implicitly {@link flyteidl.admin.ActiveLaunchPlanRequest.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.ActiveLaunchPlanRequest
             * @static
             * @param {flyteidl.admin.IActiveLaunchPlanRequest} message ActiveLaunchPlanRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ActiveLaunchPlanRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    $root.flyteidl.admin.NamedEntityIdentifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes an ActiveLaunchPlanRequest message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.ActiveLaunchPlanRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.ActiveLaunchPlanRequest} ActiveLaunchPlanRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ActiveLaunchPlanRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.ActiveLaunchPlanRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = $root.flyteidl.admin.NamedEntityIdentifier.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies an ActiveLaunchPlanRequest message.
             * @function verify
             * @memberof flyteidl.admin.ActiveLaunchPlanRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ActiveLaunchPlanRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id")) {
                    let error = $root.flyteidl.admin.NamedEntityIdentifier.verify(message.id);
                    if (error)
                        return "id." + error;
                }
                return null;
            };

            return ActiveLaunchPlanRequest;
        })();

        admin.ActiveLaunchPlanListRequest = (function() {

            /**
             * Properties of an ActiveLaunchPlanListRequest.
             * @memberof flyteidl.admin
             * @interface IActiveLaunchPlanListRequest
             * @property {string|null} [project] ActiveLaunchPlanListRequest project
             * @property {string|null} [domain] ActiveLaunchPlanListRequest domain
             * @property {number|null} [limit] ActiveLaunchPlanListRequest limit
             * @property {string|null} [token] ActiveLaunchPlanListRequest token
             * @property {flyteidl.admin.ISort|null} [sortBy] ActiveLaunchPlanListRequest sortBy
             */

            /**
             * Constructs a new ActiveLaunchPlanListRequest.
             * @memberof flyteidl.admin
             * @classdesc Represents an ActiveLaunchPlanListRequest.
             * @implements IActiveLaunchPlanListRequest
             * @constructor
             * @param {flyteidl.admin.IActiveLaunchPlanListRequest=} [properties] Properties to set
             */
            function ActiveLaunchPlanListRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ActiveLaunchPlanListRequest project.
             * @member {string} project
             * @memberof flyteidl.admin.ActiveLaunchPlanListRequest
             * @instance
             */
            ActiveLaunchPlanListRequest.prototype.project = "";

            /**
             * ActiveLaunchPlanListRequest domain.
             * @member {string} domain
             * @memberof flyteidl.admin.ActiveLaunchPlanListRequest
             * @instance
             */
            ActiveLaunchPlanListRequest.prototype.domain = "";

            /**
             * ActiveLaunchPlanListRequest limit.
             * @member {number} limit
             * @memberof flyteidl.admin.ActiveLaunchPlanListRequest
             * @instance
             */
            ActiveLaunchPlanListRequest.prototype.limit = 0;

            /**
             * ActiveLaunchPlanListRequest token.
             * @member {string} token
             * @memberof flyteidl.admin.ActiveLaunchPlanListRequest
             * @instance
             */
            ActiveLaunchPlanListRequest.prototype.token = "";

            /**
             * ActiveLaunchPlanListRequest sortBy.
             * @member {flyteidl.admin.ISort|null|undefined} sortBy
             * @memberof flyteidl.admin.ActiveLaunchPlanListRequest
             * @instance
             */
            ActiveLaunchPlanListRequest.prototype.sortBy = null;

            /**
             * Creates a new ActiveLaunchPlanListRequest instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.ActiveLaunchPlanListRequest
             * @static
             * @param {flyteidl.admin.IActiveLaunchPlanListRequest=} [properties] Properties to set
             * @returns {flyteidl.admin.ActiveLaunchPlanListRequest} ActiveLaunchPlanListRequest instance
             */
            ActiveLaunchPlanListRequest.create = function create(properties) {
                return new ActiveLaunchPlanListRequest(properties);
            };

            /**
             * Encodes the specified ActiveLaunchPlanListRequest message. Does not implicitly {@link flyteidl.admin.ActiveLaunchPlanListRequest.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.ActiveLaunchPlanListRequest
             * @static
             * @param {flyteidl.admin.IActiveLaunchPlanListRequest} message ActiveLaunchPlanListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ActiveLaunchPlanListRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.project != null && message.hasOwnProperty("project"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.project);
                if (message.domain != null && message.hasOwnProperty("domain"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.domain);
                if (message.limit != null && message.hasOwnProperty("limit"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.limit);
                if (message.token != null && message.hasOwnProperty("token"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.token);
                if (message.sortBy != null && message.hasOwnProperty("sortBy"))
                    $root.flyteidl.admin.Sort.encode(message.sortBy, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes an ActiveLaunchPlanListRequest message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.ActiveLaunchPlanListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.ActiveLaunchPlanListRequest} ActiveLaunchPlanListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ActiveLaunchPlanListRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.ActiveLaunchPlanListRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.project = reader.string();
                        break;
                    case 2:
                        message.domain = reader.string();
                        break;
                    case 3:
                        message.limit = reader.uint32();
                        break;
                    case 4:
                        message.token = reader.string();
                        break;
                    case 5:
                        message.sortBy = $root.flyteidl.admin.Sort.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies an ActiveLaunchPlanListRequest message.
             * @function verify
             * @memberof flyteidl.admin.ActiveLaunchPlanListRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ActiveLaunchPlanListRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.project != null && message.hasOwnProperty("project"))
                    if (!$util.isString(message.project))
                        return "project: string expected";
                if (message.domain != null && message.hasOwnProperty("domain"))
                    if (!$util.isString(message.domain))
                        return "domain: string expected";
                if (message.limit != null && message.hasOwnProperty("limit"))
                    if (!$util.isInteger(message.limit))
                        return "limit: integer expected";
                if (message.token != null && message.hasOwnProperty("token"))
                    if (!$util.isString(message.token))
                        return "token: string expected";
                if (message.sortBy != null && message.hasOwnProperty("sortBy")) {
                    let error = $root.flyteidl.admin.Sort.verify(message.sortBy);
                    if (error)
                        return "sortBy." + error;
                }
                return null;
            };

            return ActiveLaunchPlanListRequest;
        })();

        /**
         * FixedRateUnit enum.
         * @name flyteidl.admin.FixedRateUnit
         * @enum {string}
         * @property {number} MINUTE=0 MINUTE value
         * @property {number} HOUR=1 HOUR value
         * @property {number} DAY=2 DAY value
         */
        admin.FixedRateUnit = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "MINUTE"] = 0;
            values[valuesById[1] = "HOUR"] = 1;
            values[valuesById[2] = "DAY"] = 2;
            return values;
        })();

        admin.FixedRate = (function() {

            /**
             * Properties of a FixedRate.
             * @memberof flyteidl.admin
             * @interface IFixedRate
             * @property {number|null} [value] FixedRate value
             * @property {flyteidl.admin.FixedRateUnit|null} [unit] FixedRate unit
             */

            /**
             * Constructs a new FixedRate.
             * @memberof flyteidl.admin
             * @classdesc Represents a FixedRate.
             * @implements IFixedRate
             * @constructor
             * @param {flyteidl.admin.IFixedRate=} [properties] Properties to set
             */
            function FixedRate(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FixedRate value.
             * @member {number} value
             * @memberof flyteidl.admin.FixedRate
             * @instance
             */
            FixedRate.prototype.value = 0;

            /**
             * FixedRate unit.
             * @member {flyteidl.admin.FixedRateUnit} unit
             * @memberof flyteidl.admin.FixedRate
             * @instance
             */
            FixedRate.prototype.unit = 0;

            /**
             * Creates a new FixedRate instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.FixedRate
             * @static
             * @param {flyteidl.admin.IFixedRate=} [properties] Properties to set
             * @returns {flyteidl.admin.FixedRate} FixedRate instance
             */
            FixedRate.create = function create(properties) {
                return new FixedRate(properties);
            };

            /**
             * Encodes the specified FixedRate message. Does not implicitly {@link flyteidl.admin.FixedRate.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.FixedRate
             * @static
             * @param {flyteidl.admin.IFixedRate} message FixedRate message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FixedRate.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && message.hasOwnProperty("value"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.value);
                if (message.unit != null && message.hasOwnProperty("unit"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.unit);
                return writer;
            };

            /**
             * Decodes a FixedRate message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.FixedRate
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.FixedRate} FixedRate
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FixedRate.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.FixedRate();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.value = reader.uint32();
                        break;
                    case 2:
                        message.unit = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a FixedRate message.
             * @function verify
             * @memberof flyteidl.admin.FixedRate
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FixedRate.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isInteger(message.value))
                        return "value: integer expected";
                if (message.unit != null && message.hasOwnProperty("unit"))
                    switch (message.unit) {
                    default:
                        return "unit: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                return null;
            };

            return FixedRate;
        })();

        admin.Schedule = (function() {

            /**
             * Properties of a Schedule.
             * @memberof flyteidl.admin
             * @interface ISchedule
             * @property {string|null} [cronExpression] Schedule cronExpression
             * @property {flyteidl.admin.IFixedRate|null} [rate] Schedule rate
             * @property {string|null} [kickoffTimeInputArg] Schedule kickoffTimeInputArg
             */

            /**
             * Constructs a new Schedule.
             * @memberof flyteidl.admin
             * @classdesc Represents a Schedule.
             * @implements ISchedule
             * @constructor
             * @param {flyteidl.admin.ISchedule=} [properties] Properties to set
             */
            function Schedule(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Schedule cronExpression.
             * @member {string} cronExpression
             * @memberof flyteidl.admin.Schedule
             * @instance
             */
            Schedule.prototype.cronExpression = "";

            /**
             * Schedule rate.
             * @member {flyteidl.admin.IFixedRate|null|undefined} rate
             * @memberof flyteidl.admin.Schedule
             * @instance
             */
            Schedule.prototype.rate = null;

            /**
             * Schedule kickoffTimeInputArg.
             * @member {string} kickoffTimeInputArg
             * @memberof flyteidl.admin.Schedule
             * @instance
             */
            Schedule.prototype.kickoffTimeInputArg = "";

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * Schedule ScheduleExpression.
             * @member {"cronExpression"|"rate"|undefined} ScheduleExpression
             * @memberof flyteidl.admin.Schedule
             * @instance
             */
            Object.defineProperty(Schedule.prototype, "ScheduleExpression", {
                get: $util.oneOfGetter($oneOfFields = ["cronExpression", "rate"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new Schedule instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.Schedule
             * @static
             * @param {flyteidl.admin.ISchedule=} [properties] Properties to set
             * @returns {flyteidl.admin.Schedule} Schedule instance
             */
            Schedule.create = function create(properties) {
                return new Schedule(properties);
            };

            /**
             * Encodes the specified Schedule message. Does not implicitly {@link flyteidl.admin.Schedule.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.Schedule
             * @static
             * @param {flyteidl.admin.ISchedule} message Schedule message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Schedule.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.cronExpression != null && message.hasOwnProperty("cronExpression"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.cronExpression);
                if (message.rate != null && message.hasOwnProperty("rate"))
                    $root.flyteidl.admin.FixedRate.encode(message.rate, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.kickoffTimeInputArg != null && message.hasOwnProperty("kickoffTimeInputArg"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.kickoffTimeInputArg);
                return writer;
            };

            /**
             * Decodes a Schedule message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.Schedule
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.Schedule} Schedule
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Schedule.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.Schedule();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.cronExpression = reader.string();
                        break;
                    case 2:
                        message.rate = $root.flyteidl.admin.FixedRate.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.kickoffTimeInputArg = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a Schedule message.
             * @function verify
             * @memberof flyteidl.admin.Schedule
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Schedule.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.cronExpression != null && message.hasOwnProperty("cronExpression")) {
                    properties.ScheduleExpression = 1;
                    if (!$util.isString(message.cronExpression))
                        return "cronExpression: string expected";
                }
                if (message.rate != null && message.hasOwnProperty("rate")) {
                    if (properties.ScheduleExpression === 1)
                        return "ScheduleExpression: multiple values";
                    properties.ScheduleExpression = 1;
                    {
                        let error = $root.flyteidl.admin.FixedRate.verify(message.rate);
                        if (error)
                            return "rate." + error;
                    }
                }
                if (message.kickoffTimeInputArg != null && message.hasOwnProperty("kickoffTimeInputArg"))
                    if (!$util.isString(message.kickoffTimeInputArg))
                        return "kickoffTimeInputArg: string expected";
                return null;
            };

            return Schedule;
        })();

        /**
         * MatchableResource enum.
         * @name flyteidl.admin.MatchableResource
         * @enum {string}
         * @property {number} TASK_RESOURCE=0 TASK_RESOURCE value
         * @property {number} CLUSTER_RESOURCE=1 CLUSTER_RESOURCE value
         * @property {number} EXECUTION_QUEUE=2 EXECUTION_QUEUE value
         * @property {number} EXECUTION_CLUSTER_LABEL=3 EXECUTION_CLUSTER_LABEL value
         */
        admin.MatchableResource = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "TASK_RESOURCE"] = 0;
            values[valuesById[1] = "CLUSTER_RESOURCE"] = 1;
            values[valuesById[2] = "EXECUTION_QUEUE"] = 2;
            values[valuesById[3] = "EXECUTION_CLUSTER_LABEL"] = 3;
            return values;
        })();

        admin.TaskResourceSpec = (function() {

            /**
             * Properties of a TaskResourceSpec.
             * @memberof flyteidl.admin
             * @interface ITaskResourceSpec
             * @property {string|null} [cpu] TaskResourceSpec cpu
             * @property {string|null} [gpu] TaskResourceSpec gpu
             * @property {string|null} [memory] TaskResourceSpec memory
             * @property {string|null} [storage] TaskResourceSpec storage
             */

            /**
             * Constructs a new TaskResourceSpec.
             * @memberof flyteidl.admin
             * @classdesc Represents a TaskResourceSpec.
             * @implements ITaskResourceSpec
             * @constructor
             * @param {flyteidl.admin.ITaskResourceSpec=} [properties] Properties to set
             */
            function TaskResourceSpec(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TaskResourceSpec cpu.
             * @member {string} cpu
             * @memberof flyteidl.admin.TaskResourceSpec
             * @instance
             */
            TaskResourceSpec.prototype.cpu = "";

            /**
             * TaskResourceSpec gpu.
             * @member {string} gpu
             * @memberof flyteidl.admin.TaskResourceSpec
             * @instance
             */
            TaskResourceSpec.prototype.gpu = "";

            /**
             * TaskResourceSpec memory.
             * @member {string} memory
             * @memberof flyteidl.admin.TaskResourceSpec
             * @instance
             */
            TaskResourceSpec.prototype.memory = "";

            /**
             * TaskResourceSpec storage.
             * @member {string} storage
             * @memberof flyteidl.admin.TaskResourceSpec
             * @instance
             */
            TaskResourceSpec.prototype.storage = "";

            /**
             * Creates a new TaskResourceSpec instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.TaskResourceSpec
             * @static
             * @param {flyteidl.admin.ITaskResourceSpec=} [properties] Properties to set
             * @returns {flyteidl.admin.TaskResourceSpec} TaskResourceSpec instance
             */
            TaskResourceSpec.create = function create(properties) {
                return new TaskResourceSpec(properties);
            };

            /**
             * Encodes the specified TaskResourceSpec message. Does not implicitly {@link flyteidl.admin.TaskResourceSpec.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.TaskResourceSpec
             * @static
             * @param {flyteidl.admin.ITaskResourceSpec} message TaskResourceSpec message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TaskResourceSpec.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.cpu != null && message.hasOwnProperty("cpu"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.cpu);
                if (message.gpu != null && message.hasOwnProperty("gpu"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.gpu);
                if (message.memory != null && message.hasOwnProperty("memory"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.memory);
                if (message.storage != null && message.hasOwnProperty("storage"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.storage);
                return writer;
            };

            /**
             * Decodes a TaskResourceSpec message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.TaskResourceSpec
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.TaskResourceSpec} TaskResourceSpec
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TaskResourceSpec.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.TaskResourceSpec();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.cpu = reader.string();
                        break;
                    case 2:
                        message.gpu = reader.string();
                        break;
                    case 3:
                        message.memory = reader.string();
                        break;
                    case 4:
                        message.storage = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a TaskResourceSpec message.
             * @function verify
             * @memberof flyteidl.admin.TaskResourceSpec
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TaskResourceSpec.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.cpu != null && message.hasOwnProperty("cpu"))
                    if (!$util.isString(message.cpu))
                        return "cpu: string expected";
                if (message.gpu != null && message.hasOwnProperty("gpu"))
                    if (!$util.isString(message.gpu))
                        return "gpu: string expected";
                if (message.memory != null && message.hasOwnProperty("memory"))
                    if (!$util.isString(message.memory))
                        return "memory: string expected";
                if (message.storage != null && message.hasOwnProperty("storage"))
                    if (!$util.isString(message.storage))
                        return "storage: string expected";
                return null;
            };

            return TaskResourceSpec;
        })();

        admin.TaskResourceAttributes = (function() {

            /**
             * Properties of a TaskResourceAttributes.
             * @memberof flyteidl.admin
             * @interface ITaskResourceAttributes
             * @property {flyteidl.admin.ITaskResourceSpec|null} [defaults] TaskResourceAttributes defaults
             * @property {flyteidl.admin.ITaskResourceSpec|null} [limits] TaskResourceAttributes limits
             */

            /**
             * Constructs a new TaskResourceAttributes.
             * @memberof flyteidl.admin
             * @classdesc Represents a TaskResourceAttributes.
             * @implements ITaskResourceAttributes
             * @constructor
             * @param {flyteidl.admin.ITaskResourceAttributes=} [properties] Properties to set
             */
            function TaskResourceAttributes(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TaskResourceAttributes defaults.
             * @member {flyteidl.admin.ITaskResourceSpec|null|undefined} defaults
             * @memberof flyteidl.admin.TaskResourceAttributes
             * @instance
             */
            TaskResourceAttributes.prototype.defaults = null;

            /**
             * TaskResourceAttributes limits.
             * @member {flyteidl.admin.ITaskResourceSpec|null|undefined} limits
             * @memberof flyteidl.admin.TaskResourceAttributes
             * @instance
             */
            TaskResourceAttributes.prototype.limits = null;

            /**
             * Creates a new TaskResourceAttributes instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.TaskResourceAttributes
             * @static
             * @param {flyteidl.admin.ITaskResourceAttributes=} [properties] Properties to set
             * @returns {flyteidl.admin.TaskResourceAttributes} TaskResourceAttributes instance
             */
            TaskResourceAttributes.create = function create(properties) {
                return new TaskResourceAttributes(properties);
            };

            /**
             * Encodes the specified TaskResourceAttributes message. Does not implicitly {@link flyteidl.admin.TaskResourceAttributes.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.TaskResourceAttributes
             * @static
             * @param {flyteidl.admin.ITaskResourceAttributes} message TaskResourceAttributes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TaskResourceAttributes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.defaults != null && message.hasOwnProperty("defaults"))
                    $root.flyteidl.admin.TaskResourceSpec.encode(message.defaults, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.limits != null && message.hasOwnProperty("limits"))
                    $root.flyteidl.admin.TaskResourceSpec.encode(message.limits, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a TaskResourceAttributes message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.TaskResourceAttributes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.TaskResourceAttributes} TaskResourceAttributes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TaskResourceAttributes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.TaskResourceAttributes();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.defaults = $root.flyteidl.admin.TaskResourceSpec.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.limits = $root.flyteidl.admin.TaskResourceSpec.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a TaskResourceAttributes message.
             * @function verify
             * @memberof flyteidl.admin.TaskResourceAttributes
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TaskResourceAttributes.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.defaults != null && message.hasOwnProperty("defaults")) {
                    let error = $root.flyteidl.admin.TaskResourceSpec.verify(message.defaults);
                    if (error)
                        return "defaults." + error;
                }
                if (message.limits != null && message.hasOwnProperty("limits")) {
                    let error = $root.flyteidl.admin.TaskResourceSpec.verify(message.limits);
                    if (error)
                        return "limits." + error;
                }
                return null;
            };

            return TaskResourceAttributes;
        })();

        admin.ClusterResourceAttributes = (function() {

            /**
             * Properties of a ClusterResourceAttributes.
             * @memberof flyteidl.admin
             * @interface IClusterResourceAttributes
             * @property {Object.<string,string>|null} [attributes] ClusterResourceAttributes attributes
             */

            /**
             * Constructs a new ClusterResourceAttributes.
             * @memberof flyteidl.admin
             * @classdesc Represents a ClusterResourceAttributes.
             * @implements IClusterResourceAttributes
             * @constructor
             * @param {flyteidl.admin.IClusterResourceAttributes=} [properties] Properties to set
             */
            function ClusterResourceAttributes(properties) {
                this.attributes = {};
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ClusterResourceAttributes attributes.
             * @member {Object.<string,string>} attributes
             * @memberof flyteidl.admin.ClusterResourceAttributes
             * @instance
             */
            ClusterResourceAttributes.prototype.attributes = $util.emptyObject;

            /**
             * Creates a new ClusterResourceAttributes instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.ClusterResourceAttributes
             * @static
             * @param {flyteidl.admin.IClusterResourceAttributes=} [properties] Properties to set
             * @returns {flyteidl.admin.ClusterResourceAttributes} ClusterResourceAttributes instance
             */
            ClusterResourceAttributes.create = function create(properties) {
                return new ClusterResourceAttributes(properties);
            };

            /**
             * Encodes the specified ClusterResourceAttributes message. Does not implicitly {@link flyteidl.admin.ClusterResourceAttributes.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.ClusterResourceAttributes
             * @static
             * @param {flyteidl.admin.IClusterResourceAttributes} message ClusterResourceAttributes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ClusterResourceAttributes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.attributes != null && message.hasOwnProperty("attributes"))
                    for (let keys = Object.keys(message.attributes), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.attributes[keys[i]]).ldelim();
                return writer;
            };

            /**
             * Decodes a ClusterResourceAttributes message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.ClusterResourceAttributes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.ClusterResourceAttributes} ClusterResourceAttributes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ClusterResourceAttributes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.ClusterResourceAttributes(), key;
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        reader.skip().pos++;
                        if (message.attributes === $util.emptyObject)
                            message.attributes = {};
                        key = reader.string();
                        reader.pos++;
                        message.attributes[key] = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a ClusterResourceAttributes message.
             * @function verify
             * @memberof flyteidl.admin.ClusterResourceAttributes
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ClusterResourceAttributes.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.attributes != null && message.hasOwnProperty("attributes")) {
                    if (!$util.isObject(message.attributes))
                        return "attributes: object expected";
                    let key = Object.keys(message.attributes);
                    for (let i = 0; i < key.length; ++i)
                        if (!$util.isString(message.attributes[key[i]]))
                            return "attributes: string{k:string} expected";
                }
                return null;
            };

            return ClusterResourceAttributes;
        })();

        admin.ExecutionQueueAttributes = (function() {

            /**
             * Properties of an ExecutionQueueAttributes.
             * @memberof flyteidl.admin
             * @interface IExecutionQueueAttributes
             * @property {Array.<string>|null} [tags] ExecutionQueueAttributes tags
             */

            /**
             * Constructs a new ExecutionQueueAttributes.
             * @memberof flyteidl.admin
             * @classdesc Represents an ExecutionQueueAttributes.
             * @implements IExecutionQueueAttributes
             * @constructor
             * @param {flyteidl.admin.IExecutionQueueAttributes=} [properties] Properties to set
             */
            function ExecutionQueueAttributes(properties) {
                this.tags = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExecutionQueueAttributes tags.
             * @member {Array.<string>} tags
             * @memberof flyteidl.admin.ExecutionQueueAttributes
             * @instance
             */
            ExecutionQueueAttributes.prototype.tags = $util.emptyArray;

            /**
             * Creates a new ExecutionQueueAttributes instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.ExecutionQueueAttributes
             * @static
             * @param {flyteidl.admin.IExecutionQueueAttributes=} [properties] Properties to set
             * @returns {flyteidl.admin.ExecutionQueueAttributes} ExecutionQueueAttributes instance
             */
            ExecutionQueueAttributes.create = function create(properties) {
                return new ExecutionQueueAttributes(properties);
            };

            /**
             * Encodes the specified ExecutionQueueAttributes message. Does not implicitly {@link flyteidl.admin.ExecutionQueueAttributes.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.ExecutionQueueAttributes
             * @static
             * @param {flyteidl.admin.IExecutionQueueAttributes} message ExecutionQueueAttributes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecutionQueueAttributes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tags != null && message.tags.length)
                    for (let i = 0; i < message.tags.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.tags[i]);
                return writer;
            };

            /**
             * Decodes an ExecutionQueueAttributes message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.ExecutionQueueAttributes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.ExecutionQueueAttributes} ExecutionQueueAttributes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecutionQueueAttributes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.ExecutionQueueAttributes();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.tags && message.tags.length))
                            message.tags = [];
                        message.tags.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies an ExecutionQueueAttributes message.
             * @function verify
             * @memberof flyteidl.admin.ExecutionQueueAttributes
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExecutionQueueAttributes.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tags != null && message.hasOwnProperty("tags")) {
                    if (!Array.isArray(message.tags))
                        return "tags: array expected";
                    for (let i = 0; i < message.tags.length; ++i)
                        if (!$util.isString(message.tags[i]))
                            return "tags: string[] expected";
                }
                return null;
            };

            return ExecutionQueueAttributes;
        })();

        admin.ExecutionClusterLabel = (function() {

            /**
             * Properties of an ExecutionClusterLabel.
             * @memberof flyteidl.admin
             * @interface IExecutionClusterLabel
             * @property {string|null} [value] ExecutionClusterLabel value
             */

            /**
             * Constructs a new ExecutionClusterLabel.
             * @memberof flyteidl.admin
             * @classdesc Represents an ExecutionClusterLabel.
             * @implements IExecutionClusterLabel
             * @constructor
             * @param {flyteidl.admin.IExecutionClusterLabel=} [properties] Properties to set
             */
            function ExecutionClusterLabel(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExecutionClusterLabel value.
             * @member {string} value
             * @memberof flyteidl.admin.ExecutionClusterLabel
             * @instance
             */
            ExecutionClusterLabel.prototype.value = "";

            /**
             * Creates a new ExecutionClusterLabel instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.ExecutionClusterLabel
             * @static
             * @param {flyteidl.admin.IExecutionClusterLabel=} [properties] Properties to set
             * @returns {flyteidl.admin.ExecutionClusterLabel} ExecutionClusterLabel instance
             */
            ExecutionClusterLabel.create = function create(properties) {
                return new ExecutionClusterLabel(properties);
            };

            /**
             * Encodes the specified ExecutionClusterLabel message. Does not implicitly {@link flyteidl.admin.ExecutionClusterLabel.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.ExecutionClusterLabel
             * @static
             * @param {flyteidl.admin.IExecutionClusterLabel} message ExecutionClusterLabel message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecutionClusterLabel.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && message.hasOwnProperty("value"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.value);
                return writer;
            };

            /**
             * Decodes an ExecutionClusterLabel message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.ExecutionClusterLabel
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.ExecutionClusterLabel} ExecutionClusterLabel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecutionClusterLabel.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.ExecutionClusterLabel();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.value = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies an ExecutionClusterLabel message.
             * @function verify
             * @memberof flyteidl.admin.ExecutionClusterLabel
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExecutionClusterLabel.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isString(message.value))
                        return "value: string expected";
                return null;
            };

            return ExecutionClusterLabel;
        })();

        admin.MatchingAttributes = (function() {

            /**
             * Properties of a MatchingAttributes.
             * @memberof flyteidl.admin
             * @interface IMatchingAttributes
             * @property {flyteidl.admin.ITaskResourceAttributes|null} [taskResourceAttributes] MatchingAttributes taskResourceAttributes
             * @property {flyteidl.admin.IClusterResourceAttributes|null} [clusterResourceAttributes] MatchingAttributes clusterResourceAttributes
             * @property {flyteidl.admin.IExecutionQueueAttributes|null} [executionQueueAttributes] MatchingAttributes executionQueueAttributes
             * @property {flyteidl.admin.IExecutionClusterLabel|null} [executionClusterLabel] MatchingAttributes executionClusterLabel
             */

            /**
             * Constructs a new MatchingAttributes.
             * @memberof flyteidl.admin
             * @classdesc Represents a MatchingAttributes.
             * @implements IMatchingAttributes
             * @constructor
             * @param {flyteidl.admin.IMatchingAttributes=} [properties] Properties to set
             */
            function MatchingAttributes(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MatchingAttributes taskResourceAttributes.
             * @member {flyteidl.admin.ITaskResourceAttributes|null|undefined} taskResourceAttributes
             * @memberof flyteidl.admin.MatchingAttributes
             * @instance
             */
            MatchingAttributes.prototype.taskResourceAttributes = null;

            /**
             * MatchingAttributes clusterResourceAttributes.
             * @member {flyteidl.admin.IClusterResourceAttributes|null|undefined} clusterResourceAttributes
             * @memberof flyteidl.admin.MatchingAttributes
             * @instance
             */
            MatchingAttributes.prototype.clusterResourceAttributes = null;

            /**
             * MatchingAttributes executionQueueAttributes.
             * @member {flyteidl.admin.IExecutionQueueAttributes|null|undefined} executionQueueAttributes
             * @memberof flyteidl.admin.MatchingAttributes
             * @instance
             */
            MatchingAttributes.prototype.executionQueueAttributes = null;

            /**
             * MatchingAttributes executionClusterLabel.
             * @member {flyteidl.admin.IExecutionClusterLabel|null|undefined} executionClusterLabel
             * @memberof flyteidl.admin.MatchingAttributes
             * @instance
             */
            MatchingAttributes.prototype.executionClusterLabel = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * MatchingAttributes target.
             * @member {"taskResourceAttributes"|"clusterResourceAttributes"|"executionQueueAttributes"|"executionClusterLabel"|undefined} target
             * @memberof flyteidl.admin.MatchingAttributes
             * @instance
             */
            Object.defineProperty(MatchingAttributes.prototype, "target", {
                get: $util.oneOfGetter($oneOfFields = ["taskResourceAttributes", "clusterResourceAttributes", "executionQueueAttributes", "executionClusterLabel"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new MatchingAttributes instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.MatchingAttributes
             * @static
             * @param {flyteidl.admin.IMatchingAttributes=} [properties] Properties to set
             * @returns {flyteidl.admin.MatchingAttributes} MatchingAttributes instance
             */
            MatchingAttributes.create = function create(properties) {
                return new MatchingAttributes(properties);
            };

            /**
             * Encodes the specified MatchingAttributes message. Does not implicitly {@link flyteidl.admin.MatchingAttributes.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.MatchingAttributes
             * @static
             * @param {flyteidl.admin.IMatchingAttributes} message MatchingAttributes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MatchingAttributes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.taskResourceAttributes != null && message.hasOwnProperty("taskResourceAttributes"))
                    $root.flyteidl.admin.TaskResourceAttributes.encode(message.taskResourceAttributes, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.clusterResourceAttributes != null && message.hasOwnProperty("clusterResourceAttributes"))
                    $root.flyteidl.admin.ClusterResourceAttributes.encode(message.clusterResourceAttributes, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.executionQueueAttributes != null && message.hasOwnProperty("executionQueueAttributes"))
                    $root.flyteidl.admin.ExecutionQueueAttributes.encode(message.executionQueueAttributes, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.executionClusterLabel != null && message.hasOwnProperty("executionClusterLabel"))
                    $root.flyteidl.admin.ExecutionClusterLabel.encode(message.executionClusterLabel, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a MatchingAttributes message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.MatchingAttributes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.MatchingAttributes} MatchingAttributes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MatchingAttributes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.MatchingAttributes();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.taskResourceAttributes = $root.flyteidl.admin.TaskResourceAttributes.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.clusterResourceAttributes = $root.flyteidl.admin.ClusterResourceAttributes.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.executionQueueAttributes = $root.flyteidl.admin.ExecutionQueueAttributes.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.executionClusterLabel = $root.flyteidl.admin.ExecutionClusterLabel.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a MatchingAttributes message.
             * @function verify
             * @memberof flyteidl.admin.MatchingAttributes
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MatchingAttributes.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.taskResourceAttributes != null && message.hasOwnProperty("taskResourceAttributes")) {
                    properties.target = 1;
                    {
                        let error = $root.flyteidl.admin.TaskResourceAttributes.verify(message.taskResourceAttributes);
                        if (error)
                            return "taskResourceAttributes." + error;
                    }
                }
                if (message.clusterResourceAttributes != null && message.hasOwnProperty("clusterResourceAttributes")) {
                    if (properties.target === 1)
                        return "target: multiple values";
                    properties.target = 1;
                    {
                        let error = $root.flyteidl.admin.ClusterResourceAttributes.verify(message.clusterResourceAttributes);
                        if (error)
                            return "clusterResourceAttributes." + error;
                    }
                }
                if (message.executionQueueAttributes != null && message.hasOwnProperty("executionQueueAttributes")) {
                    if (properties.target === 1)
                        return "target: multiple values";
                    properties.target = 1;
                    {
                        let error = $root.flyteidl.admin.ExecutionQueueAttributes.verify(message.executionQueueAttributes);
                        if (error)
                            return "executionQueueAttributes." + error;
                    }
                }
                if (message.executionClusterLabel != null && message.hasOwnProperty("executionClusterLabel")) {
                    if (properties.target === 1)
                        return "target: multiple values";
                    properties.target = 1;
                    {
                        let error = $root.flyteidl.admin.ExecutionClusterLabel.verify(message.executionClusterLabel);
                        if (error)
                            return "executionClusterLabel." + error;
                    }
                }
                return null;
            };

            return MatchingAttributes;
        })();

        admin.MatchableAttributesConfiguration = (function() {

            /**
             * Properties of a MatchableAttributesConfiguration.
             * @memberof flyteidl.admin
             * @interface IMatchableAttributesConfiguration
             * @property {flyteidl.admin.IMatchingAttributes|null} [attributes] MatchableAttributesConfiguration attributes
             * @property {string|null} [domain] MatchableAttributesConfiguration domain
             * @property {string|null} [project] MatchableAttributesConfiguration project
             * @property {string|null} [workflow] MatchableAttributesConfiguration workflow
             * @property {string|null} [launchPlan] MatchableAttributesConfiguration launchPlan
             */

            /**
             * Constructs a new MatchableAttributesConfiguration.
             * @memberof flyteidl.admin
             * @classdesc Represents a MatchableAttributesConfiguration.
             * @implements IMatchableAttributesConfiguration
             * @constructor
             * @param {flyteidl.admin.IMatchableAttributesConfiguration=} [properties] Properties to set
             */
            function MatchableAttributesConfiguration(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MatchableAttributesConfiguration attributes.
             * @member {flyteidl.admin.IMatchingAttributes|null|undefined} attributes
             * @memberof flyteidl.admin.MatchableAttributesConfiguration
             * @instance
             */
            MatchableAttributesConfiguration.prototype.attributes = null;

            /**
             * MatchableAttributesConfiguration domain.
             * @member {string} domain
             * @memberof flyteidl.admin.MatchableAttributesConfiguration
             * @instance
             */
            MatchableAttributesConfiguration.prototype.domain = "";

            /**
             * MatchableAttributesConfiguration project.
             * @member {string} project
             * @memberof flyteidl.admin.MatchableAttributesConfiguration
             * @instance
             */
            MatchableAttributesConfiguration.prototype.project = "";

            /**
             * MatchableAttributesConfiguration workflow.
             * @member {string} workflow
             * @memberof flyteidl.admin.MatchableAttributesConfiguration
             * @instance
             */
            MatchableAttributesConfiguration.prototype.workflow = "";

            /**
             * MatchableAttributesConfiguration launchPlan.
             * @member {string} launchPlan
             * @memberof flyteidl.admin.MatchableAttributesConfiguration
             * @instance
             */
            MatchableAttributesConfiguration.prototype.launchPlan = "";

            /**
             * Creates a new MatchableAttributesConfiguration instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.MatchableAttributesConfiguration
             * @static
             * @param {flyteidl.admin.IMatchableAttributesConfiguration=} [properties] Properties to set
             * @returns {flyteidl.admin.MatchableAttributesConfiguration} MatchableAttributesConfiguration instance
             */
            MatchableAttributesConfiguration.create = function create(properties) {
                return new MatchableAttributesConfiguration(properties);
            };

            /**
             * Encodes the specified MatchableAttributesConfiguration message. Does not implicitly {@link flyteidl.admin.MatchableAttributesConfiguration.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.MatchableAttributesConfiguration
             * @static
             * @param {flyteidl.admin.IMatchableAttributesConfiguration} message MatchableAttributesConfiguration message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MatchableAttributesConfiguration.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.attributes != null && message.hasOwnProperty("attributes"))
                    $root.flyteidl.admin.MatchingAttributes.encode(message.attributes, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.domain != null && message.hasOwnProperty("domain"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.domain);
                if (message.project != null && message.hasOwnProperty("project"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.project);
                if (message.workflow != null && message.hasOwnProperty("workflow"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.workflow);
                if (message.launchPlan != null && message.hasOwnProperty("launchPlan"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.launchPlan);
                return writer;
            };

            /**
             * Decodes a MatchableAttributesConfiguration message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.MatchableAttributesConfiguration
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.MatchableAttributesConfiguration} MatchableAttributesConfiguration
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MatchableAttributesConfiguration.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.MatchableAttributesConfiguration();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.attributes = $root.flyteidl.admin.MatchingAttributes.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.domain = reader.string();
                        break;
                    case 3:
                        message.project = reader.string();
                        break;
                    case 4:
                        message.workflow = reader.string();
                        break;
                    case 5:
                        message.launchPlan = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a MatchableAttributesConfiguration message.
             * @function verify
             * @memberof flyteidl.admin.MatchableAttributesConfiguration
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MatchableAttributesConfiguration.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.attributes != null && message.hasOwnProperty("attributes")) {
                    let error = $root.flyteidl.admin.MatchingAttributes.verify(message.attributes);
                    if (error)
                        return "attributes." + error;
                }
                if (message.domain != null && message.hasOwnProperty("domain"))
                    if (!$util.isString(message.domain))
                        return "domain: string expected";
                if (message.project != null && message.hasOwnProperty("project"))
                    if (!$util.isString(message.project))
                        return "project: string expected";
                if (message.workflow != null && message.hasOwnProperty("workflow"))
                    if (!$util.isString(message.workflow))
                        return "workflow: string expected";
                if (message.launchPlan != null && message.hasOwnProperty("launchPlan"))
                    if (!$util.isString(message.launchPlan))
                        return "launchPlan: string expected";
                return null;
            };

            return MatchableAttributesConfiguration;
        })();

        admin.ListMatchableAttributesRequest = (function() {

            /**
             * Properties of a ListMatchableAttributesRequest.
             * @memberof flyteidl.admin
             * @interface IListMatchableAttributesRequest
             * @property {flyteidl.admin.MatchableResource|null} [resourceType] ListMatchableAttributesRequest resourceType
             */

            /**
             * Constructs a new ListMatchableAttributesRequest.
             * @memberof flyteidl.admin
             * @classdesc Represents a ListMatchableAttributesRequest.
             * @implements IListMatchableAttributesRequest
             * @constructor
             * @param {flyteidl.admin.IListMatchableAttributesRequest=} [properties] Properties to set
             */
            function ListMatchableAttributesRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ListMatchableAttributesRequest resourceType.
             * @member {flyteidl.admin.MatchableResource} resourceType
             * @memberof flyteidl.admin.ListMatchableAttributesRequest
             * @instance
             */
            ListMatchableAttributesRequest.prototype.resourceType = 0;

            /**
             * Creates a new ListMatchableAttributesRequest instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.ListMatchableAttributesRequest
             * @static
             * @param {flyteidl.admin.IListMatchableAttributesRequest=} [properties] Properties to set
             * @returns {flyteidl.admin.ListMatchableAttributesRequest} ListMatchableAttributesRequest instance
             */
            ListMatchableAttributesRequest.create = function create(properties) {
                return new ListMatchableAttributesRequest(properties);
            };

            /**
             * Encodes the specified ListMatchableAttributesRequest message. Does not implicitly {@link flyteidl.admin.ListMatchableAttributesRequest.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.ListMatchableAttributesRequest
             * @static
             * @param {flyteidl.admin.IListMatchableAttributesRequest} message ListMatchableAttributesRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListMatchableAttributesRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.resourceType != null && message.hasOwnProperty("resourceType"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.resourceType);
                return writer;
            };

            /**
             * Decodes a ListMatchableAttributesRequest message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.ListMatchableAttributesRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.ListMatchableAttributesRequest} ListMatchableAttributesRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListMatchableAttributesRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.ListMatchableAttributesRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.resourceType = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a ListMatchableAttributesRequest message.
             * @function verify
             * @memberof flyteidl.admin.ListMatchableAttributesRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ListMatchableAttributesRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.resourceType != null && message.hasOwnProperty("resourceType"))
                    switch (message.resourceType) {
                    default:
                        return "resourceType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                return null;
            };

            return ListMatchableAttributesRequest;
        })();

        admin.ListMatchableAttributesResponse = (function() {

            /**
             * Properties of a ListMatchableAttributesResponse.
             * @memberof flyteidl.admin
             * @interface IListMatchableAttributesResponse
             * @property {Array.<flyteidl.admin.IMatchableAttributesConfiguration>|null} [configurations] ListMatchableAttributesResponse configurations
             */

            /**
             * Constructs a new ListMatchableAttributesResponse.
             * @memberof flyteidl.admin
             * @classdesc Represents a ListMatchableAttributesResponse.
             * @implements IListMatchableAttributesResponse
             * @constructor
             * @param {flyteidl.admin.IListMatchableAttributesResponse=} [properties] Properties to set
             */
            function ListMatchableAttributesResponse(properties) {
                this.configurations = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ListMatchableAttributesResponse configurations.
             * @member {Array.<flyteidl.admin.IMatchableAttributesConfiguration>} configurations
             * @memberof flyteidl.admin.ListMatchableAttributesResponse
             * @instance
             */
            ListMatchableAttributesResponse.prototype.configurations = $util.emptyArray;

            /**
             * Creates a new ListMatchableAttributesResponse instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.ListMatchableAttributesResponse
             * @static
             * @param {flyteidl.admin.IListMatchableAttributesResponse=} [properties] Properties to set
             * @returns {flyteidl.admin.ListMatchableAttributesResponse} ListMatchableAttributesResponse instance
             */
            ListMatchableAttributesResponse.create = function create(properties) {
                return new ListMatchableAttributesResponse(properties);
            };

            /**
             * Encodes the specified ListMatchableAttributesResponse message. Does not implicitly {@link flyteidl.admin.ListMatchableAttributesResponse.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.ListMatchableAttributesResponse
             * @static
             * @param {flyteidl.admin.IListMatchableAttributesResponse} message ListMatchableAttributesResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListMatchableAttributesResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.configurations != null && message.configurations.length)
                    for (let i = 0; i < message.configurations.length; ++i)
                        $root.flyteidl.admin.MatchableAttributesConfiguration.encode(message.configurations[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a ListMatchableAttributesResponse message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.ListMatchableAttributesResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.ListMatchableAttributesResponse} ListMatchableAttributesResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListMatchableAttributesResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.ListMatchableAttributesResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.configurations && message.configurations.length))
                            message.configurations = [];
                        message.configurations.push($root.flyteidl.admin.MatchableAttributesConfiguration.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a ListMatchableAttributesResponse message.
             * @function verify
             * @memberof flyteidl.admin.ListMatchableAttributesResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ListMatchableAttributesResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.configurations != null && message.hasOwnProperty("configurations")) {
                    if (!Array.isArray(message.configurations))
                        return "configurations: array expected";
                    for (let i = 0; i < message.configurations.length; ++i) {
                        let error = $root.flyteidl.admin.MatchableAttributesConfiguration.verify(message.configurations[i]);
                        if (error)
                            return "configurations." + error;
                    }
                }
                return null;
            };

            return ListMatchableAttributesResponse;
        })();

        admin.NodeExecutionGetRequest = (function() {

            /**
             * Properties of a NodeExecutionGetRequest.
             * @memberof flyteidl.admin
             * @interface INodeExecutionGetRequest
             * @property {flyteidl.core.INodeExecutionIdentifier|null} [id] NodeExecutionGetRequest id
             */

            /**
             * Constructs a new NodeExecutionGetRequest.
             * @memberof flyteidl.admin
             * @classdesc Represents a NodeExecutionGetRequest.
             * @implements INodeExecutionGetRequest
             * @constructor
             * @param {flyteidl.admin.INodeExecutionGetRequest=} [properties] Properties to set
             */
            function NodeExecutionGetRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NodeExecutionGetRequest id.
             * @member {flyteidl.core.INodeExecutionIdentifier|null|undefined} id
             * @memberof flyteidl.admin.NodeExecutionGetRequest
             * @instance
             */
            NodeExecutionGetRequest.prototype.id = null;

            /**
             * Creates a new NodeExecutionGetRequest instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.NodeExecutionGetRequest
             * @static
             * @param {flyteidl.admin.INodeExecutionGetRequest=} [properties] Properties to set
             * @returns {flyteidl.admin.NodeExecutionGetRequest} NodeExecutionGetRequest instance
             */
            NodeExecutionGetRequest.create = function create(properties) {
                return new NodeExecutionGetRequest(properties);
            };

            /**
             * Encodes the specified NodeExecutionGetRequest message. Does not implicitly {@link flyteidl.admin.NodeExecutionGetRequest.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.NodeExecutionGetRequest
             * @static
             * @param {flyteidl.admin.INodeExecutionGetRequest} message NodeExecutionGetRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NodeExecutionGetRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    $root.flyteidl.core.NodeExecutionIdentifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a NodeExecutionGetRequest message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.NodeExecutionGetRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.NodeExecutionGetRequest} NodeExecutionGetRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NodeExecutionGetRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.NodeExecutionGetRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = $root.flyteidl.core.NodeExecutionIdentifier.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a NodeExecutionGetRequest message.
             * @function verify
             * @memberof flyteidl.admin.NodeExecutionGetRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NodeExecutionGetRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id")) {
                    let error = $root.flyteidl.core.NodeExecutionIdentifier.verify(message.id);
                    if (error)
                        return "id." + error;
                }
                return null;
            };

            return NodeExecutionGetRequest;
        })();

        admin.NodeExecutionListRequest = (function() {

            /**
             * Properties of a NodeExecutionListRequest.
             * @memberof flyteidl.admin
             * @interface INodeExecutionListRequest
             * @property {flyteidl.core.IWorkflowExecutionIdentifier|null} [workflowExecutionId] NodeExecutionListRequest workflowExecutionId
             * @property {number|null} [limit] NodeExecutionListRequest limit
             * @property {string|null} [token] NodeExecutionListRequest token
             * @property {string|null} [filters] NodeExecutionListRequest filters
             * @property {flyteidl.admin.ISort|null} [sortBy] NodeExecutionListRequest sortBy
             */

            /**
             * Constructs a new NodeExecutionListRequest.
             * @memberof flyteidl.admin
             * @classdesc Represents a NodeExecutionListRequest.
             * @implements INodeExecutionListRequest
             * @constructor
             * @param {flyteidl.admin.INodeExecutionListRequest=} [properties] Properties to set
             */
            function NodeExecutionListRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NodeExecutionListRequest workflowExecutionId.
             * @member {flyteidl.core.IWorkflowExecutionIdentifier|null|undefined} workflowExecutionId
             * @memberof flyteidl.admin.NodeExecutionListRequest
             * @instance
             */
            NodeExecutionListRequest.prototype.workflowExecutionId = null;

            /**
             * NodeExecutionListRequest limit.
             * @member {number} limit
             * @memberof flyteidl.admin.NodeExecutionListRequest
             * @instance
             */
            NodeExecutionListRequest.prototype.limit = 0;

            /**
             * NodeExecutionListRequest token.
             * @member {string} token
             * @memberof flyteidl.admin.NodeExecutionListRequest
             * @instance
             */
            NodeExecutionListRequest.prototype.token = "";

            /**
             * NodeExecutionListRequest filters.
             * @member {string} filters
             * @memberof flyteidl.admin.NodeExecutionListRequest
             * @instance
             */
            NodeExecutionListRequest.prototype.filters = "";

            /**
             * NodeExecutionListRequest sortBy.
             * @member {flyteidl.admin.ISort|null|undefined} sortBy
             * @memberof flyteidl.admin.NodeExecutionListRequest
             * @instance
             */
            NodeExecutionListRequest.prototype.sortBy = null;

            /**
             * Creates a new NodeExecutionListRequest instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.NodeExecutionListRequest
             * @static
             * @param {flyteidl.admin.INodeExecutionListRequest=} [properties] Properties to set
             * @returns {flyteidl.admin.NodeExecutionListRequest} NodeExecutionListRequest instance
             */
            NodeExecutionListRequest.create = function create(properties) {
                return new NodeExecutionListRequest(properties);
            };

            /**
             * Encodes the specified NodeExecutionListRequest message. Does not implicitly {@link flyteidl.admin.NodeExecutionListRequest.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.NodeExecutionListRequest
             * @static
             * @param {flyteidl.admin.INodeExecutionListRequest} message NodeExecutionListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NodeExecutionListRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.workflowExecutionId != null && message.hasOwnProperty("workflowExecutionId"))
                    $root.flyteidl.core.WorkflowExecutionIdentifier.encode(message.workflowExecutionId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.limit != null && message.hasOwnProperty("limit"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.limit);
                if (message.token != null && message.hasOwnProperty("token"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.token);
                if (message.filters != null && message.hasOwnProperty("filters"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.filters);
                if (message.sortBy != null && message.hasOwnProperty("sortBy"))
                    $root.flyteidl.admin.Sort.encode(message.sortBy, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a NodeExecutionListRequest message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.NodeExecutionListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.NodeExecutionListRequest} NodeExecutionListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NodeExecutionListRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.NodeExecutionListRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.workflowExecutionId = $root.flyteidl.core.WorkflowExecutionIdentifier.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.limit = reader.uint32();
                        break;
                    case 3:
                        message.token = reader.string();
                        break;
                    case 4:
                        message.filters = reader.string();
                        break;
                    case 5:
                        message.sortBy = $root.flyteidl.admin.Sort.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a NodeExecutionListRequest message.
             * @function verify
             * @memberof flyteidl.admin.NodeExecutionListRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NodeExecutionListRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.workflowExecutionId != null && message.hasOwnProperty("workflowExecutionId")) {
                    let error = $root.flyteidl.core.WorkflowExecutionIdentifier.verify(message.workflowExecutionId);
                    if (error)
                        return "workflowExecutionId." + error;
                }
                if (message.limit != null && message.hasOwnProperty("limit"))
                    if (!$util.isInteger(message.limit))
                        return "limit: integer expected";
                if (message.token != null && message.hasOwnProperty("token"))
                    if (!$util.isString(message.token))
                        return "token: string expected";
                if (message.filters != null && message.hasOwnProperty("filters"))
                    if (!$util.isString(message.filters))
                        return "filters: string expected";
                if (message.sortBy != null && message.hasOwnProperty("sortBy")) {
                    let error = $root.flyteidl.admin.Sort.verify(message.sortBy);
                    if (error)
                        return "sortBy." + error;
                }
                return null;
            };

            return NodeExecutionListRequest;
        })();

        admin.NodeExecutionForTaskListRequest = (function() {

            /**
             * Properties of a NodeExecutionForTaskListRequest.
             * @memberof flyteidl.admin
             * @interface INodeExecutionForTaskListRequest
             * @property {flyteidl.core.ITaskExecutionIdentifier|null} [taskExecutionId] NodeExecutionForTaskListRequest taskExecutionId
             * @property {number|null} [limit] NodeExecutionForTaskListRequest limit
             * @property {string|null} [token] NodeExecutionForTaskListRequest token
             * @property {string|null} [filters] NodeExecutionForTaskListRequest filters
             * @property {flyteidl.admin.ISort|null} [sortBy] NodeExecutionForTaskListRequest sortBy
             */

            /**
             * Constructs a new NodeExecutionForTaskListRequest.
             * @memberof flyteidl.admin
             * @classdesc Represents a NodeExecutionForTaskListRequest.
             * @implements INodeExecutionForTaskListRequest
             * @constructor
             * @param {flyteidl.admin.INodeExecutionForTaskListRequest=} [properties] Properties to set
             */
            function NodeExecutionForTaskListRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NodeExecutionForTaskListRequest taskExecutionId.
             * @member {flyteidl.core.ITaskExecutionIdentifier|null|undefined} taskExecutionId
             * @memberof flyteidl.admin.NodeExecutionForTaskListRequest
             * @instance
             */
            NodeExecutionForTaskListRequest.prototype.taskExecutionId = null;

            /**
             * NodeExecutionForTaskListRequest limit.
             * @member {number} limit
             * @memberof flyteidl.admin.NodeExecutionForTaskListRequest
             * @instance
             */
            NodeExecutionForTaskListRequest.prototype.limit = 0;

            /**
             * NodeExecutionForTaskListRequest token.
             * @member {string} token
             * @memberof flyteidl.admin.NodeExecutionForTaskListRequest
             * @instance
             */
            NodeExecutionForTaskListRequest.prototype.token = "";

            /**
             * NodeExecutionForTaskListRequest filters.
             * @member {string} filters
             * @memberof flyteidl.admin.NodeExecutionForTaskListRequest
             * @instance
             */
            NodeExecutionForTaskListRequest.prototype.filters = "";

            /**
             * NodeExecutionForTaskListRequest sortBy.
             * @member {flyteidl.admin.ISort|null|undefined} sortBy
             * @memberof flyteidl.admin.NodeExecutionForTaskListRequest
             * @instance
             */
            NodeExecutionForTaskListRequest.prototype.sortBy = null;

            /**
             * Creates a new NodeExecutionForTaskListRequest instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.NodeExecutionForTaskListRequest
             * @static
             * @param {flyteidl.admin.INodeExecutionForTaskListRequest=} [properties] Properties to set
             * @returns {flyteidl.admin.NodeExecutionForTaskListRequest} NodeExecutionForTaskListRequest instance
             */
            NodeExecutionForTaskListRequest.create = function create(properties) {
                return new NodeExecutionForTaskListRequest(properties);
            };

            /**
             * Encodes the specified NodeExecutionForTaskListRequest message. Does not implicitly {@link flyteidl.admin.NodeExecutionForTaskListRequest.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.NodeExecutionForTaskListRequest
             * @static
             * @param {flyteidl.admin.INodeExecutionForTaskListRequest} message NodeExecutionForTaskListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NodeExecutionForTaskListRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.taskExecutionId != null && message.hasOwnProperty("taskExecutionId"))
                    $root.flyteidl.core.TaskExecutionIdentifier.encode(message.taskExecutionId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.limit != null && message.hasOwnProperty("limit"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.limit);
                if (message.token != null && message.hasOwnProperty("token"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.token);
                if (message.filters != null && message.hasOwnProperty("filters"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.filters);
                if (message.sortBy != null && message.hasOwnProperty("sortBy"))
                    $root.flyteidl.admin.Sort.encode(message.sortBy, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a NodeExecutionForTaskListRequest message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.NodeExecutionForTaskListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.NodeExecutionForTaskListRequest} NodeExecutionForTaskListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NodeExecutionForTaskListRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.NodeExecutionForTaskListRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.taskExecutionId = $root.flyteidl.core.TaskExecutionIdentifier.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.limit = reader.uint32();
                        break;
                    case 3:
                        message.token = reader.string();
                        break;
                    case 4:
                        message.filters = reader.string();
                        break;
                    case 5:
                        message.sortBy = $root.flyteidl.admin.Sort.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a NodeExecutionForTaskListRequest message.
             * @function verify
             * @memberof flyteidl.admin.NodeExecutionForTaskListRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NodeExecutionForTaskListRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.taskExecutionId != null && message.hasOwnProperty("taskExecutionId")) {
                    let error = $root.flyteidl.core.TaskExecutionIdentifier.verify(message.taskExecutionId);
                    if (error)
                        return "taskExecutionId." + error;
                }
                if (message.limit != null && message.hasOwnProperty("limit"))
                    if (!$util.isInteger(message.limit))
                        return "limit: integer expected";
                if (message.token != null && message.hasOwnProperty("token"))
                    if (!$util.isString(message.token))
                        return "token: string expected";
                if (message.filters != null && message.hasOwnProperty("filters"))
                    if (!$util.isString(message.filters))
                        return "filters: string expected";
                if (message.sortBy != null && message.hasOwnProperty("sortBy")) {
                    let error = $root.flyteidl.admin.Sort.verify(message.sortBy);
                    if (error)
                        return "sortBy." + error;
                }
                return null;
            };

            return NodeExecutionForTaskListRequest;
        })();

        admin.NodeExecution = (function() {

            /**
             * Properties of a NodeExecution.
             * @memberof flyteidl.admin
             * @interface INodeExecution
             * @property {flyteidl.core.INodeExecutionIdentifier|null} [id] NodeExecution id
             * @property {string|null} [inputUri] NodeExecution inputUri
             * @property {flyteidl.admin.INodeExecutionClosure|null} [closure] NodeExecution closure
             * @property {flyteidl.admin.INodeExecutionMetaData|null} [metadata] NodeExecution metadata
             */

            /**
             * Constructs a new NodeExecution.
             * @memberof flyteidl.admin
             * @classdesc Represents a NodeExecution.
             * @implements INodeExecution
             * @constructor
             * @param {flyteidl.admin.INodeExecution=} [properties] Properties to set
             */
            function NodeExecution(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NodeExecution id.
             * @member {flyteidl.core.INodeExecutionIdentifier|null|undefined} id
             * @memberof flyteidl.admin.NodeExecution
             * @instance
             */
            NodeExecution.prototype.id = null;

            /**
             * NodeExecution inputUri.
             * @member {string} inputUri
             * @memberof flyteidl.admin.NodeExecution
             * @instance
             */
            NodeExecution.prototype.inputUri = "";

            /**
             * NodeExecution closure.
             * @member {flyteidl.admin.INodeExecutionClosure|null|undefined} closure
             * @memberof flyteidl.admin.NodeExecution
             * @instance
             */
            NodeExecution.prototype.closure = null;

            /**
             * NodeExecution metadata.
             * @member {flyteidl.admin.INodeExecutionMetaData|null|undefined} metadata
             * @memberof flyteidl.admin.NodeExecution
             * @instance
             */
            NodeExecution.prototype.metadata = null;

            /**
             * Creates a new NodeExecution instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.NodeExecution
             * @static
             * @param {flyteidl.admin.INodeExecution=} [properties] Properties to set
             * @returns {flyteidl.admin.NodeExecution} NodeExecution instance
             */
            NodeExecution.create = function create(properties) {
                return new NodeExecution(properties);
            };

            /**
             * Encodes the specified NodeExecution message. Does not implicitly {@link flyteidl.admin.NodeExecution.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.NodeExecution
             * @static
             * @param {flyteidl.admin.INodeExecution} message NodeExecution message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NodeExecution.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    $root.flyteidl.core.NodeExecutionIdentifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.inputUri != null && message.hasOwnProperty("inputUri"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.inputUri);
                if (message.closure != null && message.hasOwnProperty("closure"))
                    $root.flyteidl.admin.NodeExecutionClosure.encode(message.closure, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    $root.flyteidl.admin.NodeExecutionMetaData.encode(message.metadata, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a NodeExecution message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.NodeExecution
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.NodeExecution} NodeExecution
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NodeExecution.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.NodeExecution();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = $root.flyteidl.core.NodeExecutionIdentifier.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.inputUri = reader.string();
                        break;
                    case 3:
                        message.closure = $root.flyteidl.admin.NodeExecutionClosure.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.metadata = $root.flyteidl.admin.NodeExecutionMetaData.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a NodeExecution message.
             * @function verify
             * @memberof flyteidl.admin.NodeExecution
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NodeExecution.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id")) {
                    let error = $root.flyteidl.core.NodeExecutionIdentifier.verify(message.id);
                    if (error)
                        return "id." + error;
                }
                if (message.inputUri != null && message.hasOwnProperty("inputUri"))
                    if (!$util.isString(message.inputUri))
                        return "inputUri: string expected";
                if (message.closure != null && message.hasOwnProperty("closure")) {
                    let error = $root.flyteidl.admin.NodeExecutionClosure.verify(message.closure);
                    if (error)
                        return "closure." + error;
                }
                if (message.metadata != null && message.hasOwnProperty("metadata")) {
                    let error = $root.flyteidl.admin.NodeExecutionMetaData.verify(message.metadata);
                    if (error)
                        return "metadata." + error;
                }
                return null;
            };

            return NodeExecution;
        })();

        admin.NodeExecutionMetaData = (function() {

            /**
             * Properties of a NodeExecutionMetaData.
             * @memberof flyteidl.admin
             * @interface INodeExecutionMetaData
             */

            /**
             * Constructs a new NodeExecutionMetaData.
             * @memberof flyteidl.admin
             * @classdesc Represents a NodeExecutionMetaData.
             * @implements INodeExecutionMetaData
             * @constructor
             * @param {flyteidl.admin.INodeExecutionMetaData=} [properties] Properties to set
             */
            function NodeExecutionMetaData(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new NodeExecutionMetaData instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.NodeExecutionMetaData
             * @static
             * @param {flyteidl.admin.INodeExecutionMetaData=} [properties] Properties to set
             * @returns {flyteidl.admin.NodeExecutionMetaData} NodeExecutionMetaData instance
             */
            NodeExecutionMetaData.create = function create(properties) {
                return new NodeExecutionMetaData(properties);
            };

            /**
             * Encodes the specified NodeExecutionMetaData message. Does not implicitly {@link flyteidl.admin.NodeExecutionMetaData.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.NodeExecutionMetaData
             * @static
             * @param {flyteidl.admin.INodeExecutionMetaData} message NodeExecutionMetaData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NodeExecutionMetaData.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Decodes a NodeExecutionMetaData message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.NodeExecutionMetaData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.NodeExecutionMetaData} NodeExecutionMetaData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NodeExecutionMetaData.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.NodeExecutionMetaData();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a NodeExecutionMetaData message.
             * @function verify
             * @memberof flyteidl.admin.NodeExecutionMetaData
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NodeExecutionMetaData.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            return NodeExecutionMetaData;
        })();

        admin.NodeExecutionList = (function() {

            /**
             * Properties of a NodeExecutionList.
             * @memberof flyteidl.admin
             * @interface INodeExecutionList
             * @property {Array.<flyteidl.admin.INodeExecution>|null} [nodeExecutions] NodeExecutionList nodeExecutions
             * @property {string|null} [token] NodeExecutionList token
             */

            /**
             * Constructs a new NodeExecutionList.
             * @memberof flyteidl.admin
             * @classdesc Represents a NodeExecutionList.
             * @implements INodeExecutionList
             * @constructor
             * @param {flyteidl.admin.INodeExecutionList=} [properties] Properties to set
             */
            function NodeExecutionList(properties) {
                this.nodeExecutions = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NodeExecutionList nodeExecutions.
             * @member {Array.<flyteidl.admin.INodeExecution>} nodeExecutions
             * @memberof flyteidl.admin.NodeExecutionList
             * @instance
             */
            NodeExecutionList.prototype.nodeExecutions = $util.emptyArray;

            /**
             * NodeExecutionList token.
             * @member {string} token
             * @memberof flyteidl.admin.NodeExecutionList
             * @instance
             */
            NodeExecutionList.prototype.token = "";

            /**
             * Creates a new NodeExecutionList instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.NodeExecutionList
             * @static
             * @param {flyteidl.admin.INodeExecutionList=} [properties] Properties to set
             * @returns {flyteidl.admin.NodeExecutionList} NodeExecutionList instance
             */
            NodeExecutionList.create = function create(properties) {
                return new NodeExecutionList(properties);
            };

            /**
             * Encodes the specified NodeExecutionList message. Does not implicitly {@link flyteidl.admin.NodeExecutionList.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.NodeExecutionList
             * @static
             * @param {flyteidl.admin.INodeExecutionList} message NodeExecutionList message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NodeExecutionList.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.nodeExecutions != null && message.nodeExecutions.length)
                    for (let i = 0; i < message.nodeExecutions.length; ++i)
                        $root.flyteidl.admin.NodeExecution.encode(message.nodeExecutions[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.token != null && message.hasOwnProperty("token"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.token);
                return writer;
            };

            /**
             * Decodes a NodeExecutionList message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.NodeExecutionList
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.NodeExecutionList} NodeExecutionList
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NodeExecutionList.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.NodeExecutionList();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.nodeExecutions && message.nodeExecutions.length))
                            message.nodeExecutions = [];
                        message.nodeExecutions.push($root.flyteidl.admin.NodeExecution.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        message.token = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a NodeExecutionList message.
             * @function verify
             * @memberof flyteidl.admin.NodeExecutionList
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NodeExecutionList.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.nodeExecutions != null && message.hasOwnProperty("nodeExecutions")) {
                    if (!Array.isArray(message.nodeExecutions))
                        return "nodeExecutions: array expected";
                    for (let i = 0; i < message.nodeExecutions.length; ++i) {
                        let error = $root.flyteidl.admin.NodeExecution.verify(message.nodeExecutions[i]);
                        if (error)
                            return "nodeExecutions." + error;
                    }
                }
                if (message.token != null && message.hasOwnProperty("token"))
                    if (!$util.isString(message.token))
                        return "token: string expected";
                return null;
            };

            return NodeExecutionList;
        })();

        admin.NodeExecutionClosure = (function() {

            /**
             * Properties of a NodeExecutionClosure.
             * @memberof flyteidl.admin
             * @interface INodeExecutionClosure
             * @property {string|null} [outputUri] NodeExecutionClosure outputUri
             * @property {flyteidl.core.IExecutionError|null} [error] NodeExecutionClosure error
             * @property {flyteidl.core.NodeExecution.Phase|null} [phase] NodeExecutionClosure phase
             * @property {google.protobuf.ITimestamp|null} [startedAt] NodeExecutionClosure startedAt
             * @property {google.protobuf.IDuration|null} [duration] NodeExecutionClosure duration
             * @property {google.protobuf.ITimestamp|null} [createdAt] NodeExecutionClosure createdAt
             * @property {google.protobuf.ITimestamp|null} [updatedAt] NodeExecutionClosure updatedAt
             * @property {flyteidl.admin.IWorkflowNodeMetadata|null} [workflowNodeMetadata] NodeExecutionClosure workflowNodeMetadata
             */

            /**
             * Constructs a new NodeExecutionClosure.
             * @memberof flyteidl.admin
             * @classdesc Represents a NodeExecutionClosure.
             * @implements INodeExecutionClosure
             * @constructor
             * @param {flyteidl.admin.INodeExecutionClosure=} [properties] Properties to set
             */
            function NodeExecutionClosure(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NodeExecutionClosure outputUri.
             * @member {string} outputUri
             * @memberof flyteidl.admin.NodeExecutionClosure
             * @instance
             */
            NodeExecutionClosure.prototype.outputUri = "";

            /**
             * NodeExecutionClosure error.
             * @member {flyteidl.core.IExecutionError|null|undefined} error
             * @memberof flyteidl.admin.NodeExecutionClosure
             * @instance
             */
            NodeExecutionClosure.prototype.error = null;

            /**
             * NodeExecutionClosure phase.
             * @member {flyteidl.core.NodeExecution.Phase} phase
             * @memberof flyteidl.admin.NodeExecutionClosure
             * @instance
             */
            NodeExecutionClosure.prototype.phase = 0;

            /**
             * NodeExecutionClosure startedAt.
             * @member {google.protobuf.ITimestamp|null|undefined} startedAt
             * @memberof flyteidl.admin.NodeExecutionClosure
             * @instance
             */
            NodeExecutionClosure.prototype.startedAt = null;

            /**
             * NodeExecutionClosure duration.
             * @member {google.protobuf.IDuration|null|undefined} duration
             * @memberof flyteidl.admin.NodeExecutionClosure
             * @instance
             */
            NodeExecutionClosure.prototype.duration = null;

            /**
             * NodeExecutionClosure createdAt.
             * @member {google.protobuf.ITimestamp|null|undefined} createdAt
             * @memberof flyteidl.admin.NodeExecutionClosure
             * @instance
             */
            NodeExecutionClosure.prototype.createdAt = null;

            /**
             * NodeExecutionClosure updatedAt.
             * @member {google.protobuf.ITimestamp|null|undefined} updatedAt
             * @memberof flyteidl.admin.NodeExecutionClosure
             * @instance
             */
            NodeExecutionClosure.prototype.updatedAt = null;

            /**
             * NodeExecutionClosure workflowNodeMetadata.
             * @member {flyteidl.admin.IWorkflowNodeMetadata|null|undefined} workflowNodeMetadata
             * @memberof flyteidl.admin.NodeExecutionClosure
             * @instance
             */
            NodeExecutionClosure.prototype.workflowNodeMetadata = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * NodeExecutionClosure outputResult.
             * @member {"outputUri"|"error"|undefined} outputResult
             * @memberof flyteidl.admin.NodeExecutionClosure
             * @instance
             */
            Object.defineProperty(NodeExecutionClosure.prototype, "outputResult", {
                get: $util.oneOfGetter($oneOfFields = ["outputUri", "error"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * NodeExecutionClosure targetMetadata.
             * @member {"workflowNodeMetadata"|undefined} targetMetadata
             * @memberof flyteidl.admin.NodeExecutionClosure
             * @instance
             */
            Object.defineProperty(NodeExecutionClosure.prototype, "targetMetadata", {
                get: $util.oneOfGetter($oneOfFields = ["workflowNodeMetadata"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new NodeExecutionClosure instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.NodeExecutionClosure
             * @static
             * @param {flyteidl.admin.INodeExecutionClosure=} [properties] Properties to set
             * @returns {flyteidl.admin.NodeExecutionClosure} NodeExecutionClosure instance
             */
            NodeExecutionClosure.create = function create(properties) {
                return new NodeExecutionClosure(properties);
            };

            /**
             * Encodes the specified NodeExecutionClosure message. Does not implicitly {@link flyteidl.admin.NodeExecutionClosure.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.NodeExecutionClosure
             * @static
             * @param {flyteidl.admin.INodeExecutionClosure} message NodeExecutionClosure message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NodeExecutionClosure.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.outputUri != null && message.hasOwnProperty("outputUri"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.outputUri);
                if (message.error != null && message.hasOwnProperty("error"))
                    $root.flyteidl.core.ExecutionError.encode(message.error, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.phase != null && message.hasOwnProperty("phase"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.phase);
                if (message.startedAt != null && message.hasOwnProperty("startedAt"))
                    $root.google.protobuf.Timestamp.encode(message.startedAt, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.duration != null && message.hasOwnProperty("duration"))
                    $root.google.protobuf.Duration.encode(message.duration, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.createdAt != null && message.hasOwnProperty("createdAt"))
                    $root.google.protobuf.Timestamp.encode(message.createdAt, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.updatedAt != null && message.hasOwnProperty("updatedAt"))
                    $root.google.protobuf.Timestamp.encode(message.updatedAt, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.workflowNodeMetadata != null && message.hasOwnProperty("workflowNodeMetadata"))
                    $root.flyteidl.admin.WorkflowNodeMetadata.encode(message.workflowNodeMetadata, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a NodeExecutionClosure message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.NodeExecutionClosure
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.NodeExecutionClosure} NodeExecutionClosure
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NodeExecutionClosure.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.NodeExecutionClosure();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.outputUri = reader.string();
                        break;
                    case 2:
                        message.error = $root.flyteidl.core.ExecutionError.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.phase = reader.int32();
                        break;
                    case 4:
                        message.startedAt = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.duration = $root.google.protobuf.Duration.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.createdAt = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.updatedAt = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                        break;
                    case 8:
                        message.workflowNodeMetadata = $root.flyteidl.admin.WorkflowNodeMetadata.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a NodeExecutionClosure message.
             * @function verify
             * @memberof flyteidl.admin.NodeExecutionClosure
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NodeExecutionClosure.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.outputUri != null && message.hasOwnProperty("outputUri")) {
                    properties.outputResult = 1;
                    if (!$util.isString(message.outputUri))
                        return "outputUri: string expected";
                }
                if (message.error != null && message.hasOwnProperty("error")) {
                    if (properties.outputResult === 1)
                        return "outputResult: multiple values";
                    properties.outputResult = 1;
                    {
                        let error = $root.flyteidl.core.ExecutionError.verify(message.error);
                        if (error)
                            return "error." + error;
                    }
                }
                if (message.phase != null && message.hasOwnProperty("phase"))
                    switch (message.phase) {
                    default:
                        return "phase: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                        break;
                    }
                if (message.startedAt != null && message.hasOwnProperty("startedAt")) {
                    let error = $root.google.protobuf.Timestamp.verify(message.startedAt);
                    if (error)
                        return "startedAt." + error;
                }
                if (message.duration != null && message.hasOwnProperty("duration")) {
                    let error = $root.google.protobuf.Duration.verify(message.duration);
                    if (error)
                        return "duration." + error;
                }
                if (message.createdAt != null && message.hasOwnProperty("createdAt")) {
                    let error = $root.google.protobuf.Timestamp.verify(message.createdAt);
                    if (error)
                        return "createdAt." + error;
                }
                if (message.updatedAt != null && message.hasOwnProperty("updatedAt")) {
                    let error = $root.google.protobuf.Timestamp.verify(message.updatedAt);
                    if (error)
                        return "updatedAt." + error;
                }
                if (message.workflowNodeMetadata != null && message.hasOwnProperty("workflowNodeMetadata")) {
                    properties.targetMetadata = 1;
                    {
                        let error = $root.flyteidl.admin.WorkflowNodeMetadata.verify(message.workflowNodeMetadata);
                        if (error)
                            return "workflowNodeMetadata." + error;
                    }
                }
                return null;
            };

            return NodeExecutionClosure;
        })();

        admin.WorkflowNodeMetadata = (function() {

            /**
             * Properties of a WorkflowNodeMetadata.
             * @memberof flyteidl.admin
             * @interface IWorkflowNodeMetadata
             * @property {flyteidl.core.IWorkflowExecutionIdentifier|null} [executionId] WorkflowNodeMetadata executionId
             */

            /**
             * Constructs a new WorkflowNodeMetadata.
             * @memberof flyteidl.admin
             * @classdesc Represents a WorkflowNodeMetadata.
             * @implements IWorkflowNodeMetadata
             * @constructor
             * @param {flyteidl.admin.IWorkflowNodeMetadata=} [properties] Properties to set
             */
            function WorkflowNodeMetadata(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WorkflowNodeMetadata executionId.
             * @member {flyteidl.core.IWorkflowExecutionIdentifier|null|undefined} executionId
             * @memberof flyteidl.admin.WorkflowNodeMetadata
             * @instance
             */
            WorkflowNodeMetadata.prototype.executionId = null;

            /**
             * Creates a new WorkflowNodeMetadata instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.WorkflowNodeMetadata
             * @static
             * @param {flyteidl.admin.IWorkflowNodeMetadata=} [properties] Properties to set
             * @returns {flyteidl.admin.WorkflowNodeMetadata} WorkflowNodeMetadata instance
             */
            WorkflowNodeMetadata.create = function create(properties) {
                return new WorkflowNodeMetadata(properties);
            };

            /**
             * Encodes the specified WorkflowNodeMetadata message. Does not implicitly {@link flyteidl.admin.WorkflowNodeMetadata.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.WorkflowNodeMetadata
             * @static
             * @param {flyteidl.admin.IWorkflowNodeMetadata} message WorkflowNodeMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WorkflowNodeMetadata.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.executionId != null && message.hasOwnProperty("executionId"))
                    $root.flyteidl.core.WorkflowExecutionIdentifier.encode(message.executionId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a WorkflowNodeMetadata message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.WorkflowNodeMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.WorkflowNodeMetadata} WorkflowNodeMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WorkflowNodeMetadata.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.WorkflowNodeMetadata();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.executionId = $root.flyteidl.core.WorkflowExecutionIdentifier.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a WorkflowNodeMetadata message.
             * @function verify
             * @memberof flyteidl.admin.WorkflowNodeMetadata
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WorkflowNodeMetadata.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.executionId != null && message.hasOwnProperty("executionId")) {
                    let error = $root.flyteidl.core.WorkflowExecutionIdentifier.verify(message.executionId);
                    if (error)
                        return "executionId." + error;
                }
                return null;
            };

            return WorkflowNodeMetadata;
        })();

        admin.NodeExecutionGetDataRequest = (function() {

            /**
             * Properties of a NodeExecutionGetDataRequest.
             * @memberof flyteidl.admin
             * @interface INodeExecutionGetDataRequest
             * @property {flyteidl.core.INodeExecutionIdentifier|null} [id] NodeExecutionGetDataRequest id
             */

            /**
             * Constructs a new NodeExecutionGetDataRequest.
             * @memberof flyteidl.admin
             * @classdesc Represents a NodeExecutionGetDataRequest.
             * @implements INodeExecutionGetDataRequest
             * @constructor
             * @param {flyteidl.admin.INodeExecutionGetDataRequest=} [properties] Properties to set
             */
            function NodeExecutionGetDataRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NodeExecutionGetDataRequest id.
             * @member {flyteidl.core.INodeExecutionIdentifier|null|undefined} id
             * @memberof flyteidl.admin.NodeExecutionGetDataRequest
             * @instance
             */
            NodeExecutionGetDataRequest.prototype.id = null;

            /**
             * Creates a new NodeExecutionGetDataRequest instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.NodeExecutionGetDataRequest
             * @static
             * @param {flyteidl.admin.INodeExecutionGetDataRequest=} [properties] Properties to set
             * @returns {flyteidl.admin.NodeExecutionGetDataRequest} NodeExecutionGetDataRequest instance
             */
            NodeExecutionGetDataRequest.create = function create(properties) {
                return new NodeExecutionGetDataRequest(properties);
            };

            /**
             * Encodes the specified NodeExecutionGetDataRequest message. Does not implicitly {@link flyteidl.admin.NodeExecutionGetDataRequest.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.NodeExecutionGetDataRequest
             * @static
             * @param {flyteidl.admin.INodeExecutionGetDataRequest} message NodeExecutionGetDataRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NodeExecutionGetDataRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    $root.flyteidl.core.NodeExecutionIdentifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a NodeExecutionGetDataRequest message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.NodeExecutionGetDataRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.NodeExecutionGetDataRequest} NodeExecutionGetDataRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NodeExecutionGetDataRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.NodeExecutionGetDataRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = $root.flyteidl.core.NodeExecutionIdentifier.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a NodeExecutionGetDataRequest message.
             * @function verify
             * @memberof flyteidl.admin.NodeExecutionGetDataRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NodeExecutionGetDataRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id")) {
                    let error = $root.flyteidl.core.NodeExecutionIdentifier.verify(message.id);
                    if (error)
                        return "id." + error;
                }
                return null;
            };

            return NodeExecutionGetDataRequest;
        })();

        admin.NodeExecutionGetDataResponse = (function() {

            /**
             * Properties of a NodeExecutionGetDataResponse.
             * @memberof flyteidl.admin
             * @interface INodeExecutionGetDataResponse
             * @property {flyteidl.admin.IUrlBlob|null} [inputs] NodeExecutionGetDataResponse inputs
             * @property {flyteidl.admin.IUrlBlob|null} [outputs] NodeExecutionGetDataResponse outputs
             */

            /**
             * Constructs a new NodeExecutionGetDataResponse.
             * @memberof flyteidl.admin
             * @classdesc Represents a NodeExecutionGetDataResponse.
             * @implements INodeExecutionGetDataResponse
             * @constructor
             * @param {flyteidl.admin.INodeExecutionGetDataResponse=} [properties] Properties to set
             */
            function NodeExecutionGetDataResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NodeExecutionGetDataResponse inputs.
             * @member {flyteidl.admin.IUrlBlob|null|undefined} inputs
             * @memberof flyteidl.admin.NodeExecutionGetDataResponse
             * @instance
             */
            NodeExecutionGetDataResponse.prototype.inputs = null;

            /**
             * NodeExecutionGetDataResponse outputs.
             * @member {flyteidl.admin.IUrlBlob|null|undefined} outputs
             * @memberof flyteidl.admin.NodeExecutionGetDataResponse
             * @instance
             */
            NodeExecutionGetDataResponse.prototype.outputs = null;

            /**
             * Creates a new NodeExecutionGetDataResponse instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.NodeExecutionGetDataResponse
             * @static
             * @param {flyteidl.admin.INodeExecutionGetDataResponse=} [properties] Properties to set
             * @returns {flyteidl.admin.NodeExecutionGetDataResponse} NodeExecutionGetDataResponse instance
             */
            NodeExecutionGetDataResponse.create = function create(properties) {
                return new NodeExecutionGetDataResponse(properties);
            };

            /**
             * Encodes the specified NodeExecutionGetDataResponse message. Does not implicitly {@link flyteidl.admin.NodeExecutionGetDataResponse.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.NodeExecutionGetDataResponse
             * @static
             * @param {flyteidl.admin.INodeExecutionGetDataResponse} message NodeExecutionGetDataResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NodeExecutionGetDataResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.inputs != null && message.hasOwnProperty("inputs"))
                    $root.flyteidl.admin.UrlBlob.encode(message.inputs, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.outputs != null && message.hasOwnProperty("outputs"))
                    $root.flyteidl.admin.UrlBlob.encode(message.outputs, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a NodeExecutionGetDataResponse message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.NodeExecutionGetDataResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.NodeExecutionGetDataResponse} NodeExecutionGetDataResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NodeExecutionGetDataResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.NodeExecutionGetDataResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.inputs = $root.flyteidl.admin.UrlBlob.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.outputs = $root.flyteidl.admin.UrlBlob.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a NodeExecutionGetDataResponse message.
             * @function verify
             * @memberof flyteidl.admin.NodeExecutionGetDataResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NodeExecutionGetDataResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.inputs != null && message.hasOwnProperty("inputs")) {
                    let error = $root.flyteidl.admin.UrlBlob.verify(message.inputs);
                    if (error)
                        return "inputs." + error;
                }
                if (message.outputs != null && message.hasOwnProperty("outputs")) {
                    let error = $root.flyteidl.admin.UrlBlob.verify(message.outputs);
                    if (error)
                        return "outputs." + error;
                }
                return null;
            };

            return NodeExecutionGetDataResponse;
        })();

        admin.EmailMessage = (function() {

            /**
             * Properties of an EmailMessage.
             * @memberof flyteidl.admin
             * @interface IEmailMessage
             * @property {Array.<string>|null} [recipientsEmail] EmailMessage recipientsEmail
             * @property {string|null} [senderEmail] EmailMessage senderEmail
             * @property {string|null} [subjectLine] EmailMessage subjectLine
             * @property {string|null} [body] EmailMessage body
             */

            /**
             * Constructs a new EmailMessage.
             * @memberof flyteidl.admin
             * @classdesc Represents an EmailMessage.
             * @implements IEmailMessage
             * @constructor
             * @param {flyteidl.admin.IEmailMessage=} [properties] Properties to set
             */
            function EmailMessage(properties) {
                this.recipientsEmail = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EmailMessage recipientsEmail.
             * @member {Array.<string>} recipientsEmail
             * @memberof flyteidl.admin.EmailMessage
             * @instance
             */
            EmailMessage.prototype.recipientsEmail = $util.emptyArray;

            /**
             * EmailMessage senderEmail.
             * @member {string} senderEmail
             * @memberof flyteidl.admin.EmailMessage
             * @instance
             */
            EmailMessage.prototype.senderEmail = "";

            /**
             * EmailMessage subjectLine.
             * @member {string} subjectLine
             * @memberof flyteidl.admin.EmailMessage
             * @instance
             */
            EmailMessage.prototype.subjectLine = "";

            /**
             * EmailMessage body.
             * @member {string} body
             * @memberof flyteidl.admin.EmailMessage
             * @instance
             */
            EmailMessage.prototype.body = "";

            /**
             * Creates a new EmailMessage instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.EmailMessage
             * @static
             * @param {flyteidl.admin.IEmailMessage=} [properties] Properties to set
             * @returns {flyteidl.admin.EmailMessage} EmailMessage instance
             */
            EmailMessage.create = function create(properties) {
                return new EmailMessage(properties);
            };

            /**
             * Encodes the specified EmailMessage message. Does not implicitly {@link flyteidl.admin.EmailMessage.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.EmailMessage
             * @static
             * @param {flyteidl.admin.IEmailMessage} message EmailMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EmailMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.recipientsEmail != null && message.recipientsEmail.length)
                    for (let i = 0; i < message.recipientsEmail.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.recipientsEmail[i]);
                if (message.senderEmail != null && message.hasOwnProperty("senderEmail"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.senderEmail);
                if (message.subjectLine != null && message.hasOwnProperty("subjectLine"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.subjectLine);
                if (message.body != null && message.hasOwnProperty("body"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.body);
                return writer;
            };

            /**
             * Decodes an EmailMessage message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.EmailMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.EmailMessage} EmailMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EmailMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.EmailMessage();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.recipientsEmail && message.recipientsEmail.length))
                            message.recipientsEmail = [];
                        message.recipientsEmail.push(reader.string());
                        break;
                    case 2:
                        message.senderEmail = reader.string();
                        break;
                    case 3:
                        message.subjectLine = reader.string();
                        break;
                    case 4:
                        message.body = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies an EmailMessage message.
             * @function verify
             * @memberof flyteidl.admin.EmailMessage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EmailMessage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.recipientsEmail != null && message.hasOwnProperty("recipientsEmail")) {
                    if (!Array.isArray(message.recipientsEmail))
                        return "recipientsEmail: array expected";
                    for (let i = 0; i < message.recipientsEmail.length; ++i)
                        if (!$util.isString(message.recipientsEmail[i]))
                            return "recipientsEmail: string[] expected";
                }
                if (message.senderEmail != null && message.hasOwnProperty("senderEmail"))
                    if (!$util.isString(message.senderEmail))
                        return "senderEmail: string expected";
                if (message.subjectLine != null && message.hasOwnProperty("subjectLine"))
                    if (!$util.isString(message.subjectLine))
                        return "subjectLine: string expected";
                if (message.body != null && message.hasOwnProperty("body"))
                    if (!$util.isString(message.body))
                        return "body: string expected";
                return null;
            };

            return EmailMessage;
        })();

        admin.Domain = (function() {

            /**
             * Properties of a Domain.
             * @memberof flyteidl.admin
             * @interface IDomain
             * @property {string|null} [id] Domain id
             * @property {string|null} [name] Domain name
             */

            /**
             * Constructs a new Domain.
             * @memberof flyteidl.admin
             * @classdesc Represents a Domain.
             * @implements IDomain
             * @constructor
             * @param {flyteidl.admin.IDomain=} [properties] Properties to set
             */
            function Domain(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Domain id.
             * @member {string} id
             * @memberof flyteidl.admin.Domain
             * @instance
             */
            Domain.prototype.id = "";

            /**
             * Domain name.
             * @member {string} name
             * @memberof flyteidl.admin.Domain
             * @instance
             */
            Domain.prototype.name = "";

            /**
             * Creates a new Domain instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.Domain
             * @static
             * @param {flyteidl.admin.IDomain=} [properties] Properties to set
             * @returns {flyteidl.admin.Domain} Domain instance
             */
            Domain.create = function create(properties) {
                return new Domain(properties);
            };

            /**
             * Encodes the specified Domain message. Does not implicitly {@link flyteidl.admin.Domain.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.Domain
             * @static
             * @param {flyteidl.admin.IDomain} message Domain message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Domain.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                return writer;
            };

            /**
             * Decodes a Domain message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.Domain
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.Domain} Domain
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Domain.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.Domain();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        message.name = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a Domain message.
             * @function verify
             * @memberof flyteidl.admin.Domain
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Domain.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                return null;
            };

            return Domain;
        })();

        admin.Project = (function() {

            /**
             * Properties of a Project.
             * @memberof flyteidl.admin
             * @interface IProject
             * @property {string|null} [id] Project id
             * @property {string|null} [name] Project name
             * @property {Array.<flyteidl.admin.IDomain>|null} [domains] Project domains
             * @property {string|null} [description] Project description
             */

            /**
             * Constructs a new Project.
             * @memberof flyteidl.admin
             * @classdesc Represents a Project.
             * @implements IProject
             * @constructor
             * @param {flyteidl.admin.IProject=} [properties] Properties to set
             */
            function Project(properties) {
                this.domains = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Project id.
             * @member {string} id
             * @memberof flyteidl.admin.Project
             * @instance
             */
            Project.prototype.id = "";

            /**
             * Project name.
             * @member {string} name
             * @memberof flyteidl.admin.Project
             * @instance
             */
            Project.prototype.name = "";

            /**
             * Project domains.
             * @member {Array.<flyteidl.admin.IDomain>} domains
             * @memberof flyteidl.admin.Project
             * @instance
             */
            Project.prototype.domains = $util.emptyArray;

            /**
             * Project description.
             * @member {string} description
             * @memberof flyteidl.admin.Project
             * @instance
             */
            Project.prototype.description = "";

            /**
             * Creates a new Project instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.Project
             * @static
             * @param {flyteidl.admin.IProject=} [properties] Properties to set
             * @returns {flyteidl.admin.Project} Project instance
             */
            Project.create = function create(properties) {
                return new Project(properties);
            };

            /**
             * Encodes the specified Project message. Does not implicitly {@link flyteidl.admin.Project.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.Project
             * @static
             * @param {flyteidl.admin.IProject} message Project message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Project.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                if (message.domains != null && message.domains.length)
                    for (let i = 0; i < message.domains.length; ++i)
                        $root.flyteidl.admin.Domain.encode(message.domains[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.description != null && message.hasOwnProperty("description"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.description);
                return writer;
            };

            /**
             * Decodes a Project message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.Project
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.Project} Project
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Project.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.Project();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        message.name = reader.string();
                        break;
                    case 3:
                        if (!(message.domains && message.domains.length))
                            message.domains = [];
                        message.domains.push($root.flyteidl.admin.Domain.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        message.description = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a Project message.
             * @function verify
             * @memberof flyteidl.admin.Project
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Project.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.domains != null && message.hasOwnProperty("domains")) {
                    if (!Array.isArray(message.domains))
                        return "domains: array expected";
                    for (let i = 0; i < message.domains.length; ++i) {
                        let error = $root.flyteidl.admin.Domain.verify(message.domains[i]);
                        if (error)
                            return "domains." + error;
                    }
                }
                if (message.description != null && message.hasOwnProperty("description"))
                    if (!$util.isString(message.description))
                        return "description: string expected";
                return null;
            };

            return Project;
        })();

        admin.Projects = (function() {

            /**
             * Properties of a Projects.
             * @memberof flyteidl.admin
             * @interface IProjects
             * @property {Array.<flyteidl.admin.IProject>|null} [projects] Projects projects
             */

            /**
             * Constructs a new Projects.
             * @memberof flyteidl.admin
             * @classdesc Represents a Projects.
             * @implements IProjects
             * @constructor
             * @param {flyteidl.admin.IProjects=} [properties] Properties to set
             */
            function Projects(properties) {
                this.projects = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Projects projects.
             * @member {Array.<flyteidl.admin.IProject>} projects
             * @memberof flyteidl.admin.Projects
             * @instance
             */
            Projects.prototype.projects = $util.emptyArray;

            /**
             * Creates a new Projects instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.Projects
             * @static
             * @param {flyteidl.admin.IProjects=} [properties] Properties to set
             * @returns {flyteidl.admin.Projects} Projects instance
             */
            Projects.create = function create(properties) {
                return new Projects(properties);
            };

            /**
             * Encodes the specified Projects message. Does not implicitly {@link flyteidl.admin.Projects.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.Projects
             * @static
             * @param {flyteidl.admin.IProjects} message Projects message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Projects.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.projects != null && message.projects.length)
                    for (let i = 0; i < message.projects.length; ++i)
                        $root.flyteidl.admin.Project.encode(message.projects[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a Projects message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.Projects
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.Projects} Projects
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Projects.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.Projects();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.projects && message.projects.length))
                            message.projects = [];
                        message.projects.push($root.flyteidl.admin.Project.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a Projects message.
             * @function verify
             * @memberof flyteidl.admin.Projects
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Projects.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.projects != null && message.hasOwnProperty("projects")) {
                    if (!Array.isArray(message.projects))
                        return "projects: array expected";
                    for (let i = 0; i < message.projects.length; ++i) {
                        let error = $root.flyteidl.admin.Project.verify(message.projects[i]);
                        if (error)
                            return "projects." + error;
                    }
                }
                return null;
            };

            return Projects;
        })();

        admin.ProjectListRequest = (function() {

            /**
             * Properties of a ProjectListRequest.
             * @memberof flyteidl.admin
             * @interface IProjectListRequest
             */

            /**
             * Constructs a new ProjectListRequest.
             * @memberof flyteidl.admin
             * @classdesc Represents a ProjectListRequest.
             * @implements IProjectListRequest
             * @constructor
             * @param {flyteidl.admin.IProjectListRequest=} [properties] Properties to set
             */
            function ProjectListRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new ProjectListRequest instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.ProjectListRequest
             * @static
             * @param {flyteidl.admin.IProjectListRequest=} [properties] Properties to set
             * @returns {flyteidl.admin.ProjectListRequest} ProjectListRequest instance
             */
            ProjectListRequest.create = function create(properties) {
                return new ProjectListRequest(properties);
            };

            /**
             * Encodes the specified ProjectListRequest message. Does not implicitly {@link flyteidl.admin.ProjectListRequest.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.ProjectListRequest
             * @static
             * @param {flyteidl.admin.IProjectListRequest} message ProjectListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProjectListRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Decodes a ProjectListRequest message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.ProjectListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.ProjectListRequest} ProjectListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProjectListRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.ProjectListRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a ProjectListRequest message.
             * @function verify
             * @memberof flyteidl.admin.ProjectListRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ProjectListRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            return ProjectListRequest;
        })();

        admin.ProjectRegisterRequest = (function() {

            /**
             * Properties of a ProjectRegisterRequest.
             * @memberof flyteidl.admin
             * @interface IProjectRegisterRequest
             * @property {flyteidl.admin.IProject|null} [project] ProjectRegisterRequest project
             */

            /**
             * Constructs a new ProjectRegisterRequest.
             * @memberof flyteidl.admin
             * @classdesc Represents a ProjectRegisterRequest.
             * @implements IProjectRegisterRequest
             * @constructor
             * @param {flyteidl.admin.IProjectRegisterRequest=} [properties] Properties to set
             */
            function ProjectRegisterRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ProjectRegisterRequest project.
             * @member {flyteidl.admin.IProject|null|undefined} project
             * @memberof flyteidl.admin.ProjectRegisterRequest
             * @instance
             */
            ProjectRegisterRequest.prototype.project = null;

            /**
             * Creates a new ProjectRegisterRequest instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.ProjectRegisterRequest
             * @static
             * @param {flyteidl.admin.IProjectRegisterRequest=} [properties] Properties to set
             * @returns {flyteidl.admin.ProjectRegisterRequest} ProjectRegisterRequest instance
             */
            ProjectRegisterRequest.create = function create(properties) {
                return new ProjectRegisterRequest(properties);
            };

            /**
             * Encodes the specified ProjectRegisterRequest message. Does not implicitly {@link flyteidl.admin.ProjectRegisterRequest.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.ProjectRegisterRequest
             * @static
             * @param {flyteidl.admin.IProjectRegisterRequest} message ProjectRegisterRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProjectRegisterRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.project != null && message.hasOwnProperty("project"))
                    $root.flyteidl.admin.Project.encode(message.project, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a ProjectRegisterRequest message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.ProjectRegisterRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.ProjectRegisterRequest} ProjectRegisterRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProjectRegisterRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.ProjectRegisterRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.project = $root.flyteidl.admin.Project.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a ProjectRegisterRequest message.
             * @function verify
             * @memberof flyteidl.admin.ProjectRegisterRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ProjectRegisterRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.project != null && message.hasOwnProperty("project")) {
                    let error = $root.flyteidl.admin.Project.verify(message.project);
                    if (error)
                        return "project." + error;
                }
                return null;
            };

            return ProjectRegisterRequest;
        })();

        admin.ProjectRegisterResponse = (function() {

            /**
             * Properties of a ProjectRegisterResponse.
             * @memberof flyteidl.admin
             * @interface IProjectRegisterResponse
             */

            /**
             * Constructs a new ProjectRegisterResponse.
             * @memberof flyteidl.admin
             * @classdesc Represents a ProjectRegisterResponse.
             * @implements IProjectRegisterResponse
             * @constructor
             * @param {flyteidl.admin.IProjectRegisterResponse=} [properties] Properties to set
             */
            function ProjectRegisterResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new ProjectRegisterResponse instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.ProjectRegisterResponse
             * @static
             * @param {flyteidl.admin.IProjectRegisterResponse=} [properties] Properties to set
             * @returns {flyteidl.admin.ProjectRegisterResponse} ProjectRegisterResponse instance
             */
            ProjectRegisterResponse.create = function create(properties) {
                return new ProjectRegisterResponse(properties);
            };

            /**
             * Encodes the specified ProjectRegisterResponse message. Does not implicitly {@link flyteidl.admin.ProjectRegisterResponse.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.ProjectRegisterResponse
             * @static
             * @param {flyteidl.admin.IProjectRegisterResponse} message ProjectRegisterResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProjectRegisterResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Decodes a ProjectRegisterResponse message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.ProjectRegisterResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.ProjectRegisterResponse} ProjectRegisterResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProjectRegisterResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.ProjectRegisterResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a ProjectRegisterResponse message.
             * @function verify
             * @memberof flyteidl.admin.ProjectRegisterResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ProjectRegisterResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            return ProjectRegisterResponse;
        })();

        admin.ProjectDomainAttributes = (function() {

            /**
             * Properties of a ProjectDomainAttributes.
             * @memberof flyteidl.admin
             * @interface IProjectDomainAttributes
             * @property {string|null} [project] ProjectDomainAttributes project
             * @property {string|null} [domain] ProjectDomainAttributes domain
             * @property {flyteidl.admin.IMatchingAttributes|null} [matchingAttributes] ProjectDomainAttributes matchingAttributes
             */

            /**
             * Constructs a new ProjectDomainAttributes.
             * @memberof flyteidl.admin
             * @classdesc Represents a ProjectDomainAttributes.
             * @implements IProjectDomainAttributes
             * @constructor
             * @param {flyteidl.admin.IProjectDomainAttributes=} [properties] Properties to set
             */
            function ProjectDomainAttributes(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ProjectDomainAttributes project.
             * @member {string} project
             * @memberof flyteidl.admin.ProjectDomainAttributes
             * @instance
             */
            ProjectDomainAttributes.prototype.project = "";

            /**
             * ProjectDomainAttributes domain.
             * @member {string} domain
             * @memberof flyteidl.admin.ProjectDomainAttributes
             * @instance
             */
            ProjectDomainAttributes.prototype.domain = "";

            /**
             * ProjectDomainAttributes matchingAttributes.
             * @member {flyteidl.admin.IMatchingAttributes|null|undefined} matchingAttributes
             * @memberof flyteidl.admin.ProjectDomainAttributes
             * @instance
             */
            ProjectDomainAttributes.prototype.matchingAttributes = null;

            /**
             * Creates a new ProjectDomainAttributes instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.ProjectDomainAttributes
             * @static
             * @param {flyteidl.admin.IProjectDomainAttributes=} [properties] Properties to set
             * @returns {flyteidl.admin.ProjectDomainAttributes} ProjectDomainAttributes instance
             */
            ProjectDomainAttributes.create = function create(properties) {
                return new ProjectDomainAttributes(properties);
            };

            /**
             * Encodes the specified ProjectDomainAttributes message. Does not implicitly {@link flyteidl.admin.ProjectDomainAttributes.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.ProjectDomainAttributes
             * @static
             * @param {flyteidl.admin.IProjectDomainAttributes} message ProjectDomainAttributes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProjectDomainAttributes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.project != null && message.hasOwnProperty("project"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.project);
                if (message.domain != null && message.hasOwnProperty("domain"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.domain);
                if (message.matchingAttributes != null && message.hasOwnProperty("matchingAttributes"))
                    $root.flyteidl.admin.MatchingAttributes.encode(message.matchingAttributes, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a ProjectDomainAttributes message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.ProjectDomainAttributes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.ProjectDomainAttributes} ProjectDomainAttributes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProjectDomainAttributes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.ProjectDomainAttributes();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.project = reader.string();
                        break;
                    case 2:
                        message.domain = reader.string();
                        break;
                    case 3:
                        message.matchingAttributes = $root.flyteidl.admin.MatchingAttributes.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a ProjectDomainAttributes message.
             * @function verify
             * @memberof flyteidl.admin.ProjectDomainAttributes
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ProjectDomainAttributes.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.project != null && message.hasOwnProperty("project"))
                    if (!$util.isString(message.project))
                        return "project: string expected";
                if (message.domain != null && message.hasOwnProperty("domain"))
                    if (!$util.isString(message.domain))
                        return "domain: string expected";
                if (message.matchingAttributes != null && message.hasOwnProperty("matchingAttributes")) {
                    let error = $root.flyteidl.admin.MatchingAttributes.verify(message.matchingAttributes);
                    if (error)
                        return "matchingAttributes." + error;
                }
                return null;
            };

            return ProjectDomainAttributes;
        })();

        admin.ProjectDomainAttributesUpdateRequest = (function() {

            /**
             * Properties of a ProjectDomainAttributesUpdateRequest.
             * @memberof flyteidl.admin
             * @interface IProjectDomainAttributesUpdateRequest
             * @property {flyteidl.admin.IProjectDomainAttributes|null} [attributes] ProjectDomainAttributesUpdateRequest attributes
             */

            /**
             * Constructs a new ProjectDomainAttributesUpdateRequest.
             * @memberof flyteidl.admin
             * @classdesc Represents a ProjectDomainAttributesUpdateRequest.
             * @implements IProjectDomainAttributesUpdateRequest
             * @constructor
             * @param {flyteidl.admin.IProjectDomainAttributesUpdateRequest=} [properties] Properties to set
             */
            function ProjectDomainAttributesUpdateRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ProjectDomainAttributesUpdateRequest attributes.
             * @member {flyteidl.admin.IProjectDomainAttributes|null|undefined} attributes
             * @memberof flyteidl.admin.ProjectDomainAttributesUpdateRequest
             * @instance
             */
            ProjectDomainAttributesUpdateRequest.prototype.attributes = null;

            /**
             * Creates a new ProjectDomainAttributesUpdateRequest instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.ProjectDomainAttributesUpdateRequest
             * @static
             * @param {flyteidl.admin.IProjectDomainAttributesUpdateRequest=} [properties] Properties to set
             * @returns {flyteidl.admin.ProjectDomainAttributesUpdateRequest} ProjectDomainAttributesUpdateRequest instance
             */
            ProjectDomainAttributesUpdateRequest.create = function create(properties) {
                return new ProjectDomainAttributesUpdateRequest(properties);
            };

            /**
             * Encodes the specified ProjectDomainAttributesUpdateRequest message. Does not implicitly {@link flyteidl.admin.ProjectDomainAttributesUpdateRequest.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.ProjectDomainAttributesUpdateRequest
             * @static
             * @param {flyteidl.admin.IProjectDomainAttributesUpdateRequest} message ProjectDomainAttributesUpdateRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProjectDomainAttributesUpdateRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.attributes != null && message.hasOwnProperty("attributes"))
                    $root.flyteidl.admin.ProjectDomainAttributes.encode(message.attributes, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a ProjectDomainAttributesUpdateRequest message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.ProjectDomainAttributesUpdateRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.ProjectDomainAttributesUpdateRequest} ProjectDomainAttributesUpdateRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProjectDomainAttributesUpdateRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.ProjectDomainAttributesUpdateRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.attributes = $root.flyteidl.admin.ProjectDomainAttributes.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a ProjectDomainAttributesUpdateRequest message.
             * @function verify
             * @memberof flyteidl.admin.ProjectDomainAttributesUpdateRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ProjectDomainAttributesUpdateRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.attributes != null && message.hasOwnProperty("attributes")) {
                    let error = $root.flyteidl.admin.ProjectDomainAttributes.verify(message.attributes);
                    if (error)
                        return "attributes." + error;
                }
                return null;
            };

            return ProjectDomainAttributesUpdateRequest;
        })();

        admin.ProjectDomainAttributesUpdateResponse = (function() {

            /**
             * Properties of a ProjectDomainAttributesUpdateResponse.
             * @memberof flyteidl.admin
             * @interface IProjectDomainAttributesUpdateResponse
             */

            /**
             * Constructs a new ProjectDomainAttributesUpdateResponse.
             * @memberof flyteidl.admin
             * @classdesc Represents a ProjectDomainAttributesUpdateResponse.
             * @implements IProjectDomainAttributesUpdateResponse
             * @constructor
             * @param {flyteidl.admin.IProjectDomainAttributesUpdateResponse=} [properties] Properties to set
             */
            function ProjectDomainAttributesUpdateResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new ProjectDomainAttributesUpdateResponse instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.ProjectDomainAttributesUpdateResponse
             * @static
             * @param {flyteidl.admin.IProjectDomainAttributesUpdateResponse=} [properties] Properties to set
             * @returns {flyteidl.admin.ProjectDomainAttributesUpdateResponse} ProjectDomainAttributesUpdateResponse instance
             */
            ProjectDomainAttributesUpdateResponse.create = function create(properties) {
                return new ProjectDomainAttributesUpdateResponse(properties);
            };

            /**
             * Encodes the specified ProjectDomainAttributesUpdateResponse message. Does not implicitly {@link flyteidl.admin.ProjectDomainAttributesUpdateResponse.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.ProjectDomainAttributesUpdateResponse
             * @static
             * @param {flyteidl.admin.IProjectDomainAttributesUpdateResponse} message ProjectDomainAttributesUpdateResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProjectDomainAttributesUpdateResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Decodes a ProjectDomainAttributesUpdateResponse message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.ProjectDomainAttributesUpdateResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.ProjectDomainAttributesUpdateResponse} ProjectDomainAttributesUpdateResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProjectDomainAttributesUpdateResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.ProjectDomainAttributesUpdateResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a ProjectDomainAttributesUpdateResponse message.
             * @function verify
             * @memberof flyteidl.admin.ProjectDomainAttributesUpdateResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ProjectDomainAttributesUpdateResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            return ProjectDomainAttributesUpdateResponse;
        })();

        admin.ProjectDomainAttributesGetRequest = (function() {

            /**
             * Properties of a ProjectDomainAttributesGetRequest.
             * @memberof flyteidl.admin
             * @interface IProjectDomainAttributesGetRequest
             * @property {string|null} [project] ProjectDomainAttributesGetRequest project
             * @property {string|null} [domain] ProjectDomainAttributesGetRequest domain
             * @property {flyteidl.admin.MatchableResource|null} [resourceType] ProjectDomainAttributesGetRequest resourceType
             */

            /**
             * Constructs a new ProjectDomainAttributesGetRequest.
             * @memberof flyteidl.admin
             * @classdesc Represents a ProjectDomainAttributesGetRequest.
             * @implements IProjectDomainAttributesGetRequest
             * @constructor
             * @param {flyteidl.admin.IProjectDomainAttributesGetRequest=} [properties] Properties to set
             */
            function ProjectDomainAttributesGetRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ProjectDomainAttributesGetRequest project.
             * @member {string} project
             * @memberof flyteidl.admin.ProjectDomainAttributesGetRequest
             * @instance
             */
            ProjectDomainAttributesGetRequest.prototype.project = "";

            /**
             * ProjectDomainAttributesGetRequest domain.
             * @member {string} domain
             * @memberof flyteidl.admin.ProjectDomainAttributesGetRequest
             * @instance
             */
            ProjectDomainAttributesGetRequest.prototype.domain = "";

            /**
             * ProjectDomainAttributesGetRequest resourceType.
             * @member {flyteidl.admin.MatchableResource} resourceType
             * @memberof flyteidl.admin.ProjectDomainAttributesGetRequest
             * @instance
             */
            ProjectDomainAttributesGetRequest.prototype.resourceType = 0;

            /**
             * Creates a new ProjectDomainAttributesGetRequest instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.ProjectDomainAttributesGetRequest
             * @static
             * @param {flyteidl.admin.IProjectDomainAttributesGetRequest=} [properties] Properties to set
             * @returns {flyteidl.admin.ProjectDomainAttributesGetRequest} ProjectDomainAttributesGetRequest instance
             */
            ProjectDomainAttributesGetRequest.create = function create(properties) {
                return new ProjectDomainAttributesGetRequest(properties);
            };

            /**
             * Encodes the specified ProjectDomainAttributesGetRequest message. Does not implicitly {@link flyteidl.admin.ProjectDomainAttributesGetRequest.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.ProjectDomainAttributesGetRequest
             * @static
             * @param {flyteidl.admin.IProjectDomainAttributesGetRequest} message ProjectDomainAttributesGetRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProjectDomainAttributesGetRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.project != null && message.hasOwnProperty("project"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.project);
                if (message.domain != null && message.hasOwnProperty("domain"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.domain);
                if (message.resourceType != null && message.hasOwnProperty("resourceType"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.resourceType);
                return writer;
            };

            /**
             * Decodes a ProjectDomainAttributesGetRequest message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.ProjectDomainAttributesGetRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.ProjectDomainAttributesGetRequest} ProjectDomainAttributesGetRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProjectDomainAttributesGetRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.ProjectDomainAttributesGetRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.project = reader.string();
                        break;
                    case 2:
                        message.domain = reader.string();
                        break;
                    case 3:
                        message.resourceType = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a ProjectDomainAttributesGetRequest message.
             * @function verify
             * @memberof flyteidl.admin.ProjectDomainAttributesGetRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ProjectDomainAttributesGetRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.project != null && message.hasOwnProperty("project"))
                    if (!$util.isString(message.project))
                        return "project: string expected";
                if (message.domain != null && message.hasOwnProperty("domain"))
                    if (!$util.isString(message.domain))
                        return "domain: string expected";
                if (message.resourceType != null && message.hasOwnProperty("resourceType"))
                    switch (message.resourceType) {
                    default:
                        return "resourceType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                return null;
            };

            return ProjectDomainAttributesGetRequest;
        })();

        admin.ProjectDomainAttributesGetResponse = (function() {

            /**
             * Properties of a ProjectDomainAttributesGetResponse.
             * @memberof flyteidl.admin
             * @interface IProjectDomainAttributesGetResponse
             * @property {flyteidl.admin.IProjectDomainAttributes|null} [attributes] ProjectDomainAttributesGetResponse attributes
             */

            /**
             * Constructs a new ProjectDomainAttributesGetResponse.
             * @memberof flyteidl.admin
             * @classdesc Represents a ProjectDomainAttributesGetResponse.
             * @implements IProjectDomainAttributesGetResponse
             * @constructor
             * @param {flyteidl.admin.IProjectDomainAttributesGetResponse=} [properties] Properties to set
             */
            function ProjectDomainAttributesGetResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ProjectDomainAttributesGetResponse attributes.
             * @member {flyteidl.admin.IProjectDomainAttributes|null|undefined} attributes
             * @memberof flyteidl.admin.ProjectDomainAttributesGetResponse
             * @instance
             */
            ProjectDomainAttributesGetResponse.prototype.attributes = null;

            /**
             * Creates a new ProjectDomainAttributesGetResponse instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.ProjectDomainAttributesGetResponse
             * @static
             * @param {flyteidl.admin.IProjectDomainAttributesGetResponse=} [properties] Properties to set
             * @returns {flyteidl.admin.ProjectDomainAttributesGetResponse} ProjectDomainAttributesGetResponse instance
             */
            ProjectDomainAttributesGetResponse.create = function create(properties) {
                return new ProjectDomainAttributesGetResponse(properties);
            };

            /**
             * Encodes the specified ProjectDomainAttributesGetResponse message. Does not implicitly {@link flyteidl.admin.ProjectDomainAttributesGetResponse.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.ProjectDomainAttributesGetResponse
             * @static
             * @param {flyteidl.admin.IProjectDomainAttributesGetResponse} message ProjectDomainAttributesGetResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProjectDomainAttributesGetResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.attributes != null && message.hasOwnProperty("attributes"))
                    $root.flyteidl.admin.ProjectDomainAttributes.encode(message.attributes, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a ProjectDomainAttributesGetResponse message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.ProjectDomainAttributesGetResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.ProjectDomainAttributesGetResponse} ProjectDomainAttributesGetResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProjectDomainAttributesGetResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.ProjectDomainAttributesGetResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.attributes = $root.flyteidl.admin.ProjectDomainAttributes.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a ProjectDomainAttributesGetResponse message.
             * @function verify
             * @memberof flyteidl.admin.ProjectDomainAttributesGetResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ProjectDomainAttributesGetResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.attributes != null && message.hasOwnProperty("attributes")) {
                    let error = $root.flyteidl.admin.ProjectDomainAttributes.verify(message.attributes);
                    if (error)
                        return "attributes." + error;
                }
                return null;
            };

            return ProjectDomainAttributesGetResponse;
        })();

        admin.ProjectDomainAttributesDeleteRequest = (function() {

            /**
             * Properties of a ProjectDomainAttributesDeleteRequest.
             * @memberof flyteidl.admin
             * @interface IProjectDomainAttributesDeleteRequest
             * @property {string|null} [project] ProjectDomainAttributesDeleteRequest project
             * @property {string|null} [domain] ProjectDomainAttributesDeleteRequest domain
             * @property {flyteidl.admin.MatchableResource|null} [resourceType] ProjectDomainAttributesDeleteRequest resourceType
             */

            /**
             * Constructs a new ProjectDomainAttributesDeleteRequest.
             * @memberof flyteidl.admin
             * @classdesc Represents a ProjectDomainAttributesDeleteRequest.
             * @implements IProjectDomainAttributesDeleteRequest
             * @constructor
             * @param {flyteidl.admin.IProjectDomainAttributesDeleteRequest=} [properties] Properties to set
             */
            function ProjectDomainAttributesDeleteRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ProjectDomainAttributesDeleteRequest project.
             * @member {string} project
             * @memberof flyteidl.admin.ProjectDomainAttributesDeleteRequest
             * @instance
             */
            ProjectDomainAttributesDeleteRequest.prototype.project = "";

            /**
             * ProjectDomainAttributesDeleteRequest domain.
             * @member {string} domain
             * @memberof flyteidl.admin.ProjectDomainAttributesDeleteRequest
             * @instance
             */
            ProjectDomainAttributesDeleteRequest.prototype.domain = "";

            /**
             * ProjectDomainAttributesDeleteRequest resourceType.
             * @member {flyteidl.admin.MatchableResource} resourceType
             * @memberof flyteidl.admin.ProjectDomainAttributesDeleteRequest
             * @instance
             */
            ProjectDomainAttributesDeleteRequest.prototype.resourceType = 0;

            /**
             * Creates a new ProjectDomainAttributesDeleteRequest instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.ProjectDomainAttributesDeleteRequest
             * @static
             * @param {flyteidl.admin.IProjectDomainAttributesDeleteRequest=} [properties] Properties to set
             * @returns {flyteidl.admin.ProjectDomainAttributesDeleteRequest} ProjectDomainAttributesDeleteRequest instance
             */
            ProjectDomainAttributesDeleteRequest.create = function create(properties) {
                return new ProjectDomainAttributesDeleteRequest(properties);
            };

            /**
             * Encodes the specified ProjectDomainAttributesDeleteRequest message. Does not implicitly {@link flyteidl.admin.ProjectDomainAttributesDeleteRequest.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.ProjectDomainAttributesDeleteRequest
             * @static
             * @param {flyteidl.admin.IProjectDomainAttributesDeleteRequest} message ProjectDomainAttributesDeleteRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProjectDomainAttributesDeleteRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.project != null && message.hasOwnProperty("project"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.project);
                if (message.domain != null && message.hasOwnProperty("domain"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.domain);
                if (message.resourceType != null && message.hasOwnProperty("resourceType"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.resourceType);
                return writer;
            };

            /**
             * Decodes a ProjectDomainAttributesDeleteRequest message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.ProjectDomainAttributesDeleteRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.ProjectDomainAttributesDeleteRequest} ProjectDomainAttributesDeleteRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProjectDomainAttributesDeleteRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.ProjectDomainAttributesDeleteRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.project = reader.string();
                        break;
                    case 2:
                        message.domain = reader.string();
                        break;
                    case 3:
                        message.resourceType = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a ProjectDomainAttributesDeleteRequest message.
             * @function verify
             * @memberof flyteidl.admin.ProjectDomainAttributesDeleteRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ProjectDomainAttributesDeleteRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.project != null && message.hasOwnProperty("project"))
                    if (!$util.isString(message.project))
                        return "project: string expected";
                if (message.domain != null && message.hasOwnProperty("domain"))
                    if (!$util.isString(message.domain))
                        return "domain: string expected";
                if (message.resourceType != null && message.hasOwnProperty("resourceType"))
                    switch (message.resourceType) {
                    default:
                        return "resourceType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                return null;
            };

            return ProjectDomainAttributesDeleteRequest;
        })();

        admin.ProjectDomainAttributesDeleteResponse = (function() {

            /**
             * Properties of a ProjectDomainAttributesDeleteResponse.
             * @memberof flyteidl.admin
             * @interface IProjectDomainAttributesDeleteResponse
             */

            /**
             * Constructs a new ProjectDomainAttributesDeleteResponse.
             * @memberof flyteidl.admin
             * @classdesc Represents a ProjectDomainAttributesDeleteResponse.
             * @implements IProjectDomainAttributesDeleteResponse
             * @constructor
             * @param {flyteidl.admin.IProjectDomainAttributesDeleteResponse=} [properties] Properties to set
             */
            function ProjectDomainAttributesDeleteResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new ProjectDomainAttributesDeleteResponse instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.ProjectDomainAttributesDeleteResponse
             * @static
             * @param {flyteidl.admin.IProjectDomainAttributesDeleteResponse=} [properties] Properties to set
             * @returns {flyteidl.admin.ProjectDomainAttributesDeleteResponse} ProjectDomainAttributesDeleteResponse instance
             */
            ProjectDomainAttributesDeleteResponse.create = function create(properties) {
                return new ProjectDomainAttributesDeleteResponse(properties);
            };

            /**
             * Encodes the specified ProjectDomainAttributesDeleteResponse message. Does not implicitly {@link flyteidl.admin.ProjectDomainAttributesDeleteResponse.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.ProjectDomainAttributesDeleteResponse
             * @static
             * @param {flyteidl.admin.IProjectDomainAttributesDeleteResponse} message ProjectDomainAttributesDeleteResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProjectDomainAttributesDeleteResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Decodes a ProjectDomainAttributesDeleteResponse message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.ProjectDomainAttributesDeleteResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.ProjectDomainAttributesDeleteResponse} ProjectDomainAttributesDeleteResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProjectDomainAttributesDeleteResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.ProjectDomainAttributesDeleteResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a ProjectDomainAttributesDeleteResponse message.
             * @function verify
             * @memberof flyteidl.admin.ProjectDomainAttributesDeleteResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ProjectDomainAttributesDeleteResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            return ProjectDomainAttributesDeleteResponse;
        })();

        admin.TaskCreateRequest = (function() {

            /**
             * Properties of a TaskCreateRequest.
             * @memberof flyteidl.admin
             * @interface ITaskCreateRequest
             * @property {flyteidl.core.IIdentifier|null} [id] TaskCreateRequest id
             * @property {flyteidl.admin.ITaskSpec|null} [spec] TaskCreateRequest spec
             */

            /**
             * Constructs a new TaskCreateRequest.
             * @memberof flyteidl.admin
             * @classdesc Represents a TaskCreateRequest.
             * @implements ITaskCreateRequest
             * @constructor
             * @param {flyteidl.admin.ITaskCreateRequest=} [properties] Properties to set
             */
            function TaskCreateRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TaskCreateRequest id.
             * @member {flyteidl.core.IIdentifier|null|undefined} id
             * @memberof flyteidl.admin.TaskCreateRequest
             * @instance
             */
            TaskCreateRequest.prototype.id = null;

            /**
             * TaskCreateRequest spec.
             * @member {flyteidl.admin.ITaskSpec|null|undefined} spec
             * @memberof flyteidl.admin.TaskCreateRequest
             * @instance
             */
            TaskCreateRequest.prototype.spec = null;

            /**
             * Creates a new TaskCreateRequest instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.TaskCreateRequest
             * @static
             * @param {flyteidl.admin.ITaskCreateRequest=} [properties] Properties to set
             * @returns {flyteidl.admin.TaskCreateRequest} TaskCreateRequest instance
             */
            TaskCreateRequest.create = function create(properties) {
                return new TaskCreateRequest(properties);
            };

            /**
             * Encodes the specified TaskCreateRequest message. Does not implicitly {@link flyteidl.admin.TaskCreateRequest.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.TaskCreateRequest
             * @static
             * @param {flyteidl.admin.ITaskCreateRequest} message TaskCreateRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TaskCreateRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    $root.flyteidl.core.Identifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.spec != null && message.hasOwnProperty("spec"))
                    $root.flyteidl.admin.TaskSpec.encode(message.spec, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a TaskCreateRequest message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.TaskCreateRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.TaskCreateRequest} TaskCreateRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TaskCreateRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.TaskCreateRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = $root.flyteidl.core.Identifier.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.spec = $root.flyteidl.admin.TaskSpec.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a TaskCreateRequest message.
             * @function verify
             * @memberof flyteidl.admin.TaskCreateRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TaskCreateRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id")) {
                    let error = $root.flyteidl.core.Identifier.verify(message.id);
                    if (error)
                        return "id." + error;
                }
                if (message.spec != null && message.hasOwnProperty("spec")) {
                    let error = $root.flyteidl.admin.TaskSpec.verify(message.spec);
                    if (error)
                        return "spec." + error;
                }
                return null;
            };

            return TaskCreateRequest;
        })();

        admin.TaskCreateResponse = (function() {

            /**
             * Properties of a TaskCreateResponse.
             * @memberof flyteidl.admin
             * @interface ITaskCreateResponse
             */

            /**
             * Constructs a new TaskCreateResponse.
             * @memberof flyteidl.admin
             * @classdesc Represents a TaskCreateResponse.
             * @implements ITaskCreateResponse
             * @constructor
             * @param {flyteidl.admin.ITaskCreateResponse=} [properties] Properties to set
             */
            function TaskCreateResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new TaskCreateResponse instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.TaskCreateResponse
             * @static
             * @param {flyteidl.admin.ITaskCreateResponse=} [properties] Properties to set
             * @returns {flyteidl.admin.TaskCreateResponse} TaskCreateResponse instance
             */
            TaskCreateResponse.create = function create(properties) {
                return new TaskCreateResponse(properties);
            };

            /**
             * Encodes the specified TaskCreateResponse message. Does not implicitly {@link flyteidl.admin.TaskCreateResponse.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.TaskCreateResponse
             * @static
             * @param {flyteidl.admin.ITaskCreateResponse} message TaskCreateResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TaskCreateResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Decodes a TaskCreateResponse message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.TaskCreateResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.TaskCreateResponse} TaskCreateResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TaskCreateResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.TaskCreateResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a TaskCreateResponse message.
             * @function verify
             * @memberof flyteidl.admin.TaskCreateResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TaskCreateResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            return TaskCreateResponse;
        })();

        admin.Task = (function() {

            /**
             * Properties of a Task.
             * @memberof flyteidl.admin
             * @interface ITask
             * @property {flyteidl.core.IIdentifier|null} [id] Task id
             * @property {flyteidl.admin.ITaskClosure|null} [closure] Task closure
             */

            /**
             * Constructs a new Task.
             * @memberof flyteidl.admin
             * @classdesc Represents a Task.
             * @implements ITask
             * @constructor
             * @param {flyteidl.admin.ITask=} [properties] Properties to set
             */
            function Task(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Task id.
             * @member {flyteidl.core.IIdentifier|null|undefined} id
             * @memberof flyteidl.admin.Task
             * @instance
             */
            Task.prototype.id = null;

            /**
             * Task closure.
             * @member {flyteidl.admin.ITaskClosure|null|undefined} closure
             * @memberof flyteidl.admin.Task
             * @instance
             */
            Task.prototype.closure = null;

            /**
             * Creates a new Task instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.Task
             * @static
             * @param {flyteidl.admin.ITask=} [properties] Properties to set
             * @returns {flyteidl.admin.Task} Task instance
             */
            Task.create = function create(properties) {
                return new Task(properties);
            };

            /**
             * Encodes the specified Task message. Does not implicitly {@link flyteidl.admin.Task.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.Task
             * @static
             * @param {flyteidl.admin.ITask} message Task message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Task.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    $root.flyteidl.core.Identifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.closure != null && message.hasOwnProperty("closure"))
                    $root.flyteidl.admin.TaskClosure.encode(message.closure, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a Task message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.Task
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.Task} Task
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Task.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.Task();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = $root.flyteidl.core.Identifier.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.closure = $root.flyteidl.admin.TaskClosure.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a Task message.
             * @function verify
             * @memberof flyteidl.admin.Task
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Task.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id")) {
                    let error = $root.flyteidl.core.Identifier.verify(message.id);
                    if (error)
                        return "id." + error;
                }
                if (message.closure != null && message.hasOwnProperty("closure")) {
                    let error = $root.flyteidl.admin.TaskClosure.verify(message.closure);
                    if (error)
                        return "closure." + error;
                }
                return null;
            };

            return Task;
        })();

        admin.TaskList = (function() {

            /**
             * Properties of a TaskList.
             * @memberof flyteidl.admin
             * @interface ITaskList
             * @property {Array.<flyteidl.admin.ITask>|null} [tasks] TaskList tasks
             * @property {string|null} [token] TaskList token
             */

            /**
             * Constructs a new TaskList.
             * @memberof flyteidl.admin
             * @classdesc Represents a TaskList.
             * @implements ITaskList
             * @constructor
             * @param {flyteidl.admin.ITaskList=} [properties] Properties to set
             */
            function TaskList(properties) {
                this.tasks = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TaskList tasks.
             * @member {Array.<flyteidl.admin.ITask>} tasks
             * @memberof flyteidl.admin.TaskList
             * @instance
             */
            TaskList.prototype.tasks = $util.emptyArray;

            /**
             * TaskList token.
             * @member {string} token
             * @memberof flyteidl.admin.TaskList
             * @instance
             */
            TaskList.prototype.token = "";

            /**
             * Creates a new TaskList instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.TaskList
             * @static
             * @param {flyteidl.admin.ITaskList=} [properties] Properties to set
             * @returns {flyteidl.admin.TaskList} TaskList instance
             */
            TaskList.create = function create(properties) {
                return new TaskList(properties);
            };

            /**
             * Encodes the specified TaskList message. Does not implicitly {@link flyteidl.admin.TaskList.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.TaskList
             * @static
             * @param {flyteidl.admin.ITaskList} message TaskList message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TaskList.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tasks != null && message.tasks.length)
                    for (let i = 0; i < message.tasks.length; ++i)
                        $root.flyteidl.admin.Task.encode(message.tasks[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.token != null && message.hasOwnProperty("token"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.token);
                return writer;
            };

            /**
             * Decodes a TaskList message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.TaskList
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.TaskList} TaskList
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TaskList.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.TaskList();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.tasks && message.tasks.length))
                            message.tasks = [];
                        message.tasks.push($root.flyteidl.admin.Task.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        message.token = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a TaskList message.
             * @function verify
             * @memberof flyteidl.admin.TaskList
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TaskList.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tasks != null && message.hasOwnProperty("tasks")) {
                    if (!Array.isArray(message.tasks))
                        return "tasks: array expected";
                    for (let i = 0; i < message.tasks.length; ++i) {
                        let error = $root.flyteidl.admin.Task.verify(message.tasks[i]);
                        if (error)
                            return "tasks." + error;
                    }
                }
                if (message.token != null && message.hasOwnProperty("token"))
                    if (!$util.isString(message.token))
                        return "token: string expected";
                return null;
            };

            return TaskList;
        })();

        admin.TaskSpec = (function() {

            /**
             * Properties of a TaskSpec.
             * @memberof flyteidl.admin
             * @interface ITaskSpec
             * @property {flyteidl.core.ITaskTemplate|null} [template] TaskSpec template
             */

            /**
             * Constructs a new TaskSpec.
             * @memberof flyteidl.admin
             * @classdesc Represents a TaskSpec.
             * @implements ITaskSpec
             * @constructor
             * @param {flyteidl.admin.ITaskSpec=} [properties] Properties to set
             */
            function TaskSpec(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TaskSpec template.
             * @member {flyteidl.core.ITaskTemplate|null|undefined} template
             * @memberof flyteidl.admin.TaskSpec
             * @instance
             */
            TaskSpec.prototype.template = null;

            /**
             * Creates a new TaskSpec instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.TaskSpec
             * @static
             * @param {flyteidl.admin.ITaskSpec=} [properties] Properties to set
             * @returns {flyteidl.admin.TaskSpec} TaskSpec instance
             */
            TaskSpec.create = function create(properties) {
                return new TaskSpec(properties);
            };

            /**
             * Encodes the specified TaskSpec message. Does not implicitly {@link flyteidl.admin.TaskSpec.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.TaskSpec
             * @static
             * @param {flyteidl.admin.ITaskSpec} message TaskSpec message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TaskSpec.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.template != null && message.hasOwnProperty("template"))
                    $root.flyteidl.core.TaskTemplate.encode(message.template, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a TaskSpec message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.TaskSpec
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.TaskSpec} TaskSpec
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TaskSpec.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.TaskSpec();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.template = $root.flyteidl.core.TaskTemplate.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a TaskSpec message.
             * @function verify
             * @memberof flyteidl.admin.TaskSpec
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TaskSpec.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.template != null && message.hasOwnProperty("template")) {
                    let error = $root.flyteidl.core.TaskTemplate.verify(message.template);
                    if (error)
                        return "template." + error;
                }
                return null;
            };

            return TaskSpec;
        })();

        admin.TaskClosure = (function() {

            /**
             * Properties of a TaskClosure.
             * @memberof flyteidl.admin
             * @interface ITaskClosure
             * @property {flyteidl.core.ICompiledTask|null} [compiledTask] TaskClosure compiledTask
             * @property {google.protobuf.ITimestamp|null} [createdAt] TaskClosure createdAt
             */

            /**
             * Constructs a new TaskClosure.
             * @memberof flyteidl.admin
             * @classdesc Represents a TaskClosure.
             * @implements ITaskClosure
             * @constructor
             * @param {flyteidl.admin.ITaskClosure=} [properties] Properties to set
             */
            function TaskClosure(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TaskClosure compiledTask.
             * @member {flyteidl.core.ICompiledTask|null|undefined} compiledTask
             * @memberof flyteidl.admin.TaskClosure
             * @instance
             */
            TaskClosure.prototype.compiledTask = null;

            /**
             * TaskClosure createdAt.
             * @member {google.protobuf.ITimestamp|null|undefined} createdAt
             * @memberof flyteidl.admin.TaskClosure
             * @instance
             */
            TaskClosure.prototype.createdAt = null;

            /**
             * Creates a new TaskClosure instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.TaskClosure
             * @static
             * @param {flyteidl.admin.ITaskClosure=} [properties] Properties to set
             * @returns {flyteidl.admin.TaskClosure} TaskClosure instance
             */
            TaskClosure.create = function create(properties) {
                return new TaskClosure(properties);
            };

            /**
             * Encodes the specified TaskClosure message. Does not implicitly {@link flyteidl.admin.TaskClosure.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.TaskClosure
             * @static
             * @param {flyteidl.admin.ITaskClosure} message TaskClosure message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TaskClosure.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.compiledTask != null && message.hasOwnProperty("compiledTask"))
                    $root.flyteidl.core.CompiledTask.encode(message.compiledTask, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.createdAt != null && message.hasOwnProperty("createdAt"))
                    $root.google.protobuf.Timestamp.encode(message.createdAt, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a TaskClosure message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.TaskClosure
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.TaskClosure} TaskClosure
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TaskClosure.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.TaskClosure();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.compiledTask = $root.flyteidl.core.CompiledTask.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.createdAt = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a TaskClosure message.
             * @function verify
             * @memberof flyteidl.admin.TaskClosure
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TaskClosure.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.compiledTask != null && message.hasOwnProperty("compiledTask")) {
                    let error = $root.flyteidl.core.CompiledTask.verify(message.compiledTask);
                    if (error)
                        return "compiledTask." + error;
                }
                if (message.createdAt != null && message.hasOwnProperty("createdAt")) {
                    let error = $root.google.protobuf.Timestamp.verify(message.createdAt);
                    if (error)
                        return "createdAt." + error;
                }
                return null;
            };

            return TaskClosure;
        })();

        admin.TaskExecutionGetRequest = (function() {

            /**
             * Properties of a TaskExecutionGetRequest.
             * @memberof flyteidl.admin
             * @interface ITaskExecutionGetRequest
             * @property {flyteidl.core.ITaskExecutionIdentifier|null} [id] TaskExecutionGetRequest id
             */

            /**
             * Constructs a new TaskExecutionGetRequest.
             * @memberof flyteidl.admin
             * @classdesc Represents a TaskExecutionGetRequest.
             * @implements ITaskExecutionGetRequest
             * @constructor
             * @param {flyteidl.admin.ITaskExecutionGetRequest=} [properties] Properties to set
             */
            function TaskExecutionGetRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TaskExecutionGetRequest id.
             * @member {flyteidl.core.ITaskExecutionIdentifier|null|undefined} id
             * @memberof flyteidl.admin.TaskExecutionGetRequest
             * @instance
             */
            TaskExecutionGetRequest.prototype.id = null;

            /**
             * Creates a new TaskExecutionGetRequest instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.TaskExecutionGetRequest
             * @static
             * @param {flyteidl.admin.ITaskExecutionGetRequest=} [properties] Properties to set
             * @returns {flyteidl.admin.TaskExecutionGetRequest} TaskExecutionGetRequest instance
             */
            TaskExecutionGetRequest.create = function create(properties) {
                return new TaskExecutionGetRequest(properties);
            };

            /**
             * Encodes the specified TaskExecutionGetRequest message. Does not implicitly {@link flyteidl.admin.TaskExecutionGetRequest.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.TaskExecutionGetRequest
             * @static
             * @param {flyteidl.admin.ITaskExecutionGetRequest} message TaskExecutionGetRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TaskExecutionGetRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    $root.flyteidl.core.TaskExecutionIdentifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a TaskExecutionGetRequest message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.TaskExecutionGetRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.TaskExecutionGetRequest} TaskExecutionGetRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TaskExecutionGetRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.TaskExecutionGetRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = $root.flyteidl.core.TaskExecutionIdentifier.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a TaskExecutionGetRequest message.
             * @function verify
             * @memberof flyteidl.admin.TaskExecutionGetRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TaskExecutionGetRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id")) {
                    let error = $root.flyteidl.core.TaskExecutionIdentifier.verify(message.id);
                    if (error)
                        return "id." + error;
                }
                return null;
            };

            return TaskExecutionGetRequest;
        })();

        admin.TaskExecutionListRequest = (function() {

            /**
             * Properties of a TaskExecutionListRequest.
             * @memberof flyteidl.admin
             * @interface ITaskExecutionListRequest
             * @property {flyteidl.core.INodeExecutionIdentifier|null} [nodeExecutionId] TaskExecutionListRequest nodeExecutionId
             * @property {number|null} [limit] TaskExecutionListRequest limit
             * @property {string|null} [token] TaskExecutionListRequest token
             * @property {string|null} [filters] TaskExecutionListRequest filters
             * @property {flyteidl.admin.ISort|null} [sortBy] TaskExecutionListRequest sortBy
             */

            /**
             * Constructs a new TaskExecutionListRequest.
             * @memberof flyteidl.admin
             * @classdesc Represents a TaskExecutionListRequest.
             * @implements ITaskExecutionListRequest
             * @constructor
             * @param {flyteidl.admin.ITaskExecutionListRequest=} [properties] Properties to set
             */
            function TaskExecutionListRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TaskExecutionListRequest nodeExecutionId.
             * @member {flyteidl.core.INodeExecutionIdentifier|null|undefined} nodeExecutionId
             * @memberof flyteidl.admin.TaskExecutionListRequest
             * @instance
             */
            TaskExecutionListRequest.prototype.nodeExecutionId = null;

            /**
             * TaskExecutionListRequest limit.
             * @member {number} limit
             * @memberof flyteidl.admin.TaskExecutionListRequest
             * @instance
             */
            TaskExecutionListRequest.prototype.limit = 0;

            /**
             * TaskExecutionListRequest token.
             * @member {string} token
             * @memberof flyteidl.admin.TaskExecutionListRequest
             * @instance
             */
            TaskExecutionListRequest.prototype.token = "";

            /**
             * TaskExecutionListRequest filters.
             * @member {string} filters
             * @memberof flyteidl.admin.TaskExecutionListRequest
             * @instance
             */
            TaskExecutionListRequest.prototype.filters = "";

            /**
             * TaskExecutionListRequest sortBy.
             * @member {flyteidl.admin.ISort|null|undefined} sortBy
             * @memberof flyteidl.admin.TaskExecutionListRequest
             * @instance
             */
            TaskExecutionListRequest.prototype.sortBy = null;

            /**
             * Creates a new TaskExecutionListRequest instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.TaskExecutionListRequest
             * @static
             * @param {flyteidl.admin.ITaskExecutionListRequest=} [properties] Properties to set
             * @returns {flyteidl.admin.TaskExecutionListRequest} TaskExecutionListRequest instance
             */
            TaskExecutionListRequest.create = function create(properties) {
                return new TaskExecutionListRequest(properties);
            };

            /**
             * Encodes the specified TaskExecutionListRequest message. Does not implicitly {@link flyteidl.admin.TaskExecutionListRequest.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.TaskExecutionListRequest
             * @static
             * @param {flyteidl.admin.ITaskExecutionListRequest} message TaskExecutionListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TaskExecutionListRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.nodeExecutionId != null && message.hasOwnProperty("nodeExecutionId"))
                    $root.flyteidl.core.NodeExecutionIdentifier.encode(message.nodeExecutionId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.limit != null && message.hasOwnProperty("limit"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.limit);
                if (message.token != null && message.hasOwnProperty("token"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.token);
                if (message.filters != null && message.hasOwnProperty("filters"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.filters);
                if (message.sortBy != null && message.hasOwnProperty("sortBy"))
                    $root.flyteidl.admin.Sort.encode(message.sortBy, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a TaskExecutionListRequest message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.TaskExecutionListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.TaskExecutionListRequest} TaskExecutionListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TaskExecutionListRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.TaskExecutionListRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.nodeExecutionId = $root.flyteidl.core.NodeExecutionIdentifier.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.limit = reader.uint32();
                        break;
                    case 3:
                        message.token = reader.string();
                        break;
                    case 4:
                        message.filters = reader.string();
                        break;
                    case 5:
                        message.sortBy = $root.flyteidl.admin.Sort.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a TaskExecutionListRequest message.
             * @function verify
             * @memberof flyteidl.admin.TaskExecutionListRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TaskExecutionListRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.nodeExecutionId != null && message.hasOwnProperty("nodeExecutionId")) {
                    let error = $root.flyteidl.core.NodeExecutionIdentifier.verify(message.nodeExecutionId);
                    if (error)
                        return "nodeExecutionId." + error;
                }
                if (message.limit != null && message.hasOwnProperty("limit"))
                    if (!$util.isInteger(message.limit))
                        return "limit: integer expected";
                if (message.token != null && message.hasOwnProperty("token"))
                    if (!$util.isString(message.token))
                        return "token: string expected";
                if (message.filters != null && message.hasOwnProperty("filters"))
                    if (!$util.isString(message.filters))
                        return "filters: string expected";
                if (message.sortBy != null && message.hasOwnProperty("sortBy")) {
                    let error = $root.flyteidl.admin.Sort.verify(message.sortBy);
                    if (error)
                        return "sortBy." + error;
                }
                return null;
            };

            return TaskExecutionListRequest;
        })();

        admin.TaskExecution = (function() {

            /**
             * Properties of a TaskExecution.
             * @memberof flyteidl.admin
             * @interface ITaskExecution
             * @property {flyteidl.core.ITaskExecutionIdentifier|null} [id] TaskExecution id
             * @property {string|null} [inputUri] TaskExecution inputUri
             * @property {flyteidl.admin.ITaskExecutionClosure|null} [closure] TaskExecution closure
             * @property {boolean|null} [isParent] TaskExecution isParent
             */

            /**
             * Constructs a new TaskExecution.
             * @memberof flyteidl.admin
             * @classdesc Represents a TaskExecution.
             * @implements ITaskExecution
             * @constructor
             * @param {flyteidl.admin.ITaskExecution=} [properties] Properties to set
             */
            function TaskExecution(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TaskExecution id.
             * @member {flyteidl.core.ITaskExecutionIdentifier|null|undefined} id
             * @memberof flyteidl.admin.TaskExecution
             * @instance
             */
            TaskExecution.prototype.id = null;

            /**
             * TaskExecution inputUri.
             * @member {string} inputUri
             * @memberof flyteidl.admin.TaskExecution
             * @instance
             */
            TaskExecution.prototype.inputUri = "";

            /**
             * TaskExecution closure.
             * @member {flyteidl.admin.ITaskExecutionClosure|null|undefined} closure
             * @memberof flyteidl.admin.TaskExecution
             * @instance
             */
            TaskExecution.prototype.closure = null;

            /**
             * TaskExecution isParent.
             * @member {boolean} isParent
             * @memberof flyteidl.admin.TaskExecution
             * @instance
             */
            TaskExecution.prototype.isParent = false;

            /**
             * Creates a new TaskExecution instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.TaskExecution
             * @static
             * @param {flyteidl.admin.ITaskExecution=} [properties] Properties to set
             * @returns {flyteidl.admin.TaskExecution} TaskExecution instance
             */
            TaskExecution.create = function create(properties) {
                return new TaskExecution(properties);
            };

            /**
             * Encodes the specified TaskExecution message. Does not implicitly {@link flyteidl.admin.TaskExecution.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.TaskExecution
             * @static
             * @param {flyteidl.admin.ITaskExecution} message TaskExecution message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TaskExecution.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    $root.flyteidl.core.TaskExecutionIdentifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.inputUri != null && message.hasOwnProperty("inputUri"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.inputUri);
                if (message.closure != null && message.hasOwnProperty("closure"))
                    $root.flyteidl.admin.TaskExecutionClosure.encode(message.closure, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.isParent != null && message.hasOwnProperty("isParent"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.isParent);
                return writer;
            };

            /**
             * Decodes a TaskExecution message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.TaskExecution
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.TaskExecution} TaskExecution
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TaskExecution.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.TaskExecution();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = $root.flyteidl.core.TaskExecutionIdentifier.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.inputUri = reader.string();
                        break;
                    case 3:
                        message.closure = $root.flyteidl.admin.TaskExecutionClosure.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.isParent = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a TaskExecution message.
             * @function verify
             * @memberof flyteidl.admin.TaskExecution
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TaskExecution.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id")) {
                    let error = $root.flyteidl.core.TaskExecutionIdentifier.verify(message.id);
                    if (error)
                        return "id." + error;
                }
                if (message.inputUri != null && message.hasOwnProperty("inputUri"))
                    if (!$util.isString(message.inputUri))
                        return "inputUri: string expected";
                if (message.closure != null && message.hasOwnProperty("closure")) {
                    let error = $root.flyteidl.admin.TaskExecutionClosure.verify(message.closure);
                    if (error)
                        return "closure." + error;
                }
                if (message.isParent != null && message.hasOwnProperty("isParent"))
                    if (typeof message.isParent !== "boolean")
                        return "isParent: boolean expected";
                return null;
            };

            return TaskExecution;
        })();

        admin.TaskExecutionList = (function() {

            /**
             * Properties of a TaskExecutionList.
             * @memberof flyteidl.admin
             * @interface ITaskExecutionList
             * @property {Array.<flyteidl.admin.ITaskExecution>|null} [taskExecutions] TaskExecutionList taskExecutions
             * @property {string|null} [token] TaskExecutionList token
             */

            /**
             * Constructs a new TaskExecutionList.
             * @memberof flyteidl.admin
             * @classdesc Represents a TaskExecutionList.
             * @implements ITaskExecutionList
             * @constructor
             * @param {flyteidl.admin.ITaskExecutionList=} [properties] Properties to set
             */
            function TaskExecutionList(properties) {
                this.taskExecutions = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TaskExecutionList taskExecutions.
             * @member {Array.<flyteidl.admin.ITaskExecution>} taskExecutions
             * @memberof flyteidl.admin.TaskExecutionList
             * @instance
             */
            TaskExecutionList.prototype.taskExecutions = $util.emptyArray;

            /**
             * TaskExecutionList token.
             * @member {string} token
             * @memberof flyteidl.admin.TaskExecutionList
             * @instance
             */
            TaskExecutionList.prototype.token = "";

            /**
             * Creates a new TaskExecutionList instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.TaskExecutionList
             * @static
             * @param {flyteidl.admin.ITaskExecutionList=} [properties] Properties to set
             * @returns {flyteidl.admin.TaskExecutionList} TaskExecutionList instance
             */
            TaskExecutionList.create = function create(properties) {
                return new TaskExecutionList(properties);
            };

            /**
             * Encodes the specified TaskExecutionList message. Does not implicitly {@link flyteidl.admin.TaskExecutionList.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.TaskExecutionList
             * @static
             * @param {flyteidl.admin.ITaskExecutionList} message TaskExecutionList message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TaskExecutionList.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.taskExecutions != null && message.taskExecutions.length)
                    for (let i = 0; i < message.taskExecutions.length; ++i)
                        $root.flyteidl.admin.TaskExecution.encode(message.taskExecutions[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.token != null && message.hasOwnProperty("token"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.token);
                return writer;
            };

            /**
             * Decodes a TaskExecutionList message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.TaskExecutionList
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.TaskExecutionList} TaskExecutionList
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TaskExecutionList.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.TaskExecutionList();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.taskExecutions && message.taskExecutions.length))
                            message.taskExecutions = [];
                        message.taskExecutions.push($root.flyteidl.admin.TaskExecution.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        message.token = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a TaskExecutionList message.
             * @function verify
             * @memberof flyteidl.admin.TaskExecutionList
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TaskExecutionList.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.taskExecutions != null && message.hasOwnProperty("taskExecutions")) {
                    if (!Array.isArray(message.taskExecutions))
                        return "taskExecutions: array expected";
                    for (let i = 0; i < message.taskExecutions.length; ++i) {
                        let error = $root.flyteidl.admin.TaskExecution.verify(message.taskExecutions[i]);
                        if (error)
                            return "taskExecutions." + error;
                    }
                }
                if (message.token != null && message.hasOwnProperty("token"))
                    if (!$util.isString(message.token))
                        return "token: string expected";
                return null;
            };

            return TaskExecutionList;
        })();

        admin.TaskExecutionClosure = (function() {

            /**
             * Properties of a TaskExecutionClosure.
             * @memberof flyteidl.admin
             * @interface ITaskExecutionClosure
             * @property {string|null} [outputUri] TaskExecutionClosure outputUri
             * @property {flyteidl.core.IExecutionError|null} [error] TaskExecutionClosure error
             * @property {flyteidl.core.TaskExecution.Phase|null} [phase] TaskExecutionClosure phase
             * @property {Array.<flyteidl.core.ITaskLog>|null} [logs] TaskExecutionClosure logs
             * @property {google.protobuf.ITimestamp|null} [startedAt] TaskExecutionClosure startedAt
             * @property {google.protobuf.IDuration|null} [duration] TaskExecutionClosure duration
             * @property {google.protobuf.ITimestamp|null} [createdAt] TaskExecutionClosure createdAt
             * @property {google.protobuf.ITimestamp|null} [updatedAt] TaskExecutionClosure updatedAt
             * @property {google.protobuf.IStruct|null} [customInfo] TaskExecutionClosure customInfo
             */

            /**
             * Constructs a new TaskExecutionClosure.
             * @memberof flyteidl.admin
             * @classdesc Represents a TaskExecutionClosure.
             * @implements ITaskExecutionClosure
             * @constructor
             * @param {flyteidl.admin.ITaskExecutionClosure=} [properties] Properties to set
             */
            function TaskExecutionClosure(properties) {
                this.logs = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TaskExecutionClosure outputUri.
             * @member {string} outputUri
             * @memberof flyteidl.admin.TaskExecutionClosure
             * @instance
             */
            TaskExecutionClosure.prototype.outputUri = "";

            /**
             * TaskExecutionClosure error.
             * @member {flyteidl.core.IExecutionError|null|undefined} error
             * @memberof flyteidl.admin.TaskExecutionClosure
             * @instance
             */
            TaskExecutionClosure.prototype.error = null;

            /**
             * TaskExecutionClosure phase.
             * @member {flyteidl.core.TaskExecution.Phase} phase
             * @memberof flyteidl.admin.TaskExecutionClosure
             * @instance
             */
            TaskExecutionClosure.prototype.phase = 0;

            /**
             * TaskExecutionClosure logs.
             * @member {Array.<flyteidl.core.ITaskLog>} logs
             * @memberof flyteidl.admin.TaskExecutionClosure
             * @instance
             */
            TaskExecutionClosure.prototype.logs = $util.emptyArray;

            /**
             * TaskExecutionClosure startedAt.
             * @member {google.protobuf.ITimestamp|null|undefined} startedAt
             * @memberof flyteidl.admin.TaskExecutionClosure
             * @instance
             */
            TaskExecutionClosure.prototype.startedAt = null;

            /**
             * TaskExecutionClosure duration.
             * @member {google.protobuf.IDuration|null|undefined} duration
             * @memberof flyteidl.admin.TaskExecutionClosure
             * @instance
             */
            TaskExecutionClosure.prototype.duration = null;

            /**
             * TaskExecutionClosure createdAt.
             * @member {google.protobuf.ITimestamp|null|undefined} createdAt
             * @memberof flyteidl.admin.TaskExecutionClosure
             * @instance
             */
            TaskExecutionClosure.prototype.createdAt = null;

            /**
             * TaskExecutionClosure updatedAt.
             * @member {google.protobuf.ITimestamp|null|undefined} updatedAt
             * @memberof flyteidl.admin.TaskExecutionClosure
             * @instance
             */
            TaskExecutionClosure.prototype.updatedAt = null;

            /**
             * TaskExecutionClosure customInfo.
             * @member {google.protobuf.IStruct|null|undefined} customInfo
             * @memberof flyteidl.admin.TaskExecutionClosure
             * @instance
             */
            TaskExecutionClosure.prototype.customInfo = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * TaskExecutionClosure outputResult.
             * @member {"outputUri"|"error"|undefined} outputResult
             * @memberof flyteidl.admin.TaskExecutionClosure
             * @instance
             */
            Object.defineProperty(TaskExecutionClosure.prototype, "outputResult", {
                get: $util.oneOfGetter($oneOfFields = ["outputUri", "error"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new TaskExecutionClosure instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.TaskExecutionClosure
             * @static
             * @param {flyteidl.admin.ITaskExecutionClosure=} [properties] Properties to set
             * @returns {flyteidl.admin.TaskExecutionClosure} TaskExecutionClosure instance
             */
            TaskExecutionClosure.create = function create(properties) {
                return new TaskExecutionClosure(properties);
            };

            /**
             * Encodes the specified TaskExecutionClosure message. Does not implicitly {@link flyteidl.admin.TaskExecutionClosure.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.TaskExecutionClosure
             * @static
             * @param {flyteidl.admin.ITaskExecutionClosure} message TaskExecutionClosure message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TaskExecutionClosure.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.outputUri != null && message.hasOwnProperty("outputUri"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.outputUri);
                if (message.error != null && message.hasOwnProperty("error"))
                    $root.flyteidl.core.ExecutionError.encode(message.error, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.phase != null && message.hasOwnProperty("phase"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.phase);
                if (message.logs != null && message.logs.length)
                    for (let i = 0; i < message.logs.length; ++i)
                        $root.flyteidl.core.TaskLog.encode(message.logs[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.startedAt != null && message.hasOwnProperty("startedAt"))
                    $root.google.protobuf.Timestamp.encode(message.startedAt, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.duration != null && message.hasOwnProperty("duration"))
                    $root.google.protobuf.Duration.encode(message.duration, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.createdAt != null && message.hasOwnProperty("createdAt"))
                    $root.google.protobuf.Timestamp.encode(message.createdAt, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.updatedAt != null && message.hasOwnProperty("updatedAt"))
                    $root.google.protobuf.Timestamp.encode(message.updatedAt, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.customInfo != null && message.hasOwnProperty("customInfo"))
                    $root.google.protobuf.Struct.encode(message.customInfo, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a TaskExecutionClosure message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.TaskExecutionClosure
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.TaskExecutionClosure} TaskExecutionClosure
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TaskExecutionClosure.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.TaskExecutionClosure();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.outputUri = reader.string();
                        break;
                    case 2:
                        message.error = $root.flyteidl.core.ExecutionError.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.phase = reader.int32();
                        break;
                    case 4:
                        if (!(message.logs && message.logs.length))
                            message.logs = [];
                        message.logs.push($root.flyteidl.core.TaskLog.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        message.startedAt = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.duration = $root.google.protobuf.Duration.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.createdAt = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                        break;
                    case 8:
                        message.updatedAt = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                        break;
                    case 9:
                        message.customInfo = $root.google.protobuf.Struct.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a TaskExecutionClosure message.
             * @function verify
             * @memberof flyteidl.admin.TaskExecutionClosure
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TaskExecutionClosure.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.outputUri != null && message.hasOwnProperty("outputUri")) {
                    properties.outputResult = 1;
                    if (!$util.isString(message.outputUri))
                        return "outputUri: string expected";
                }
                if (message.error != null && message.hasOwnProperty("error")) {
                    if (properties.outputResult === 1)
                        return "outputResult: multiple values";
                    properties.outputResult = 1;
                    {
                        let error = $root.flyteidl.core.ExecutionError.verify(message.error);
                        if (error)
                            return "error." + error;
                    }
                }
                if (message.phase != null && message.hasOwnProperty("phase"))
                    switch (message.phase) {
                    default:
                        return "phase: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                        break;
                    }
                if (message.logs != null && message.hasOwnProperty("logs")) {
                    if (!Array.isArray(message.logs))
                        return "logs: array expected";
                    for (let i = 0; i < message.logs.length; ++i) {
                        let error = $root.flyteidl.core.TaskLog.verify(message.logs[i]);
                        if (error)
                            return "logs." + error;
                    }
                }
                if (message.startedAt != null && message.hasOwnProperty("startedAt")) {
                    let error = $root.google.protobuf.Timestamp.verify(message.startedAt);
                    if (error)
                        return "startedAt." + error;
                }
                if (message.duration != null && message.hasOwnProperty("duration")) {
                    let error = $root.google.protobuf.Duration.verify(message.duration);
                    if (error)
                        return "duration." + error;
                }
                if (message.createdAt != null && message.hasOwnProperty("createdAt")) {
                    let error = $root.google.protobuf.Timestamp.verify(message.createdAt);
                    if (error)
                        return "createdAt." + error;
                }
                if (message.updatedAt != null && message.hasOwnProperty("updatedAt")) {
                    let error = $root.google.protobuf.Timestamp.verify(message.updatedAt);
                    if (error)
                        return "updatedAt." + error;
                }
                if (message.customInfo != null && message.hasOwnProperty("customInfo")) {
                    let error = $root.google.protobuf.Struct.verify(message.customInfo);
                    if (error)
                        return "customInfo." + error;
                }
                return null;
            };

            return TaskExecutionClosure;
        })();

        admin.TaskExecutionGetDataRequest = (function() {

            /**
             * Properties of a TaskExecutionGetDataRequest.
             * @memberof flyteidl.admin
             * @interface ITaskExecutionGetDataRequest
             * @property {flyteidl.core.ITaskExecutionIdentifier|null} [id] TaskExecutionGetDataRequest id
             */

            /**
             * Constructs a new TaskExecutionGetDataRequest.
             * @memberof flyteidl.admin
             * @classdesc Represents a TaskExecutionGetDataRequest.
             * @implements ITaskExecutionGetDataRequest
             * @constructor
             * @param {flyteidl.admin.ITaskExecutionGetDataRequest=} [properties] Properties to set
             */
            function TaskExecutionGetDataRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TaskExecutionGetDataRequest id.
             * @member {flyteidl.core.ITaskExecutionIdentifier|null|undefined} id
             * @memberof flyteidl.admin.TaskExecutionGetDataRequest
             * @instance
             */
            TaskExecutionGetDataRequest.prototype.id = null;

            /**
             * Creates a new TaskExecutionGetDataRequest instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.TaskExecutionGetDataRequest
             * @static
             * @param {flyteidl.admin.ITaskExecutionGetDataRequest=} [properties] Properties to set
             * @returns {flyteidl.admin.TaskExecutionGetDataRequest} TaskExecutionGetDataRequest instance
             */
            TaskExecutionGetDataRequest.create = function create(properties) {
                return new TaskExecutionGetDataRequest(properties);
            };

            /**
             * Encodes the specified TaskExecutionGetDataRequest message. Does not implicitly {@link flyteidl.admin.TaskExecutionGetDataRequest.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.TaskExecutionGetDataRequest
             * @static
             * @param {flyteidl.admin.ITaskExecutionGetDataRequest} message TaskExecutionGetDataRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TaskExecutionGetDataRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    $root.flyteidl.core.TaskExecutionIdentifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a TaskExecutionGetDataRequest message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.TaskExecutionGetDataRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.TaskExecutionGetDataRequest} TaskExecutionGetDataRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TaskExecutionGetDataRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.TaskExecutionGetDataRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = $root.flyteidl.core.TaskExecutionIdentifier.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a TaskExecutionGetDataRequest message.
             * @function verify
             * @memberof flyteidl.admin.TaskExecutionGetDataRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TaskExecutionGetDataRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id")) {
                    let error = $root.flyteidl.core.TaskExecutionIdentifier.verify(message.id);
                    if (error)
                        return "id." + error;
                }
                return null;
            };

            return TaskExecutionGetDataRequest;
        })();

        admin.TaskExecutionGetDataResponse = (function() {

            /**
             * Properties of a TaskExecutionGetDataResponse.
             * @memberof flyteidl.admin
             * @interface ITaskExecutionGetDataResponse
             * @property {flyteidl.admin.IUrlBlob|null} [inputs] TaskExecutionGetDataResponse inputs
             * @property {flyteidl.admin.IUrlBlob|null} [outputs] TaskExecutionGetDataResponse outputs
             */

            /**
             * Constructs a new TaskExecutionGetDataResponse.
             * @memberof flyteidl.admin
             * @classdesc Represents a TaskExecutionGetDataResponse.
             * @implements ITaskExecutionGetDataResponse
             * @constructor
             * @param {flyteidl.admin.ITaskExecutionGetDataResponse=} [properties] Properties to set
             */
            function TaskExecutionGetDataResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TaskExecutionGetDataResponse inputs.
             * @member {flyteidl.admin.IUrlBlob|null|undefined} inputs
             * @memberof flyteidl.admin.TaskExecutionGetDataResponse
             * @instance
             */
            TaskExecutionGetDataResponse.prototype.inputs = null;

            /**
             * TaskExecutionGetDataResponse outputs.
             * @member {flyteidl.admin.IUrlBlob|null|undefined} outputs
             * @memberof flyteidl.admin.TaskExecutionGetDataResponse
             * @instance
             */
            TaskExecutionGetDataResponse.prototype.outputs = null;

            /**
             * Creates a new TaskExecutionGetDataResponse instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.TaskExecutionGetDataResponse
             * @static
             * @param {flyteidl.admin.ITaskExecutionGetDataResponse=} [properties] Properties to set
             * @returns {flyteidl.admin.TaskExecutionGetDataResponse} TaskExecutionGetDataResponse instance
             */
            TaskExecutionGetDataResponse.create = function create(properties) {
                return new TaskExecutionGetDataResponse(properties);
            };

            /**
             * Encodes the specified TaskExecutionGetDataResponse message. Does not implicitly {@link flyteidl.admin.TaskExecutionGetDataResponse.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.TaskExecutionGetDataResponse
             * @static
             * @param {flyteidl.admin.ITaskExecutionGetDataResponse} message TaskExecutionGetDataResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TaskExecutionGetDataResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.inputs != null && message.hasOwnProperty("inputs"))
                    $root.flyteidl.admin.UrlBlob.encode(message.inputs, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.outputs != null && message.hasOwnProperty("outputs"))
                    $root.flyteidl.admin.UrlBlob.encode(message.outputs, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a TaskExecutionGetDataResponse message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.TaskExecutionGetDataResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.TaskExecutionGetDataResponse} TaskExecutionGetDataResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TaskExecutionGetDataResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.TaskExecutionGetDataResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.inputs = $root.flyteidl.admin.UrlBlob.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.outputs = $root.flyteidl.admin.UrlBlob.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a TaskExecutionGetDataResponse message.
             * @function verify
             * @memberof flyteidl.admin.TaskExecutionGetDataResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TaskExecutionGetDataResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.inputs != null && message.hasOwnProperty("inputs")) {
                    let error = $root.flyteidl.admin.UrlBlob.verify(message.inputs);
                    if (error)
                        return "inputs." + error;
                }
                if (message.outputs != null && message.hasOwnProperty("outputs")) {
                    let error = $root.flyteidl.admin.UrlBlob.verify(message.outputs);
                    if (error)
                        return "outputs." + error;
                }
                return null;
            };

            return TaskExecutionGetDataResponse;
        })();

        admin.WorkflowCreateRequest = (function() {

            /**
             * Properties of a WorkflowCreateRequest.
             * @memberof flyteidl.admin
             * @interface IWorkflowCreateRequest
             * @property {flyteidl.core.IIdentifier|null} [id] WorkflowCreateRequest id
             * @property {flyteidl.admin.IWorkflowSpec|null} [spec] WorkflowCreateRequest spec
             */

            /**
             * Constructs a new WorkflowCreateRequest.
             * @memberof flyteidl.admin
             * @classdesc Represents a WorkflowCreateRequest.
             * @implements IWorkflowCreateRequest
             * @constructor
             * @param {flyteidl.admin.IWorkflowCreateRequest=} [properties] Properties to set
             */
            function WorkflowCreateRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WorkflowCreateRequest id.
             * @member {flyteidl.core.IIdentifier|null|undefined} id
             * @memberof flyteidl.admin.WorkflowCreateRequest
             * @instance
             */
            WorkflowCreateRequest.prototype.id = null;

            /**
             * WorkflowCreateRequest spec.
             * @member {flyteidl.admin.IWorkflowSpec|null|undefined} spec
             * @memberof flyteidl.admin.WorkflowCreateRequest
             * @instance
             */
            WorkflowCreateRequest.prototype.spec = null;

            /**
             * Creates a new WorkflowCreateRequest instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.WorkflowCreateRequest
             * @static
             * @param {flyteidl.admin.IWorkflowCreateRequest=} [properties] Properties to set
             * @returns {flyteidl.admin.WorkflowCreateRequest} WorkflowCreateRequest instance
             */
            WorkflowCreateRequest.create = function create(properties) {
                return new WorkflowCreateRequest(properties);
            };

            /**
             * Encodes the specified WorkflowCreateRequest message. Does not implicitly {@link flyteidl.admin.WorkflowCreateRequest.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.WorkflowCreateRequest
             * @static
             * @param {flyteidl.admin.IWorkflowCreateRequest} message WorkflowCreateRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WorkflowCreateRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    $root.flyteidl.core.Identifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.spec != null && message.hasOwnProperty("spec"))
                    $root.flyteidl.admin.WorkflowSpec.encode(message.spec, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a WorkflowCreateRequest message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.WorkflowCreateRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.WorkflowCreateRequest} WorkflowCreateRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WorkflowCreateRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.WorkflowCreateRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = $root.flyteidl.core.Identifier.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.spec = $root.flyteidl.admin.WorkflowSpec.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a WorkflowCreateRequest message.
             * @function verify
             * @memberof flyteidl.admin.WorkflowCreateRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WorkflowCreateRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id")) {
                    let error = $root.flyteidl.core.Identifier.verify(message.id);
                    if (error)
                        return "id." + error;
                }
                if (message.spec != null && message.hasOwnProperty("spec")) {
                    let error = $root.flyteidl.admin.WorkflowSpec.verify(message.spec);
                    if (error)
                        return "spec." + error;
                }
                return null;
            };

            return WorkflowCreateRequest;
        })();

        admin.WorkflowCreateResponse = (function() {

            /**
             * Properties of a WorkflowCreateResponse.
             * @memberof flyteidl.admin
             * @interface IWorkflowCreateResponse
             */

            /**
             * Constructs a new WorkflowCreateResponse.
             * @memberof flyteidl.admin
             * @classdesc Represents a WorkflowCreateResponse.
             * @implements IWorkflowCreateResponse
             * @constructor
             * @param {flyteidl.admin.IWorkflowCreateResponse=} [properties] Properties to set
             */
            function WorkflowCreateResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new WorkflowCreateResponse instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.WorkflowCreateResponse
             * @static
             * @param {flyteidl.admin.IWorkflowCreateResponse=} [properties] Properties to set
             * @returns {flyteidl.admin.WorkflowCreateResponse} WorkflowCreateResponse instance
             */
            WorkflowCreateResponse.create = function create(properties) {
                return new WorkflowCreateResponse(properties);
            };

            /**
             * Encodes the specified WorkflowCreateResponse message. Does not implicitly {@link flyteidl.admin.WorkflowCreateResponse.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.WorkflowCreateResponse
             * @static
             * @param {flyteidl.admin.IWorkflowCreateResponse} message WorkflowCreateResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WorkflowCreateResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Decodes a WorkflowCreateResponse message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.WorkflowCreateResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.WorkflowCreateResponse} WorkflowCreateResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WorkflowCreateResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.WorkflowCreateResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a WorkflowCreateResponse message.
             * @function verify
             * @memberof flyteidl.admin.WorkflowCreateResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WorkflowCreateResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            return WorkflowCreateResponse;
        })();

        admin.Workflow = (function() {

            /**
             * Properties of a Workflow.
             * @memberof flyteidl.admin
             * @interface IWorkflow
             * @property {flyteidl.core.IIdentifier|null} [id] Workflow id
             * @property {flyteidl.admin.IWorkflowClosure|null} [closure] Workflow closure
             */

            /**
             * Constructs a new Workflow.
             * @memberof flyteidl.admin
             * @classdesc Represents a Workflow.
             * @implements IWorkflow
             * @constructor
             * @param {flyteidl.admin.IWorkflow=} [properties] Properties to set
             */
            function Workflow(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Workflow id.
             * @member {flyteidl.core.IIdentifier|null|undefined} id
             * @memberof flyteidl.admin.Workflow
             * @instance
             */
            Workflow.prototype.id = null;

            /**
             * Workflow closure.
             * @member {flyteidl.admin.IWorkflowClosure|null|undefined} closure
             * @memberof flyteidl.admin.Workflow
             * @instance
             */
            Workflow.prototype.closure = null;

            /**
             * Creates a new Workflow instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.Workflow
             * @static
             * @param {flyteidl.admin.IWorkflow=} [properties] Properties to set
             * @returns {flyteidl.admin.Workflow} Workflow instance
             */
            Workflow.create = function create(properties) {
                return new Workflow(properties);
            };

            /**
             * Encodes the specified Workflow message. Does not implicitly {@link flyteidl.admin.Workflow.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.Workflow
             * @static
             * @param {flyteidl.admin.IWorkflow} message Workflow message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Workflow.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    $root.flyteidl.core.Identifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.closure != null && message.hasOwnProperty("closure"))
                    $root.flyteidl.admin.WorkflowClosure.encode(message.closure, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a Workflow message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.Workflow
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.Workflow} Workflow
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Workflow.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.Workflow();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = $root.flyteidl.core.Identifier.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.closure = $root.flyteidl.admin.WorkflowClosure.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a Workflow message.
             * @function verify
             * @memberof flyteidl.admin.Workflow
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Workflow.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id")) {
                    let error = $root.flyteidl.core.Identifier.verify(message.id);
                    if (error)
                        return "id." + error;
                }
                if (message.closure != null && message.hasOwnProperty("closure")) {
                    let error = $root.flyteidl.admin.WorkflowClosure.verify(message.closure);
                    if (error)
                        return "closure." + error;
                }
                return null;
            };

            return Workflow;
        })();

        admin.WorkflowList = (function() {

            /**
             * Properties of a WorkflowList.
             * @memberof flyteidl.admin
             * @interface IWorkflowList
             * @property {Array.<flyteidl.admin.IWorkflow>|null} [workflows] WorkflowList workflows
             * @property {string|null} [token] WorkflowList token
             */

            /**
             * Constructs a new WorkflowList.
             * @memberof flyteidl.admin
             * @classdesc Represents a WorkflowList.
             * @implements IWorkflowList
             * @constructor
             * @param {flyteidl.admin.IWorkflowList=} [properties] Properties to set
             */
            function WorkflowList(properties) {
                this.workflows = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WorkflowList workflows.
             * @member {Array.<flyteidl.admin.IWorkflow>} workflows
             * @memberof flyteidl.admin.WorkflowList
             * @instance
             */
            WorkflowList.prototype.workflows = $util.emptyArray;

            /**
             * WorkflowList token.
             * @member {string} token
             * @memberof flyteidl.admin.WorkflowList
             * @instance
             */
            WorkflowList.prototype.token = "";

            /**
             * Creates a new WorkflowList instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.WorkflowList
             * @static
             * @param {flyteidl.admin.IWorkflowList=} [properties] Properties to set
             * @returns {flyteidl.admin.WorkflowList} WorkflowList instance
             */
            WorkflowList.create = function create(properties) {
                return new WorkflowList(properties);
            };

            /**
             * Encodes the specified WorkflowList message. Does not implicitly {@link flyteidl.admin.WorkflowList.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.WorkflowList
             * @static
             * @param {flyteidl.admin.IWorkflowList} message WorkflowList message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WorkflowList.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.workflows != null && message.workflows.length)
                    for (let i = 0; i < message.workflows.length; ++i)
                        $root.flyteidl.admin.Workflow.encode(message.workflows[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.token != null && message.hasOwnProperty("token"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.token);
                return writer;
            };

            /**
             * Decodes a WorkflowList message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.WorkflowList
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.WorkflowList} WorkflowList
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WorkflowList.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.WorkflowList();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.workflows && message.workflows.length))
                            message.workflows = [];
                        message.workflows.push($root.flyteidl.admin.Workflow.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        message.token = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a WorkflowList message.
             * @function verify
             * @memberof flyteidl.admin.WorkflowList
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WorkflowList.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.workflows != null && message.hasOwnProperty("workflows")) {
                    if (!Array.isArray(message.workflows))
                        return "workflows: array expected";
                    for (let i = 0; i < message.workflows.length; ++i) {
                        let error = $root.flyteidl.admin.Workflow.verify(message.workflows[i]);
                        if (error)
                            return "workflows." + error;
                    }
                }
                if (message.token != null && message.hasOwnProperty("token"))
                    if (!$util.isString(message.token))
                        return "token: string expected";
                return null;
            };

            return WorkflowList;
        })();

        admin.WorkflowSpec = (function() {

            /**
             * Properties of a WorkflowSpec.
             * @memberof flyteidl.admin
             * @interface IWorkflowSpec
             * @property {flyteidl.core.IWorkflowTemplate|null} [template] WorkflowSpec template
             * @property {Array.<flyteidl.core.IWorkflowTemplate>|null} [subWorkflows] WorkflowSpec subWorkflows
             */

            /**
             * Constructs a new WorkflowSpec.
             * @memberof flyteidl.admin
             * @classdesc Represents a WorkflowSpec.
             * @implements IWorkflowSpec
             * @constructor
             * @param {flyteidl.admin.IWorkflowSpec=} [properties] Properties to set
             */
            function WorkflowSpec(properties) {
                this.subWorkflows = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WorkflowSpec template.
             * @member {flyteidl.core.IWorkflowTemplate|null|undefined} template
             * @memberof flyteidl.admin.WorkflowSpec
             * @instance
             */
            WorkflowSpec.prototype.template = null;

            /**
             * WorkflowSpec subWorkflows.
             * @member {Array.<flyteidl.core.IWorkflowTemplate>} subWorkflows
             * @memberof flyteidl.admin.WorkflowSpec
             * @instance
             */
            WorkflowSpec.prototype.subWorkflows = $util.emptyArray;

            /**
             * Creates a new WorkflowSpec instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.WorkflowSpec
             * @static
             * @param {flyteidl.admin.IWorkflowSpec=} [properties] Properties to set
             * @returns {flyteidl.admin.WorkflowSpec} WorkflowSpec instance
             */
            WorkflowSpec.create = function create(properties) {
                return new WorkflowSpec(properties);
            };

            /**
             * Encodes the specified WorkflowSpec message. Does not implicitly {@link flyteidl.admin.WorkflowSpec.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.WorkflowSpec
             * @static
             * @param {flyteidl.admin.IWorkflowSpec} message WorkflowSpec message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WorkflowSpec.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.template != null && message.hasOwnProperty("template"))
                    $root.flyteidl.core.WorkflowTemplate.encode(message.template, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.subWorkflows != null && message.subWorkflows.length)
                    for (let i = 0; i < message.subWorkflows.length; ++i)
                        $root.flyteidl.core.WorkflowTemplate.encode(message.subWorkflows[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a WorkflowSpec message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.WorkflowSpec
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.WorkflowSpec} WorkflowSpec
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WorkflowSpec.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.WorkflowSpec();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.template = $root.flyteidl.core.WorkflowTemplate.decode(reader, reader.uint32());
                        break;
                    case 2:
                        if (!(message.subWorkflows && message.subWorkflows.length))
                            message.subWorkflows = [];
                        message.subWorkflows.push($root.flyteidl.core.WorkflowTemplate.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a WorkflowSpec message.
             * @function verify
             * @memberof flyteidl.admin.WorkflowSpec
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WorkflowSpec.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.template != null && message.hasOwnProperty("template")) {
                    let error = $root.flyteidl.core.WorkflowTemplate.verify(message.template);
                    if (error)
                        return "template." + error;
                }
                if (message.subWorkflows != null && message.hasOwnProperty("subWorkflows")) {
                    if (!Array.isArray(message.subWorkflows))
                        return "subWorkflows: array expected";
                    for (let i = 0; i < message.subWorkflows.length; ++i) {
                        let error = $root.flyteidl.core.WorkflowTemplate.verify(message.subWorkflows[i]);
                        if (error)
                            return "subWorkflows." + error;
                    }
                }
                return null;
            };

            return WorkflowSpec;
        })();

        admin.WorkflowClosure = (function() {

            /**
             * Properties of a WorkflowClosure.
             * @memberof flyteidl.admin
             * @interface IWorkflowClosure
             * @property {flyteidl.core.ICompiledWorkflowClosure|null} [compiledWorkflow] WorkflowClosure compiledWorkflow
             * @property {google.protobuf.ITimestamp|null} [createdAt] WorkflowClosure createdAt
             */

            /**
             * Constructs a new WorkflowClosure.
             * @memberof flyteidl.admin
             * @classdesc Represents a WorkflowClosure.
             * @implements IWorkflowClosure
             * @constructor
             * @param {flyteidl.admin.IWorkflowClosure=} [properties] Properties to set
             */
            function WorkflowClosure(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WorkflowClosure compiledWorkflow.
             * @member {flyteidl.core.ICompiledWorkflowClosure|null|undefined} compiledWorkflow
             * @memberof flyteidl.admin.WorkflowClosure
             * @instance
             */
            WorkflowClosure.prototype.compiledWorkflow = null;

            /**
             * WorkflowClosure createdAt.
             * @member {google.protobuf.ITimestamp|null|undefined} createdAt
             * @memberof flyteidl.admin.WorkflowClosure
             * @instance
             */
            WorkflowClosure.prototype.createdAt = null;

            /**
             * Creates a new WorkflowClosure instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.WorkflowClosure
             * @static
             * @param {flyteidl.admin.IWorkflowClosure=} [properties] Properties to set
             * @returns {flyteidl.admin.WorkflowClosure} WorkflowClosure instance
             */
            WorkflowClosure.create = function create(properties) {
                return new WorkflowClosure(properties);
            };

            /**
             * Encodes the specified WorkflowClosure message. Does not implicitly {@link flyteidl.admin.WorkflowClosure.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.WorkflowClosure
             * @static
             * @param {flyteidl.admin.IWorkflowClosure} message WorkflowClosure message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WorkflowClosure.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.compiledWorkflow != null && message.hasOwnProperty("compiledWorkflow"))
                    $root.flyteidl.core.CompiledWorkflowClosure.encode(message.compiledWorkflow, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.createdAt != null && message.hasOwnProperty("createdAt"))
                    $root.google.protobuf.Timestamp.encode(message.createdAt, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a WorkflowClosure message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.WorkflowClosure
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.WorkflowClosure} WorkflowClosure
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WorkflowClosure.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.WorkflowClosure();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.compiledWorkflow = $root.flyteidl.core.CompiledWorkflowClosure.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.createdAt = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a WorkflowClosure message.
             * @function verify
             * @memberof flyteidl.admin.WorkflowClosure
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WorkflowClosure.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.compiledWorkflow != null && message.hasOwnProperty("compiledWorkflow")) {
                    let error = $root.flyteidl.core.CompiledWorkflowClosure.verify(message.compiledWorkflow);
                    if (error)
                        return "compiledWorkflow." + error;
                }
                if (message.createdAt != null && message.hasOwnProperty("createdAt")) {
                    let error = $root.google.protobuf.Timestamp.verify(message.createdAt);
                    if (error)
                        return "createdAt." + error;
                }
                return null;
            };

            return WorkflowClosure;
        })();

        admin.WorkflowAttributes = (function() {

            /**
             * Properties of a WorkflowAttributes.
             * @memberof flyteidl.admin
             * @interface IWorkflowAttributes
             * @property {string|null} [project] WorkflowAttributes project
             * @property {string|null} [domain] WorkflowAttributes domain
             * @property {string|null} [workflow] WorkflowAttributes workflow
             * @property {flyteidl.admin.IMatchingAttributes|null} [matchingAttributes] WorkflowAttributes matchingAttributes
             */

            /**
             * Constructs a new WorkflowAttributes.
             * @memberof flyteidl.admin
             * @classdesc Represents a WorkflowAttributes.
             * @implements IWorkflowAttributes
             * @constructor
             * @param {flyteidl.admin.IWorkflowAttributes=} [properties] Properties to set
             */
            function WorkflowAttributes(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WorkflowAttributes project.
             * @member {string} project
             * @memberof flyteidl.admin.WorkflowAttributes
             * @instance
             */
            WorkflowAttributes.prototype.project = "";

            /**
             * WorkflowAttributes domain.
             * @member {string} domain
             * @memberof flyteidl.admin.WorkflowAttributes
             * @instance
             */
            WorkflowAttributes.prototype.domain = "";

            /**
             * WorkflowAttributes workflow.
             * @member {string} workflow
             * @memberof flyteidl.admin.WorkflowAttributes
             * @instance
             */
            WorkflowAttributes.prototype.workflow = "";

            /**
             * WorkflowAttributes matchingAttributes.
             * @member {flyteidl.admin.IMatchingAttributes|null|undefined} matchingAttributes
             * @memberof flyteidl.admin.WorkflowAttributes
             * @instance
             */
            WorkflowAttributes.prototype.matchingAttributes = null;

            /**
             * Creates a new WorkflowAttributes instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.WorkflowAttributes
             * @static
             * @param {flyteidl.admin.IWorkflowAttributes=} [properties] Properties to set
             * @returns {flyteidl.admin.WorkflowAttributes} WorkflowAttributes instance
             */
            WorkflowAttributes.create = function create(properties) {
                return new WorkflowAttributes(properties);
            };

            /**
             * Encodes the specified WorkflowAttributes message. Does not implicitly {@link flyteidl.admin.WorkflowAttributes.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.WorkflowAttributes
             * @static
             * @param {flyteidl.admin.IWorkflowAttributes} message WorkflowAttributes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WorkflowAttributes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.project != null && message.hasOwnProperty("project"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.project);
                if (message.domain != null && message.hasOwnProperty("domain"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.domain);
                if (message.workflow != null && message.hasOwnProperty("workflow"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.workflow);
                if (message.matchingAttributes != null && message.hasOwnProperty("matchingAttributes"))
                    $root.flyteidl.admin.MatchingAttributes.encode(message.matchingAttributes, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a WorkflowAttributes message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.WorkflowAttributes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.WorkflowAttributes} WorkflowAttributes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WorkflowAttributes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.WorkflowAttributes();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.project = reader.string();
                        break;
                    case 2:
                        message.domain = reader.string();
                        break;
                    case 3:
                        message.workflow = reader.string();
                        break;
                    case 4:
                        message.matchingAttributes = $root.flyteidl.admin.MatchingAttributes.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a WorkflowAttributes message.
             * @function verify
             * @memberof flyteidl.admin.WorkflowAttributes
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WorkflowAttributes.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.project != null && message.hasOwnProperty("project"))
                    if (!$util.isString(message.project))
                        return "project: string expected";
                if (message.domain != null && message.hasOwnProperty("domain"))
                    if (!$util.isString(message.domain))
                        return "domain: string expected";
                if (message.workflow != null && message.hasOwnProperty("workflow"))
                    if (!$util.isString(message.workflow))
                        return "workflow: string expected";
                if (message.matchingAttributes != null && message.hasOwnProperty("matchingAttributes")) {
                    let error = $root.flyteidl.admin.MatchingAttributes.verify(message.matchingAttributes);
                    if (error)
                        return "matchingAttributes." + error;
                }
                return null;
            };

            return WorkflowAttributes;
        })();

        admin.WorkflowAttributesUpdateRequest = (function() {

            /**
             * Properties of a WorkflowAttributesUpdateRequest.
             * @memberof flyteidl.admin
             * @interface IWorkflowAttributesUpdateRequest
             * @property {flyteidl.admin.IWorkflowAttributes|null} [attributes] WorkflowAttributesUpdateRequest attributes
             */

            /**
             * Constructs a new WorkflowAttributesUpdateRequest.
             * @memberof flyteidl.admin
             * @classdesc Represents a WorkflowAttributesUpdateRequest.
             * @implements IWorkflowAttributesUpdateRequest
             * @constructor
             * @param {flyteidl.admin.IWorkflowAttributesUpdateRequest=} [properties] Properties to set
             */
            function WorkflowAttributesUpdateRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WorkflowAttributesUpdateRequest attributes.
             * @member {flyteidl.admin.IWorkflowAttributes|null|undefined} attributes
             * @memberof flyteidl.admin.WorkflowAttributesUpdateRequest
             * @instance
             */
            WorkflowAttributesUpdateRequest.prototype.attributes = null;

            /**
             * Creates a new WorkflowAttributesUpdateRequest instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.WorkflowAttributesUpdateRequest
             * @static
             * @param {flyteidl.admin.IWorkflowAttributesUpdateRequest=} [properties] Properties to set
             * @returns {flyteidl.admin.WorkflowAttributesUpdateRequest} WorkflowAttributesUpdateRequest instance
             */
            WorkflowAttributesUpdateRequest.create = function create(properties) {
                return new WorkflowAttributesUpdateRequest(properties);
            };

            /**
             * Encodes the specified WorkflowAttributesUpdateRequest message. Does not implicitly {@link flyteidl.admin.WorkflowAttributesUpdateRequest.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.WorkflowAttributesUpdateRequest
             * @static
             * @param {flyteidl.admin.IWorkflowAttributesUpdateRequest} message WorkflowAttributesUpdateRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WorkflowAttributesUpdateRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.attributes != null && message.hasOwnProperty("attributes"))
                    $root.flyteidl.admin.WorkflowAttributes.encode(message.attributes, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a WorkflowAttributesUpdateRequest message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.WorkflowAttributesUpdateRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.WorkflowAttributesUpdateRequest} WorkflowAttributesUpdateRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WorkflowAttributesUpdateRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.WorkflowAttributesUpdateRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.attributes = $root.flyteidl.admin.WorkflowAttributes.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a WorkflowAttributesUpdateRequest message.
             * @function verify
             * @memberof flyteidl.admin.WorkflowAttributesUpdateRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WorkflowAttributesUpdateRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.attributes != null && message.hasOwnProperty("attributes")) {
                    let error = $root.flyteidl.admin.WorkflowAttributes.verify(message.attributes);
                    if (error)
                        return "attributes." + error;
                }
                return null;
            };

            return WorkflowAttributesUpdateRequest;
        })();

        admin.WorkflowAttributesUpdateResponse = (function() {

            /**
             * Properties of a WorkflowAttributesUpdateResponse.
             * @memberof flyteidl.admin
             * @interface IWorkflowAttributesUpdateResponse
             */

            /**
             * Constructs a new WorkflowAttributesUpdateResponse.
             * @memberof flyteidl.admin
             * @classdesc Represents a WorkflowAttributesUpdateResponse.
             * @implements IWorkflowAttributesUpdateResponse
             * @constructor
             * @param {flyteidl.admin.IWorkflowAttributesUpdateResponse=} [properties] Properties to set
             */
            function WorkflowAttributesUpdateResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new WorkflowAttributesUpdateResponse instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.WorkflowAttributesUpdateResponse
             * @static
             * @param {flyteidl.admin.IWorkflowAttributesUpdateResponse=} [properties] Properties to set
             * @returns {flyteidl.admin.WorkflowAttributesUpdateResponse} WorkflowAttributesUpdateResponse instance
             */
            WorkflowAttributesUpdateResponse.create = function create(properties) {
                return new WorkflowAttributesUpdateResponse(properties);
            };

            /**
             * Encodes the specified WorkflowAttributesUpdateResponse message. Does not implicitly {@link flyteidl.admin.WorkflowAttributesUpdateResponse.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.WorkflowAttributesUpdateResponse
             * @static
             * @param {flyteidl.admin.IWorkflowAttributesUpdateResponse} message WorkflowAttributesUpdateResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WorkflowAttributesUpdateResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Decodes a WorkflowAttributesUpdateResponse message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.WorkflowAttributesUpdateResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.WorkflowAttributesUpdateResponse} WorkflowAttributesUpdateResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WorkflowAttributesUpdateResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.WorkflowAttributesUpdateResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a WorkflowAttributesUpdateResponse message.
             * @function verify
             * @memberof flyteidl.admin.WorkflowAttributesUpdateResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WorkflowAttributesUpdateResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            return WorkflowAttributesUpdateResponse;
        })();

        admin.WorkflowAttributesGetRequest = (function() {

            /**
             * Properties of a WorkflowAttributesGetRequest.
             * @memberof flyteidl.admin
             * @interface IWorkflowAttributesGetRequest
             * @property {string|null} [project] WorkflowAttributesGetRequest project
             * @property {string|null} [domain] WorkflowAttributesGetRequest domain
             * @property {string|null} [workflow] WorkflowAttributesGetRequest workflow
             * @property {flyteidl.admin.MatchableResource|null} [resourceType] WorkflowAttributesGetRequest resourceType
             */

            /**
             * Constructs a new WorkflowAttributesGetRequest.
             * @memberof flyteidl.admin
             * @classdesc Represents a WorkflowAttributesGetRequest.
             * @implements IWorkflowAttributesGetRequest
             * @constructor
             * @param {flyteidl.admin.IWorkflowAttributesGetRequest=} [properties] Properties to set
             */
            function WorkflowAttributesGetRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WorkflowAttributesGetRequest project.
             * @member {string} project
             * @memberof flyteidl.admin.WorkflowAttributesGetRequest
             * @instance
             */
            WorkflowAttributesGetRequest.prototype.project = "";

            /**
             * WorkflowAttributesGetRequest domain.
             * @member {string} domain
             * @memberof flyteidl.admin.WorkflowAttributesGetRequest
             * @instance
             */
            WorkflowAttributesGetRequest.prototype.domain = "";

            /**
             * WorkflowAttributesGetRequest workflow.
             * @member {string} workflow
             * @memberof flyteidl.admin.WorkflowAttributesGetRequest
             * @instance
             */
            WorkflowAttributesGetRequest.prototype.workflow = "";

            /**
             * WorkflowAttributesGetRequest resourceType.
             * @member {flyteidl.admin.MatchableResource} resourceType
             * @memberof flyteidl.admin.WorkflowAttributesGetRequest
             * @instance
             */
            WorkflowAttributesGetRequest.prototype.resourceType = 0;

            /**
             * Creates a new WorkflowAttributesGetRequest instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.WorkflowAttributesGetRequest
             * @static
             * @param {flyteidl.admin.IWorkflowAttributesGetRequest=} [properties] Properties to set
             * @returns {flyteidl.admin.WorkflowAttributesGetRequest} WorkflowAttributesGetRequest instance
             */
            WorkflowAttributesGetRequest.create = function create(properties) {
                return new WorkflowAttributesGetRequest(properties);
            };

            /**
             * Encodes the specified WorkflowAttributesGetRequest message. Does not implicitly {@link flyteidl.admin.WorkflowAttributesGetRequest.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.WorkflowAttributesGetRequest
             * @static
             * @param {flyteidl.admin.IWorkflowAttributesGetRequest} message WorkflowAttributesGetRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WorkflowAttributesGetRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.project != null && message.hasOwnProperty("project"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.project);
                if (message.domain != null && message.hasOwnProperty("domain"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.domain);
                if (message.workflow != null && message.hasOwnProperty("workflow"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.workflow);
                if (message.resourceType != null && message.hasOwnProperty("resourceType"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.resourceType);
                return writer;
            };

            /**
             * Decodes a WorkflowAttributesGetRequest message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.WorkflowAttributesGetRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.WorkflowAttributesGetRequest} WorkflowAttributesGetRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WorkflowAttributesGetRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.WorkflowAttributesGetRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.project = reader.string();
                        break;
                    case 2:
                        message.domain = reader.string();
                        break;
                    case 3:
                        message.workflow = reader.string();
                        break;
                    case 4:
                        message.resourceType = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a WorkflowAttributesGetRequest message.
             * @function verify
             * @memberof flyteidl.admin.WorkflowAttributesGetRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WorkflowAttributesGetRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.project != null && message.hasOwnProperty("project"))
                    if (!$util.isString(message.project))
                        return "project: string expected";
                if (message.domain != null && message.hasOwnProperty("domain"))
                    if (!$util.isString(message.domain))
                        return "domain: string expected";
                if (message.workflow != null && message.hasOwnProperty("workflow"))
                    if (!$util.isString(message.workflow))
                        return "workflow: string expected";
                if (message.resourceType != null && message.hasOwnProperty("resourceType"))
                    switch (message.resourceType) {
                    default:
                        return "resourceType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                return null;
            };

            return WorkflowAttributesGetRequest;
        })();

        admin.WorkflowAttributesGetResponse = (function() {

            /**
             * Properties of a WorkflowAttributesGetResponse.
             * @memberof flyteidl.admin
             * @interface IWorkflowAttributesGetResponse
             * @property {flyteidl.admin.IWorkflowAttributes|null} [attributes] WorkflowAttributesGetResponse attributes
             */

            /**
             * Constructs a new WorkflowAttributesGetResponse.
             * @memberof flyteidl.admin
             * @classdesc Represents a WorkflowAttributesGetResponse.
             * @implements IWorkflowAttributesGetResponse
             * @constructor
             * @param {flyteidl.admin.IWorkflowAttributesGetResponse=} [properties] Properties to set
             */
            function WorkflowAttributesGetResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WorkflowAttributesGetResponse attributes.
             * @member {flyteidl.admin.IWorkflowAttributes|null|undefined} attributes
             * @memberof flyteidl.admin.WorkflowAttributesGetResponse
             * @instance
             */
            WorkflowAttributesGetResponse.prototype.attributes = null;

            /**
             * Creates a new WorkflowAttributesGetResponse instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.WorkflowAttributesGetResponse
             * @static
             * @param {flyteidl.admin.IWorkflowAttributesGetResponse=} [properties] Properties to set
             * @returns {flyteidl.admin.WorkflowAttributesGetResponse} WorkflowAttributesGetResponse instance
             */
            WorkflowAttributesGetResponse.create = function create(properties) {
                return new WorkflowAttributesGetResponse(properties);
            };

            /**
             * Encodes the specified WorkflowAttributesGetResponse message. Does not implicitly {@link flyteidl.admin.WorkflowAttributesGetResponse.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.WorkflowAttributesGetResponse
             * @static
             * @param {flyteidl.admin.IWorkflowAttributesGetResponse} message WorkflowAttributesGetResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WorkflowAttributesGetResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.attributes != null && message.hasOwnProperty("attributes"))
                    $root.flyteidl.admin.WorkflowAttributes.encode(message.attributes, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a WorkflowAttributesGetResponse message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.WorkflowAttributesGetResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.WorkflowAttributesGetResponse} WorkflowAttributesGetResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WorkflowAttributesGetResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.WorkflowAttributesGetResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.attributes = $root.flyteidl.admin.WorkflowAttributes.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a WorkflowAttributesGetResponse message.
             * @function verify
             * @memberof flyteidl.admin.WorkflowAttributesGetResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WorkflowAttributesGetResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.attributes != null && message.hasOwnProperty("attributes")) {
                    let error = $root.flyteidl.admin.WorkflowAttributes.verify(message.attributes);
                    if (error)
                        return "attributes." + error;
                }
                return null;
            };

            return WorkflowAttributesGetResponse;
        })();

        admin.WorkflowAttributesDeleteRequest = (function() {

            /**
             * Properties of a WorkflowAttributesDeleteRequest.
             * @memberof flyteidl.admin
             * @interface IWorkflowAttributesDeleteRequest
             * @property {string|null} [project] WorkflowAttributesDeleteRequest project
             * @property {string|null} [domain] WorkflowAttributesDeleteRequest domain
             * @property {string|null} [workflow] WorkflowAttributesDeleteRequest workflow
             * @property {flyteidl.admin.MatchableResource|null} [resourceType] WorkflowAttributesDeleteRequest resourceType
             */

            /**
             * Constructs a new WorkflowAttributesDeleteRequest.
             * @memberof flyteidl.admin
             * @classdesc Represents a WorkflowAttributesDeleteRequest.
             * @implements IWorkflowAttributesDeleteRequest
             * @constructor
             * @param {flyteidl.admin.IWorkflowAttributesDeleteRequest=} [properties] Properties to set
             */
            function WorkflowAttributesDeleteRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WorkflowAttributesDeleteRequest project.
             * @member {string} project
             * @memberof flyteidl.admin.WorkflowAttributesDeleteRequest
             * @instance
             */
            WorkflowAttributesDeleteRequest.prototype.project = "";

            /**
             * WorkflowAttributesDeleteRequest domain.
             * @member {string} domain
             * @memberof flyteidl.admin.WorkflowAttributesDeleteRequest
             * @instance
             */
            WorkflowAttributesDeleteRequest.prototype.domain = "";

            /**
             * WorkflowAttributesDeleteRequest workflow.
             * @member {string} workflow
             * @memberof flyteidl.admin.WorkflowAttributesDeleteRequest
             * @instance
             */
            WorkflowAttributesDeleteRequest.prototype.workflow = "";

            /**
             * WorkflowAttributesDeleteRequest resourceType.
             * @member {flyteidl.admin.MatchableResource} resourceType
             * @memberof flyteidl.admin.WorkflowAttributesDeleteRequest
             * @instance
             */
            WorkflowAttributesDeleteRequest.prototype.resourceType = 0;

            /**
             * Creates a new WorkflowAttributesDeleteRequest instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.WorkflowAttributesDeleteRequest
             * @static
             * @param {flyteidl.admin.IWorkflowAttributesDeleteRequest=} [properties] Properties to set
             * @returns {flyteidl.admin.WorkflowAttributesDeleteRequest} WorkflowAttributesDeleteRequest instance
             */
            WorkflowAttributesDeleteRequest.create = function create(properties) {
                return new WorkflowAttributesDeleteRequest(properties);
            };

            /**
             * Encodes the specified WorkflowAttributesDeleteRequest message. Does not implicitly {@link flyteidl.admin.WorkflowAttributesDeleteRequest.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.WorkflowAttributesDeleteRequest
             * @static
             * @param {flyteidl.admin.IWorkflowAttributesDeleteRequest} message WorkflowAttributesDeleteRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WorkflowAttributesDeleteRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.project != null && message.hasOwnProperty("project"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.project);
                if (message.domain != null && message.hasOwnProperty("domain"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.domain);
                if (message.workflow != null && message.hasOwnProperty("workflow"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.workflow);
                if (message.resourceType != null && message.hasOwnProperty("resourceType"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.resourceType);
                return writer;
            };

            /**
             * Decodes a WorkflowAttributesDeleteRequest message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.WorkflowAttributesDeleteRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.WorkflowAttributesDeleteRequest} WorkflowAttributesDeleteRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WorkflowAttributesDeleteRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.WorkflowAttributesDeleteRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.project = reader.string();
                        break;
                    case 2:
                        message.domain = reader.string();
                        break;
                    case 3:
                        message.workflow = reader.string();
                        break;
                    case 4:
                        message.resourceType = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a WorkflowAttributesDeleteRequest message.
             * @function verify
             * @memberof flyteidl.admin.WorkflowAttributesDeleteRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WorkflowAttributesDeleteRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.project != null && message.hasOwnProperty("project"))
                    if (!$util.isString(message.project))
                        return "project: string expected";
                if (message.domain != null && message.hasOwnProperty("domain"))
                    if (!$util.isString(message.domain))
                        return "domain: string expected";
                if (message.workflow != null && message.hasOwnProperty("workflow"))
                    if (!$util.isString(message.workflow))
                        return "workflow: string expected";
                if (message.resourceType != null && message.hasOwnProperty("resourceType"))
                    switch (message.resourceType) {
                    default:
                        return "resourceType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                return null;
            };

            return WorkflowAttributesDeleteRequest;
        })();

        admin.WorkflowAttributesDeleteResponse = (function() {

            /**
             * Properties of a WorkflowAttributesDeleteResponse.
             * @memberof flyteidl.admin
             * @interface IWorkflowAttributesDeleteResponse
             */

            /**
             * Constructs a new WorkflowAttributesDeleteResponse.
             * @memberof flyteidl.admin
             * @classdesc Represents a WorkflowAttributesDeleteResponse.
             * @implements IWorkflowAttributesDeleteResponse
             * @constructor
             * @param {flyteidl.admin.IWorkflowAttributesDeleteResponse=} [properties] Properties to set
             */
            function WorkflowAttributesDeleteResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new WorkflowAttributesDeleteResponse instance using the specified properties.
             * @function create
             * @memberof flyteidl.admin.WorkflowAttributesDeleteResponse
             * @static
             * @param {flyteidl.admin.IWorkflowAttributesDeleteResponse=} [properties] Properties to set
             * @returns {flyteidl.admin.WorkflowAttributesDeleteResponse} WorkflowAttributesDeleteResponse instance
             */
            WorkflowAttributesDeleteResponse.create = function create(properties) {
                return new WorkflowAttributesDeleteResponse(properties);
            };

            /**
             * Encodes the specified WorkflowAttributesDeleteResponse message. Does not implicitly {@link flyteidl.admin.WorkflowAttributesDeleteResponse.verify|verify} messages.
             * @function encode
             * @memberof flyteidl.admin.WorkflowAttributesDeleteResponse
             * @static
             * @param {flyteidl.admin.IWorkflowAttributesDeleteResponse} message WorkflowAttributesDeleteResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WorkflowAttributesDeleteResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Decodes a WorkflowAttributesDeleteResponse message from the specified reader or buffer.
             * @function decode
             * @memberof flyteidl.admin.WorkflowAttributesDeleteResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {flyteidl.admin.WorkflowAttributesDeleteResponse} WorkflowAttributesDeleteResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WorkflowAttributesDeleteResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.flyteidl.admin.WorkflowAttributesDeleteResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a WorkflowAttributesDeleteResponse message.
             * @function verify
             * @memberof flyteidl.admin.WorkflowAttributesDeleteResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WorkflowAttributesDeleteResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            return WorkflowAttributesDeleteResponse;
        })();

        return admin;
    })();

    flyteidl.service = (function() {

        /**
         * Namespace service.
         * @memberof flyteidl
         * @namespace
         */
        const service = {};

        service.AdminService = (function() {

            /**
             * Constructs a new AdminService service.
             * @memberof flyteidl.service
             * @classdesc Represents an AdminService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function AdminService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (AdminService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = AdminService;

            /**
             * Creates new AdminService service using the specified rpc implementation.
             * @function create
             * @memberof flyteidl.service.AdminService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {AdminService} RPC service. Useful where requests and/or responses are streamed.
             */
            AdminService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link flyteidl.service.AdminService#createTask}.
             * @memberof flyteidl.service.AdminService
             * @typedef CreateTaskCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {flyteidl.admin.TaskCreateResponse} [response] TaskCreateResponse
             */

            /**
             * Calls CreateTask.
             * @function createTask
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.ITaskCreateRequest} request TaskCreateRequest message or plain object
             * @param {flyteidl.service.AdminService.CreateTaskCallback} callback Node-style callback called with the error, if any, and TaskCreateResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(AdminService.prototype.createTask = function createTask(request, callback) {
                return this.rpcCall(createTask, $root.flyteidl.admin.TaskCreateRequest, $root.flyteidl.admin.TaskCreateResponse, request, callback);
            }, "name", { value: "CreateTask" });

            /**
             * Calls CreateTask.
             * @function createTask
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.ITaskCreateRequest} request TaskCreateRequest message or plain object
             * @returns {Promise<flyteidl.admin.TaskCreateResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link flyteidl.service.AdminService#getTask}.
             * @memberof flyteidl.service.AdminService
             * @typedef GetTaskCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {flyteidl.admin.Task} [response] Task
             */

            /**
             * Calls GetTask.
             * @function getTask
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.IObjectGetRequest} request ObjectGetRequest message or plain object
             * @param {flyteidl.service.AdminService.GetTaskCallback} callback Node-style callback called with the error, if any, and Task
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(AdminService.prototype.getTask = function getTask(request, callback) {
                return this.rpcCall(getTask, $root.flyteidl.admin.ObjectGetRequest, $root.flyteidl.admin.Task, request, callback);
            }, "name", { value: "GetTask" });

            /**
             * Calls GetTask.
             * @function getTask
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.IObjectGetRequest} request ObjectGetRequest message or plain object
             * @returns {Promise<flyteidl.admin.Task>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link flyteidl.service.AdminService#listTaskIds}.
             * @memberof flyteidl.service.AdminService
             * @typedef ListTaskIdsCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {flyteidl.admin.NamedEntityIdentifierList} [response] NamedEntityIdentifierList
             */

            /**
             * Calls ListTaskIds.
             * @function listTaskIds
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.INamedEntityIdentifierListRequest} request NamedEntityIdentifierListRequest message or plain object
             * @param {flyteidl.service.AdminService.ListTaskIdsCallback} callback Node-style callback called with the error, if any, and NamedEntityIdentifierList
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(AdminService.prototype.listTaskIds = function listTaskIds(request, callback) {
                return this.rpcCall(listTaskIds, $root.flyteidl.admin.NamedEntityIdentifierListRequest, $root.flyteidl.admin.NamedEntityIdentifierList, request, callback);
            }, "name", { value: "ListTaskIds" });

            /**
             * Calls ListTaskIds.
             * @function listTaskIds
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.INamedEntityIdentifierListRequest} request NamedEntityIdentifierListRequest message or plain object
             * @returns {Promise<flyteidl.admin.NamedEntityIdentifierList>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link flyteidl.service.AdminService#listTasks}.
             * @memberof flyteidl.service.AdminService
             * @typedef ListTasksCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {flyteidl.admin.TaskList} [response] TaskList
             */

            /**
             * Calls ListTasks.
             * @function listTasks
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.IResourceListRequest} request ResourceListRequest message or plain object
             * @param {flyteidl.service.AdminService.ListTasksCallback} callback Node-style callback called with the error, if any, and TaskList
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(AdminService.prototype.listTasks = function listTasks(request, callback) {
                return this.rpcCall(listTasks, $root.flyteidl.admin.ResourceListRequest, $root.flyteidl.admin.TaskList, request, callback);
            }, "name", { value: "ListTasks" });

            /**
             * Calls ListTasks.
             * @function listTasks
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.IResourceListRequest} request ResourceListRequest message or plain object
             * @returns {Promise<flyteidl.admin.TaskList>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link flyteidl.service.AdminService#createWorkflow}.
             * @memberof flyteidl.service.AdminService
             * @typedef CreateWorkflowCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {flyteidl.admin.WorkflowCreateResponse} [response] WorkflowCreateResponse
             */

            /**
             * Calls CreateWorkflow.
             * @function createWorkflow
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.IWorkflowCreateRequest} request WorkflowCreateRequest message or plain object
             * @param {flyteidl.service.AdminService.CreateWorkflowCallback} callback Node-style callback called with the error, if any, and WorkflowCreateResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(AdminService.prototype.createWorkflow = function createWorkflow(request, callback) {
                return this.rpcCall(createWorkflow, $root.flyteidl.admin.WorkflowCreateRequest, $root.flyteidl.admin.WorkflowCreateResponse, request, callback);
            }, "name", { value: "CreateWorkflow" });

            /**
             * Calls CreateWorkflow.
             * @function createWorkflow
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.IWorkflowCreateRequest} request WorkflowCreateRequest message or plain object
             * @returns {Promise<flyteidl.admin.WorkflowCreateResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link flyteidl.service.AdminService#getWorkflow}.
             * @memberof flyteidl.service.AdminService
             * @typedef GetWorkflowCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {flyteidl.admin.Workflow} [response] Workflow
             */

            /**
             * Calls GetWorkflow.
             * @function getWorkflow
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.IObjectGetRequest} request ObjectGetRequest message or plain object
             * @param {flyteidl.service.AdminService.GetWorkflowCallback} callback Node-style callback called with the error, if any, and Workflow
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(AdminService.prototype.getWorkflow = function getWorkflow(request, callback) {
                return this.rpcCall(getWorkflow, $root.flyteidl.admin.ObjectGetRequest, $root.flyteidl.admin.Workflow, request, callback);
            }, "name", { value: "GetWorkflow" });

            /**
             * Calls GetWorkflow.
             * @function getWorkflow
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.IObjectGetRequest} request ObjectGetRequest message or plain object
             * @returns {Promise<flyteidl.admin.Workflow>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link flyteidl.service.AdminService#listWorkflowIds}.
             * @memberof flyteidl.service.AdminService
             * @typedef ListWorkflowIdsCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {flyteidl.admin.NamedEntityIdentifierList} [response] NamedEntityIdentifierList
             */

            /**
             * Calls ListWorkflowIds.
             * @function listWorkflowIds
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.INamedEntityIdentifierListRequest} request NamedEntityIdentifierListRequest message or plain object
             * @param {flyteidl.service.AdminService.ListWorkflowIdsCallback} callback Node-style callback called with the error, if any, and NamedEntityIdentifierList
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(AdminService.prototype.listWorkflowIds = function listWorkflowIds(request, callback) {
                return this.rpcCall(listWorkflowIds, $root.flyteidl.admin.NamedEntityIdentifierListRequest, $root.flyteidl.admin.NamedEntityIdentifierList, request, callback);
            }, "name", { value: "ListWorkflowIds" });

            /**
             * Calls ListWorkflowIds.
             * @function listWorkflowIds
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.INamedEntityIdentifierListRequest} request NamedEntityIdentifierListRequest message or plain object
             * @returns {Promise<flyteidl.admin.NamedEntityIdentifierList>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link flyteidl.service.AdminService#listWorkflows}.
             * @memberof flyteidl.service.AdminService
             * @typedef ListWorkflowsCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {flyteidl.admin.WorkflowList} [response] WorkflowList
             */

            /**
             * Calls ListWorkflows.
             * @function listWorkflows
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.IResourceListRequest} request ResourceListRequest message or plain object
             * @param {flyteidl.service.AdminService.ListWorkflowsCallback} callback Node-style callback called with the error, if any, and WorkflowList
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(AdminService.prototype.listWorkflows = function listWorkflows(request, callback) {
                return this.rpcCall(listWorkflows, $root.flyteidl.admin.ResourceListRequest, $root.flyteidl.admin.WorkflowList, request, callback);
            }, "name", { value: "ListWorkflows" });

            /**
             * Calls ListWorkflows.
             * @function listWorkflows
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.IResourceListRequest} request ResourceListRequest message or plain object
             * @returns {Promise<flyteidl.admin.WorkflowList>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link flyteidl.service.AdminService#createLaunchPlan}.
             * @memberof flyteidl.service.AdminService
             * @typedef CreateLaunchPlanCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {flyteidl.admin.LaunchPlanCreateResponse} [response] LaunchPlanCreateResponse
             */

            /**
             * Calls CreateLaunchPlan.
             * @function createLaunchPlan
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.ILaunchPlanCreateRequest} request LaunchPlanCreateRequest message or plain object
             * @param {flyteidl.service.AdminService.CreateLaunchPlanCallback} callback Node-style callback called with the error, if any, and LaunchPlanCreateResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(AdminService.prototype.createLaunchPlan = function createLaunchPlan(request, callback) {
                return this.rpcCall(createLaunchPlan, $root.flyteidl.admin.LaunchPlanCreateRequest, $root.flyteidl.admin.LaunchPlanCreateResponse, request, callback);
            }, "name", { value: "CreateLaunchPlan" });

            /**
             * Calls CreateLaunchPlan.
             * @function createLaunchPlan
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.ILaunchPlanCreateRequest} request LaunchPlanCreateRequest message or plain object
             * @returns {Promise<flyteidl.admin.LaunchPlanCreateResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link flyteidl.service.AdminService#getLaunchPlan}.
             * @memberof flyteidl.service.AdminService
             * @typedef GetLaunchPlanCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {flyteidl.admin.LaunchPlan} [response] LaunchPlan
             */

            /**
             * Calls GetLaunchPlan.
             * @function getLaunchPlan
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.IObjectGetRequest} request ObjectGetRequest message or plain object
             * @param {flyteidl.service.AdminService.GetLaunchPlanCallback} callback Node-style callback called with the error, if any, and LaunchPlan
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(AdminService.prototype.getLaunchPlan = function getLaunchPlan(request, callback) {
                return this.rpcCall(getLaunchPlan, $root.flyteidl.admin.ObjectGetRequest, $root.flyteidl.admin.LaunchPlan, request, callback);
            }, "name", { value: "GetLaunchPlan" });

            /**
             * Calls GetLaunchPlan.
             * @function getLaunchPlan
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.IObjectGetRequest} request ObjectGetRequest message or plain object
             * @returns {Promise<flyteidl.admin.LaunchPlan>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link flyteidl.service.AdminService#getActiveLaunchPlan}.
             * @memberof flyteidl.service.AdminService
             * @typedef GetActiveLaunchPlanCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {flyteidl.admin.LaunchPlan} [response] LaunchPlan
             */

            /**
             * Calls GetActiveLaunchPlan.
             * @function getActiveLaunchPlan
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.IActiveLaunchPlanRequest} request ActiveLaunchPlanRequest message or plain object
             * @param {flyteidl.service.AdminService.GetActiveLaunchPlanCallback} callback Node-style callback called with the error, if any, and LaunchPlan
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(AdminService.prototype.getActiveLaunchPlan = function getActiveLaunchPlan(request, callback) {
                return this.rpcCall(getActiveLaunchPlan, $root.flyteidl.admin.ActiveLaunchPlanRequest, $root.flyteidl.admin.LaunchPlan, request, callback);
            }, "name", { value: "GetActiveLaunchPlan" });

            /**
             * Calls GetActiveLaunchPlan.
             * @function getActiveLaunchPlan
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.IActiveLaunchPlanRequest} request ActiveLaunchPlanRequest message or plain object
             * @returns {Promise<flyteidl.admin.LaunchPlan>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link flyteidl.service.AdminService#listActiveLaunchPlans}.
             * @memberof flyteidl.service.AdminService
             * @typedef ListActiveLaunchPlansCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {flyteidl.admin.LaunchPlanList} [response] LaunchPlanList
             */

            /**
             * Calls ListActiveLaunchPlans.
             * @function listActiveLaunchPlans
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.IActiveLaunchPlanListRequest} request ActiveLaunchPlanListRequest message or plain object
             * @param {flyteidl.service.AdminService.ListActiveLaunchPlansCallback} callback Node-style callback called with the error, if any, and LaunchPlanList
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(AdminService.prototype.listActiveLaunchPlans = function listActiveLaunchPlans(request, callback) {
                return this.rpcCall(listActiveLaunchPlans, $root.flyteidl.admin.ActiveLaunchPlanListRequest, $root.flyteidl.admin.LaunchPlanList, request, callback);
            }, "name", { value: "ListActiveLaunchPlans" });

            /**
             * Calls ListActiveLaunchPlans.
             * @function listActiveLaunchPlans
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.IActiveLaunchPlanListRequest} request ActiveLaunchPlanListRequest message or plain object
             * @returns {Promise<flyteidl.admin.LaunchPlanList>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link flyteidl.service.AdminService#listLaunchPlanIds}.
             * @memberof flyteidl.service.AdminService
             * @typedef ListLaunchPlanIdsCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {flyteidl.admin.NamedEntityIdentifierList} [response] NamedEntityIdentifierList
             */

            /**
             * Calls ListLaunchPlanIds.
             * @function listLaunchPlanIds
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.INamedEntityIdentifierListRequest} request NamedEntityIdentifierListRequest message or plain object
             * @param {flyteidl.service.AdminService.ListLaunchPlanIdsCallback} callback Node-style callback called with the error, if any, and NamedEntityIdentifierList
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(AdminService.prototype.listLaunchPlanIds = function listLaunchPlanIds(request, callback) {
                return this.rpcCall(listLaunchPlanIds, $root.flyteidl.admin.NamedEntityIdentifierListRequest, $root.flyteidl.admin.NamedEntityIdentifierList, request, callback);
            }, "name", { value: "ListLaunchPlanIds" });

            /**
             * Calls ListLaunchPlanIds.
             * @function listLaunchPlanIds
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.INamedEntityIdentifierListRequest} request NamedEntityIdentifierListRequest message or plain object
             * @returns {Promise<flyteidl.admin.NamedEntityIdentifierList>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link flyteidl.service.AdminService#listLaunchPlans}.
             * @memberof flyteidl.service.AdminService
             * @typedef ListLaunchPlansCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {flyteidl.admin.LaunchPlanList} [response] LaunchPlanList
             */

            /**
             * Calls ListLaunchPlans.
             * @function listLaunchPlans
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.IResourceListRequest} request ResourceListRequest message or plain object
             * @param {flyteidl.service.AdminService.ListLaunchPlansCallback} callback Node-style callback called with the error, if any, and LaunchPlanList
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(AdminService.prototype.listLaunchPlans = function listLaunchPlans(request, callback) {
                return this.rpcCall(listLaunchPlans, $root.flyteidl.admin.ResourceListRequest, $root.flyteidl.admin.LaunchPlanList, request, callback);
            }, "name", { value: "ListLaunchPlans" });

            /**
             * Calls ListLaunchPlans.
             * @function listLaunchPlans
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.IResourceListRequest} request ResourceListRequest message or plain object
             * @returns {Promise<flyteidl.admin.LaunchPlanList>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link flyteidl.service.AdminService#updateLaunchPlan}.
             * @memberof flyteidl.service.AdminService
             * @typedef UpdateLaunchPlanCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {flyteidl.admin.LaunchPlanUpdateResponse} [response] LaunchPlanUpdateResponse
             */

            /**
             * Calls UpdateLaunchPlan.
             * @function updateLaunchPlan
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.ILaunchPlanUpdateRequest} request LaunchPlanUpdateRequest message or plain object
             * @param {flyteidl.service.AdminService.UpdateLaunchPlanCallback} callback Node-style callback called with the error, if any, and LaunchPlanUpdateResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(AdminService.prototype.updateLaunchPlan = function updateLaunchPlan(request, callback) {
                return this.rpcCall(updateLaunchPlan, $root.flyteidl.admin.LaunchPlanUpdateRequest, $root.flyteidl.admin.LaunchPlanUpdateResponse, request, callback);
            }, "name", { value: "UpdateLaunchPlan" });

            /**
             * Calls UpdateLaunchPlan.
             * @function updateLaunchPlan
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.ILaunchPlanUpdateRequest} request LaunchPlanUpdateRequest message or plain object
             * @returns {Promise<flyteidl.admin.LaunchPlanUpdateResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link flyteidl.service.AdminService#createExecution}.
             * @memberof flyteidl.service.AdminService
             * @typedef CreateExecutionCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {flyteidl.admin.ExecutionCreateResponse} [response] ExecutionCreateResponse
             */

            /**
             * Calls CreateExecution.
             * @function createExecution
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.IExecutionCreateRequest} request ExecutionCreateRequest message or plain object
             * @param {flyteidl.service.AdminService.CreateExecutionCallback} callback Node-style callback called with the error, if any, and ExecutionCreateResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(AdminService.prototype.createExecution = function createExecution(request, callback) {
                return this.rpcCall(createExecution, $root.flyteidl.admin.ExecutionCreateRequest, $root.flyteidl.admin.ExecutionCreateResponse, request, callback);
            }, "name", { value: "CreateExecution" });

            /**
             * Calls CreateExecution.
             * @function createExecution
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.IExecutionCreateRequest} request ExecutionCreateRequest message or plain object
             * @returns {Promise<flyteidl.admin.ExecutionCreateResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link flyteidl.service.AdminService#relaunchExecution}.
             * @memberof flyteidl.service.AdminService
             * @typedef RelaunchExecutionCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {flyteidl.admin.ExecutionCreateResponse} [response] ExecutionCreateResponse
             */

            /**
             * Calls RelaunchExecution.
             * @function relaunchExecution
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.IExecutionRelaunchRequest} request ExecutionRelaunchRequest message or plain object
             * @param {flyteidl.service.AdminService.RelaunchExecutionCallback} callback Node-style callback called with the error, if any, and ExecutionCreateResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(AdminService.prototype.relaunchExecution = function relaunchExecution(request, callback) {
                return this.rpcCall(relaunchExecution, $root.flyteidl.admin.ExecutionRelaunchRequest, $root.flyteidl.admin.ExecutionCreateResponse, request, callback);
            }, "name", { value: "RelaunchExecution" });

            /**
             * Calls RelaunchExecution.
             * @function relaunchExecution
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.IExecutionRelaunchRequest} request ExecutionRelaunchRequest message or plain object
             * @returns {Promise<flyteidl.admin.ExecutionCreateResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link flyteidl.service.AdminService#getExecution}.
             * @memberof flyteidl.service.AdminService
             * @typedef GetExecutionCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {flyteidl.admin.Execution} [response] Execution
             */

            /**
             * Calls GetExecution.
             * @function getExecution
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.IWorkflowExecutionGetRequest} request WorkflowExecutionGetRequest message or plain object
             * @param {flyteidl.service.AdminService.GetExecutionCallback} callback Node-style callback called with the error, if any, and Execution
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(AdminService.prototype.getExecution = function getExecution(request, callback) {
                return this.rpcCall(getExecution, $root.flyteidl.admin.WorkflowExecutionGetRequest, $root.flyteidl.admin.Execution, request, callback);
            }, "name", { value: "GetExecution" });

            /**
             * Calls GetExecution.
             * @function getExecution
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.IWorkflowExecutionGetRequest} request WorkflowExecutionGetRequest message or plain object
             * @returns {Promise<flyteidl.admin.Execution>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link flyteidl.service.AdminService#getExecutionData}.
             * @memberof flyteidl.service.AdminService
             * @typedef GetExecutionDataCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {flyteidl.admin.WorkflowExecutionGetDataResponse} [response] WorkflowExecutionGetDataResponse
             */

            /**
             * Calls GetExecutionData.
             * @function getExecutionData
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.IWorkflowExecutionGetDataRequest} request WorkflowExecutionGetDataRequest message or plain object
             * @param {flyteidl.service.AdminService.GetExecutionDataCallback} callback Node-style callback called with the error, if any, and WorkflowExecutionGetDataResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(AdminService.prototype.getExecutionData = function getExecutionData(request, callback) {
                return this.rpcCall(getExecutionData, $root.flyteidl.admin.WorkflowExecutionGetDataRequest, $root.flyteidl.admin.WorkflowExecutionGetDataResponse, request, callback);
            }, "name", { value: "GetExecutionData" });

            /**
             * Calls GetExecutionData.
             * @function getExecutionData
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.IWorkflowExecutionGetDataRequest} request WorkflowExecutionGetDataRequest message or plain object
             * @returns {Promise<flyteidl.admin.WorkflowExecutionGetDataResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link flyteidl.service.AdminService#listExecutions}.
             * @memberof flyteidl.service.AdminService
             * @typedef ListExecutionsCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {flyteidl.admin.ExecutionList} [response] ExecutionList
             */

            /**
             * Calls ListExecutions.
             * @function listExecutions
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.IResourceListRequest} request ResourceListRequest message or plain object
             * @param {flyteidl.service.AdminService.ListExecutionsCallback} callback Node-style callback called with the error, if any, and ExecutionList
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(AdminService.prototype.listExecutions = function listExecutions(request, callback) {
                return this.rpcCall(listExecutions, $root.flyteidl.admin.ResourceListRequest, $root.flyteidl.admin.ExecutionList, request, callback);
            }, "name", { value: "ListExecutions" });

            /**
             * Calls ListExecutions.
             * @function listExecutions
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.IResourceListRequest} request ResourceListRequest message or plain object
             * @returns {Promise<flyteidl.admin.ExecutionList>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link flyteidl.service.AdminService#terminateExecution}.
             * @memberof flyteidl.service.AdminService
             * @typedef TerminateExecutionCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {flyteidl.admin.ExecutionTerminateResponse} [response] ExecutionTerminateResponse
             */

            /**
             * Calls TerminateExecution.
             * @function terminateExecution
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.IExecutionTerminateRequest} request ExecutionTerminateRequest message or plain object
             * @param {flyteidl.service.AdminService.TerminateExecutionCallback} callback Node-style callback called with the error, if any, and ExecutionTerminateResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(AdminService.prototype.terminateExecution = function terminateExecution(request, callback) {
                return this.rpcCall(terminateExecution, $root.flyteidl.admin.ExecutionTerminateRequest, $root.flyteidl.admin.ExecutionTerminateResponse, request, callback);
            }, "name", { value: "TerminateExecution" });

            /**
             * Calls TerminateExecution.
             * @function terminateExecution
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.IExecutionTerminateRequest} request ExecutionTerminateRequest message or plain object
             * @returns {Promise<flyteidl.admin.ExecutionTerminateResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link flyteidl.service.AdminService#getNodeExecution}.
             * @memberof flyteidl.service.AdminService
             * @typedef GetNodeExecutionCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {flyteidl.admin.NodeExecution} [response] NodeExecution
             */

            /**
             * Calls GetNodeExecution.
             * @function getNodeExecution
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.INodeExecutionGetRequest} request NodeExecutionGetRequest message or plain object
             * @param {flyteidl.service.AdminService.GetNodeExecutionCallback} callback Node-style callback called with the error, if any, and NodeExecution
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(AdminService.prototype.getNodeExecution = function getNodeExecution(request, callback) {
                return this.rpcCall(getNodeExecution, $root.flyteidl.admin.NodeExecutionGetRequest, $root.flyteidl.admin.NodeExecution, request, callback);
            }, "name", { value: "GetNodeExecution" });

            /**
             * Calls GetNodeExecution.
             * @function getNodeExecution
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.INodeExecutionGetRequest} request NodeExecutionGetRequest message or plain object
             * @returns {Promise<flyteidl.admin.NodeExecution>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link flyteidl.service.AdminService#listNodeExecutions}.
             * @memberof flyteidl.service.AdminService
             * @typedef ListNodeExecutionsCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {flyteidl.admin.NodeExecutionList} [response] NodeExecutionList
             */

            /**
             * Calls ListNodeExecutions.
             * @function listNodeExecutions
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.INodeExecutionListRequest} request NodeExecutionListRequest message or plain object
             * @param {flyteidl.service.AdminService.ListNodeExecutionsCallback} callback Node-style callback called with the error, if any, and NodeExecutionList
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(AdminService.prototype.listNodeExecutions = function listNodeExecutions(request, callback) {
                return this.rpcCall(listNodeExecutions, $root.flyteidl.admin.NodeExecutionListRequest, $root.flyteidl.admin.NodeExecutionList, request, callback);
            }, "name", { value: "ListNodeExecutions" });

            /**
             * Calls ListNodeExecutions.
             * @function listNodeExecutions
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.INodeExecutionListRequest} request NodeExecutionListRequest message or plain object
             * @returns {Promise<flyteidl.admin.NodeExecutionList>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link flyteidl.service.AdminService#listNodeExecutionsForTask}.
             * @memberof flyteidl.service.AdminService
             * @typedef ListNodeExecutionsForTaskCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {flyteidl.admin.NodeExecutionList} [response] NodeExecutionList
             */

            /**
             * Calls ListNodeExecutionsForTask.
             * @function listNodeExecutionsForTask
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.INodeExecutionForTaskListRequest} request NodeExecutionForTaskListRequest message or plain object
             * @param {flyteidl.service.AdminService.ListNodeExecutionsForTaskCallback} callback Node-style callback called with the error, if any, and NodeExecutionList
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(AdminService.prototype.listNodeExecutionsForTask = function listNodeExecutionsForTask(request, callback) {
                return this.rpcCall(listNodeExecutionsForTask, $root.flyteidl.admin.NodeExecutionForTaskListRequest, $root.flyteidl.admin.NodeExecutionList, request, callback);
            }, "name", { value: "ListNodeExecutionsForTask" });

            /**
             * Calls ListNodeExecutionsForTask.
             * @function listNodeExecutionsForTask
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.INodeExecutionForTaskListRequest} request NodeExecutionForTaskListRequest message or plain object
             * @returns {Promise<flyteidl.admin.NodeExecutionList>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link flyteidl.service.AdminService#getNodeExecutionData}.
             * @memberof flyteidl.service.AdminService
             * @typedef GetNodeExecutionDataCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {flyteidl.admin.NodeExecutionGetDataResponse} [response] NodeExecutionGetDataResponse
             */

            /**
             * Calls GetNodeExecutionData.
             * @function getNodeExecutionData
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.INodeExecutionGetDataRequest} request NodeExecutionGetDataRequest message or plain object
             * @param {flyteidl.service.AdminService.GetNodeExecutionDataCallback} callback Node-style callback called with the error, if any, and NodeExecutionGetDataResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(AdminService.prototype.getNodeExecutionData = function getNodeExecutionData(request, callback) {
                return this.rpcCall(getNodeExecutionData, $root.flyteidl.admin.NodeExecutionGetDataRequest, $root.flyteidl.admin.NodeExecutionGetDataResponse, request, callback);
            }, "name", { value: "GetNodeExecutionData" });

            /**
             * Calls GetNodeExecutionData.
             * @function getNodeExecutionData
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.INodeExecutionGetDataRequest} request NodeExecutionGetDataRequest message or plain object
             * @returns {Promise<flyteidl.admin.NodeExecutionGetDataResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link flyteidl.service.AdminService#registerProject}.
             * @memberof flyteidl.service.AdminService
             * @typedef RegisterProjectCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {flyteidl.admin.ProjectRegisterResponse} [response] ProjectRegisterResponse
             */

            /**
             * Calls RegisterProject.
             * @function registerProject
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.IProjectRegisterRequest} request ProjectRegisterRequest message or plain object
             * @param {flyteidl.service.AdminService.RegisterProjectCallback} callback Node-style callback called with the error, if any, and ProjectRegisterResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(AdminService.prototype.registerProject = function registerProject(request, callback) {
                return this.rpcCall(registerProject, $root.flyteidl.admin.ProjectRegisterRequest, $root.flyteidl.admin.ProjectRegisterResponse, request, callback);
            }, "name", { value: "RegisterProject" });

            /**
             * Calls RegisterProject.
             * @function registerProject
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.IProjectRegisterRequest} request ProjectRegisterRequest message or plain object
             * @returns {Promise<flyteidl.admin.ProjectRegisterResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link flyteidl.service.AdminService#listProjects}.
             * @memberof flyteidl.service.AdminService
             * @typedef ListProjectsCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {flyteidl.admin.Projects} [response] Projects
             */

            /**
             * Calls ListProjects.
             * @function listProjects
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.IProjectListRequest} request ProjectListRequest message or plain object
             * @param {flyteidl.service.AdminService.ListProjectsCallback} callback Node-style callback called with the error, if any, and Projects
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(AdminService.prototype.listProjects = function listProjects(request, callback) {
                return this.rpcCall(listProjects, $root.flyteidl.admin.ProjectListRequest, $root.flyteidl.admin.Projects, request, callback);
            }, "name", { value: "ListProjects" });

            /**
             * Calls ListProjects.
             * @function listProjects
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.IProjectListRequest} request ProjectListRequest message or plain object
             * @returns {Promise<flyteidl.admin.Projects>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link flyteidl.service.AdminService#createWorkflowEvent}.
             * @memberof flyteidl.service.AdminService
             * @typedef CreateWorkflowEventCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {flyteidl.admin.WorkflowExecutionEventResponse} [response] WorkflowExecutionEventResponse
             */

            /**
             * Calls CreateWorkflowEvent.
             * @function createWorkflowEvent
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.IWorkflowExecutionEventRequest} request WorkflowExecutionEventRequest message or plain object
             * @param {flyteidl.service.AdminService.CreateWorkflowEventCallback} callback Node-style callback called with the error, if any, and WorkflowExecutionEventResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(AdminService.prototype.createWorkflowEvent = function createWorkflowEvent(request, callback) {
                return this.rpcCall(createWorkflowEvent, $root.flyteidl.admin.WorkflowExecutionEventRequest, $root.flyteidl.admin.WorkflowExecutionEventResponse, request, callback);
            }, "name", { value: "CreateWorkflowEvent" });

            /**
             * Calls CreateWorkflowEvent.
             * @function createWorkflowEvent
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.IWorkflowExecutionEventRequest} request WorkflowExecutionEventRequest message or plain object
             * @returns {Promise<flyteidl.admin.WorkflowExecutionEventResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link flyteidl.service.AdminService#createNodeEvent}.
             * @memberof flyteidl.service.AdminService
             * @typedef CreateNodeEventCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {flyteidl.admin.NodeExecutionEventResponse} [response] NodeExecutionEventResponse
             */

            /**
             * Calls CreateNodeEvent.
             * @function createNodeEvent
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.INodeExecutionEventRequest} request NodeExecutionEventRequest message or plain object
             * @param {flyteidl.service.AdminService.CreateNodeEventCallback} callback Node-style callback called with the error, if any, and NodeExecutionEventResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(AdminService.prototype.createNodeEvent = function createNodeEvent(request, callback) {
                return this.rpcCall(createNodeEvent, $root.flyteidl.admin.NodeExecutionEventRequest, $root.flyteidl.admin.NodeExecutionEventResponse, request, callback);
            }, "name", { value: "CreateNodeEvent" });

            /**
             * Calls CreateNodeEvent.
             * @function createNodeEvent
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.INodeExecutionEventRequest} request NodeExecutionEventRequest message or plain object
             * @returns {Promise<flyteidl.admin.NodeExecutionEventResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link flyteidl.service.AdminService#createTaskEvent}.
             * @memberof flyteidl.service.AdminService
             * @typedef CreateTaskEventCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {flyteidl.admin.TaskExecutionEventResponse} [response] TaskExecutionEventResponse
             */

            /**
             * Calls CreateTaskEvent.
             * @function createTaskEvent
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.ITaskExecutionEventRequest} request TaskExecutionEventRequest message or plain object
             * @param {flyteidl.service.AdminService.CreateTaskEventCallback} callback Node-style callback called with the error, if any, and TaskExecutionEventResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(AdminService.prototype.createTaskEvent = function createTaskEvent(request, callback) {
                return this.rpcCall(createTaskEvent, $root.flyteidl.admin.TaskExecutionEventRequest, $root.flyteidl.admin.TaskExecutionEventResponse, request, callback);
            }, "name", { value: "CreateTaskEvent" });

            /**
             * Calls CreateTaskEvent.
             * @function createTaskEvent
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.ITaskExecutionEventRequest} request TaskExecutionEventRequest message or plain object
             * @returns {Promise<flyteidl.admin.TaskExecutionEventResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link flyteidl.service.AdminService#getTaskExecution}.
             * @memberof flyteidl.service.AdminService
             * @typedef GetTaskExecutionCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {flyteidl.admin.TaskExecution} [response] TaskExecution
             */

            /**
             * Calls GetTaskExecution.
             * @function getTaskExecution
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.ITaskExecutionGetRequest} request TaskExecutionGetRequest message or plain object
             * @param {flyteidl.service.AdminService.GetTaskExecutionCallback} callback Node-style callback called with the error, if any, and TaskExecution
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(AdminService.prototype.getTaskExecution = function getTaskExecution(request, callback) {
                return this.rpcCall(getTaskExecution, $root.flyteidl.admin.TaskExecutionGetRequest, $root.flyteidl.admin.TaskExecution, request, callback);
            }, "name", { value: "GetTaskExecution" });

            /**
             * Calls GetTaskExecution.
             * @function getTaskExecution
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.ITaskExecutionGetRequest} request TaskExecutionGetRequest message or plain object
             * @returns {Promise<flyteidl.admin.TaskExecution>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link flyteidl.service.AdminService#listTaskExecutions}.
             * @memberof flyteidl.service.AdminService
             * @typedef ListTaskExecutionsCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {flyteidl.admin.TaskExecutionList} [response] TaskExecutionList
             */

            /**
             * Calls ListTaskExecutions.
             * @function listTaskExecutions
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.ITaskExecutionListRequest} request TaskExecutionListRequest message or plain object
             * @param {flyteidl.service.AdminService.ListTaskExecutionsCallback} callback Node-style callback called with the error, if any, and TaskExecutionList
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(AdminService.prototype.listTaskExecutions = function listTaskExecutions(request, callback) {
                return this.rpcCall(listTaskExecutions, $root.flyteidl.admin.TaskExecutionListRequest, $root.flyteidl.admin.TaskExecutionList, request, callback);
            }, "name", { value: "ListTaskExecutions" });

            /**
             * Calls ListTaskExecutions.
             * @function listTaskExecutions
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.ITaskExecutionListRequest} request TaskExecutionListRequest message or plain object
             * @returns {Promise<flyteidl.admin.TaskExecutionList>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link flyteidl.service.AdminService#getTaskExecutionData}.
             * @memberof flyteidl.service.AdminService
             * @typedef GetTaskExecutionDataCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {flyteidl.admin.TaskExecutionGetDataResponse} [response] TaskExecutionGetDataResponse
             */

            /**
             * Calls GetTaskExecutionData.
             * @function getTaskExecutionData
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.ITaskExecutionGetDataRequest} request TaskExecutionGetDataRequest message or plain object
             * @param {flyteidl.service.AdminService.GetTaskExecutionDataCallback} callback Node-style callback called with the error, if any, and TaskExecutionGetDataResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(AdminService.prototype.getTaskExecutionData = function getTaskExecutionData(request, callback) {
                return this.rpcCall(getTaskExecutionData, $root.flyteidl.admin.TaskExecutionGetDataRequest, $root.flyteidl.admin.TaskExecutionGetDataResponse, request, callback);
            }, "name", { value: "GetTaskExecutionData" });

            /**
             * Calls GetTaskExecutionData.
             * @function getTaskExecutionData
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.ITaskExecutionGetDataRequest} request TaskExecutionGetDataRequest message or plain object
             * @returns {Promise<flyteidl.admin.TaskExecutionGetDataResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link flyteidl.service.AdminService#updateProjectDomainAttributes}.
             * @memberof flyteidl.service.AdminService
             * @typedef UpdateProjectDomainAttributesCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {flyteidl.admin.ProjectDomainAttributesUpdateResponse} [response] ProjectDomainAttributesUpdateResponse
             */

            /**
             * Calls UpdateProjectDomainAttributes.
             * @function updateProjectDomainAttributes
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.IProjectDomainAttributesUpdateRequest} request ProjectDomainAttributesUpdateRequest message or plain object
             * @param {flyteidl.service.AdminService.UpdateProjectDomainAttributesCallback} callback Node-style callback called with the error, if any, and ProjectDomainAttributesUpdateResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(AdminService.prototype.updateProjectDomainAttributes = function updateProjectDomainAttributes(request, callback) {
                return this.rpcCall(updateProjectDomainAttributes, $root.flyteidl.admin.ProjectDomainAttributesUpdateRequest, $root.flyteidl.admin.ProjectDomainAttributesUpdateResponse, request, callback);
            }, "name", { value: "UpdateProjectDomainAttributes" });

            /**
             * Calls UpdateProjectDomainAttributes.
             * @function updateProjectDomainAttributes
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.IProjectDomainAttributesUpdateRequest} request ProjectDomainAttributesUpdateRequest message or plain object
             * @returns {Promise<flyteidl.admin.ProjectDomainAttributesUpdateResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link flyteidl.service.AdminService#getProjectDomainAttributes}.
             * @memberof flyteidl.service.AdminService
             * @typedef GetProjectDomainAttributesCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {flyteidl.admin.ProjectDomainAttributesGetResponse} [response] ProjectDomainAttributesGetResponse
             */

            /**
             * Calls GetProjectDomainAttributes.
             * @function getProjectDomainAttributes
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.IProjectDomainAttributesGetRequest} request ProjectDomainAttributesGetRequest message or plain object
             * @param {flyteidl.service.AdminService.GetProjectDomainAttributesCallback} callback Node-style callback called with the error, if any, and ProjectDomainAttributesGetResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(AdminService.prototype.getProjectDomainAttributes = function getProjectDomainAttributes(request, callback) {
                return this.rpcCall(getProjectDomainAttributes, $root.flyteidl.admin.ProjectDomainAttributesGetRequest, $root.flyteidl.admin.ProjectDomainAttributesGetResponse, request, callback);
            }, "name", { value: "GetProjectDomainAttributes" });

            /**
             * Calls GetProjectDomainAttributes.
             * @function getProjectDomainAttributes
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.IProjectDomainAttributesGetRequest} request ProjectDomainAttributesGetRequest message or plain object
             * @returns {Promise<flyteidl.admin.ProjectDomainAttributesGetResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link flyteidl.service.AdminService#deleteProjectDomainAttributes}.
             * @memberof flyteidl.service.AdminService
             * @typedef DeleteProjectDomainAttributesCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {flyteidl.admin.ProjectDomainAttributesDeleteResponse} [response] ProjectDomainAttributesDeleteResponse
             */

            /**
             * Calls DeleteProjectDomainAttributes.
             * @function deleteProjectDomainAttributes
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.IProjectDomainAttributesDeleteRequest} request ProjectDomainAttributesDeleteRequest message or plain object
             * @param {flyteidl.service.AdminService.DeleteProjectDomainAttributesCallback} callback Node-style callback called with the error, if any, and ProjectDomainAttributesDeleteResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(AdminService.prototype.deleteProjectDomainAttributes = function deleteProjectDomainAttributes(request, callback) {
                return this.rpcCall(deleteProjectDomainAttributes, $root.flyteidl.admin.ProjectDomainAttributesDeleteRequest, $root.flyteidl.admin.ProjectDomainAttributesDeleteResponse, request, callback);
            }, "name", { value: "DeleteProjectDomainAttributes" });

            /**
             * Calls DeleteProjectDomainAttributes.
             * @function deleteProjectDomainAttributes
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.IProjectDomainAttributesDeleteRequest} request ProjectDomainAttributesDeleteRequest message or plain object
             * @returns {Promise<flyteidl.admin.ProjectDomainAttributesDeleteResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link flyteidl.service.AdminService#updateWorkflowAttributes}.
             * @memberof flyteidl.service.AdminService
             * @typedef UpdateWorkflowAttributesCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {flyteidl.admin.WorkflowAttributesUpdateResponse} [response] WorkflowAttributesUpdateResponse
             */

            /**
             * Calls UpdateWorkflowAttributes.
             * @function updateWorkflowAttributes
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.IWorkflowAttributesUpdateRequest} request WorkflowAttributesUpdateRequest message or plain object
             * @param {flyteidl.service.AdminService.UpdateWorkflowAttributesCallback} callback Node-style callback called with the error, if any, and WorkflowAttributesUpdateResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(AdminService.prototype.updateWorkflowAttributes = function updateWorkflowAttributes(request, callback) {
                return this.rpcCall(updateWorkflowAttributes, $root.flyteidl.admin.WorkflowAttributesUpdateRequest, $root.flyteidl.admin.WorkflowAttributesUpdateResponse, request, callback);
            }, "name", { value: "UpdateWorkflowAttributes" });

            /**
             * Calls UpdateWorkflowAttributes.
             * @function updateWorkflowAttributes
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.IWorkflowAttributesUpdateRequest} request WorkflowAttributesUpdateRequest message or plain object
             * @returns {Promise<flyteidl.admin.WorkflowAttributesUpdateResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link flyteidl.service.AdminService#getWorkflowAttributes}.
             * @memberof flyteidl.service.AdminService
             * @typedef GetWorkflowAttributesCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {flyteidl.admin.WorkflowAttributesGetResponse} [response] WorkflowAttributesGetResponse
             */

            /**
             * Calls GetWorkflowAttributes.
             * @function getWorkflowAttributes
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.IWorkflowAttributesGetRequest} request WorkflowAttributesGetRequest message or plain object
             * @param {flyteidl.service.AdminService.GetWorkflowAttributesCallback} callback Node-style callback called with the error, if any, and WorkflowAttributesGetResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(AdminService.prototype.getWorkflowAttributes = function getWorkflowAttributes(request, callback) {
                return this.rpcCall(getWorkflowAttributes, $root.flyteidl.admin.WorkflowAttributesGetRequest, $root.flyteidl.admin.WorkflowAttributesGetResponse, request, callback);
            }, "name", { value: "GetWorkflowAttributes" });

            /**
             * Calls GetWorkflowAttributes.
             * @function getWorkflowAttributes
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.IWorkflowAttributesGetRequest} request WorkflowAttributesGetRequest message or plain object
             * @returns {Promise<flyteidl.admin.WorkflowAttributesGetResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link flyteidl.service.AdminService#deleteWorkflowAttributes}.
             * @memberof flyteidl.service.AdminService
             * @typedef DeleteWorkflowAttributesCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {flyteidl.admin.WorkflowAttributesDeleteResponse} [response] WorkflowAttributesDeleteResponse
             */

            /**
             * Calls DeleteWorkflowAttributes.
             * @function deleteWorkflowAttributes
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.IWorkflowAttributesDeleteRequest} request WorkflowAttributesDeleteRequest message or plain object
             * @param {flyteidl.service.AdminService.DeleteWorkflowAttributesCallback} callback Node-style callback called with the error, if any, and WorkflowAttributesDeleteResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(AdminService.prototype.deleteWorkflowAttributes = function deleteWorkflowAttributes(request, callback) {
                return this.rpcCall(deleteWorkflowAttributes, $root.flyteidl.admin.WorkflowAttributesDeleteRequest, $root.flyteidl.admin.WorkflowAttributesDeleteResponse, request, callback);
            }, "name", { value: "DeleteWorkflowAttributes" });

            /**
             * Calls DeleteWorkflowAttributes.
             * @function deleteWorkflowAttributes
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.IWorkflowAttributesDeleteRequest} request WorkflowAttributesDeleteRequest message or plain object
             * @returns {Promise<flyteidl.admin.WorkflowAttributesDeleteResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link flyteidl.service.AdminService#listMatchableAttributes}.
             * @memberof flyteidl.service.AdminService
             * @typedef ListMatchableAttributesCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {flyteidl.admin.ListMatchableAttributesResponse} [response] ListMatchableAttributesResponse
             */

            /**
             * Calls ListMatchableAttributes.
             * @function listMatchableAttributes
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.IListMatchableAttributesRequest} request ListMatchableAttributesRequest message or plain object
             * @param {flyteidl.service.AdminService.ListMatchableAttributesCallback} callback Node-style callback called with the error, if any, and ListMatchableAttributesResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(AdminService.prototype.listMatchableAttributes = function listMatchableAttributes(request, callback) {
                return this.rpcCall(listMatchableAttributes, $root.flyteidl.admin.ListMatchableAttributesRequest, $root.flyteidl.admin.ListMatchableAttributesResponse, request, callback);
            }, "name", { value: "ListMatchableAttributes" });

            /**
             * Calls ListMatchableAttributes.
             * @function listMatchableAttributes
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.IListMatchableAttributesRequest} request ListMatchableAttributesRequest message or plain object
             * @returns {Promise<flyteidl.admin.ListMatchableAttributesResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link flyteidl.service.AdminService#listNamedEntities}.
             * @memberof flyteidl.service.AdminService
             * @typedef ListNamedEntitiesCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {flyteidl.admin.NamedEntityList} [response] NamedEntityList
             */

            /**
             * Calls ListNamedEntities.
             * @function listNamedEntities
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.INamedEntityListRequest} request NamedEntityListRequest message or plain object
             * @param {flyteidl.service.AdminService.ListNamedEntitiesCallback} callback Node-style callback called with the error, if any, and NamedEntityList
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(AdminService.prototype.listNamedEntities = function listNamedEntities(request, callback) {
                return this.rpcCall(listNamedEntities, $root.flyteidl.admin.NamedEntityListRequest, $root.flyteidl.admin.NamedEntityList, request, callback);
            }, "name", { value: "ListNamedEntities" });

            /**
             * Calls ListNamedEntities.
             * @function listNamedEntities
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.INamedEntityListRequest} request NamedEntityListRequest message or plain object
             * @returns {Promise<flyteidl.admin.NamedEntityList>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link flyteidl.service.AdminService#getNamedEntity}.
             * @memberof flyteidl.service.AdminService
             * @typedef GetNamedEntityCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {flyteidl.admin.NamedEntity} [response] NamedEntity
             */

            /**
             * Calls GetNamedEntity.
             * @function getNamedEntity
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.INamedEntityGetRequest} request NamedEntityGetRequest message or plain object
             * @param {flyteidl.service.AdminService.GetNamedEntityCallback} callback Node-style callback called with the error, if any, and NamedEntity
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(AdminService.prototype.getNamedEntity = function getNamedEntity(request, callback) {
                return this.rpcCall(getNamedEntity, $root.flyteidl.admin.NamedEntityGetRequest, $root.flyteidl.admin.NamedEntity, request, callback);
            }, "name", { value: "GetNamedEntity" });

            /**
             * Calls GetNamedEntity.
             * @function getNamedEntity
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.INamedEntityGetRequest} request NamedEntityGetRequest message or plain object
             * @returns {Promise<flyteidl.admin.NamedEntity>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link flyteidl.service.AdminService#updateNamedEntity}.
             * @memberof flyteidl.service.AdminService
             * @typedef UpdateNamedEntityCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {flyteidl.admin.NamedEntityUpdateResponse} [response] NamedEntityUpdateResponse
             */

            /**
             * Calls UpdateNamedEntity.
             * @function updateNamedEntity
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.INamedEntityUpdateRequest} request NamedEntityUpdateRequest message or plain object
             * @param {flyteidl.service.AdminService.UpdateNamedEntityCallback} callback Node-style callback called with the error, if any, and NamedEntityUpdateResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(AdminService.prototype.updateNamedEntity = function updateNamedEntity(request, callback) {
                return this.rpcCall(updateNamedEntity, $root.flyteidl.admin.NamedEntityUpdateRequest, $root.flyteidl.admin.NamedEntityUpdateResponse, request, callback);
            }, "name", { value: "UpdateNamedEntity" });

            /**
             * Calls UpdateNamedEntity.
             * @function updateNamedEntity
             * @memberof flyteidl.service.AdminService
             * @instance
             * @param {flyteidl.admin.INamedEntityUpdateRequest} request NamedEntityUpdateRequest message or plain object
             * @returns {Promise<flyteidl.admin.NamedEntityUpdateResponse>} Promise
             * @variation 2
             */

            return AdminService;
        })();

        return service;
    })();

    return flyteidl;
})();

export const google = $root.google = (() => {

    /**
     * Namespace google.
     * @exports google
     * @namespace
     */
    const google = {};

    google.protobuf = (function() {

        /**
         * Namespace protobuf.
         * @memberof google
         * @namespace
         */
        const protobuf = {};

        protobuf.Timestamp = (function() {

            /**
             * Properties of a Timestamp.
             * @memberof google.protobuf
             * @interface ITimestamp
             * @property {Long|null} [seconds] Timestamp seconds
             * @property {number|null} [nanos] Timestamp nanos
             */

            /**
             * Constructs a new Timestamp.
             * @memberof google.protobuf
             * @classdesc Represents a Timestamp.
             * @implements ITimestamp
             * @constructor
             * @param {google.protobuf.ITimestamp=} [properties] Properties to set
             */
            function Timestamp(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Timestamp seconds.
             * @member {Long} seconds
             * @memberof google.protobuf.Timestamp
             * @instance
             */
            Timestamp.prototype.seconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Timestamp nanos.
             * @member {number} nanos
             * @memberof google.protobuf.Timestamp
             * @instance
             */
            Timestamp.prototype.nanos = 0;

            /**
             * Creates a new Timestamp instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {google.protobuf.ITimestamp=} [properties] Properties to set
             * @returns {google.protobuf.Timestamp} Timestamp instance
             */
            Timestamp.create = function create(properties) {
                return new Timestamp(properties);
            };

            /**
             * Encodes the specified Timestamp message. Does not implicitly {@link google.protobuf.Timestamp.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {google.protobuf.ITimestamp} message Timestamp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Timestamp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.seconds != null && message.hasOwnProperty("seconds"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.seconds);
                if (message.nanos != null && message.hasOwnProperty("nanos"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.nanos);
                return writer;
            };

            /**
             * Decodes a Timestamp message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Timestamp} Timestamp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Timestamp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Timestamp();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.seconds = reader.int64();
                        break;
                    case 2:
                        message.nanos = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a Timestamp message.
             * @function verify
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Timestamp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.seconds != null && message.hasOwnProperty("seconds"))
                    if (!$util.isInteger(message.seconds) && !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high)))
                        return "seconds: integer|Long expected";
                if (message.nanos != null && message.hasOwnProperty("nanos"))
                    if (!$util.isInteger(message.nanos))
                        return "nanos: integer expected";
                return null;
            };

            return Timestamp;
        })();

        protobuf.Duration = (function() {

            /**
             * Properties of a Duration.
             * @memberof google.protobuf
             * @interface IDuration
             * @property {Long|null} [seconds] Duration seconds
             * @property {number|null} [nanos] Duration nanos
             */

            /**
             * Constructs a new Duration.
             * @memberof google.protobuf
             * @classdesc Represents a Duration.
             * @implements IDuration
             * @constructor
             * @param {google.protobuf.IDuration=} [properties] Properties to set
             */
            function Duration(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Duration seconds.
             * @member {Long} seconds
             * @memberof google.protobuf.Duration
             * @instance
             */
            Duration.prototype.seconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Duration nanos.
             * @member {number} nanos
             * @memberof google.protobuf.Duration
             * @instance
             */
            Duration.prototype.nanos = 0;

            /**
             * Creates a new Duration instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Duration
             * @static
             * @param {google.protobuf.IDuration=} [properties] Properties to set
             * @returns {google.protobuf.Duration} Duration instance
             */
            Duration.create = function create(properties) {
                return new Duration(properties);
            };

            /**
             * Encodes the specified Duration message. Does not implicitly {@link google.protobuf.Duration.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Duration
             * @static
             * @param {google.protobuf.IDuration} message Duration message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Duration.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.seconds != null && message.hasOwnProperty("seconds"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.seconds);
                if (message.nanos != null && message.hasOwnProperty("nanos"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.nanos);
                return writer;
            };

            /**
             * Decodes a Duration message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Duration
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Duration} Duration
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Duration.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Duration();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.seconds = reader.int64();
                        break;
                    case 2:
                        message.nanos = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a Duration message.
             * @function verify
             * @memberof google.protobuf.Duration
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Duration.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.seconds != null && message.hasOwnProperty("seconds"))
                    if (!$util.isInteger(message.seconds) && !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high)))
                        return "seconds: integer|Long expected";
                if (message.nanos != null && message.hasOwnProperty("nanos"))
                    if (!$util.isInteger(message.nanos))
                        return "nanos: integer expected";
                return null;
            };

            return Duration;
        })();

        protobuf.Struct = (function() {

            /**
             * Properties of a Struct.
             * @memberof google.protobuf
             * @interface IStruct
             * @property {Object.<string,google.protobuf.IValue>|null} [fields] Struct fields
             */

            /**
             * Constructs a new Struct.
             * @memberof google.protobuf
             * @classdesc Represents a Struct.
             * @implements IStruct
             * @constructor
             * @param {google.protobuf.IStruct=} [properties] Properties to set
             */
            function Struct(properties) {
                this.fields = {};
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Struct fields.
             * @member {Object.<string,google.protobuf.IValue>} fields
             * @memberof google.protobuf.Struct
             * @instance
             */
            Struct.prototype.fields = $util.emptyObject;

            /**
             * Creates a new Struct instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Struct
             * @static
             * @param {google.protobuf.IStruct=} [properties] Properties to set
             * @returns {google.protobuf.Struct} Struct instance
             */
            Struct.create = function create(properties) {
                return new Struct(properties);
            };

            /**
             * Encodes the specified Struct message. Does not implicitly {@link google.protobuf.Struct.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Struct
             * @static
             * @param {google.protobuf.IStruct} message Struct message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Struct.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fields != null && message.hasOwnProperty("fields"))
                    for (let keys = Object.keys(message.fields), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.google.protobuf.Value.encode(message.fields[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                return writer;
            };

            /**
             * Decodes a Struct message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Struct
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Struct} Struct
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Struct.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Struct(), key;
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        reader.skip().pos++;
                        if (message.fields === $util.emptyObject)
                            message.fields = {};
                        key = reader.string();
                        reader.pos++;
                        message.fields[key] = $root.google.protobuf.Value.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a Struct message.
             * @function verify
             * @memberof google.protobuf.Struct
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Struct.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fields != null && message.hasOwnProperty("fields")) {
                    if (!$util.isObject(message.fields))
                        return "fields: object expected";
                    let key = Object.keys(message.fields);
                    for (let i = 0; i < key.length; ++i) {
                        let error = $root.google.protobuf.Value.verify(message.fields[key[i]]);
                        if (error)
                            return "fields." + error;
                    }
                }
                return null;
            };

            return Struct;
        })();

        protobuf.Value = (function() {

            /**
             * Properties of a Value.
             * @memberof google.protobuf
             * @interface IValue
             * @property {google.protobuf.NullValue|null} [nullValue] Value nullValue
             * @property {number|null} [numberValue] Value numberValue
             * @property {string|null} [stringValue] Value stringValue
             * @property {boolean|null} [boolValue] Value boolValue
             * @property {google.protobuf.IStruct|null} [structValue] Value structValue
             * @property {google.protobuf.IListValue|null} [listValue] Value listValue
             */

            /**
             * Constructs a new Value.
             * @memberof google.protobuf
             * @classdesc Represents a Value.
             * @implements IValue
             * @constructor
             * @param {google.protobuf.IValue=} [properties] Properties to set
             */
            function Value(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Value nullValue.
             * @member {google.protobuf.NullValue} nullValue
             * @memberof google.protobuf.Value
             * @instance
             */
            Value.prototype.nullValue = 0;

            /**
             * Value numberValue.
             * @member {number} numberValue
             * @memberof google.protobuf.Value
             * @instance
             */
            Value.prototype.numberValue = 0;

            /**
             * Value stringValue.
             * @member {string} stringValue
             * @memberof google.protobuf.Value
             * @instance
             */
            Value.prototype.stringValue = "";

            /**
             * Value boolValue.
             * @member {boolean} boolValue
             * @memberof google.protobuf.Value
             * @instance
             */
            Value.prototype.boolValue = false;

            /**
             * Value structValue.
             * @member {google.protobuf.IStruct|null|undefined} structValue
             * @memberof google.protobuf.Value
             * @instance
             */
            Value.prototype.structValue = null;

            /**
             * Value listValue.
             * @member {google.protobuf.IListValue|null|undefined} listValue
             * @memberof google.protobuf.Value
             * @instance
             */
            Value.prototype.listValue = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * Value kind.
             * @member {"nullValue"|"numberValue"|"stringValue"|"boolValue"|"structValue"|"listValue"|undefined} kind
             * @memberof google.protobuf.Value
             * @instance
             */
            Object.defineProperty(Value.prototype, "kind", {
                get: $util.oneOfGetter($oneOfFields = ["nullValue", "numberValue", "stringValue", "boolValue", "structValue", "listValue"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new Value instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Value
             * @static
             * @param {google.protobuf.IValue=} [properties] Properties to set
             * @returns {google.protobuf.Value} Value instance
             */
            Value.create = function create(properties) {
                return new Value(properties);
            };

            /**
             * Encodes the specified Value message. Does not implicitly {@link google.protobuf.Value.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Value
             * @static
             * @param {google.protobuf.IValue} message Value message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Value.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.nullValue != null && message.hasOwnProperty("nullValue"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.nullValue);
                if (message.numberValue != null && message.hasOwnProperty("numberValue"))
                    writer.uint32(/* id 2, wireType 1 =*/17).double(message.numberValue);
                if (message.stringValue != null && message.hasOwnProperty("stringValue"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.stringValue);
                if (message.boolValue != null && message.hasOwnProperty("boolValue"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.boolValue);
                if (message.structValue != null && message.hasOwnProperty("structValue"))
                    $root.google.protobuf.Struct.encode(message.structValue, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.listValue != null && message.hasOwnProperty("listValue"))
                    $root.google.protobuf.ListValue.encode(message.listValue, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a Value message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Value
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Value} Value
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Value.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Value();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.nullValue = reader.int32();
                        break;
                    case 2:
                        message.numberValue = reader.double();
                        break;
                    case 3:
                        message.stringValue = reader.string();
                        break;
                    case 4:
                        message.boolValue = reader.bool();
                        break;
                    case 5:
                        message.structValue = $root.google.protobuf.Struct.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.listValue = $root.google.protobuf.ListValue.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a Value message.
             * @function verify
             * @memberof google.protobuf.Value
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Value.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.nullValue != null && message.hasOwnProperty("nullValue")) {
                    properties.kind = 1;
                    switch (message.nullValue) {
                    default:
                        return "nullValue: enum value expected";
                    case 0:
                        break;
                    }
                }
                if (message.numberValue != null && message.hasOwnProperty("numberValue")) {
                    if (properties.kind === 1)
                        return "kind: multiple values";
                    properties.kind = 1;
                    if (typeof message.numberValue !== "number")
                        return "numberValue: number expected";
                }
                if (message.stringValue != null && message.hasOwnProperty("stringValue")) {
                    if (properties.kind === 1)
                        return "kind: multiple values";
                    properties.kind = 1;
                    if (!$util.isString(message.stringValue))
                        return "stringValue: string expected";
                }
                if (message.boolValue != null && message.hasOwnProperty("boolValue")) {
                    if (properties.kind === 1)
                        return "kind: multiple values";
                    properties.kind = 1;
                    if (typeof message.boolValue !== "boolean")
                        return "boolValue: boolean expected";
                }
                if (message.structValue != null && message.hasOwnProperty("structValue")) {
                    if (properties.kind === 1)
                        return "kind: multiple values";
                    properties.kind = 1;
                    {
                        let error = $root.google.protobuf.Struct.verify(message.structValue);
                        if (error)
                            return "structValue." + error;
                    }
                }
                if (message.listValue != null && message.hasOwnProperty("listValue")) {
                    if (properties.kind === 1)
                        return "kind: multiple values";
                    properties.kind = 1;
                    {
                        let error = $root.google.protobuf.ListValue.verify(message.listValue);
                        if (error)
                            return "listValue." + error;
                    }
                }
                return null;
            };

            return Value;
        })();

        /**
         * NullValue enum.
         * @name google.protobuf.NullValue
         * @enum {string}
         * @property {number} NULL_VALUE=0 NULL_VALUE value
         */
        protobuf.NullValue = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "NULL_VALUE"] = 0;
            return values;
        })();

        protobuf.ListValue = (function() {

            /**
             * Properties of a ListValue.
             * @memberof google.protobuf
             * @interface IListValue
             * @property {Array.<google.protobuf.IValue>|null} [values] ListValue values
             */

            /**
             * Constructs a new ListValue.
             * @memberof google.protobuf
             * @classdesc Represents a ListValue.
             * @implements IListValue
             * @constructor
             * @param {google.protobuf.IListValue=} [properties] Properties to set
             */
            function ListValue(properties) {
                this.values = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ListValue values.
             * @member {Array.<google.protobuf.IValue>} values
             * @memberof google.protobuf.ListValue
             * @instance
             */
            ListValue.prototype.values = $util.emptyArray;

            /**
             * Creates a new ListValue instance using the specified properties.
             * @function create
             * @memberof google.protobuf.ListValue
             * @static
             * @param {google.protobuf.IListValue=} [properties] Properties to set
             * @returns {google.protobuf.ListValue} ListValue instance
             */
            ListValue.create = function create(properties) {
                return new ListValue(properties);
            };

            /**
             * Encodes the specified ListValue message. Does not implicitly {@link google.protobuf.ListValue.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.ListValue
             * @static
             * @param {google.protobuf.IListValue} message ListValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListValue.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.values != null && message.values.length)
                    for (let i = 0; i < message.values.length; ++i)
                        $root.google.protobuf.Value.encode(message.values[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a ListValue message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.ListValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.ListValue} ListValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListValue.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ListValue();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.values && message.values.length))
                            message.values = [];
                        message.values.push($root.google.protobuf.Value.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a ListValue message.
             * @function verify
             * @memberof google.protobuf.ListValue
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ListValue.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.values != null && message.hasOwnProperty("values")) {
                    if (!Array.isArray(message.values))
                        return "values: array expected";
                    for (let i = 0; i < message.values.length; ++i) {
                        let error = $root.google.protobuf.Value.verify(message.values[i]);
                        if (error)
                            return "values." + error;
                    }
                }
                return null;
            };

            return ListValue;
        })();

        protobuf.FileDescriptorSet = (function() {

            /**
             * Properties of a FileDescriptorSet.
             * @memberof google.protobuf
             * @interface IFileDescriptorSet
             * @property {Array.<google.protobuf.IFileDescriptorProto>|null} [file] FileDescriptorSet file
             */

            /**
             * Constructs a new FileDescriptorSet.
             * @memberof google.protobuf
             * @classdesc Represents a FileDescriptorSet.
             * @implements IFileDescriptorSet
             * @constructor
             * @param {google.protobuf.IFileDescriptorSet=} [properties] Properties to set
             */
            function FileDescriptorSet(properties) {
                this.file = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FileDescriptorSet file.
             * @member {Array.<google.protobuf.IFileDescriptorProto>} file
             * @memberof google.protobuf.FileDescriptorSet
             * @instance
             */
            FileDescriptorSet.prototype.file = $util.emptyArray;

            /**
             * Creates a new FileDescriptorSet instance using the specified properties.
             * @function create
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {google.protobuf.IFileDescriptorSet=} [properties] Properties to set
             * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet instance
             */
            FileDescriptorSet.create = function create(properties) {
                return new FileDescriptorSet(properties);
            };

            /**
             * Encodes the specified FileDescriptorSet message. Does not implicitly {@link google.protobuf.FileDescriptorSet.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {google.protobuf.IFileDescriptorSet} message FileDescriptorSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileDescriptorSet.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.file != null && message.file.length)
                    for (let i = 0; i < message.file.length; ++i)
                        $root.google.protobuf.FileDescriptorProto.encode(message.file[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a FileDescriptorSet message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileDescriptorSet.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileDescriptorSet();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.file && message.file.length))
                            message.file = [];
                        message.file.push($root.google.protobuf.FileDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a FileDescriptorSet message.
             * @function verify
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FileDescriptorSet.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.file != null && message.hasOwnProperty("file")) {
                    if (!Array.isArray(message.file))
                        return "file: array expected";
                    for (let i = 0; i < message.file.length; ++i) {
                        let error = $root.google.protobuf.FileDescriptorProto.verify(message.file[i]);
                        if (error)
                            return "file." + error;
                    }
                }
                return null;
            };

            return FileDescriptorSet;
        })();

        protobuf.FileDescriptorProto = (function() {

            /**
             * Properties of a FileDescriptorProto.
             * @memberof google.protobuf
             * @interface IFileDescriptorProto
             * @property {string|null} [name] FileDescriptorProto name
             * @property {string|null} ["package"] FileDescriptorProto package
             * @property {Array.<string>|null} [dependency] FileDescriptorProto dependency
             * @property {Array.<number>|null} [publicDependency] FileDescriptorProto publicDependency
             * @property {Array.<number>|null} [weakDependency] FileDescriptorProto weakDependency
             * @property {Array.<google.protobuf.IDescriptorProto>|null} [messageType] FileDescriptorProto messageType
             * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enumType] FileDescriptorProto enumType
             * @property {Array.<google.protobuf.IServiceDescriptorProto>|null} [service] FileDescriptorProto service
             * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] FileDescriptorProto extension
             * @property {google.protobuf.IFileOptions|null} [options] FileDescriptorProto options
             * @property {google.protobuf.ISourceCodeInfo|null} [sourceCodeInfo] FileDescriptorProto sourceCodeInfo
             * @property {string|null} [syntax] FileDescriptorProto syntax
             */

            /**
             * Constructs a new FileDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a FileDescriptorProto.
             * @implements IFileDescriptorProto
             * @constructor
             * @param {google.protobuf.IFileDescriptorProto=} [properties] Properties to set
             */
            function FileDescriptorProto(properties) {
                this.dependency = [];
                this.publicDependency = [];
                this.weakDependency = [];
                this.messageType = [];
                this.enumType = [];
                this.service = [];
                this.extension = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FileDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.name = "";

            /**
             * FileDescriptorProto package.
             * @member {string} package
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype["package"] = "";

            /**
             * FileDescriptorProto dependency.
             * @member {Array.<string>} dependency
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.dependency = $util.emptyArray;

            /**
             * FileDescriptorProto publicDependency.
             * @member {Array.<number>} publicDependency
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.publicDependency = $util.emptyArray;

            /**
             * FileDescriptorProto weakDependency.
             * @member {Array.<number>} weakDependency
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.weakDependency = $util.emptyArray;

            /**
             * FileDescriptorProto messageType.
             * @member {Array.<google.protobuf.IDescriptorProto>} messageType
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.messageType = $util.emptyArray;

            /**
             * FileDescriptorProto enumType.
             * @member {Array.<google.protobuf.IEnumDescriptorProto>} enumType
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.enumType = $util.emptyArray;

            /**
             * FileDescriptorProto service.
             * @member {Array.<google.protobuf.IServiceDescriptorProto>} service
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.service = $util.emptyArray;

            /**
             * FileDescriptorProto extension.
             * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.extension = $util.emptyArray;

            /**
             * FileDescriptorProto options.
             * @member {google.protobuf.IFileOptions|null|undefined} options
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.options = null;

            /**
             * FileDescriptorProto sourceCodeInfo.
             * @member {google.protobuf.ISourceCodeInfo|null|undefined} sourceCodeInfo
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.sourceCodeInfo = null;

            /**
             * FileDescriptorProto syntax.
             * @member {string} syntax
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.syntax = "";

            /**
             * Creates a new FileDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {google.protobuf.IFileDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto instance
             */
            FileDescriptorProto.create = function create(properties) {
                return new FileDescriptorProto(properties);
            };

            /**
             * Encodes the specified FileDescriptorProto message. Does not implicitly {@link google.protobuf.FileDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {google.protobuf.IFileDescriptorProto} message FileDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message["package"] != null && message.hasOwnProperty("package"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message["package"]);
                if (message.dependency != null && message.dependency.length)
                    for (let i = 0; i < message.dependency.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.dependency[i]);
                if (message.messageType != null && message.messageType.length)
                    for (let i = 0; i < message.messageType.length; ++i)
                        $root.google.protobuf.DescriptorProto.encode(message.messageType[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.enumType != null && message.enumType.length)
                    for (let i = 0; i < message.enumType.length; ++i)
                        $root.google.protobuf.EnumDescriptorProto.encode(message.enumType[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.service != null && message.service.length)
                    for (let i = 0; i < message.service.length; ++i)
                        $root.google.protobuf.ServiceDescriptorProto.encode(message.service[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.extension != null && message.extension.length)
                    for (let i = 0; i < message.extension.length; ++i)
                        $root.google.protobuf.FieldDescriptorProto.encode(message.extension[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.options != null && message.hasOwnProperty("options"))
                    $root.google.protobuf.FileOptions.encode(message.options, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.sourceCodeInfo != null && message.hasOwnProperty("sourceCodeInfo"))
                    $root.google.protobuf.SourceCodeInfo.encode(message.sourceCodeInfo, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.publicDependency != null && message.publicDependency.length)
                    for (let i = 0; i < message.publicDependency.length; ++i)
                        writer.uint32(/* id 10, wireType 0 =*/80).int32(message.publicDependency[i]);
                if (message.weakDependency != null && message.weakDependency.length)
                    for (let i = 0; i < message.weakDependency.length; ++i)
                        writer.uint32(/* id 11, wireType 0 =*/88).int32(message.weakDependency[i]);
                if (message.syntax != null && message.hasOwnProperty("syntax"))
                    writer.uint32(/* id 12, wireType 2 =*/98).string(message.syntax);
                return writer;
            };

            /**
             * Decodes a FileDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message["package"] = reader.string();
                        break;
                    case 3:
                        if (!(message.dependency && message.dependency.length))
                            message.dependency = [];
                        message.dependency.push(reader.string());
                        break;
                    case 10:
                        if (!(message.publicDependency && message.publicDependency.length))
                            message.publicDependency = [];
                        if ((tag & 7) === 2) {
                            let end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.publicDependency.push(reader.int32());
                        } else
                            message.publicDependency.push(reader.int32());
                        break;
                    case 11:
                        if (!(message.weakDependency && message.weakDependency.length))
                            message.weakDependency = [];
                        if ((tag & 7) === 2) {
                            let end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.weakDependency.push(reader.int32());
                        } else
                            message.weakDependency.push(reader.int32());
                        break;
                    case 4:
                        if (!(message.messageType && message.messageType.length))
                            message.messageType = [];
                        message.messageType.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        if (!(message.enumType && message.enumType.length))
                            message.enumType = [];
                        message.enumType.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        if (!(message.service && message.service.length))
                            message.service = [];
                        message.service.push($root.google.protobuf.ServiceDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        if (!(message.extension && message.extension.length))
                            message.extension = [];
                        message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 8:
                        message.options = $root.google.protobuf.FileOptions.decode(reader, reader.uint32());
                        break;
                    case 9:
                        message.sourceCodeInfo = $root.google.protobuf.SourceCodeInfo.decode(reader, reader.uint32());
                        break;
                    case 12:
                        message.syntax = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a FileDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FileDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message["package"] != null && message.hasOwnProperty("package"))
                    if (!$util.isString(message["package"]))
                        return "package: string expected";
                if (message.dependency != null && message.hasOwnProperty("dependency")) {
                    if (!Array.isArray(message.dependency))
                        return "dependency: array expected";
                    for (let i = 0; i < message.dependency.length; ++i)
                        if (!$util.isString(message.dependency[i]))
                            return "dependency: string[] expected";
                }
                if (message.publicDependency != null && message.hasOwnProperty("publicDependency")) {
                    if (!Array.isArray(message.publicDependency))
                        return "publicDependency: array expected";
                    for (let i = 0; i < message.publicDependency.length; ++i)
                        if (!$util.isInteger(message.publicDependency[i]))
                            return "publicDependency: integer[] expected";
                }
                if (message.weakDependency != null && message.hasOwnProperty("weakDependency")) {
                    if (!Array.isArray(message.weakDependency))
                        return "weakDependency: array expected";
                    for (let i = 0; i < message.weakDependency.length; ++i)
                        if (!$util.isInteger(message.weakDependency[i]))
                            return "weakDependency: integer[] expected";
                }
                if (message.messageType != null && message.hasOwnProperty("messageType")) {
                    if (!Array.isArray(message.messageType))
                        return "messageType: array expected";
                    for (let i = 0; i < message.messageType.length; ++i) {
                        let error = $root.google.protobuf.DescriptorProto.verify(message.messageType[i]);
                        if (error)
                            return "messageType." + error;
                    }
                }
                if (message.enumType != null && message.hasOwnProperty("enumType")) {
                    if (!Array.isArray(message.enumType))
                        return "enumType: array expected";
                    for (let i = 0; i < message.enumType.length; ++i) {
                        let error = $root.google.protobuf.EnumDescriptorProto.verify(message.enumType[i]);
                        if (error)
                            return "enumType." + error;
                    }
                }
                if (message.service != null && message.hasOwnProperty("service")) {
                    if (!Array.isArray(message.service))
                        return "service: array expected";
                    for (let i = 0; i < message.service.length; ++i) {
                        let error = $root.google.protobuf.ServiceDescriptorProto.verify(message.service[i]);
                        if (error)
                            return "service." + error;
                    }
                }
                if (message.extension != null && message.hasOwnProperty("extension")) {
                    if (!Array.isArray(message.extension))
                        return "extension: array expected";
                    for (let i = 0; i < message.extension.length; ++i) {
                        let error = $root.google.protobuf.FieldDescriptorProto.verify(message.extension[i]);
                        if (error)
                            return "extension." + error;
                    }
                }
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.FileOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                if (message.sourceCodeInfo != null && message.hasOwnProperty("sourceCodeInfo")) {
                    let error = $root.google.protobuf.SourceCodeInfo.verify(message.sourceCodeInfo);
                    if (error)
                        return "sourceCodeInfo." + error;
                }
                if (message.syntax != null && message.hasOwnProperty("syntax"))
                    if (!$util.isString(message.syntax))
                        return "syntax: string expected";
                return null;
            };

            return FileDescriptorProto;
        })();

        protobuf.DescriptorProto = (function() {

            /**
             * Properties of a DescriptorProto.
             * @memberof google.protobuf
             * @interface IDescriptorProto
             * @property {string|null} [name] DescriptorProto name
             * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [field] DescriptorProto field
             * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] DescriptorProto extension
             * @property {Array.<google.protobuf.IDescriptorProto>|null} [nestedType] DescriptorProto nestedType
             * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enumType] DescriptorProto enumType
             * @property {Array.<google.protobuf.DescriptorProto.IExtensionRange>|null} [extensionRange] DescriptorProto extensionRange
             * @property {Array.<google.protobuf.IOneofDescriptorProto>|null} [oneofDecl] DescriptorProto oneofDecl
             * @property {google.protobuf.IMessageOptions|null} [options] DescriptorProto options
             * @property {Array.<google.protobuf.DescriptorProto.IReservedRange>|null} [reservedRange] DescriptorProto reservedRange
             * @property {Array.<string>|null} [reservedName] DescriptorProto reservedName
             */

            /**
             * Constructs a new DescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a DescriptorProto.
             * @implements IDescriptorProto
             * @constructor
             * @param {google.protobuf.IDescriptorProto=} [properties] Properties to set
             */
            function DescriptorProto(properties) {
                this.field = [];
                this.extension = [];
                this.nestedType = [];
                this.enumType = [];
                this.extensionRange = [];
                this.oneofDecl = [];
                this.reservedRange = [];
                this.reservedName = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.name = "";

            /**
             * DescriptorProto field.
             * @member {Array.<google.protobuf.IFieldDescriptorProto>} field
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.field = $util.emptyArray;

            /**
             * DescriptorProto extension.
             * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.extension = $util.emptyArray;

            /**
             * DescriptorProto nestedType.
             * @member {Array.<google.protobuf.IDescriptorProto>} nestedType
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.nestedType = $util.emptyArray;

            /**
             * DescriptorProto enumType.
             * @member {Array.<google.protobuf.IEnumDescriptorProto>} enumType
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.enumType = $util.emptyArray;

            /**
             * DescriptorProto extensionRange.
             * @member {Array.<google.protobuf.DescriptorProto.IExtensionRange>} extensionRange
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.extensionRange = $util.emptyArray;

            /**
             * DescriptorProto oneofDecl.
             * @member {Array.<google.protobuf.IOneofDescriptorProto>} oneofDecl
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.oneofDecl = $util.emptyArray;

            /**
             * DescriptorProto options.
             * @member {google.protobuf.IMessageOptions|null|undefined} options
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.options = null;

            /**
             * DescriptorProto reservedRange.
             * @member {Array.<google.protobuf.DescriptorProto.IReservedRange>} reservedRange
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.reservedRange = $util.emptyArray;

            /**
             * DescriptorProto reservedName.
             * @member {Array.<string>} reservedName
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.reservedName = $util.emptyArray;

            /**
             * Creates a new DescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {google.protobuf.IDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.DescriptorProto} DescriptorProto instance
             */
            DescriptorProto.create = function create(properties) {
                return new DescriptorProto(properties);
            };

            /**
             * Encodes the specified DescriptorProto message. Does not implicitly {@link google.protobuf.DescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {google.protobuf.IDescriptorProto} message DescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.field != null && message.field.length)
                    for (let i = 0; i < message.field.length; ++i)
                        $root.google.protobuf.FieldDescriptorProto.encode(message.field[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.nestedType != null && message.nestedType.length)
                    for (let i = 0; i < message.nestedType.length; ++i)
                        $root.google.protobuf.DescriptorProto.encode(message.nestedType[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.enumType != null && message.enumType.length)
                    for (let i = 0; i < message.enumType.length; ++i)
                        $root.google.protobuf.EnumDescriptorProto.encode(message.enumType[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.extensionRange != null && message.extensionRange.length)
                    for (let i = 0; i < message.extensionRange.length; ++i)
                        $root.google.protobuf.DescriptorProto.ExtensionRange.encode(message.extensionRange[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.extension != null && message.extension.length)
                    for (let i = 0; i < message.extension.length; ++i)
                        $root.google.protobuf.FieldDescriptorProto.encode(message.extension[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.options != null && message.hasOwnProperty("options"))
                    $root.google.protobuf.MessageOptions.encode(message.options, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.oneofDecl != null && message.oneofDecl.length)
                    for (let i = 0; i < message.oneofDecl.length; ++i)
                        $root.google.protobuf.OneofDescriptorProto.encode(message.oneofDecl[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.reservedRange != null && message.reservedRange.length)
                    for (let i = 0; i < message.reservedRange.length; ++i)
                        $root.google.protobuf.DescriptorProto.ReservedRange.encode(message.reservedRange[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.reservedName != null && message.reservedName.length)
                    for (let i = 0; i < message.reservedName.length; ++i)
                        writer.uint32(/* id 10, wireType 2 =*/82).string(message.reservedName[i]);
                return writer;
            };

            /**
             * Decodes a DescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.DescriptorProto} DescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        if (!(message.field && message.field.length))
                            message.field = [];
                        message.field.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        if (!(message.extension && message.extension.length))
                            message.extension = [];
                        message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        if (!(message.nestedType && message.nestedType.length))
                            message.nestedType = [];
                        message.nestedType.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        if (!(message.enumType && message.enumType.length))
                            message.enumType = [];
                        message.enumType.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        if (!(message.extensionRange && message.extensionRange.length))
                            message.extensionRange = [];
                        message.extensionRange.push($root.google.protobuf.DescriptorProto.ExtensionRange.decode(reader, reader.uint32()));
                        break;
                    case 8:
                        if (!(message.oneofDecl && message.oneofDecl.length))
                            message.oneofDecl = [];
                        message.oneofDecl.push($root.google.protobuf.OneofDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        message.options = $root.google.protobuf.MessageOptions.decode(reader, reader.uint32());
                        break;
                    case 9:
                        if (!(message.reservedRange && message.reservedRange.length))
                            message.reservedRange = [];
                        message.reservedRange.push($root.google.protobuf.DescriptorProto.ReservedRange.decode(reader, reader.uint32()));
                        break;
                    case 10:
                        if (!(message.reservedName && message.reservedName.length))
                            message.reservedName = [];
                        message.reservedName.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a DescriptorProto message.
             * @function verify
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.field != null && message.hasOwnProperty("field")) {
                    if (!Array.isArray(message.field))
                        return "field: array expected";
                    for (let i = 0; i < message.field.length; ++i) {
                        let error = $root.google.protobuf.FieldDescriptorProto.verify(message.field[i]);
                        if (error)
                            return "field." + error;
                    }
                }
                if (message.extension != null && message.hasOwnProperty("extension")) {
                    if (!Array.isArray(message.extension))
                        return "extension: array expected";
                    for (let i = 0; i < message.extension.length; ++i) {
                        let error = $root.google.protobuf.FieldDescriptorProto.verify(message.extension[i]);
                        if (error)
                            return "extension." + error;
                    }
                }
                if (message.nestedType != null && message.hasOwnProperty("nestedType")) {
                    if (!Array.isArray(message.nestedType))
                        return "nestedType: array expected";
                    for (let i = 0; i < message.nestedType.length; ++i) {
                        let error = $root.google.protobuf.DescriptorProto.verify(message.nestedType[i]);
                        if (error)
                            return "nestedType." + error;
                    }
                }
                if (message.enumType != null && message.hasOwnProperty("enumType")) {
                    if (!Array.isArray(message.enumType))
                        return "enumType: array expected";
                    for (let i = 0; i < message.enumType.length; ++i) {
                        let error = $root.google.protobuf.EnumDescriptorProto.verify(message.enumType[i]);
                        if (error)
                            return "enumType." + error;
                    }
                }
                if (message.extensionRange != null && message.hasOwnProperty("extensionRange")) {
                    if (!Array.isArray(message.extensionRange))
                        return "extensionRange: array expected";
                    for (let i = 0; i < message.extensionRange.length; ++i) {
                        let error = $root.google.protobuf.DescriptorProto.ExtensionRange.verify(message.extensionRange[i]);
                        if (error)
                            return "extensionRange." + error;
                    }
                }
                if (message.oneofDecl != null && message.hasOwnProperty("oneofDecl")) {
                    if (!Array.isArray(message.oneofDecl))
                        return "oneofDecl: array expected";
                    for (let i = 0; i < message.oneofDecl.length; ++i) {
                        let error = $root.google.protobuf.OneofDescriptorProto.verify(message.oneofDecl[i]);
                        if (error)
                            return "oneofDecl." + error;
                    }
                }
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.MessageOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                if (message.reservedRange != null && message.hasOwnProperty("reservedRange")) {
                    if (!Array.isArray(message.reservedRange))
                        return "reservedRange: array expected";
                    for (let i = 0; i < message.reservedRange.length; ++i) {
                        let error = $root.google.protobuf.DescriptorProto.ReservedRange.verify(message.reservedRange[i]);
                        if (error)
                            return "reservedRange." + error;
                    }
                }
                if (message.reservedName != null && message.hasOwnProperty("reservedName")) {
                    if (!Array.isArray(message.reservedName))
                        return "reservedName: array expected";
                    for (let i = 0; i < message.reservedName.length; ++i)
                        if (!$util.isString(message.reservedName[i]))
                            return "reservedName: string[] expected";
                }
                return null;
            };

            DescriptorProto.ExtensionRange = (function() {

                /**
                 * Properties of an ExtensionRange.
                 * @memberof google.protobuf.DescriptorProto
                 * @interface IExtensionRange
                 * @property {number|null} [start] ExtensionRange start
                 * @property {number|null} [end] ExtensionRange end
                 */

                /**
                 * Constructs a new ExtensionRange.
                 * @memberof google.protobuf.DescriptorProto
                 * @classdesc Represents an ExtensionRange.
                 * @implements IExtensionRange
                 * @constructor
                 * @param {google.protobuf.DescriptorProto.IExtensionRange=} [properties] Properties to set
                 */
                function ExtensionRange(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ExtensionRange start.
                 * @member {number} start
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @instance
                 */
                ExtensionRange.prototype.start = 0;

                /**
                 * ExtensionRange end.
                 * @member {number} end
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @instance
                 */
                ExtensionRange.prototype.end = 0;

                /**
                 * Creates a new ExtensionRange instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.IExtensionRange=} [properties] Properties to set
                 * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange instance
                 */
                ExtensionRange.create = function create(properties) {
                    return new ExtensionRange(properties);
                };

                /**
                 * Encodes the specified ExtensionRange message. Does not implicitly {@link google.protobuf.DescriptorProto.ExtensionRange.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.IExtensionRange} message ExtensionRange message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ExtensionRange.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.start != null && message.hasOwnProperty("start"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.start);
                    if (message.end != null && message.hasOwnProperty("end"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.end);
                    return writer;
                };

                /**
                 * Decodes an ExtensionRange message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ExtensionRange.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto.ExtensionRange();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.start = reader.int32();
                            break;
                        case 2:
                            message.end = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Verifies an ExtensionRange message.
                 * @function verify
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ExtensionRange.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.start != null && message.hasOwnProperty("start"))
                        if (!$util.isInteger(message.start))
                            return "start: integer expected";
                    if (message.end != null && message.hasOwnProperty("end"))
                        if (!$util.isInteger(message.end))
                            return "end: integer expected";
                    return null;
                };

                return ExtensionRange;
            })();

            DescriptorProto.ReservedRange = (function() {

                /**
                 * Properties of a ReservedRange.
                 * @memberof google.protobuf.DescriptorProto
                 * @interface IReservedRange
                 * @property {number|null} [start] ReservedRange start
                 * @property {number|null} [end] ReservedRange end
                 */

                /**
                 * Constructs a new ReservedRange.
                 * @memberof google.protobuf.DescriptorProto
                 * @classdesc Represents a ReservedRange.
                 * @implements IReservedRange
                 * @constructor
                 * @param {google.protobuf.DescriptorProto.IReservedRange=} [properties] Properties to set
                 */
                function ReservedRange(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ReservedRange start.
                 * @member {number} start
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @instance
                 */
                ReservedRange.prototype.start = 0;

                /**
                 * ReservedRange end.
                 * @member {number} end
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @instance
                 */
                ReservedRange.prototype.end = 0;

                /**
                 * Creates a new ReservedRange instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.IReservedRange=} [properties] Properties to set
                 * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange instance
                 */
                ReservedRange.create = function create(properties) {
                    return new ReservedRange(properties);
                };

                /**
                 * Encodes the specified ReservedRange message. Does not implicitly {@link google.protobuf.DescriptorProto.ReservedRange.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.IReservedRange} message ReservedRange message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReservedRange.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.start != null && message.hasOwnProperty("start"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.start);
                    if (message.end != null && message.hasOwnProperty("end"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.end);
                    return writer;
                };

                /**
                 * Decodes a ReservedRange message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReservedRange.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto.ReservedRange();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.start = reader.int32();
                            break;
                        case 2:
                            message.end = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Verifies a ReservedRange message.
                 * @function verify
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ReservedRange.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.start != null && message.hasOwnProperty("start"))
                        if (!$util.isInteger(message.start))
                            return "start: integer expected";
                    if (message.end != null && message.hasOwnProperty("end"))
                        if (!$util.isInteger(message.end))
                            return "end: integer expected";
                    return null;
                };

                return ReservedRange;
            })();

            return DescriptorProto;
        })();

        protobuf.FieldDescriptorProto = (function() {

            /**
             * Properties of a FieldDescriptorProto.
             * @memberof google.protobuf
             * @interface IFieldDescriptorProto
             * @property {string|null} [name] FieldDescriptorProto name
             * @property {number|null} [number] FieldDescriptorProto number
             * @property {google.protobuf.FieldDescriptorProto.Label|null} [label] FieldDescriptorProto label
             * @property {google.protobuf.FieldDescriptorProto.Type|null} [type] FieldDescriptorProto type
             * @property {string|null} [typeName] FieldDescriptorProto typeName
             * @property {string|null} [extendee] FieldDescriptorProto extendee
             * @property {string|null} [defaultValue] FieldDescriptorProto defaultValue
             * @property {number|null} [oneofIndex] FieldDescriptorProto oneofIndex
             * @property {string|null} [jsonName] FieldDescriptorProto jsonName
             * @property {google.protobuf.IFieldOptions|null} [options] FieldDescriptorProto options
             */

            /**
             * Constructs a new FieldDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a FieldDescriptorProto.
             * @implements IFieldDescriptorProto
             * @constructor
             * @param {google.protobuf.IFieldDescriptorProto=} [properties] Properties to set
             */
            function FieldDescriptorProto(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FieldDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.name = "";

            /**
             * FieldDescriptorProto number.
             * @member {number} number
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.number = 0;

            /**
             * FieldDescriptorProto label.
             * @member {google.protobuf.FieldDescriptorProto.Label} label
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.label = 1;

            /**
             * FieldDescriptorProto type.
             * @member {google.protobuf.FieldDescriptorProto.Type} type
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.type = 1;

            /**
             * FieldDescriptorProto typeName.
             * @member {string} typeName
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.typeName = "";

            /**
             * FieldDescriptorProto extendee.
             * @member {string} extendee
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.extendee = "";

            /**
             * FieldDescriptorProto defaultValue.
             * @member {string} defaultValue
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.defaultValue = "";

            /**
             * FieldDescriptorProto oneofIndex.
             * @member {number} oneofIndex
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.oneofIndex = 0;

            /**
             * FieldDescriptorProto jsonName.
             * @member {string} jsonName
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.jsonName = "";

            /**
             * FieldDescriptorProto options.
             * @member {google.protobuf.IFieldOptions|null|undefined} options
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.options = null;

            /**
             * Creates a new FieldDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {google.protobuf.IFieldDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto instance
             */
            FieldDescriptorProto.create = function create(properties) {
                return new FieldDescriptorProto(properties);
            };

            /**
             * Encodes the specified FieldDescriptorProto message. Does not implicitly {@link google.protobuf.FieldDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {google.protobuf.IFieldDescriptorProto} message FieldDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.extendee != null && message.hasOwnProperty("extendee"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.extendee);
                if (message.number != null && message.hasOwnProperty("number"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.number);
                if (message.label != null && message.hasOwnProperty("label"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.label);
                if (message.type != null && message.hasOwnProperty("type"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.type);
                if (message.typeName != null && message.hasOwnProperty("typeName"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.typeName);
                if (message.defaultValue != null && message.hasOwnProperty("defaultValue"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.defaultValue);
                if (message.options != null && message.hasOwnProperty("options"))
                    $root.google.protobuf.FieldOptions.encode(message.options, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.oneofIndex != null && message.hasOwnProperty("oneofIndex"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.oneofIndex);
                if (message.jsonName != null && message.hasOwnProperty("jsonName"))
                    writer.uint32(/* id 10, wireType 2 =*/82).string(message.jsonName);
                return writer;
            };

            /**
             * Decodes a FieldDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 3:
                        message.number = reader.int32();
                        break;
                    case 4:
                        message.label = reader.int32();
                        break;
                    case 5:
                        message.type = reader.int32();
                        break;
                    case 6:
                        message.typeName = reader.string();
                        break;
                    case 2:
                        message.extendee = reader.string();
                        break;
                    case 7:
                        message.defaultValue = reader.string();
                        break;
                    case 9:
                        message.oneofIndex = reader.int32();
                        break;
                    case 10:
                        message.jsonName = reader.string();
                        break;
                    case 8:
                        message.options = $root.google.protobuf.FieldOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a FieldDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FieldDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.number != null && message.hasOwnProperty("number"))
                    if (!$util.isInteger(message.number))
                        return "number: integer expected";
                if (message.label != null && message.hasOwnProperty("label"))
                    switch (message.label) {
                    default:
                        return "label: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                    case 16:
                    case 17:
                    case 18:
                        break;
                    }
                if (message.typeName != null && message.hasOwnProperty("typeName"))
                    if (!$util.isString(message.typeName))
                        return "typeName: string expected";
                if (message.extendee != null && message.hasOwnProperty("extendee"))
                    if (!$util.isString(message.extendee))
                        return "extendee: string expected";
                if (message.defaultValue != null && message.hasOwnProperty("defaultValue"))
                    if (!$util.isString(message.defaultValue))
                        return "defaultValue: string expected";
                if (message.oneofIndex != null && message.hasOwnProperty("oneofIndex"))
                    if (!$util.isInteger(message.oneofIndex))
                        return "oneofIndex: integer expected";
                if (message.jsonName != null && message.hasOwnProperty("jsonName"))
                    if (!$util.isString(message.jsonName))
                        return "jsonName: string expected";
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.FieldOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };

            /**
             * Type enum.
             * @name google.protobuf.FieldDescriptorProto.Type
             * @enum {string}
             * @property {number} TYPE_DOUBLE=1 TYPE_DOUBLE value
             * @property {number} TYPE_FLOAT=2 TYPE_FLOAT value
             * @property {number} TYPE_INT64=3 TYPE_INT64 value
             * @property {number} TYPE_UINT64=4 TYPE_UINT64 value
             * @property {number} TYPE_INT32=5 TYPE_INT32 value
             * @property {number} TYPE_FIXED64=6 TYPE_FIXED64 value
             * @property {number} TYPE_FIXED32=7 TYPE_FIXED32 value
             * @property {number} TYPE_BOOL=8 TYPE_BOOL value
             * @property {number} TYPE_STRING=9 TYPE_STRING value
             * @property {number} TYPE_GROUP=10 TYPE_GROUP value
             * @property {number} TYPE_MESSAGE=11 TYPE_MESSAGE value
             * @property {number} TYPE_BYTES=12 TYPE_BYTES value
             * @property {number} TYPE_UINT32=13 TYPE_UINT32 value
             * @property {number} TYPE_ENUM=14 TYPE_ENUM value
             * @property {number} TYPE_SFIXED32=15 TYPE_SFIXED32 value
             * @property {number} TYPE_SFIXED64=16 TYPE_SFIXED64 value
             * @property {number} TYPE_SINT32=17 TYPE_SINT32 value
             * @property {number} TYPE_SINT64=18 TYPE_SINT64 value
             */
            FieldDescriptorProto.Type = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[1] = "TYPE_DOUBLE"] = 1;
                values[valuesById[2] = "TYPE_FLOAT"] = 2;
                values[valuesById[3] = "TYPE_INT64"] = 3;
                values[valuesById[4] = "TYPE_UINT64"] = 4;
                values[valuesById[5] = "TYPE_INT32"] = 5;
                values[valuesById[6] = "TYPE_FIXED64"] = 6;
                values[valuesById[7] = "TYPE_FIXED32"] = 7;
                values[valuesById[8] = "TYPE_BOOL"] = 8;
                values[valuesById[9] = "TYPE_STRING"] = 9;
                values[valuesById[10] = "TYPE_GROUP"] = 10;
                values[valuesById[11] = "TYPE_MESSAGE"] = 11;
                values[valuesById[12] = "TYPE_BYTES"] = 12;
                values[valuesById[13] = "TYPE_UINT32"] = 13;
                values[valuesById[14] = "TYPE_ENUM"] = 14;
                values[valuesById[15] = "TYPE_SFIXED32"] = 15;
                values[valuesById[16] = "TYPE_SFIXED64"] = 16;
                values[valuesById[17] = "TYPE_SINT32"] = 17;
                values[valuesById[18] = "TYPE_SINT64"] = 18;
                return values;
            })();

            /**
             * Label enum.
             * @name google.protobuf.FieldDescriptorProto.Label
             * @enum {string}
             * @property {number} LABEL_OPTIONAL=1 LABEL_OPTIONAL value
             * @property {number} LABEL_REQUIRED=2 LABEL_REQUIRED value
             * @property {number} LABEL_REPEATED=3 LABEL_REPEATED value
             */
            FieldDescriptorProto.Label = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[1] = "LABEL_OPTIONAL"] = 1;
                values[valuesById[2] = "LABEL_REQUIRED"] = 2;
                values[valuesById[3] = "LABEL_REPEATED"] = 3;
                return values;
            })();

            return FieldDescriptorProto;
        })();

        protobuf.OneofDescriptorProto = (function() {

            /**
             * Properties of an OneofDescriptorProto.
             * @memberof google.protobuf
             * @interface IOneofDescriptorProto
             * @property {string|null} [name] OneofDescriptorProto name
             * @property {google.protobuf.IOneofOptions|null} [options] OneofDescriptorProto options
             */

            /**
             * Constructs a new OneofDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents an OneofDescriptorProto.
             * @implements IOneofDescriptorProto
             * @constructor
             * @param {google.protobuf.IOneofDescriptorProto=} [properties] Properties to set
             */
            function OneofDescriptorProto(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * OneofDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.OneofDescriptorProto
             * @instance
             */
            OneofDescriptorProto.prototype.name = "";

            /**
             * OneofDescriptorProto options.
             * @member {google.protobuf.IOneofOptions|null|undefined} options
             * @memberof google.protobuf.OneofDescriptorProto
             * @instance
             */
            OneofDescriptorProto.prototype.options = null;

            /**
             * Creates a new OneofDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {google.protobuf.IOneofDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto instance
             */
            OneofDescriptorProto.create = function create(properties) {
                return new OneofDescriptorProto(properties);
            };

            /**
             * Encodes the specified OneofDescriptorProto message. Does not implicitly {@link google.protobuf.OneofDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {google.protobuf.IOneofDescriptorProto} message OneofDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OneofDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.options != null && message.hasOwnProperty("options"))
                    $root.google.protobuf.OneofOptions.encode(message.options, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes an OneofDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OneofDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.OneofDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.options = $root.google.protobuf.OneofOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies an OneofDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OneofDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.OneofOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };

            return OneofDescriptorProto;
        })();

        protobuf.EnumDescriptorProto = (function() {

            /**
             * Properties of an EnumDescriptorProto.
             * @memberof google.protobuf
             * @interface IEnumDescriptorProto
             * @property {string|null} [name] EnumDescriptorProto name
             * @property {Array.<google.protobuf.IEnumValueDescriptorProto>|null} [value] EnumDescriptorProto value
             * @property {google.protobuf.IEnumOptions|null} [options] EnumDescriptorProto options
             */

            /**
             * Constructs a new EnumDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents an EnumDescriptorProto.
             * @implements IEnumDescriptorProto
             * @constructor
             * @param {google.protobuf.IEnumDescriptorProto=} [properties] Properties to set
             */
            function EnumDescriptorProto(properties) {
                this.value = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnumDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             */
            EnumDescriptorProto.prototype.name = "";

            /**
             * EnumDescriptorProto value.
             * @member {Array.<google.protobuf.IEnumValueDescriptorProto>} value
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             */
            EnumDescriptorProto.prototype.value = $util.emptyArray;

            /**
             * EnumDescriptorProto options.
             * @member {google.protobuf.IEnumOptions|null|undefined} options
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             */
            EnumDescriptorProto.prototype.options = null;

            /**
             * Creates a new EnumDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {google.protobuf.IEnumDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto instance
             */
            EnumDescriptorProto.create = function create(properties) {
                return new EnumDescriptorProto(properties);
            };

            /**
             * Encodes the specified EnumDescriptorProto message. Does not implicitly {@link google.protobuf.EnumDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {google.protobuf.IEnumDescriptorProto} message EnumDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.value != null && message.value.length)
                    for (let i = 0; i < message.value.length; ++i)
                        $root.google.protobuf.EnumValueDescriptorProto.encode(message.value[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.options != null && message.hasOwnProperty("options"))
                    $root.google.protobuf.EnumOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes an EnumDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        if (!(message.value && message.value.length))
                            message.value = [];
                        message.value.push($root.google.protobuf.EnumValueDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.options = $root.google.protobuf.EnumOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies an EnumDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EnumDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.value != null && message.hasOwnProperty("value")) {
                    if (!Array.isArray(message.value))
                        return "value: array expected";
                    for (let i = 0; i < message.value.length; ++i) {
                        let error = $root.google.protobuf.EnumValueDescriptorProto.verify(message.value[i]);
                        if (error)
                            return "value." + error;
                    }
                }
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.EnumOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };

            return EnumDescriptorProto;
        })();

        protobuf.EnumValueDescriptorProto = (function() {

            /**
             * Properties of an EnumValueDescriptorProto.
             * @memberof google.protobuf
             * @interface IEnumValueDescriptorProto
             * @property {string|null} [name] EnumValueDescriptorProto name
             * @property {number|null} [number] EnumValueDescriptorProto number
             * @property {google.protobuf.IEnumValueOptions|null} [options] EnumValueDescriptorProto options
             */

            /**
             * Constructs a new EnumValueDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents an EnumValueDescriptorProto.
             * @implements IEnumValueDescriptorProto
             * @constructor
             * @param {google.protobuf.IEnumValueDescriptorProto=} [properties] Properties to set
             */
            function EnumValueDescriptorProto(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnumValueDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @instance
             */
            EnumValueDescriptorProto.prototype.name = "";

            /**
             * EnumValueDescriptorProto number.
             * @member {number} number
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @instance
             */
            EnumValueDescriptorProto.prototype.number = 0;

            /**
             * EnumValueDescriptorProto options.
             * @member {google.protobuf.IEnumValueOptions|null|undefined} options
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @instance
             */
            EnumValueDescriptorProto.prototype.options = null;

            /**
             * Creates a new EnumValueDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {google.protobuf.IEnumValueDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto instance
             */
            EnumValueDescriptorProto.create = function create(properties) {
                return new EnumValueDescriptorProto(properties);
            };

            /**
             * Encodes the specified EnumValueDescriptorProto message. Does not implicitly {@link google.protobuf.EnumValueDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {google.protobuf.IEnumValueDescriptorProto} message EnumValueDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumValueDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.number != null && message.hasOwnProperty("number"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.number);
                if (message.options != null && message.hasOwnProperty("options"))
                    $root.google.protobuf.EnumValueOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes an EnumValueDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumValueDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumValueDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.number = reader.int32();
                        break;
                    case 3:
                        message.options = $root.google.protobuf.EnumValueOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies an EnumValueDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EnumValueDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.number != null && message.hasOwnProperty("number"))
                    if (!$util.isInteger(message.number))
                        return "number: integer expected";
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.EnumValueOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };

            return EnumValueDescriptorProto;
        })();

        protobuf.ServiceDescriptorProto = (function() {

            /**
             * Properties of a ServiceDescriptorProto.
             * @memberof google.protobuf
             * @interface IServiceDescriptorProto
             * @property {string|null} [name] ServiceDescriptorProto name
             * @property {Array.<google.protobuf.IMethodDescriptorProto>|null} [method] ServiceDescriptorProto method
             * @property {google.protobuf.IServiceOptions|null} [options] ServiceDescriptorProto options
             */

            /**
             * Constructs a new ServiceDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a ServiceDescriptorProto.
             * @implements IServiceDescriptorProto
             * @constructor
             * @param {google.protobuf.IServiceDescriptorProto=} [properties] Properties to set
             */
            function ServiceDescriptorProto(properties) {
                this.method = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ServiceDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.ServiceDescriptorProto
             * @instance
             */
            ServiceDescriptorProto.prototype.name = "";

            /**
             * ServiceDescriptorProto method.
             * @member {Array.<google.protobuf.IMethodDescriptorProto>} method
             * @memberof google.protobuf.ServiceDescriptorProto
             * @instance
             */
            ServiceDescriptorProto.prototype.method = $util.emptyArray;

            /**
             * ServiceDescriptorProto options.
             * @member {google.protobuf.IServiceOptions|null|undefined} options
             * @memberof google.protobuf.ServiceDescriptorProto
             * @instance
             */
            ServiceDescriptorProto.prototype.options = null;

            /**
             * Creates a new ServiceDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {google.protobuf.IServiceDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto instance
             */
            ServiceDescriptorProto.create = function create(properties) {
                return new ServiceDescriptorProto(properties);
            };

            /**
             * Encodes the specified ServiceDescriptorProto message. Does not implicitly {@link google.protobuf.ServiceDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {google.protobuf.IServiceDescriptorProto} message ServiceDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServiceDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.method != null && message.method.length)
                    for (let i = 0; i < message.method.length; ++i)
                        $root.google.protobuf.MethodDescriptorProto.encode(message.method[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.options != null && message.hasOwnProperty("options"))
                    $root.google.protobuf.ServiceOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a ServiceDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServiceDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ServiceDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        if (!(message.method && message.method.length))
                            message.method = [];
                        message.method.push($root.google.protobuf.MethodDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.options = $root.google.protobuf.ServiceOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a ServiceDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ServiceDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.method != null && message.hasOwnProperty("method")) {
                    if (!Array.isArray(message.method))
                        return "method: array expected";
                    for (let i = 0; i < message.method.length; ++i) {
                        let error = $root.google.protobuf.MethodDescriptorProto.verify(message.method[i]);
                        if (error)
                            return "method." + error;
                    }
                }
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.ServiceOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };

            return ServiceDescriptorProto;
        })();

        protobuf.MethodDescriptorProto = (function() {

            /**
             * Properties of a MethodDescriptorProto.
             * @memberof google.protobuf
             * @interface IMethodDescriptorProto
             * @property {string|null} [name] MethodDescriptorProto name
             * @property {string|null} [inputType] MethodDescriptorProto inputType
             * @property {string|null} [outputType] MethodDescriptorProto outputType
             * @property {google.protobuf.IMethodOptions|null} [options] MethodDescriptorProto options
             * @property {boolean|null} [clientStreaming] MethodDescriptorProto clientStreaming
             * @property {boolean|null} [serverStreaming] MethodDescriptorProto serverStreaming
             */

            /**
             * Constructs a new MethodDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a MethodDescriptorProto.
             * @implements IMethodDescriptorProto
             * @constructor
             * @param {google.protobuf.IMethodDescriptorProto=} [properties] Properties to set
             */
            function MethodDescriptorProto(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MethodDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.name = "";

            /**
             * MethodDescriptorProto inputType.
             * @member {string} inputType
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.inputType = "";

            /**
             * MethodDescriptorProto outputType.
             * @member {string} outputType
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.outputType = "";

            /**
             * MethodDescriptorProto options.
             * @member {google.protobuf.IMethodOptions|null|undefined} options
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.options = null;

            /**
             * MethodDescriptorProto clientStreaming.
             * @member {boolean} clientStreaming
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.clientStreaming = false;

            /**
             * MethodDescriptorProto serverStreaming.
             * @member {boolean} serverStreaming
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.serverStreaming = false;

            /**
             * Creates a new MethodDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {google.protobuf.IMethodDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto instance
             */
            MethodDescriptorProto.create = function create(properties) {
                return new MethodDescriptorProto(properties);
            };

            /**
             * Encodes the specified MethodDescriptorProto message. Does not implicitly {@link google.protobuf.MethodDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {google.protobuf.IMethodDescriptorProto} message MethodDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MethodDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.inputType != null && message.hasOwnProperty("inputType"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.inputType);
                if (message.outputType != null && message.hasOwnProperty("outputType"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.outputType);
                if (message.options != null && message.hasOwnProperty("options"))
                    $root.google.protobuf.MethodOptions.encode(message.options, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.clientStreaming != null && message.hasOwnProperty("clientStreaming"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.clientStreaming);
                if (message.serverStreaming != null && message.hasOwnProperty("serverStreaming"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.serverStreaming);
                return writer;
            };

            /**
             * Decodes a MethodDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MethodDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MethodDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.inputType = reader.string();
                        break;
                    case 3:
                        message.outputType = reader.string();
                        break;
                    case 4:
                        message.options = $root.google.protobuf.MethodOptions.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.clientStreaming = reader.bool();
                        break;
                    case 6:
                        message.serverStreaming = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a MethodDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MethodDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.inputType != null && message.hasOwnProperty("inputType"))
                    if (!$util.isString(message.inputType))
                        return "inputType: string expected";
                if (message.outputType != null && message.hasOwnProperty("outputType"))
                    if (!$util.isString(message.outputType))
                        return "outputType: string expected";
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.MethodOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                if (message.clientStreaming != null && message.hasOwnProperty("clientStreaming"))
                    if (typeof message.clientStreaming !== "boolean")
                        return "clientStreaming: boolean expected";
                if (message.serverStreaming != null && message.hasOwnProperty("serverStreaming"))
                    if (typeof message.serverStreaming !== "boolean")
                        return "serverStreaming: boolean expected";
                return null;
            };

            return MethodDescriptorProto;
        })();

        protobuf.FileOptions = (function() {

            /**
             * Properties of a FileOptions.
             * @memberof google.protobuf
             * @interface IFileOptions
             * @property {string|null} [javaPackage] FileOptions javaPackage
             * @property {string|null} [javaOuterClassname] FileOptions javaOuterClassname
             * @property {boolean|null} [javaMultipleFiles] FileOptions javaMultipleFiles
             * @property {boolean|null} [javaGenerateEqualsAndHash] FileOptions javaGenerateEqualsAndHash
             * @property {boolean|null} [javaStringCheckUtf8] FileOptions javaStringCheckUtf8
             * @property {google.protobuf.FileOptions.OptimizeMode|null} [optimizeFor] FileOptions optimizeFor
             * @property {string|null} [goPackage] FileOptions goPackage
             * @property {boolean|null} [ccGenericServices] FileOptions ccGenericServices
             * @property {boolean|null} [javaGenericServices] FileOptions javaGenericServices
             * @property {boolean|null} [pyGenericServices] FileOptions pyGenericServices
             * @property {boolean|null} [deprecated] FileOptions deprecated
             * @property {boolean|null} [ccEnableArenas] FileOptions ccEnableArenas
             * @property {string|null} [objcClassPrefix] FileOptions objcClassPrefix
             * @property {string|null} [csharpNamespace] FileOptions csharpNamespace
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] FileOptions uninterpretedOption
             */

            /**
             * Constructs a new FileOptions.
             * @memberof google.protobuf
             * @classdesc Represents a FileOptions.
             * @implements IFileOptions
             * @constructor
             * @param {google.protobuf.IFileOptions=} [properties] Properties to set
             */
            function FileOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FileOptions javaPackage.
             * @member {string} javaPackage
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaPackage = "";

            /**
             * FileOptions javaOuterClassname.
             * @member {string} javaOuterClassname
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaOuterClassname = "";

            /**
             * FileOptions javaMultipleFiles.
             * @member {boolean} javaMultipleFiles
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaMultipleFiles = false;

            /**
             * FileOptions javaGenerateEqualsAndHash.
             * @member {boolean} javaGenerateEqualsAndHash
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaGenerateEqualsAndHash = false;

            /**
             * FileOptions javaStringCheckUtf8.
             * @member {boolean} javaStringCheckUtf8
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaStringCheckUtf8 = false;

            /**
             * FileOptions optimizeFor.
             * @member {google.protobuf.FileOptions.OptimizeMode} optimizeFor
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.optimizeFor = 1;

            /**
             * FileOptions goPackage.
             * @member {string} goPackage
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.goPackage = "";

            /**
             * FileOptions ccGenericServices.
             * @member {boolean} ccGenericServices
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.ccGenericServices = false;

            /**
             * FileOptions javaGenericServices.
             * @member {boolean} javaGenericServices
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaGenericServices = false;

            /**
             * FileOptions pyGenericServices.
             * @member {boolean} pyGenericServices
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.pyGenericServices = false;

            /**
             * FileOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.deprecated = false;

            /**
             * FileOptions ccEnableArenas.
             * @member {boolean} ccEnableArenas
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.ccEnableArenas = false;

            /**
             * FileOptions objcClassPrefix.
             * @member {string} objcClassPrefix
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.objcClassPrefix = "";

            /**
             * FileOptions csharpNamespace.
             * @member {string} csharpNamespace
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.csharpNamespace = "";

            /**
             * FileOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new FileOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {google.protobuf.IFileOptions=} [properties] Properties to set
             * @returns {google.protobuf.FileOptions} FileOptions instance
             */
            FileOptions.create = function create(properties) {
                return new FileOptions(properties);
            };

            /**
             * Encodes the specified FileOptions message. Does not implicitly {@link google.protobuf.FileOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {google.protobuf.IFileOptions} message FileOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.javaPackage != null && message.hasOwnProperty("javaPackage"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.javaPackage);
                if (message.javaOuterClassname != null && message.hasOwnProperty("javaOuterClassname"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.javaOuterClassname);
                if (message.optimizeFor != null && message.hasOwnProperty("optimizeFor"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.optimizeFor);
                if (message.javaMultipleFiles != null && message.hasOwnProperty("javaMultipleFiles"))
                    writer.uint32(/* id 10, wireType 0 =*/80).bool(message.javaMultipleFiles);
                if (message.goPackage != null && message.hasOwnProperty("goPackage"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.goPackage);
                if (message.ccGenericServices != null && message.hasOwnProperty("ccGenericServices"))
                    writer.uint32(/* id 16, wireType 0 =*/128).bool(message.ccGenericServices);
                if (message.javaGenericServices != null && message.hasOwnProperty("javaGenericServices"))
                    writer.uint32(/* id 17, wireType 0 =*/136).bool(message.javaGenericServices);
                if (message.pyGenericServices != null && message.hasOwnProperty("pyGenericServices"))
                    writer.uint32(/* id 18, wireType 0 =*/144).bool(message.pyGenericServices);
                if (message.javaGenerateEqualsAndHash != null && message.hasOwnProperty("javaGenerateEqualsAndHash"))
                    writer.uint32(/* id 20, wireType 0 =*/160).bool(message.javaGenerateEqualsAndHash);
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    writer.uint32(/* id 23, wireType 0 =*/184).bool(message.deprecated);
                if (message.javaStringCheckUtf8 != null && message.hasOwnProperty("javaStringCheckUtf8"))
                    writer.uint32(/* id 27, wireType 0 =*/216).bool(message.javaStringCheckUtf8);
                if (message.ccEnableArenas != null && message.hasOwnProperty("ccEnableArenas"))
                    writer.uint32(/* id 31, wireType 0 =*/248).bool(message.ccEnableArenas);
                if (message.objcClassPrefix != null && message.hasOwnProperty("objcClassPrefix"))
                    writer.uint32(/* id 36, wireType 2 =*/290).string(message.objcClassPrefix);
                if (message.csharpNamespace != null && message.hasOwnProperty("csharpNamespace"))
                    writer.uint32(/* id 37, wireType 2 =*/298).string(message.csharpNamespace);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (let i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a FileOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FileOptions} FileOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.javaPackage = reader.string();
                        break;
                    case 8:
                        message.javaOuterClassname = reader.string();
                        break;
                    case 10:
                        message.javaMultipleFiles = reader.bool();
                        break;
                    case 20:
                        message.javaGenerateEqualsAndHash = reader.bool();
                        break;
                    case 27:
                        message.javaStringCheckUtf8 = reader.bool();
                        break;
                    case 9:
                        message.optimizeFor = reader.int32();
                        break;
                    case 11:
                        message.goPackage = reader.string();
                        break;
                    case 16:
                        message.ccGenericServices = reader.bool();
                        break;
                    case 17:
                        message.javaGenericServices = reader.bool();
                        break;
                    case 18:
                        message.pyGenericServices = reader.bool();
                        break;
                    case 23:
                        message.deprecated = reader.bool();
                        break;
                    case 31:
                        message.ccEnableArenas = reader.bool();
                        break;
                    case 36:
                        message.objcClassPrefix = reader.string();
                        break;
                    case 37:
                        message.csharpNamespace = reader.string();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a FileOptions message.
             * @function verify
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FileOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.javaPackage != null && message.hasOwnProperty("javaPackage"))
                    if (!$util.isString(message.javaPackage))
                        return "javaPackage: string expected";
                if (message.javaOuterClassname != null && message.hasOwnProperty("javaOuterClassname"))
                    if (!$util.isString(message.javaOuterClassname))
                        return "javaOuterClassname: string expected";
                if (message.javaMultipleFiles != null && message.hasOwnProperty("javaMultipleFiles"))
                    if (typeof message.javaMultipleFiles !== "boolean")
                        return "javaMultipleFiles: boolean expected";
                if (message.javaGenerateEqualsAndHash != null && message.hasOwnProperty("javaGenerateEqualsAndHash"))
                    if (typeof message.javaGenerateEqualsAndHash !== "boolean")
                        return "javaGenerateEqualsAndHash: boolean expected";
                if (message.javaStringCheckUtf8 != null && message.hasOwnProperty("javaStringCheckUtf8"))
                    if (typeof message.javaStringCheckUtf8 !== "boolean")
                        return "javaStringCheckUtf8: boolean expected";
                if (message.optimizeFor != null && message.hasOwnProperty("optimizeFor"))
                    switch (message.optimizeFor) {
                    default:
                        return "optimizeFor: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.goPackage != null && message.hasOwnProperty("goPackage"))
                    if (!$util.isString(message.goPackage))
                        return "goPackage: string expected";
                if (message.ccGenericServices != null && message.hasOwnProperty("ccGenericServices"))
                    if (typeof message.ccGenericServices !== "boolean")
                        return "ccGenericServices: boolean expected";
                if (message.javaGenericServices != null && message.hasOwnProperty("javaGenericServices"))
                    if (typeof message.javaGenericServices !== "boolean")
                        return "javaGenericServices: boolean expected";
                if (message.pyGenericServices != null && message.hasOwnProperty("pyGenericServices"))
                    if (typeof message.pyGenericServices !== "boolean")
                        return "pyGenericServices: boolean expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.ccEnableArenas != null && message.hasOwnProperty("ccEnableArenas"))
                    if (typeof message.ccEnableArenas !== "boolean")
                        return "ccEnableArenas: boolean expected";
                if (message.objcClassPrefix != null && message.hasOwnProperty("objcClassPrefix"))
                    if (!$util.isString(message.objcClassPrefix))
                        return "objcClassPrefix: string expected";
                if (message.csharpNamespace != null && message.hasOwnProperty("csharpNamespace"))
                    if (!$util.isString(message.csharpNamespace))
                        return "csharpNamespace: string expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (let i = 0; i < message.uninterpretedOption.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * OptimizeMode enum.
             * @name google.protobuf.FileOptions.OptimizeMode
             * @enum {string}
             * @property {number} SPEED=1 SPEED value
             * @property {number} CODE_SIZE=2 CODE_SIZE value
             * @property {number} LITE_RUNTIME=3 LITE_RUNTIME value
             */
            FileOptions.OptimizeMode = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[1] = "SPEED"] = 1;
                values[valuesById[2] = "CODE_SIZE"] = 2;
                values[valuesById[3] = "LITE_RUNTIME"] = 3;
                return values;
            })();

            return FileOptions;
        })();

        protobuf.MessageOptions = (function() {

            /**
             * Properties of a MessageOptions.
             * @memberof google.protobuf
             * @interface IMessageOptions
             * @property {boolean|null} [messageSetWireFormat] MessageOptions messageSetWireFormat
             * @property {boolean|null} [noStandardDescriptorAccessor] MessageOptions noStandardDescriptorAccessor
             * @property {boolean|null} [deprecated] MessageOptions deprecated
             * @property {boolean|null} [mapEntry] MessageOptions mapEntry
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] MessageOptions uninterpretedOption
             */

            /**
             * Constructs a new MessageOptions.
             * @memberof google.protobuf
             * @classdesc Represents a MessageOptions.
             * @implements IMessageOptions
             * @constructor
             * @param {google.protobuf.IMessageOptions=} [properties] Properties to set
             */
            function MessageOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MessageOptions messageSetWireFormat.
             * @member {boolean} messageSetWireFormat
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.messageSetWireFormat = false;

            /**
             * MessageOptions noStandardDescriptorAccessor.
             * @member {boolean} noStandardDescriptorAccessor
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.noStandardDescriptorAccessor = false;

            /**
             * MessageOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.deprecated = false;

            /**
             * MessageOptions mapEntry.
             * @member {boolean} mapEntry
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.mapEntry = false;

            /**
             * MessageOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new MessageOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {google.protobuf.IMessageOptions=} [properties] Properties to set
             * @returns {google.protobuf.MessageOptions} MessageOptions instance
             */
            MessageOptions.create = function create(properties) {
                return new MessageOptions(properties);
            };

            /**
             * Encodes the specified MessageOptions message. Does not implicitly {@link google.protobuf.MessageOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {google.protobuf.IMessageOptions} message MessageOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MessageOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.messageSetWireFormat != null && message.hasOwnProperty("messageSetWireFormat"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.messageSetWireFormat);
                if (message.noStandardDescriptorAccessor != null && message.hasOwnProperty("noStandardDescriptorAccessor"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.noStandardDescriptorAccessor);
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                if (message.mapEntry != null && message.hasOwnProperty("mapEntry"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.mapEntry);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (let i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a MessageOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.MessageOptions} MessageOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MessageOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MessageOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.messageSetWireFormat = reader.bool();
                        break;
                    case 2:
                        message.noStandardDescriptorAccessor = reader.bool();
                        break;
                    case 3:
                        message.deprecated = reader.bool();
                        break;
                    case 7:
                        message.mapEntry = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a MessageOptions message.
             * @function verify
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MessageOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.messageSetWireFormat != null && message.hasOwnProperty("messageSetWireFormat"))
                    if (typeof message.messageSetWireFormat !== "boolean")
                        return "messageSetWireFormat: boolean expected";
                if (message.noStandardDescriptorAccessor != null && message.hasOwnProperty("noStandardDescriptorAccessor"))
                    if (typeof message.noStandardDescriptorAccessor !== "boolean")
                        return "noStandardDescriptorAccessor: boolean expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.mapEntry != null && message.hasOwnProperty("mapEntry"))
                    if (typeof message.mapEntry !== "boolean")
                        return "mapEntry: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (let i = 0; i < message.uninterpretedOption.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            return MessageOptions;
        })();

        protobuf.FieldOptions = (function() {

            /**
             * Properties of a FieldOptions.
             * @memberof google.protobuf
             * @interface IFieldOptions
             * @property {google.protobuf.FieldOptions.CType|null} [ctype] FieldOptions ctype
             * @property {boolean|null} [packed] FieldOptions packed
             * @property {google.protobuf.FieldOptions.JSType|null} [jstype] FieldOptions jstype
             * @property {boolean|null} [lazy] FieldOptions lazy
             * @property {boolean|null} [deprecated] FieldOptions deprecated
             * @property {boolean|null} [weak] FieldOptions weak
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] FieldOptions uninterpretedOption
             */

            /**
             * Constructs a new FieldOptions.
             * @memberof google.protobuf
             * @classdesc Represents a FieldOptions.
             * @implements IFieldOptions
             * @constructor
             * @param {google.protobuf.IFieldOptions=} [properties] Properties to set
             */
            function FieldOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FieldOptions ctype.
             * @member {google.protobuf.FieldOptions.CType} ctype
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.ctype = 0;

            /**
             * FieldOptions packed.
             * @member {boolean} packed
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.packed = false;

            /**
             * FieldOptions jstype.
             * @member {google.protobuf.FieldOptions.JSType} jstype
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.jstype = 0;

            /**
             * FieldOptions lazy.
             * @member {boolean} lazy
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.lazy = false;

            /**
             * FieldOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.deprecated = false;

            /**
             * FieldOptions weak.
             * @member {boolean} weak
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.weak = false;

            /**
             * FieldOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new FieldOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {google.protobuf.IFieldOptions=} [properties] Properties to set
             * @returns {google.protobuf.FieldOptions} FieldOptions instance
             */
            FieldOptions.create = function create(properties) {
                return new FieldOptions(properties);
            };

            /**
             * Encodes the specified FieldOptions message. Does not implicitly {@link google.protobuf.FieldOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {google.protobuf.IFieldOptions} message FieldOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.ctype != null && message.hasOwnProperty("ctype"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ctype);
                if (message.packed != null && message.hasOwnProperty("packed"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.packed);
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                if (message.lazy != null && message.hasOwnProperty("lazy"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.lazy);
                if (message.jstype != null && message.hasOwnProperty("jstype"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.jstype);
                if (message.weak != null && message.hasOwnProperty("weak"))
                    writer.uint32(/* id 10, wireType 0 =*/80).bool(message.weak);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (let i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a FieldOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FieldOptions} FieldOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.ctype = reader.int32();
                        break;
                    case 2:
                        message.packed = reader.bool();
                        break;
                    case 6:
                        message.jstype = reader.int32();
                        break;
                    case 5:
                        message.lazy = reader.bool();
                        break;
                    case 3:
                        message.deprecated = reader.bool();
                        break;
                    case 10:
                        message.weak = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a FieldOptions message.
             * @function verify
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FieldOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.ctype != null && message.hasOwnProperty("ctype"))
                    switch (message.ctype) {
                    default:
                        return "ctype: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.packed != null && message.hasOwnProperty("packed"))
                    if (typeof message.packed !== "boolean")
                        return "packed: boolean expected";
                if (message.jstype != null && message.hasOwnProperty("jstype"))
                    switch (message.jstype) {
                    default:
                        return "jstype: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.lazy != null && message.hasOwnProperty("lazy"))
                    if (typeof message.lazy !== "boolean")
                        return "lazy: boolean expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.weak != null && message.hasOwnProperty("weak"))
                    if (typeof message.weak !== "boolean")
                        return "weak: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (let i = 0; i < message.uninterpretedOption.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * CType enum.
             * @name google.protobuf.FieldOptions.CType
             * @enum {string}
             * @property {number} STRING=0 STRING value
             * @property {number} CORD=1 CORD value
             * @property {number} STRING_PIECE=2 STRING_PIECE value
             */
            FieldOptions.CType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "STRING"] = 0;
                values[valuesById[1] = "CORD"] = 1;
                values[valuesById[2] = "STRING_PIECE"] = 2;
                return values;
            })();

            /**
             * JSType enum.
             * @name google.protobuf.FieldOptions.JSType
             * @enum {string}
             * @property {number} JS_NORMAL=0 JS_NORMAL value
             * @property {number} JS_STRING=1 JS_STRING value
             * @property {number} JS_NUMBER=2 JS_NUMBER value
             */
            FieldOptions.JSType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "JS_NORMAL"] = 0;
                values[valuesById[1] = "JS_STRING"] = 1;
                values[valuesById[2] = "JS_NUMBER"] = 2;
                return values;
            })();

            return FieldOptions;
        })();

        protobuf.OneofOptions = (function() {

            /**
             * Properties of an OneofOptions.
             * @memberof google.protobuf
             * @interface IOneofOptions
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] OneofOptions uninterpretedOption
             */

            /**
             * Constructs a new OneofOptions.
             * @memberof google.protobuf
             * @classdesc Represents an OneofOptions.
             * @implements IOneofOptions
             * @constructor
             * @param {google.protobuf.IOneofOptions=} [properties] Properties to set
             */
            function OneofOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * OneofOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.OneofOptions
             * @instance
             */
            OneofOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new OneofOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {google.protobuf.IOneofOptions=} [properties] Properties to set
             * @returns {google.protobuf.OneofOptions} OneofOptions instance
             */
            OneofOptions.create = function create(properties) {
                return new OneofOptions(properties);
            };

            /**
             * Encodes the specified OneofOptions message. Does not implicitly {@link google.protobuf.OneofOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {google.protobuf.IOneofOptions} message OneofOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OneofOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (let i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes an OneofOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.OneofOptions} OneofOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OneofOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.OneofOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies an OneofOptions message.
             * @function verify
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OneofOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (let i = 0; i < message.uninterpretedOption.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            return OneofOptions;
        })();

        protobuf.EnumOptions = (function() {

            /**
             * Properties of an EnumOptions.
             * @memberof google.protobuf
             * @interface IEnumOptions
             * @property {boolean|null} [allowAlias] EnumOptions allowAlias
             * @property {boolean|null} [deprecated] EnumOptions deprecated
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] EnumOptions uninterpretedOption
             */

            /**
             * Constructs a new EnumOptions.
             * @memberof google.protobuf
             * @classdesc Represents an EnumOptions.
             * @implements IEnumOptions
             * @constructor
             * @param {google.protobuf.IEnumOptions=} [properties] Properties to set
             */
            function EnumOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnumOptions allowAlias.
             * @member {boolean} allowAlias
             * @memberof google.protobuf.EnumOptions
             * @instance
             */
            EnumOptions.prototype.allowAlias = false;

            /**
             * EnumOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.EnumOptions
             * @instance
             */
            EnumOptions.prototype.deprecated = false;

            /**
             * EnumOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.EnumOptions
             * @instance
             */
            EnumOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new EnumOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {google.protobuf.IEnumOptions=} [properties] Properties to set
             * @returns {google.protobuf.EnumOptions} EnumOptions instance
             */
            EnumOptions.create = function create(properties) {
                return new EnumOptions(properties);
            };

            /**
             * Encodes the specified EnumOptions message. Does not implicitly {@link google.protobuf.EnumOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {google.protobuf.IEnumOptions} message EnumOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.allowAlias != null && message.hasOwnProperty("allowAlias"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.allowAlias);
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (let i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes an EnumOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.EnumOptions} EnumOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2:
                        message.allowAlias = reader.bool();
                        break;
                    case 3:
                        message.deprecated = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies an EnumOptions message.
             * @function verify
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EnumOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.allowAlias != null && message.hasOwnProperty("allowAlias"))
                    if (typeof message.allowAlias !== "boolean")
                        return "allowAlias: boolean expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (let i = 0; i < message.uninterpretedOption.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            return EnumOptions;
        })();

        protobuf.EnumValueOptions = (function() {

            /**
             * Properties of an EnumValueOptions.
             * @memberof google.protobuf
             * @interface IEnumValueOptions
             * @property {boolean|null} [deprecated] EnumValueOptions deprecated
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] EnumValueOptions uninterpretedOption
             */

            /**
             * Constructs a new EnumValueOptions.
             * @memberof google.protobuf
             * @classdesc Represents an EnumValueOptions.
             * @implements IEnumValueOptions
             * @constructor
             * @param {google.protobuf.IEnumValueOptions=} [properties] Properties to set
             */
            function EnumValueOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnumValueOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.EnumValueOptions
             * @instance
             */
            EnumValueOptions.prototype.deprecated = false;

            /**
             * EnumValueOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.EnumValueOptions
             * @instance
             */
            EnumValueOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new EnumValueOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {google.protobuf.IEnumValueOptions=} [properties] Properties to set
             * @returns {google.protobuf.EnumValueOptions} EnumValueOptions instance
             */
            EnumValueOptions.create = function create(properties) {
                return new EnumValueOptions(properties);
            };

            /**
             * Encodes the specified EnumValueOptions message. Does not implicitly {@link google.protobuf.EnumValueOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {google.protobuf.IEnumValueOptions} message EnumValueOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumValueOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.deprecated);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (let i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes an EnumValueOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumValueOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumValueOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.deprecated = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies an EnumValueOptions message.
             * @function verify
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EnumValueOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (let i = 0; i < message.uninterpretedOption.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            return EnumValueOptions;
        })();

        protobuf.ServiceOptions = (function() {

            /**
             * Properties of a ServiceOptions.
             * @memberof google.protobuf
             * @interface IServiceOptions
             * @property {boolean|null} [deprecated] ServiceOptions deprecated
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] ServiceOptions uninterpretedOption
             */

            /**
             * Constructs a new ServiceOptions.
             * @memberof google.protobuf
             * @classdesc Represents a ServiceOptions.
             * @implements IServiceOptions
             * @constructor
             * @param {google.protobuf.IServiceOptions=} [properties] Properties to set
             */
            function ServiceOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ServiceOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.ServiceOptions
             * @instance
             */
            ServiceOptions.prototype.deprecated = false;

            /**
             * ServiceOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.ServiceOptions
             * @instance
             */
            ServiceOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new ServiceOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {google.protobuf.IServiceOptions=} [properties] Properties to set
             * @returns {google.protobuf.ServiceOptions} ServiceOptions instance
             */
            ServiceOptions.create = function create(properties) {
                return new ServiceOptions(properties);
            };

            /**
             * Encodes the specified ServiceOptions message. Does not implicitly {@link google.protobuf.ServiceOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {google.protobuf.IServiceOptions} message ServiceOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServiceOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    writer.uint32(/* id 33, wireType 0 =*/264).bool(message.deprecated);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (let i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a ServiceOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.ServiceOptions} ServiceOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServiceOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ServiceOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 33:
                        message.deprecated = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a ServiceOptions message.
             * @function verify
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ServiceOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (let i = 0; i < message.uninterpretedOption.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            return ServiceOptions;
        })();

        protobuf.MethodOptions = (function() {

            /**
             * Properties of a MethodOptions.
             * @memberof google.protobuf
             * @interface IMethodOptions
             * @property {boolean|null} [deprecated] MethodOptions deprecated
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] MethodOptions uninterpretedOption
             * @property {google.api.IHttpRule|null} [".google.api.http"] MethodOptions .google.api.http
             */

            /**
             * Constructs a new MethodOptions.
             * @memberof google.protobuf
             * @classdesc Represents a MethodOptions.
             * @implements IMethodOptions
             * @constructor
             * @param {google.protobuf.IMethodOptions=} [properties] Properties to set
             */
            function MethodOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MethodOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.MethodOptions
             * @instance
             */
            MethodOptions.prototype.deprecated = false;

            /**
             * MethodOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.MethodOptions
             * @instance
             */
            MethodOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * MethodOptions .google.api.http.
             * @member {google.api.IHttpRule|null|undefined} .google.api.http
             * @memberof google.protobuf.MethodOptions
             * @instance
             */
            MethodOptions.prototype[".google.api.http"] = null;

            /**
             * Creates a new MethodOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {google.protobuf.IMethodOptions=} [properties] Properties to set
             * @returns {google.protobuf.MethodOptions} MethodOptions instance
             */
            MethodOptions.create = function create(properties) {
                return new MethodOptions(properties);
            };

            /**
             * Encodes the specified MethodOptions message. Does not implicitly {@link google.protobuf.MethodOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {google.protobuf.IMethodOptions} message MethodOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MethodOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    writer.uint32(/* id 33, wireType 0 =*/264).bool(message.deprecated);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (let i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                if (message[".google.api.http"] != null && message.hasOwnProperty(".google.api.http"))
                    $root.google.api.HttpRule.encode(message[".google.api.http"], writer.uint32(/* id 72295728, wireType 2 =*/578365826).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a MethodOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.MethodOptions} MethodOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MethodOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MethodOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 33:
                        message.deprecated = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    case 72295728:
                        message[".google.api.http"] = $root.google.api.HttpRule.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a MethodOptions message.
             * @function verify
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MethodOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (let i = 0; i < message.uninterpretedOption.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                if (message[".google.api.http"] != null && message.hasOwnProperty(".google.api.http")) {
                    let error = $root.google.api.HttpRule.verify(message[".google.api.http"]);
                    if (error)
                        return ".google.api.http." + error;
                }
                return null;
            };

            return MethodOptions;
        })();

        protobuf.UninterpretedOption = (function() {

            /**
             * Properties of an UninterpretedOption.
             * @memberof google.protobuf
             * @interface IUninterpretedOption
             * @property {Array.<google.protobuf.UninterpretedOption.INamePart>|null} [name] UninterpretedOption name
             * @property {string|null} [identifierValue] UninterpretedOption identifierValue
             * @property {Long|null} [positiveIntValue] UninterpretedOption positiveIntValue
             * @property {Long|null} [negativeIntValue] UninterpretedOption negativeIntValue
             * @property {number|null} [doubleValue] UninterpretedOption doubleValue
             * @property {Uint8Array|null} [stringValue] UninterpretedOption stringValue
             * @property {string|null} [aggregateValue] UninterpretedOption aggregateValue
             */

            /**
             * Constructs a new UninterpretedOption.
             * @memberof google.protobuf
             * @classdesc Represents an UninterpretedOption.
             * @implements IUninterpretedOption
             * @constructor
             * @param {google.protobuf.IUninterpretedOption=} [properties] Properties to set
             */
            function UninterpretedOption(properties) {
                this.name = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UninterpretedOption name.
             * @member {Array.<google.protobuf.UninterpretedOption.INamePart>} name
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.name = $util.emptyArray;

            /**
             * UninterpretedOption identifierValue.
             * @member {string} identifierValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.identifierValue = "";

            /**
             * UninterpretedOption positiveIntValue.
             * @member {Long} positiveIntValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.positiveIntValue = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * UninterpretedOption negativeIntValue.
             * @member {Long} negativeIntValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.negativeIntValue = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * UninterpretedOption doubleValue.
             * @member {number} doubleValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.doubleValue = 0;

            /**
             * UninterpretedOption stringValue.
             * @member {Uint8Array} stringValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.stringValue = $util.newBuffer([]);

            /**
             * UninterpretedOption aggregateValue.
             * @member {string} aggregateValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.aggregateValue = "";

            /**
             * Creates a new UninterpretedOption instance using the specified properties.
             * @function create
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {google.protobuf.IUninterpretedOption=} [properties] Properties to set
             * @returns {google.protobuf.UninterpretedOption} UninterpretedOption instance
             */
            UninterpretedOption.create = function create(properties) {
                return new UninterpretedOption(properties);
            };

            /**
             * Encodes the specified UninterpretedOption message. Does not implicitly {@link google.protobuf.UninterpretedOption.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {google.protobuf.IUninterpretedOption} message UninterpretedOption message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UninterpretedOption.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.name.length)
                    for (let i = 0; i < message.name.length; ++i)
                        $root.google.protobuf.UninterpretedOption.NamePart.encode(message.name[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.identifierValue != null && message.hasOwnProperty("identifierValue"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.identifierValue);
                if (message.positiveIntValue != null && message.hasOwnProperty("positiveIntValue"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.positiveIntValue);
                if (message.negativeIntValue != null && message.hasOwnProperty("negativeIntValue"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.negativeIntValue);
                if (message.doubleValue != null && message.hasOwnProperty("doubleValue"))
                    writer.uint32(/* id 6, wireType 1 =*/49).double(message.doubleValue);
                if (message.stringValue != null && message.hasOwnProperty("stringValue"))
                    writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.stringValue);
                if (message.aggregateValue != null && message.hasOwnProperty("aggregateValue"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.aggregateValue);
                return writer;
            };

            /**
             * Decodes an UninterpretedOption message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UninterpretedOption.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UninterpretedOption();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2:
                        if (!(message.name && message.name.length))
                            message.name = [];
                        message.name.push($root.google.protobuf.UninterpretedOption.NamePart.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.identifierValue = reader.string();
                        break;
                    case 4:
                        message.positiveIntValue = reader.uint64();
                        break;
                    case 5:
                        message.negativeIntValue = reader.int64();
                        break;
                    case 6:
                        message.doubleValue = reader.double();
                        break;
                    case 7:
                        message.stringValue = reader.bytes();
                        break;
                    case 8:
                        message.aggregateValue = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies an UninterpretedOption message.
             * @function verify
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UninterpretedOption.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name")) {
                    if (!Array.isArray(message.name))
                        return "name: array expected";
                    for (let i = 0; i < message.name.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.NamePart.verify(message.name[i]);
                        if (error)
                            return "name." + error;
                    }
                }
                if (message.identifierValue != null && message.hasOwnProperty("identifierValue"))
                    if (!$util.isString(message.identifierValue))
                        return "identifierValue: string expected";
                if (message.positiveIntValue != null && message.hasOwnProperty("positiveIntValue"))
                    if (!$util.isInteger(message.positiveIntValue) && !(message.positiveIntValue && $util.isInteger(message.positiveIntValue.low) && $util.isInteger(message.positiveIntValue.high)))
                        return "positiveIntValue: integer|Long expected";
                if (message.negativeIntValue != null && message.hasOwnProperty("negativeIntValue"))
                    if (!$util.isInteger(message.negativeIntValue) && !(message.negativeIntValue && $util.isInteger(message.negativeIntValue.low) && $util.isInteger(message.negativeIntValue.high)))
                        return "negativeIntValue: integer|Long expected";
                if (message.doubleValue != null && message.hasOwnProperty("doubleValue"))
                    if (typeof message.doubleValue !== "number")
                        return "doubleValue: number expected";
                if (message.stringValue != null && message.hasOwnProperty("stringValue"))
                    if (!(message.stringValue && typeof message.stringValue.length === "number" || $util.isString(message.stringValue)))
                        return "stringValue: buffer expected";
                if (message.aggregateValue != null && message.hasOwnProperty("aggregateValue"))
                    if (!$util.isString(message.aggregateValue))
                        return "aggregateValue: string expected";
                return null;
            };

            UninterpretedOption.NamePart = (function() {

                /**
                 * Properties of a NamePart.
                 * @memberof google.protobuf.UninterpretedOption
                 * @interface INamePart
                 * @property {string} namePart NamePart namePart
                 * @property {boolean} isExtension NamePart isExtension
                 */

                /**
                 * Constructs a new NamePart.
                 * @memberof google.protobuf.UninterpretedOption
                 * @classdesc Represents a NamePart.
                 * @implements INamePart
                 * @constructor
                 * @param {google.protobuf.UninterpretedOption.INamePart=} [properties] Properties to set
                 */
                function NamePart(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * NamePart namePart.
                 * @member {string} namePart
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @instance
                 */
                NamePart.prototype.namePart = "";

                /**
                 * NamePart isExtension.
                 * @member {boolean} isExtension
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @instance
                 */
                NamePart.prototype.isExtension = false;

                /**
                 * Creates a new NamePart instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {google.protobuf.UninterpretedOption.INamePart=} [properties] Properties to set
                 * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart instance
                 */
                NamePart.create = function create(properties) {
                    return new NamePart(properties);
                };

                /**
                 * Encodes the specified NamePart message. Does not implicitly {@link google.protobuf.UninterpretedOption.NamePart.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {google.protobuf.UninterpretedOption.INamePart} message NamePart message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NamePart.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.namePart);
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isExtension);
                    return writer;
                };

                /**
                 * Decodes a NamePart message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NamePart.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UninterpretedOption.NamePart();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.namePart = reader.string();
                            break;
                        case 2:
                            message.isExtension = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("namePart"))
                        throw $util.ProtocolError("missing required 'namePart'", { instance: message });
                    if (!message.hasOwnProperty("isExtension"))
                        throw $util.ProtocolError("missing required 'isExtension'", { instance: message });
                    return message;
                };

                /**
                 * Verifies a NamePart message.
                 * @function verify
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NamePart.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (!$util.isString(message.namePart))
                        return "namePart: string expected";
                    if (typeof message.isExtension !== "boolean")
                        return "isExtension: boolean expected";
                    return null;
                };

                return NamePart;
            })();

            return UninterpretedOption;
        })();

        protobuf.SourceCodeInfo = (function() {

            /**
             * Properties of a SourceCodeInfo.
             * @memberof google.protobuf
             * @interface ISourceCodeInfo
             * @property {Array.<google.protobuf.SourceCodeInfo.ILocation>|null} [location] SourceCodeInfo location
             */

            /**
             * Constructs a new SourceCodeInfo.
             * @memberof google.protobuf
             * @classdesc Represents a SourceCodeInfo.
             * @implements ISourceCodeInfo
             * @constructor
             * @param {google.protobuf.ISourceCodeInfo=} [properties] Properties to set
             */
            function SourceCodeInfo(properties) {
                this.location = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SourceCodeInfo location.
             * @member {Array.<google.protobuf.SourceCodeInfo.ILocation>} location
             * @memberof google.protobuf.SourceCodeInfo
             * @instance
             */
            SourceCodeInfo.prototype.location = $util.emptyArray;

            /**
             * Creates a new SourceCodeInfo instance using the specified properties.
             * @function create
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {google.protobuf.ISourceCodeInfo=} [properties] Properties to set
             * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo instance
             */
            SourceCodeInfo.create = function create(properties) {
                return new SourceCodeInfo(properties);
            };

            /**
             * Encodes the specified SourceCodeInfo message. Does not implicitly {@link google.protobuf.SourceCodeInfo.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {google.protobuf.ISourceCodeInfo} message SourceCodeInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SourceCodeInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.location != null && message.location.length)
                    for (let i = 0; i < message.location.length; ++i)
                        $root.google.protobuf.SourceCodeInfo.Location.encode(message.location[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a SourceCodeInfo message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SourceCodeInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.SourceCodeInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.location && message.location.length))
                            message.location = [];
                        message.location.push($root.google.protobuf.SourceCodeInfo.Location.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a SourceCodeInfo message.
             * @function verify
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SourceCodeInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.location != null && message.hasOwnProperty("location")) {
                    if (!Array.isArray(message.location))
                        return "location: array expected";
                    for (let i = 0; i < message.location.length; ++i) {
                        let error = $root.google.protobuf.SourceCodeInfo.Location.verify(message.location[i]);
                        if (error)
                            return "location." + error;
                    }
                }
                return null;
            };

            SourceCodeInfo.Location = (function() {

                /**
                 * Properties of a Location.
                 * @memberof google.protobuf.SourceCodeInfo
                 * @interface ILocation
                 * @property {Array.<number>|null} [path] Location path
                 * @property {Array.<number>|null} [span] Location span
                 * @property {string|null} [leadingComments] Location leadingComments
                 * @property {string|null} [trailingComments] Location trailingComments
                 * @property {Array.<string>|null} [leadingDetachedComments] Location leadingDetachedComments
                 */

                /**
                 * Constructs a new Location.
                 * @memberof google.protobuf.SourceCodeInfo
                 * @classdesc Represents a Location.
                 * @implements ILocation
                 * @constructor
                 * @param {google.protobuf.SourceCodeInfo.ILocation=} [properties] Properties to set
                 */
                function Location(properties) {
                    this.path = [];
                    this.span = [];
                    this.leadingDetachedComments = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Location path.
                 * @member {Array.<number>} path
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.path = $util.emptyArray;

                /**
                 * Location span.
                 * @member {Array.<number>} span
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.span = $util.emptyArray;

                /**
                 * Location leadingComments.
                 * @member {string} leadingComments
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.leadingComments = "";

                /**
                 * Location trailingComments.
                 * @member {string} trailingComments
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.trailingComments = "";

                /**
                 * Location leadingDetachedComments.
                 * @member {Array.<string>} leadingDetachedComments
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.leadingDetachedComments = $util.emptyArray;

                /**
                 * Creates a new Location instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {google.protobuf.SourceCodeInfo.ILocation=} [properties] Properties to set
                 * @returns {google.protobuf.SourceCodeInfo.Location} Location instance
                 */
                Location.create = function create(properties) {
                    return new Location(properties);
                };

                /**
                 * Encodes the specified Location message. Does not implicitly {@link google.protobuf.SourceCodeInfo.Location.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {google.protobuf.SourceCodeInfo.ILocation} message Location message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Location.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.path != null && message.path.length) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork();
                        for (let i = 0; i < message.path.length; ++i)
                            writer.int32(message.path[i]);
                        writer.ldelim();
                    }
                    if (message.span != null && message.span.length) {
                        writer.uint32(/* id 2, wireType 2 =*/18).fork();
                        for (let i = 0; i < message.span.length; ++i)
                            writer.int32(message.span[i]);
                        writer.ldelim();
                    }
                    if (message.leadingComments != null && message.hasOwnProperty("leadingComments"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.leadingComments);
                    if (message.trailingComments != null && message.hasOwnProperty("trailingComments"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.trailingComments);
                    if (message.leadingDetachedComments != null && message.leadingDetachedComments.length)
                        for (let i = 0; i < message.leadingDetachedComments.length; ++i)
                            writer.uint32(/* id 6, wireType 2 =*/50).string(message.leadingDetachedComments[i]);
                    return writer;
                };

                /**
                 * Decodes a Location message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.SourceCodeInfo.Location} Location
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Location.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.SourceCodeInfo.Location();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.path && message.path.length))
                                message.path = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.path.push(reader.int32());
                            } else
                                message.path.push(reader.int32());
                            break;
                        case 2:
                            if (!(message.span && message.span.length))
                                message.span = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.span.push(reader.int32());
                            } else
                                message.span.push(reader.int32());
                            break;
                        case 3:
                            message.leadingComments = reader.string();
                            break;
                        case 4:
                            message.trailingComments = reader.string();
                            break;
                        case 6:
                            if (!(message.leadingDetachedComments && message.leadingDetachedComments.length))
                                message.leadingDetachedComments = [];
                            message.leadingDetachedComments.push(reader.string());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Verifies a Location message.
                 * @function verify
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Location.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.path != null && message.hasOwnProperty("path")) {
                        if (!Array.isArray(message.path))
                            return "path: array expected";
                        for (let i = 0; i < message.path.length; ++i)
                            if (!$util.isInteger(message.path[i]))
                                return "path: integer[] expected";
                    }
                    if (message.span != null && message.hasOwnProperty("span")) {
                        if (!Array.isArray(message.span))
                            return "span: array expected";
                        for (let i = 0; i < message.span.length; ++i)
                            if (!$util.isInteger(message.span[i]))
                                return "span: integer[] expected";
                    }
                    if (message.leadingComments != null && message.hasOwnProperty("leadingComments"))
                        if (!$util.isString(message.leadingComments))
                            return "leadingComments: string expected";
                    if (message.trailingComments != null && message.hasOwnProperty("trailingComments"))
                        if (!$util.isString(message.trailingComments))
                            return "trailingComments: string expected";
                    if (message.leadingDetachedComments != null && message.hasOwnProperty("leadingDetachedComments")) {
                        if (!Array.isArray(message.leadingDetachedComments))
                            return "leadingDetachedComments: array expected";
                        for (let i = 0; i < message.leadingDetachedComments.length; ++i)
                            if (!$util.isString(message.leadingDetachedComments[i]))
                                return "leadingDetachedComments: string[] expected";
                    }
                    return null;
                };

                return Location;
            })();

            return SourceCodeInfo;
        })();

        protobuf.GeneratedCodeInfo = (function() {

            /**
             * Properties of a GeneratedCodeInfo.
             * @memberof google.protobuf
             * @interface IGeneratedCodeInfo
             * @property {Array.<google.protobuf.GeneratedCodeInfo.IAnnotation>|null} [annotation] GeneratedCodeInfo annotation
             */

            /**
             * Constructs a new GeneratedCodeInfo.
             * @memberof google.protobuf
             * @classdesc Represents a GeneratedCodeInfo.
             * @implements IGeneratedCodeInfo
             * @constructor
             * @param {google.protobuf.IGeneratedCodeInfo=} [properties] Properties to set
             */
            function GeneratedCodeInfo(properties) {
                this.annotation = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GeneratedCodeInfo annotation.
             * @member {Array.<google.protobuf.GeneratedCodeInfo.IAnnotation>} annotation
             * @memberof google.protobuf.GeneratedCodeInfo
             * @instance
             */
            GeneratedCodeInfo.prototype.annotation = $util.emptyArray;

            /**
             * Creates a new GeneratedCodeInfo instance using the specified properties.
             * @function create
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {google.protobuf.IGeneratedCodeInfo=} [properties] Properties to set
             * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo instance
             */
            GeneratedCodeInfo.create = function create(properties) {
                return new GeneratedCodeInfo(properties);
            };

            /**
             * Encodes the specified GeneratedCodeInfo message. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {google.protobuf.IGeneratedCodeInfo} message GeneratedCodeInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GeneratedCodeInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.annotation != null && message.annotation.length)
                    for (let i = 0; i < message.annotation.length; ++i)
                        $root.google.protobuf.GeneratedCodeInfo.Annotation.encode(message.annotation[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a GeneratedCodeInfo message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GeneratedCodeInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.GeneratedCodeInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.annotation && message.annotation.length))
                            message.annotation = [];
                        message.annotation.push($root.google.protobuf.GeneratedCodeInfo.Annotation.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a GeneratedCodeInfo message.
             * @function verify
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GeneratedCodeInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.annotation != null && message.hasOwnProperty("annotation")) {
                    if (!Array.isArray(message.annotation))
                        return "annotation: array expected";
                    for (let i = 0; i < message.annotation.length; ++i) {
                        let error = $root.google.protobuf.GeneratedCodeInfo.Annotation.verify(message.annotation[i]);
                        if (error)
                            return "annotation." + error;
                    }
                }
                return null;
            };

            GeneratedCodeInfo.Annotation = (function() {

                /**
                 * Properties of an Annotation.
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @interface IAnnotation
                 * @property {Array.<number>|null} [path] Annotation path
                 * @property {string|null} [sourceFile] Annotation sourceFile
                 * @property {number|null} [begin] Annotation begin
                 * @property {number|null} [end] Annotation end
                 */

                /**
                 * Constructs a new Annotation.
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @classdesc Represents an Annotation.
                 * @implements IAnnotation
                 * @constructor
                 * @param {google.protobuf.GeneratedCodeInfo.IAnnotation=} [properties] Properties to set
                 */
                function Annotation(properties) {
                    this.path = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Annotation path.
                 * @member {Array.<number>} path
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 */
                Annotation.prototype.path = $util.emptyArray;

                /**
                 * Annotation sourceFile.
                 * @member {string} sourceFile
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 */
                Annotation.prototype.sourceFile = "";

                /**
                 * Annotation begin.
                 * @member {number} begin
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 */
                Annotation.prototype.begin = 0;

                /**
                 * Annotation end.
                 * @member {number} end
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 */
                Annotation.prototype.end = 0;

                /**
                 * Creates a new Annotation instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {google.protobuf.GeneratedCodeInfo.IAnnotation=} [properties] Properties to set
                 * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation instance
                 */
                Annotation.create = function create(properties) {
                    return new Annotation(properties);
                };

                /**
                 * Encodes the specified Annotation message. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.Annotation.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {google.protobuf.GeneratedCodeInfo.IAnnotation} message Annotation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Annotation.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.path != null && message.path.length) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork();
                        for (let i = 0; i < message.path.length; ++i)
                            writer.int32(message.path[i]);
                        writer.ldelim();
                    }
                    if (message.sourceFile != null && message.hasOwnProperty("sourceFile"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.sourceFile);
                    if (message.begin != null && message.hasOwnProperty("begin"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.begin);
                    if (message.end != null && message.hasOwnProperty("end"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.end);
                    return writer;
                };

                /**
                 * Decodes an Annotation message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Annotation.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.GeneratedCodeInfo.Annotation();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.path && message.path.length))
                                message.path = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.path.push(reader.int32());
                            } else
                                message.path.push(reader.int32());
                            break;
                        case 2:
                            message.sourceFile = reader.string();
                            break;
                        case 3:
                            message.begin = reader.int32();
                            break;
                        case 4:
                            message.end = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Verifies an Annotation message.
                 * @function verify
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Annotation.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.path != null && message.hasOwnProperty("path")) {
                        if (!Array.isArray(message.path))
                            return "path: array expected";
                        for (let i = 0; i < message.path.length; ++i)
                            if (!$util.isInteger(message.path[i]))
                                return "path: integer[] expected";
                    }
                    if (message.sourceFile != null && message.hasOwnProperty("sourceFile"))
                        if (!$util.isString(message.sourceFile))
                            return "sourceFile: string expected";
                    if (message.begin != null && message.hasOwnProperty("begin"))
                        if (!$util.isInteger(message.begin))
                            return "begin: integer expected";
                    if (message.end != null && message.hasOwnProperty("end"))
                        if (!$util.isInteger(message.end))
                            return "end: integer expected";
                    return null;
                };

                return Annotation;
            })();

            return GeneratedCodeInfo;
        })();

        return protobuf;
    })();

    google.api = (function() {

        /**
         * Namespace api.
         * @memberof google
         * @namespace
         */
        const api = {};

        api.Http = (function() {

            /**
             * Properties of a Http.
             * @memberof google.api
             * @interface IHttp
             * @property {Array.<google.api.IHttpRule>|null} [rules] Http rules
             */

            /**
             * Constructs a new Http.
             * @memberof google.api
             * @classdesc Represents a Http.
             * @implements IHttp
             * @constructor
             * @param {google.api.IHttp=} [properties] Properties to set
             */
            function Http(properties) {
                this.rules = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Http rules.
             * @member {Array.<google.api.IHttpRule>} rules
             * @memberof google.api.Http
             * @instance
             */
            Http.prototype.rules = $util.emptyArray;

            /**
             * Creates a new Http instance using the specified properties.
             * @function create
             * @memberof google.api.Http
             * @static
             * @param {google.api.IHttp=} [properties] Properties to set
             * @returns {google.api.Http} Http instance
             */
            Http.create = function create(properties) {
                return new Http(properties);
            };

            /**
             * Encodes the specified Http message. Does not implicitly {@link google.api.Http.verify|verify} messages.
             * @function encode
             * @memberof google.api.Http
             * @static
             * @param {google.api.IHttp} message Http message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Http.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.rules != null && message.rules.length)
                    for (let i = 0; i < message.rules.length; ++i)
                        $root.google.api.HttpRule.encode(message.rules[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a Http message from the specified reader or buffer.
             * @function decode
             * @memberof google.api.Http
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.api.Http} Http
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Http.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.api.Http();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.rules && message.rules.length))
                            message.rules = [];
                        message.rules.push($root.google.api.HttpRule.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a Http message.
             * @function verify
             * @memberof google.api.Http
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Http.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.rules != null && message.hasOwnProperty("rules")) {
                    if (!Array.isArray(message.rules))
                        return "rules: array expected";
                    for (let i = 0; i < message.rules.length; ++i) {
                        let error = $root.google.api.HttpRule.verify(message.rules[i]);
                        if (error)
                            return "rules." + error;
                    }
                }
                return null;
            };

            return Http;
        })();

        api.HttpRule = (function() {

            /**
             * Properties of a HttpRule.
             * @memberof google.api
             * @interface IHttpRule
             * @property {string|null} [get] HttpRule get
             * @property {string|null} [put] HttpRule put
             * @property {string|null} [post] HttpRule post
             * @property {string|null} ["delete"] HttpRule delete
             * @property {string|null} [patch] HttpRule patch
             * @property {google.api.ICustomHttpPattern|null} [custom] HttpRule custom
             * @property {string|null} [selector] HttpRule selector
             * @property {string|null} [body] HttpRule body
             * @property {Array.<google.api.IHttpRule>|null} [additionalBindings] HttpRule additionalBindings
             */

            /**
             * Constructs a new HttpRule.
             * @memberof google.api
             * @classdesc Represents a HttpRule.
             * @implements IHttpRule
             * @constructor
             * @param {google.api.IHttpRule=} [properties] Properties to set
             */
            function HttpRule(properties) {
                this.additionalBindings = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * HttpRule get.
             * @member {string} get
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype.get = "";

            /**
             * HttpRule put.
             * @member {string} put
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype.put = "";

            /**
             * HttpRule post.
             * @member {string} post
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype.post = "";

            /**
             * HttpRule delete.
             * @member {string} delete
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype["delete"] = "";

            /**
             * HttpRule patch.
             * @member {string} patch
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype.patch = "";

            /**
             * HttpRule custom.
             * @member {google.api.ICustomHttpPattern|null|undefined} custom
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype.custom = null;

            /**
             * HttpRule selector.
             * @member {string} selector
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype.selector = "";

            /**
             * HttpRule body.
             * @member {string} body
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype.body = "";

            /**
             * HttpRule additionalBindings.
             * @member {Array.<google.api.IHttpRule>} additionalBindings
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype.additionalBindings = $util.emptyArray;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * HttpRule pattern.
             * @member {"get"|"put"|"post"|"delete"|"patch"|"custom"|undefined} pattern
             * @memberof google.api.HttpRule
             * @instance
             */
            Object.defineProperty(HttpRule.prototype, "pattern", {
                get: $util.oneOfGetter($oneOfFields = ["get", "put", "post", "delete", "patch", "custom"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new HttpRule instance using the specified properties.
             * @function create
             * @memberof google.api.HttpRule
             * @static
             * @param {google.api.IHttpRule=} [properties] Properties to set
             * @returns {google.api.HttpRule} HttpRule instance
             */
            HttpRule.create = function create(properties) {
                return new HttpRule(properties);
            };

            /**
             * Encodes the specified HttpRule message. Does not implicitly {@link google.api.HttpRule.verify|verify} messages.
             * @function encode
             * @memberof google.api.HttpRule
             * @static
             * @param {google.api.IHttpRule} message HttpRule message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HttpRule.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.selector != null && message.hasOwnProperty("selector"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.selector);
                if (message.get != null && message.hasOwnProperty("get"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.get);
                if (message.put != null && message.hasOwnProperty("put"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.put);
                if (message.post != null && message.hasOwnProperty("post"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.post);
                if (message["delete"] != null && message.hasOwnProperty("delete"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message["delete"]);
                if (message.patch != null && message.hasOwnProperty("patch"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.patch);
                if (message.body != null && message.hasOwnProperty("body"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.body);
                if (message.custom != null && message.hasOwnProperty("custom"))
                    $root.google.api.CustomHttpPattern.encode(message.custom, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.additionalBindings != null && message.additionalBindings.length)
                    for (let i = 0; i < message.additionalBindings.length; ++i)
                        $root.google.api.HttpRule.encode(message.additionalBindings[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a HttpRule message from the specified reader or buffer.
             * @function decode
             * @memberof google.api.HttpRule
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.api.HttpRule} HttpRule
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HttpRule.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.api.HttpRule();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2:
                        message.get = reader.string();
                        break;
                    case 3:
                        message.put = reader.string();
                        break;
                    case 4:
                        message.post = reader.string();
                        break;
                    case 5:
                        message["delete"] = reader.string();
                        break;
                    case 6:
                        message.patch = reader.string();
                        break;
                    case 8:
                        message.custom = $root.google.api.CustomHttpPattern.decode(reader, reader.uint32());
                        break;
                    case 1:
                        message.selector = reader.string();
                        break;
                    case 7:
                        message.body = reader.string();
                        break;
                    case 11:
                        if (!(message.additionalBindings && message.additionalBindings.length))
                            message.additionalBindings = [];
                        message.additionalBindings.push($root.google.api.HttpRule.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a HttpRule message.
             * @function verify
             * @memberof google.api.HttpRule
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            HttpRule.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.get != null && message.hasOwnProperty("get")) {
                    properties.pattern = 1;
                    if (!$util.isString(message.get))
                        return "get: string expected";
                }
                if (message.put != null && message.hasOwnProperty("put")) {
                    if (properties.pattern === 1)
                        return "pattern: multiple values";
                    properties.pattern = 1;
                    if (!$util.isString(message.put))
                        return "put: string expected";
                }
                if (message.post != null && message.hasOwnProperty("post")) {
                    if (properties.pattern === 1)
                        return "pattern: multiple values";
                    properties.pattern = 1;
                    if (!$util.isString(message.post))
                        return "post: string expected";
                }
                if (message["delete"] != null && message.hasOwnProperty("delete")) {
                    if (properties.pattern === 1)
                        return "pattern: multiple values";
                    properties.pattern = 1;
                    if (!$util.isString(message["delete"]))
                        return "delete: string expected";
                }
                if (message.patch != null && message.hasOwnProperty("patch")) {
                    if (properties.pattern === 1)
                        return "pattern: multiple values";
                    properties.pattern = 1;
                    if (!$util.isString(message.patch))
                        return "patch: string expected";
                }
                if (message.custom != null && message.hasOwnProperty("custom")) {
                    if (properties.pattern === 1)
                        return "pattern: multiple values";
                    properties.pattern = 1;
                    {
                        let error = $root.google.api.CustomHttpPattern.verify(message.custom);
                        if (error)
                            return "custom." + error;
                    }
                }
                if (message.selector != null && message.hasOwnProperty("selector"))
                    if (!$util.isString(message.selector))
                        return "selector: string expected";
                if (message.body != null && message.hasOwnProperty("body"))
                    if (!$util.isString(message.body))
                        return "body: string expected";
                if (message.additionalBindings != null && message.hasOwnProperty("additionalBindings")) {
                    if (!Array.isArray(message.additionalBindings))
                        return "additionalBindings: array expected";
                    for (let i = 0; i < message.additionalBindings.length; ++i) {
                        let error = $root.google.api.HttpRule.verify(message.additionalBindings[i]);
                        if (error)
                            return "additionalBindings." + error;
                    }
                }
                return null;
            };

            return HttpRule;
        })();

        api.CustomHttpPattern = (function() {

            /**
             * Properties of a CustomHttpPattern.
             * @memberof google.api
             * @interface ICustomHttpPattern
             * @property {string|null} [kind] CustomHttpPattern kind
             * @property {string|null} [path] CustomHttpPattern path
             */

            /**
             * Constructs a new CustomHttpPattern.
             * @memberof google.api
             * @classdesc Represents a CustomHttpPattern.
             * @implements ICustomHttpPattern
             * @constructor
             * @param {google.api.ICustomHttpPattern=} [properties] Properties to set
             */
            function CustomHttpPattern(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CustomHttpPattern kind.
             * @member {string} kind
             * @memberof google.api.CustomHttpPattern
             * @instance
             */
            CustomHttpPattern.prototype.kind = "";

            /**
             * CustomHttpPattern path.
             * @member {string} path
             * @memberof google.api.CustomHttpPattern
             * @instance
             */
            CustomHttpPattern.prototype.path = "";

            /**
             * Creates a new CustomHttpPattern instance using the specified properties.
             * @function create
             * @memberof google.api.CustomHttpPattern
             * @static
             * @param {google.api.ICustomHttpPattern=} [properties] Properties to set
             * @returns {google.api.CustomHttpPattern} CustomHttpPattern instance
             */
            CustomHttpPattern.create = function create(properties) {
                return new CustomHttpPattern(properties);
            };

            /**
             * Encodes the specified CustomHttpPattern message. Does not implicitly {@link google.api.CustomHttpPattern.verify|verify} messages.
             * @function encode
             * @memberof google.api.CustomHttpPattern
             * @static
             * @param {google.api.ICustomHttpPattern} message CustomHttpPattern message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CustomHttpPattern.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.kind != null && message.hasOwnProperty("kind"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.kind);
                if (message.path != null && message.hasOwnProperty("path"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.path);
                return writer;
            };

            /**
             * Decodes a CustomHttpPattern message from the specified reader or buffer.
             * @function decode
             * @memberof google.api.CustomHttpPattern
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.api.CustomHttpPattern} CustomHttpPattern
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CustomHttpPattern.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.api.CustomHttpPattern();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.kind = reader.string();
                        break;
                    case 2:
                        message.path = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Verifies a CustomHttpPattern message.
             * @function verify
             * @memberof google.api.CustomHttpPattern
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CustomHttpPattern.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.kind != null && message.hasOwnProperty("kind"))
                    if (!$util.isString(message.kind))
                        return "kind: string expected";
                if (message.path != null && message.hasOwnProperty("path"))
                    if (!$util.isString(message.path))
                        return "path: string expected";
                return null;
            };

            return CustomHttpPattern;
        })();

        return api;
    })();

    return google;
})();

export { $root as default };
