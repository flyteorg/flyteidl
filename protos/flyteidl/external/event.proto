syntax = "proto3";

package flyteidl.external;

option go_package = "github.com/lyft/flyteidl/gen/pb-go/flyteidl/external";

import "flyteidl/core/execution.proto";
import "flyteidl/core/identifier.proto";
import "flyteidl/core/catalog.proto";
import "flyteidl/core/workflow_closure.proto";
import "flyteidl/admin/event.proto";
import "flyteidl/admin/execution.proto";
import "flyteidl/admin/node_execution.proto";
import "flyteidl/admin/task_execution.proto";
import "google/protobuf/timestamp.proto";
import "google/protobuf/struct.proto";

message WorkflowEvent {
   // Workflow execution id
   flyteidl.admin.Execution execution = 1;

   // This timestamp represents when the original event occurred, it is generated
   // by the executor of the workflow.
   google.protobuf.Timestamp occurred_at = 4;

   // new fields
   // WorkflowClosure.getCompiledWorkflow().getTemplate().getNodes() to understand the tasks
   // Node.getUpstreamNodeIdsList()
   // Node.getInputsList()
   flyteidl.core.WorkflowClosure workflow_closure = 7;
}

message NodeEvent {
    // Unique identifier for this node execution
    flyteidl.admin.NodeExecution node_execution = 1;

    // This timestamp represents when the original event occurred, it is generated
    // by the executor of the node.
    google.protobuf.Timestamp occurred_at           = 4;

    // Node.hasTaskNode()
    flyteidl.core.Node spec_node = 8;

    // ExecutionSpec.getMetadata()
    // ExecutionSpec.getLabels()
    // ExecutionSpec.getAnnotations()
    // ExecutionSpec.getLaunchPlan()
    flyteidl.admin.ExecutionSpec execution_spec = 9;
}

// Can be extended in the further
message NodeContext {
    string spec_node_id = 1;
}

message TaskEvent {
    // ID of the task. In combination with the retryAttempt this will indicate
    // the task execution uniquely for a given parent node execution.
    flyteidl.admin.TaskExecution taskExecution = 1;

    // Some phases, like RUNNING, can send multiple events with changed metadata (new logs, additional custom_info, etc)
    // that should be recorded regardless of the lack of phase change.
    // The version field should be incremented when metadata changes across the duration of an individual phase.
    uint32 phase_version = 2;

    NodeContext nodeContext = 3;

    // ExecutionSpec.getMetadata()
    // ExecutionSpec.getLabels()
    // ExecutionSpec.getAnnotations()
    // ExecutionSpec.getLaunchPlan()
    flyteidl.admin.ExecutionSpec execution_spec = 4;
}


// Instead of creating a new envelope, we can also use the cloudEvent as the envelope
message Event {
    string id = 1;
    string producer_id = 2;
    google.protobuf.Timestamp occurred_at = 3;
    oneof event {
        WorkflowEvent workflowEvent = 4;
        NodeEvent nodeEvent = 5;
        TaskEvent taskEvent = 6;
    }
}


