// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: flyteidl/core/workflow.proto

#include "flyteidl/core/workflow.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace flyteidl {
namespace core {
constexpr IfBlock::IfBlock(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : condition_(nullptr)
  , then_node_(nullptr){}
struct IfBlockDefaultTypeInternal {
  constexpr IfBlockDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~IfBlockDefaultTypeInternal() {}
  union {
    IfBlock _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT IfBlockDefaultTypeInternal _IfBlock_default_instance_;
constexpr IfElseBlock::IfElseBlock(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : other_()
  , case__(nullptr)
  , _oneof_case_{}{}
struct IfElseBlockDefaultTypeInternal {
  constexpr IfElseBlockDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~IfElseBlockDefaultTypeInternal() {}
  union {
    IfElseBlock _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT IfElseBlockDefaultTypeInternal _IfElseBlock_default_instance_;
constexpr BranchNode::BranchNode(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : if_else_(nullptr){}
struct BranchNodeDefaultTypeInternal {
  constexpr BranchNodeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BranchNodeDefaultTypeInternal() {}
  union {
    BranchNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BranchNodeDefaultTypeInternal _BranchNode_default_instance_;
constexpr TaskNode::TaskNode(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : overrides_(nullptr)
  , _oneof_case_{}{}
struct TaskNodeDefaultTypeInternal {
  constexpr TaskNodeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TaskNodeDefaultTypeInternal() {}
  union {
    TaskNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TaskNodeDefaultTypeInternal _TaskNode_default_instance_;
constexpr WorkflowNode::WorkflowNode(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : _oneof_case_{}{}
struct WorkflowNodeDefaultTypeInternal {
  constexpr WorkflowNodeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~WorkflowNodeDefaultTypeInternal() {}
  union {
    WorkflowNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT WorkflowNodeDefaultTypeInternal _WorkflowNode_default_instance_;
constexpr NodeMetadata::NodeMetadata(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , timeout_(nullptr)
  , retries_(nullptr)
  , _oneof_case_{}{}
struct NodeMetadataDefaultTypeInternal {
  constexpr NodeMetadataDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NodeMetadataDefaultTypeInternal() {}
  union {
    NodeMetadata _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NodeMetadataDefaultTypeInternal _NodeMetadata_default_instance_;
constexpr Alias::Alias(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : var_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , alias_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct AliasDefaultTypeInternal {
  constexpr AliasDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AliasDefaultTypeInternal() {}
  union {
    Alias _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AliasDefaultTypeInternal _Alias_default_instance_;
constexpr Node::Node(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : inputs_()
  , upstream_node_ids_()
  , output_aliases_()
  , id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , metadata_(nullptr)
  , _oneof_case_{}{}
struct NodeDefaultTypeInternal {
  constexpr NodeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NodeDefaultTypeInternal() {}
  union {
    Node _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NodeDefaultTypeInternal _Node_default_instance_;
constexpr WorkflowMetadata::WorkflowMetadata(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : quality_of_service_(nullptr)
  , on_failure_(0)
{}
struct WorkflowMetadataDefaultTypeInternal {
  constexpr WorkflowMetadataDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~WorkflowMetadataDefaultTypeInternal() {}
  union {
    WorkflowMetadata _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT WorkflowMetadataDefaultTypeInternal _WorkflowMetadata_default_instance_;
constexpr WorkflowMetadataDefaults::WorkflowMetadataDefaults(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : interruptible_(false){}
struct WorkflowMetadataDefaultsDefaultTypeInternal {
  constexpr WorkflowMetadataDefaultsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~WorkflowMetadataDefaultsDefaultTypeInternal() {}
  union {
    WorkflowMetadataDefaults _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT WorkflowMetadataDefaultsDefaultTypeInternal _WorkflowMetadataDefaults_default_instance_;
constexpr WorkflowTemplate::WorkflowTemplate(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : nodes_()
  , outputs_()
  , id_(nullptr)
  , metadata_(nullptr)
  , interface_(nullptr)
  , failure_node_(nullptr)
  , metadata_defaults_(nullptr){}
struct WorkflowTemplateDefaultTypeInternal {
  constexpr WorkflowTemplateDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~WorkflowTemplateDefaultTypeInternal() {}
  union {
    WorkflowTemplate _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT WorkflowTemplateDefaultTypeInternal _WorkflowTemplate_default_instance_;
constexpr TaskNodeOverrides::TaskNodeOverrides(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : resources_(nullptr){}
struct TaskNodeOverridesDefaultTypeInternal {
  constexpr TaskNodeOverridesDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TaskNodeOverridesDefaultTypeInternal() {}
  union {
    TaskNodeOverrides _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TaskNodeOverridesDefaultTypeInternal _TaskNodeOverrides_default_instance_;
}  // namespace core
}  // namespace flyteidl
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_flyteidl_2fcore_2fworkflow_2eproto[12];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_flyteidl_2fcore_2fworkflow_2eproto[1];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_flyteidl_2fcore_2fworkflow_2eproto = nullptr;

const uint32_t TableStruct_flyteidl_2fcore_2fworkflow_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::flyteidl::core::IfBlock, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::flyteidl::core::IfBlock, condition_),
  PROTOBUF_FIELD_OFFSET(::flyteidl::core::IfBlock, then_node_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::flyteidl::core::IfElseBlock, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::flyteidl::core::IfElseBlock, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::flyteidl::core::IfElseBlock, case__),
  PROTOBUF_FIELD_OFFSET(::flyteidl::core::IfElseBlock, other_),
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::flyteidl::core::IfElseBlock, default_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::flyteidl::core::BranchNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::flyteidl::core::BranchNode, if_else_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::flyteidl::core::TaskNode, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::flyteidl::core::TaskNode, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::flyteidl::core::TaskNode, overrides_),
  PROTOBUF_FIELD_OFFSET(::flyteidl::core::TaskNode, reference_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::flyteidl::core::WorkflowNode, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::flyteidl::core::WorkflowNode, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::flyteidl::core::WorkflowNode, reference_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::flyteidl::core::NodeMetadata, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::flyteidl::core::NodeMetadata, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::flyteidl::core::NodeMetadata, name_),
  PROTOBUF_FIELD_OFFSET(::flyteidl::core::NodeMetadata, timeout_),
  PROTOBUF_FIELD_OFFSET(::flyteidl::core::NodeMetadata, retries_),
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::flyteidl::core::NodeMetadata, interruptible_value_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::flyteidl::core::Alias, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::flyteidl::core::Alias, var_),
  PROTOBUF_FIELD_OFFSET(::flyteidl::core::Alias, alias_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::flyteidl::core::Node, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::flyteidl::core::Node, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::flyteidl::core::Node, id_),
  PROTOBUF_FIELD_OFFSET(::flyteidl::core::Node, metadata_),
  PROTOBUF_FIELD_OFFSET(::flyteidl::core::Node, inputs_),
  PROTOBUF_FIELD_OFFSET(::flyteidl::core::Node, upstream_node_ids_),
  PROTOBUF_FIELD_OFFSET(::flyteidl::core::Node, output_aliases_),
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::flyteidl::core::Node, target_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::flyteidl::core::WorkflowMetadata, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::flyteidl::core::WorkflowMetadata, quality_of_service_),
  PROTOBUF_FIELD_OFFSET(::flyteidl::core::WorkflowMetadata, on_failure_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::flyteidl::core::WorkflowMetadataDefaults, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::flyteidl::core::WorkflowMetadataDefaults, interruptible_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::flyteidl::core::WorkflowTemplate, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::flyteidl::core::WorkflowTemplate, id_),
  PROTOBUF_FIELD_OFFSET(::flyteidl::core::WorkflowTemplate, metadata_),
  PROTOBUF_FIELD_OFFSET(::flyteidl::core::WorkflowTemplate, interface_),
  PROTOBUF_FIELD_OFFSET(::flyteidl::core::WorkflowTemplate, nodes_),
  PROTOBUF_FIELD_OFFSET(::flyteidl::core::WorkflowTemplate, outputs_),
  PROTOBUF_FIELD_OFFSET(::flyteidl::core::WorkflowTemplate, failure_node_),
  PROTOBUF_FIELD_OFFSET(::flyteidl::core::WorkflowTemplate, metadata_defaults_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::flyteidl::core::TaskNodeOverrides, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::flyteidl::core::TaskNodeOverrides, resources_),
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::flyteidl::core::IfBlock)},
  { 8, -1, -1, sizeof(::flyteidl::core::IfElseBlock)},
  { 19, -1, -1, sizeof(::flyteidl::core::BranchNode)},
  { 26, -1, -1, sizeof(::flyteidl::core::TaskNode)},
  { 35, -1, -1, sizeof(::flyteidl::core::WorkflowNode)},
  { 44, -1, -1, sizeof(::flyteidl::core::NodeMetadata)},
  { 55, -1, -1, sizeof(::flyteidl::core::Alias)},
  { 63, -1, -1, sizeof(::flyteidl::core::Node)},
  { 78, -1, -1, sizeof(::flyteidl::core::WorkflowMetadata)},
  { 86, -1, -1, sizeof(::flyteidl::core::WorkflowMetadataDefaults)},
  { 93, -1, -1, sizeof(::flyteidl::core::WorkflowTemplate)},
  { 106, -1, -1, sizeof(::flyteidl::core::TaskNodeOverrides)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::flyteidl::core::_IfBlock_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::flyteidl::core::_IfElseBlock_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::flyteidl::core::_BranchNode_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::flyteidl::core::_TaskNode_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::flyteidl::core::_WorkflowNode_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::flyteidl::core::_NodeMetadata_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::flyteidl::core::_Alias_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::flyteidl::core::_Node_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::flyteidl::core::_WorkflowMetadata_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::flyteidl::core::_WorkflowMetadataDefaults_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::flyteidl::core::_WorkflowTemplate_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::flyteidl::core::_TaskNodeOverrides_default_instance_),
};

const char descriptor_table_protodef_flyteidl_2fcore_2fworkflow_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\034flyteidl/core/workflow.proto\022\rflyteidl"
  ".core\032\035flyteidl/core/condition.proto\032\035fl"
  "yteidl/core/execution.proto\032\036flyteidl/co"
  "re/identifier.proto\032\035flyteidl/core/inter"
  "face.proto\032\034flyteidl/core/literals.proto"
  "\032\031flyteidl/core/tasks.proto\032\031flyteidl/co"
  "re/types.proto\032\034flyteidl/core/security.p"
  "roto\032\036google/protobuf/duration.proto\"{\n\007"
  "IfBlock\022>\n\tcondition\030\001 \001(\0132 .flyteidl.co"
  "re.BooleanExpressionR\tcondition\0220\n\tthen_"
  "node\030\002 \001(\0132\023.flyteidl.core.NodeR\010thenNod"
  "e\"\324\001\n\013IfElseBlock\022*\n\004case\030\001 \001(\0132\026.flytei"
  "dl.core.IfBlockR\004case\022,\n\005other\030\002 \003(\0132\026.f"
  "lyteidl.core.IfBlockR\005other\0222\n\telse_node"
  "\030\003 \001(\0132\023.flyteidl.core.NodeH\000R\010elseNode\022"
  ",\n\005error\030\004 \001(\0132\024.flyteidl.core.ErrorH\000R\005"
  "errorB\t\n\007default\"A\n\nBranchNode\0223\n\007if_els"
  "e\030\001 \001(\0132\032.flyteidl.core.IfElseBlockR\006ifE"
  "lse\"\227\001\n\010TaskNode\022>\n\014reference_id\030\001 \001(\0132\031"
  ".flyteidl.core.IdentifierH\000R\013referenceId"
  "\022>\n\toverrides\030\002 \001(\0132 .flyteidl.core.Task"
  "NodeOverridesR\toverridesB\013\n\treference\"\246\001"
  "\n\014WorkflowNode\022B\n\016launchplan_ref\030\001 \001(\0132\031"
  ".flyteidl.core.IdentifierH\000R\rlaunchplanR"
  "ef\022E\n\020sub_workflow_ref\030\002 \001(\0132\031.flyteidl."
  "core.IdentifierH\000R\016subWorkflowRefB\013\n\tref"
  "erence\"\316\001\n\014NodeMetadata\022\022\n\004name\030\001 \001(\tR\004n"
  "ame\0223\n\007timeout\030\004 \001(\0132\031.google.protobuf.D"
  "urationR\007timeout\0226\n\007retries\030\005 \001(\0132\034.flyt"
  "eidl.core.RetryStrategyR\007retries\022&\n\rinte"
  "rruptible\030\006 \001(\010H\000R\rinterruptibleB\025\n\023inte"
  "rruptible_value\"/\n\005Alias\022\020\n\003var\030\001 \001(\tR\003v"
  "ar\022\024\n\005alias\030\002 \001(\tR\005alias\"\254\003\n\004Node\022\016\n\002id\030"
  "\001 \001(\tR\002id\0227\n\010metadata\030\002 \001(\0132\033.flyteidl.c"
  "ore.NodeMetadataR\010metadata\022.\n\006inputs\030\003 \003"
  "(\0132\026.flyteidl.core.BindingR\006inputs\022*\n\021up"
  "stream_node_ids\030\004 \003(\tR\017upstreamNodeIds\022;"
  "\n\016output_aliases\030\005 \003(\0132\024.flyteidl.core.A"
  "liasR\routputAliases\0226\n\ttask_node\030\006 \001(\0132\027"
  ".flyteidl.core.TaskNodeH\000R\010taskNode\022B\n\rw"
  "orkflow_node\030\007 \001(\0132\033.flyteidl.core.Workf"
  "lowNodeH\000R\014workflowNode\022<\n\013branch_node\030\010"
  " \001(\0132\031.flyteidl.core.BranchNodeH\000R\nbranc"
  "hNodeB\010\n\006target\"\204\002\n\020WorkflowMetadata\022M\n\022"
  "quality_of_service\030\001 \001(\0132\037.flyteidl.core"
  ".QualityOfServiceR\020qualityOfService\022N\n\no"
  "n_failure\030\002 \001(\0162/.flyteidl.core.Workflow"
  "Metadata.OnFailurePolicyR\tonFailure\"Q\n\017O"
  "nFailurePolicy\022\024\n\020FAIL_IMMEDIATELY\020\000\022(\n$"
  "FAIL_AFTER_EXECUTABLE_NODES_COMPLETE\020\001\"@"
  "\n\030WorkflowMetadataDefaults\022$\n\rinterrupti"
  "ble\030\001 \001(\010R\rinterruptible\"\242\003\n\020WorkflowTem"
  "plate\022)\n\002id\030\001 \001(\0132\031.flyteidl.core.Identi"
  "fierR\002id\022;\n\010metadata\030\002 \001(\0132\037.flyteidl.co"
  "re.WorkflowMetadataR\010metadata\022;\n\tinterfa"
  "ce\030\003 \001(\0132\035.flyteidl.core.TypedInterfaceR"
  "\tinterface\022)\n\005nodes\030\004 \003(\0132\023.flyteidl.cor"
  "e.NodeR\005nodes\0220\n\007outputs\030\005 \003(\0132\026.flyteid"
  "l.core.BindingR\007outputs\0226\n\014failure_node\030"
  "\006 \001(\0132\023.flyteidl.core.NodeR\013failureNode\022"
  "T\n\021metadata_defaults\030\007 \001(\0132\'.flyteidl.co"
  "re.WorkflowMetadataDefaultsR\020metadataDef"
  "aults\"K\n\021TaskNodeOverrides\0226\n\tresources\030"
  "\001 \001(\0132\030.flyteidl.core.ResourcesR\tresourc"
  "esB\260\001\n\021com.flyteidl.coreB\rWorkflowProtoH"
  "\002Z4github.com/flyteorg/flyteidl/gen/pb-g"
  "o/flyteidl/core\370\001\000\242\002\003FCX\252\002\rFlyteidl.Core"
  "\312\002\rFlyteidl\\Core\342\002\031Flyteidl\\Core\\GPBMeta"
  "data\352\002\016Flyteidl::Coreb\006proto3"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_flyteidl_2fcore_2fworkflow_2eproto_deps[9] = {
  &::descriptor_table_flyteidl_2fcore_2fcondition_2eproto,
  &::descriptor_table_flyteidl_2fcore_2fexecution_2eproto,
  &::descriptor_table_flyteidl_2fcore_2fidentifier_2eproto,
  &::descriptor_table_flyteidl_2fcore_2finterface_2eproto,
  &::descriptor_table_flyteidl_2fcore_2fliterals_2eproto,
  &::descriptor_table_flyteidl_2fcore_2fsecurity_2eproto,
  &::descriptor_table_flyteidl_2fcore_2ftasks_2eproto,
  &::descriptor_table_flyteidl_2fcore_2ftypes_2eproto,
  &::descriptor_table_google_2fprotobuf_2fduration_2eproto,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_flyteidl_2fcore_2fworkflow_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_flyteidl_2fcore_2fworkflow_2eproto = {
  false, false, 2749, descriptor_table_protodef_flyteidl_2fcore_2fworkflow_2eproto, "flyteidl/core/workflow.proto", 
  &descriptor_table_flyteidl_2fcore_2fworkflow_2eproto_once, descriptor_table_flyteidl_2fcore_2fworkflow_2eproto_deps, 9, 12,
  schemas, file_default_instances, TableStruct_flyteidl_2fcore_2fworkflow_2eproto::offsets,
  file_level_metadata_flyteidl_2fcore_2fworkflow_2eproto, file_level_enum_descriptors_flyteidl_2fcore_2fworkflow_2eproto, file_level_service_descriptors_flyteidl_2fcore_2fworkflow_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_flyteidl_2fcore_2fworkflow_2eproto_getter() {
  return &descriptor_table_flyteidl_2fcore_2fworkflow_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_flyteidl_2fcore_2fworkflow_2eproto(&descriptor_table_flyteidl_2fcore_2fworkflow_2eproto);
namespace flyteidl {
namespace core {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WorkflowMetadata_OnFailurePolicy_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_flyteidl_2fcore_2fworkflow_2eproto);
  return file_level_enum_descriptors_flyteidl_2fcore_2fworkflow_2eproto[0];
}
bool WorkflowMetadata_OnFailurePolicy_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr WorkflowMetadata_OnFailurePolicy WorkflowMetadata::FAIL_IMMEDIATELY;
constexpr WorkflowMetadata_OnFailurePolicy WorkflowMetadata::FAIL_AFTER_EXECUTABLE_NODES_COMPLETE;
constexpr WorkflowMetadata_OnFailurePolicy WorkflowMetadata::OnFailurePolicy_MIN;
constexpr WorkflowMetadata_OnFailurePolicy WorkflowMetadata::OnFailurePolicy_MAX;
constexpr int WorkflowMetadata::OnFailurePolicy_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class IfBlock::_Internal {
 public:
  static const ::flyteidl::core::BooleanExpression& condition(const IfBlock* msg);
  static const ::flyteidl::core::Node& then_node(const IfBlock* msg);
};

const ::flyteidl::core::BooleanExpression&
IfBlock::_Internal::condition(const IfBlock* msg) {
  return *msg->condition_;
}
const ::flyteidl::core::Node&
IfBlock::_Internal::then_node(const IfBlock* msg) {
  return *msg->then_node_;
}
void IfBlock::clear_condition() {
  if (GetArenaForAllocation() == nullptr && condition_ != nullptr) {
    delete condition_;
  }
  condition_ = nullptr;
}
IfBlock::IfBlock(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:flyteidl.core.IfBlock)
}
IfBlock::IfBlock(const IfBlock& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_condition()) {
    condition_ = new ::flyteidl::core::BooleanExpression(*from.condition_);
  } else {
    condition_ = nullptr;
  }
  if (from._internal_has_then_node()) {
    then_node_ = new ::flyteidl::core::Node(*from.then_node_);
  } else {
    then_node_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:flyteidl.core.IfBlock)
}

inline void IfBlock::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&condition_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&then_node_) -
    reinterpret_cast<char*>(&condition_)) + sizeof(then_node_));
}

IfBlock::~IfBlock() {
  // @@protoc_insertion_point(destructor:flyteidl.core.IfBlock)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void IfBlock::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete condition_;
  if (this != internal_default_instance()) delete then_node_;
}

void IfBlock::ArenaDtor(void* object) {
  IfBlock* _this = reinterpret_cast< IfBlock* >(object);
  (void)_this;
}
void IfBlock::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void IfBlock::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void IfBlock::InternalSwap(IfBlock* other) {
  using std::swap;
  GetReflection()->Swap(this, other);}

::PROTOBUF_NAMESPACE_ID::Metadata IfBlock::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_flyteidl_2fcore_2fworkflow_2eproto_getter, &descriptor_table_flyteidl_2fcore_2fworkflow_2eproto_once,
      file_level_metadata_flyteidl_2fcore_2fworkflow_2eproto[0]);
}

// ===================================================================

class IfElseBlock::_Internal {
 public:
  static const ::flyteidl::core::IfBlock& case_(const IfElseBlock* msg);
  static const ::flyteidl::core::Node& else_node(const IfElseBlock* msg);
  static const ::flyteidl::core::Error& error(const IfElseBlock* msg);
};

const ::flyteidl::core::IfBlock&
IfElseBlock::_Internal::case_(const IfElseBlock* msg) {
  return *msg->case__;
}
const ::flyteidl::core::Node&
IfElseBlock::_Internal::else_node(const IfElseBlock* msg) {
  return *msg->default_.else_node_;
}
const ::flyteidl::core::Error&
IfElseBlock::_Internal::error(const IfElseBlock* msg) {
  return *msg->default_.error_;
}
void IfElseBlock::set_allocated_else_node(::flyteidl::core::Node* else_node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_default();
  if (else_node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::flyteidl::core::Node>::GetOwningArena(else_node);
    if (message_arena != submessage_arena) {
      else_node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, else_node, submessage_arena);
    }
    set_has_else_node();
    default_.else_node_ = else_node;
  }
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.IfElseBlock.else_node)
}
void IfElseBlock::set_allocated_error(::flyteidl::core::Error* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_default();
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(error));
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    set_has_error();
    default_.error_ = error;
  }
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.IfElseBlock.error)
}
void IfElseBlock::clear_error() {
  if (_internal_has_error()) {
    if (GetArenaForAllocation() == nullptr) {
      delete default_.error_;
    }
    clear_has_default();
  }
}
IfElseBlock::IfElseBlock(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  other_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:flyteidl.core.IfElseBlock)
}
IfElseBlock::IfElseBlock(const IfElseBlock& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      other_(from.other_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_case_()) {
    case__ = new ::flyteidl::core::IfBlock(*from.case__);
  } else {
    case__ = nullptr;
  }
  clear_has_default();
  switch (from.default_case()) {
    case kElseNode: {
      _internal_mutable_else_node()->::flyteidl::core::Node::MergeFrom(from._internal_else_node());
      break;
    }
    case kError: {
      _internal_mutable_error()->::flyteidl::core::Error::MergeFrom(from._internal_error());
      break;
    }
    case DEFAULT_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:flyteidl.core.IfElseBlock)
}

inline void IfElseBlock::SharedCtor() {
case__ = nullptr;
clear_has_default();
}

IfElseBlock::~IfElseBlock() {
  // @@protoc_insertion_point(destructor:flyteidl.core.IfElseBlock)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void IfElseBlock::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete case__;
  if (has_default()) {
    clear_default();
  }
}

void IfElseBlock::ArenaDtor(void* object) {
  IfElseBlock* _this = reinterpret_cast< IfElseBlock* >(object);
  (void)_this;
}
void IfElseBlock::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void IfElseBlock::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void IfElseBlock::clear_default() {
// @@protoc_insertion_point(one_of_clear_start:flyteidl.core.IfElseBlock)
  switch (default_case()) {
    case kElseNode: {
      if (GetArenaForAllocation() == nullptr) {
        delete default_.else_node_;
      }
      break;
    }
    case kError: {
      if (GetArenaForAllocation() == nullptr) {
        delete default_.error_;
      }
      break;
    }
    case DEFAULT_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = DEFAULT_NOT_SET;
}


void IfElseBlock::InternalSwap(IfElseBlock* other) {
  using std::swap;
  GetReflection()->Swap(this, other);}

::PROTOBUF_NAMESPACE_ID::Metadata IfElseBlock::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_flyteidl_2fcore_2fworkflow_2eproto_getter, &descriptor_table_flyteidl_2fcore_2fworkflow_2eproto_once,
      file_level_metadata_flyteidl_2fcore_2fworkflow_2eproto[1]);
}

// ===================================================================

class BranchNode::_Internal {
 public:
  static const ::flyteidl::core::IfElseBlock& if_else(const BranchNode* msg);
};

const ::flyteidl::core::IfElseBlock&
BranchNode::_Internal::if_else(const BranchNode* msg) {
  return *msg->if_else_;
}
BranchNode::BranchNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:flyteidl.core.BranchNode)
}
BranchNode::BranchNode(const BranchNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_if_else()) {
    if_else_ = new ::flyteidl::core::IfElseBlock(*from.if_else_);
  } else {
    if_else_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:flyteidl.core.BranchNode)
}

inline void BranchNode::SharedCtor() {
if_else_ = nullptr;
}

BranchNode::~BranchNode() {
  // @@protoc_insertion_point(destructor:flyteidl.core.BranchNode)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void BranchNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete if_else_;
}

void BranchNode::ArenaDtor(void* object) {
  BranchNode* _this = reinterpret_cast< BranchNode* >(object);
  (void)_this;
}
void BranchNode::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BranchNode::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BranchNode::InternalSwap(BranchNode* other) {
  using std::swap;
  GetReflection()->Swap(this, other);}

::PROTOBUF_NAMESPACE_ID::Metadata BranchNode::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_flyteidl_2fcore_2fworkflow_2eproto_getter, &descriptor_table_flyteidl_2fcore_2fworkflow_2eproto_once,
      file_level_metadata_flyteidl_2fcore_2fworkflow_2eproto[2]);
}

// ===================================================================

class TaskNode::_Internal {
 public:
  static const ::flyteidl::core::Identifier& reference_id(const TaskNode* msg);
  static const ::flyteidl::core::TaskNodeOverrides& overrides(const TaskNode* msg);
};

const ::flyteidl::core::Identifier&
TaskNode::_Internal::reference_id(const TaskNode* msg) {
  return *msg->reference_.reference_id_;
}
const ::flyteidl::core::TaskNodeOverrides&
TaskNode::_Internal::overrides(const TaskNode* msg) {
  return *msg->overrides_;
}
void TaskNode::set_allocated_reference_id(::flyteidl::core::Identifier* reference_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_reference();
  if (reference_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(reference_id));
    if (message_arena != submessage_arena) {
      reference_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reference_id, submessage_arena);
    }
    set_has_reference_id();
    reference_.reference_id_ = reference_id;
  }
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.TaskNode.reference_id)
}
void TaskNode::clear_reference_id() {
  if (_internal_has_reference_id()) {
    if (GetArenaForAllocation() == nullptr) {
      delete reference_.reference_id_;
    }
    clear_has_reference();
  }
}
TaskNode::TaskNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:flyteidl.core.TaskNode)
}
TaskNode::TaskNode(const TaskNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_overrides()) {
    overrides_ = new ::flyteidl::core::TaskNodeOverrides(*from.overrides_);
  } else {
    overrides_ = nullptr;
  }
  clear_has_reference();
  switch (from.reference_case()) {
    case kReferenceId: {
      _internal_mutable_reference_id()->::flyteidl::core::Identifier::MergeFrom(from._internal_reference_id());
      break;
    }
    case REFERENCE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:flyteidl.core.TaskNode)
}

inline void TaskNode::SharedCtor() {
overrides_ = nullptr;
clear_has_reference();
}

TaskNode::~TaskNode() {
  // @@protoc_insertion_point(destructor:flyteidl.core.TaskNode)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void TaskNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete overrides_;
  if (has_reference()) {
    clear_reference();
  }
}

void TaskNode::ArenaDtor(void* object) {
  TaskNode* _this = reinterpret_cast< TaskNode* >(object);
  (void)_this;
}
void TaskNode::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TaskNode::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TaskNode::clear_reference() {
// @@protoc_insertion_point(one_of_clear_start:flyteidl.core.TaskNode)
  switch (reference_case()) {
    case kReferenceId: {
      if (GetArenaForAllocation() == nullptr) {
        delete reference_.reference_id_;
      }
      break;
    }
    case REFERENCE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = REFERENCE_NOT_SET;
}


void TaskNode::InternalSwap(TaskNode* other) {
  using std::swap;
  GetReflection()->Swap(this, other);}

::PROTOBUF_NAMESPACE_ID::Metadata TaskNode::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_flyteidl_2fcore_2fworkflow_2eproto_getter, &descriptor_table_flyteidl_2fcore_2fworkflow_2eproto_once,
      file_level_metadata_flyteidl_2fcore_2fworkflow_2eproto[3]);
}

// ===================================================================

class WorkflowNode::_Internal {
 public:
  static const ::flyteidl::core::Identifier& launchplan_ref(const WorkflowNode* msg);
  static const ::flyteidl::core::Identifier& sub_workflow_ref(const WorkflowNode* msg);
};

const ::flyteidl::core::Identifier&
WorkflowNode::_Internal::launchplan_ref(const WorkflowNode* msg) {
  return *msg->reference_.launchplan_ref_;
}
const ::flyteidl::core::Identifier&
WorkflowNode::_Internal::sub_workflow_ref(const WorkflowNode* msg) {
  return *msg->reference_.sub_workflow_ref_;
}
void WorkflowNode::set_allocated_launchplan_ref(::flyteidl::core::Identifier* launchplan_ref) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_reference();
  if (launchplan_ref) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(launchplan_ref));
    if (message_arena != submessage_arena) {
      launchplan_ref = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, launchplan_ref, submessage_arena);
    }
    set_has_launchplan_ref();
    reference_.launchplan_ref_ = launchplan_ref;
  }
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.WorkflowNode.launchplan_ref)
}
void WorkflowNode::clear_launchplan_ref() {
  if (_internal_has_launchplan_ref()) {
    if (GetArenaForAllocation() == nullptr) {
      delete reference_.launchplan_ref_;
    }
    clear_has_reference();
  }
}
void WorkflowNode::set_allocated_sub_workflow_ref(::flyteidl::core::Identifier* sub_workflow_ref) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_reference();
  if (sub_workflow_ref) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sub_workflow_ref));
    if (message_arena != submessage_arena) {
      sub_workflow_ref = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sub_workflow_ref, submessage_arena);
    }
    set_has_sub_workflow_ref();
    reference_.sub_workflow_ref_ = sub_workflow_ref;
  }
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.WorkflowNode.sub_workflow_ref)
}
void WorkflowNode::clear_sub_workflow_ref() {
  if (_internal_has_sub_workflow_ref()) {
    if (GetArenaForAllocation() == nullptr) {
      delete reference_.sub_workflow_ref_;
    }
    clear_has_reference();
  }
}
WorkflowNode::WorkflowNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:flyteidl.core.WorkflowNode)
}
WorkflowNode::WorkflowNode(const WorkflowNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_reference();
  switch (from.reference_case()) {
    case kLaunchplanRef: {
      _internal_mutable_launchplan_ref()->::flyteidl::core::Identifier::MergeFrom(from._internal_launchplan_ref());
      break;
    }
    case kSubWorkflowRef: {
      _internal_mutable_sub_workflow_ref()->::flyteidl::core::Identifier::MergeFrom(from._internal_sub_workflow_ref());
      break;
    }
    case REFERENCE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:flyteidl.core.WorkflowNode)
}

inline void WorkflowNode::SharedCtor() {
clear_has_reference();
}

WorkflowNode::~WorkflowNode() {
  // @@protoc_insertion_point(destructor:flyteidl.core.WorkflowNode)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void WorkflowNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_reference()) {
    clear_reference();
  }
}

void WorkflowNode::ArenaDtor(void* object) {
  WorkflowNode* _this = reinterpret_cast< WorkflowNode* >(object);
  (void)_this;
}
void WorkflowNode::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void WorkflowNode::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void WorkflowNode::clear_reference() {
// @@protoc_insertion_point(one_of_clear_start:flyteidl.core.WorkflowNode)
  switch (reference_case()) {
    case kLaunchplanRef: {
      if (GetArenaForAllocation() == nullptr) {
        delete reference_.launchplan_ref_;
      }
      break;
    }
    case kSubWorkflowRef: {
      if (GetArenaForAllocation() == nullptr) {
        delete reference_.sub_workflow_ref_;
      }
      break;
    }
    case REFERENCE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = REFERENCE_NOT_SET;
}


void WorkflowNode::InternalSwap(WorkflowNode* other) {
  using std::swap;
  GetReflection()->Swap(this, other);}

::PROTOBUF_NAMESPACE_ID::Metadata WorkflowNode::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_flyteidl_2fcore_2fworkflow_2eproto_getter, &descriptor_table_flyteidl_2fcore_2fworkflow_2eproto_once,
      file_level_metadata_flyteidl_2fcore_2fworkflow_2eproto[4]);
}

// ===================================================================

class NodeMetadata::_Internal {
 public:
  static const ::PROTOBUF_NAMESPACE_ID::Duration& timeout(const NodeMetadata* msg);
  static const ::flyteidl::core::RetryStrategy& retries(const NodeMetadata* msg);
};

const ::PROTOBUF_NAMESPACE_ID::Duration&
NodeMetadata::_Internal::timeout(const NodeMetadata* msg) {
  return *msg->timeout_;
}
const ::flyteidl::core::RetryStrategy&
NodeMetadata::_Internal::retries(const NodeMetadata* msg) {
  return *msg->retries_;
}
void NodeMetadata::clear_timeout() {
  if (GetArenaForAllocation() == nullptr && timeout_ != nullptr) {
    delete timeout_;
  }
  timeout_ = nullptr;
}
void NodeMetadata::clear_retries() {
  if (GetArenaForAllocation() == nullptr && retries_ != nullptr) {
    delete retries_;
  }
  retries_ = nullptr;
}
NodeMetadata::NodeMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:flyteidl.core.NodeMetadata)
}
NodeMetadata::NodeMetadata(const NodeMetadata& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_timeout()) {
    timeout_ = new ::PROTOBUF_NAMESPACE_ID::Duration(*from.timeout_);
  } else {
    timeout_ = nullptr;
  }
  if (from._internal_has_retries()) {
    retries_ = new ::flyteidl::core::RetryStrategy(*from.retries_);
  } else {
    retries_ = nullptr;
  }
  clear_has_interruptible_value();
  switch (from.interruptible_value_case()) {
    case kInterruptible: {
      _internal_set_interruptible(from._internal_interruptible());
      break;
    }
    case INTERRUPTIBLE_VALUE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:flyteidl.core.NodeMetadata)
}

inline void NodeMetadata::SharedCtor() {
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&timeout_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&retries_) -
    reinterpret_cast<char*>(&timeout_)) + sizeof(retries_));
clear_has_interruptible_value();
}

NodeMetadata::~NodeMetadata() {
  // @@protoc_insertion_point(destructor:flyteidl.core.NodeMetadata)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NodeMetadata::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete timeout_;
  if (this != internal_default_instance()) delete retries_;
  if (has_interruptible_value()) {
    clear_interruptible_value();
  }
}

void NodeMetadata::ArenaDtor(void* object) {
  NodeMetadata* _this = reinterpret_cast< NodeMetadata* >(object);
  (void)_this;
}
void NodeMetadata::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NodeMetadata::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NodeMetadata::clear_interruptible_value() {
// @@protoc_insertion_point(one_of_clear_start:flyteidl.core.NodeMetadata)
  switch (interruptible_value_case()) {
    case kInterruptible: {
      // No need to clear
      break;
    }
    case INTERRUPTIBLE_VALUE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = INTERRUPTIBLE_VALUE_NOT_SET;
}


void NodeMetadata::InternalSwap(NodeMetadata* other) {
  using std::swap;
  GetReflection()->Swap(this, other);}

::PROTOBUF_NAMESPACE_ID::Metadata NodeMetadata::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_flyteidl_2fcore_2fworkflow_2eproto_getter, &descriptor_table_flyteidl_2fcore_2fworkflow_2eproto_once,
      file_level_metadata_flyteidl_2fcore_2fworkflow_2eproto[5]);
}

// ===================================================================

class Alias::_Internal {
 public:
};

Alias::Alias(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:flyteidl.core.Alias)
}
Alias::Alias(const Alias& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  var_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    var_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_var().empty()) {
    var_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_var(), 
      GetArenaForAllocation());
  }
  alias_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    alias_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_alias().empty()) {
    alias_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_alias(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:flyteidl.core.Alias)
}

inline void Alias::SharedCtor() {
var_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  var_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
alias_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  alias_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Alias::~Alias() {
  // @@protoc_insertion_point(destructor:flyteidl.core.Alias)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Alias::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  var_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  alias_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void Alias::ArenaDtor(void* object) {
  Alias* _this = reinterpret_cast< Alias* >(object);
  (void)_this;
}
void Alias::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Alias::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Alias::InternalSwap(Alias* other) {
  using std::swap;
  GetReflection()->Swap(this, other);}

::PROTOBUF_NAMESPACE_ID::Metadata Alias::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_flyteidl_2fcore_2fworkflow_2eproto_getter, &descriptor_table_flyteidl_2fcore_2fworkflow_2eproto_once,
      file_level_metadata_flyteidl_2fcore_2fworkflow_2eproto[6]);
}

// ===================================================================

class Node::_Internal {
 public:
  static const ::flyteidl::core::NodeMetadata& metadata(const Node* msg);
  static const ::flyteidl::core::TaskNode& task_node(const Node* msg);
  static const ::flyteidl::core::WorkflowNode& workflow_node(const Node* msg);
  static const ::flyteidl::core::BranchNode& branch_node(const Node* msg);
};

const ::flyteidl::core::NodeMetadata&
Node::_Internal::metadata(const Node* msg) {
  return *msg->metadata_;
}
const ::flyteidl::core::TaskNode&
Node::_Internal::task_node(const Node* msg) {
  return *msg->target_.task_node_;
}
const ::flyteidl::core::WorkflowNode&
Node::_Internal::workflow_node(const Node* msg) {
  return *msg->target_.workflow_node_;
}
const ::flyteidl::core::BranchNode&
Node::_Internal::branch_node(const Node* msg) {
  return *msg->target_.branch_node_;
}
void Node::clear_inputs() {
  inputs_.Clear();
}
void Node::set_allocated_task_node(::flyteidl::core::TaskNode* task_node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_target();
  if (task_node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::flyteidl::core::TaskNode>::GetOwningArena(task_node);
    if (message_arena != submessage_arena) {
      task_node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, task_node, submessage_arena);
    }
    set_has_task_node();
    target_.task_node_ = task_node;
  }
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.Node.task_node)
}
void Node::set_allocated_workflow_node(::flyteidl::core::WorkflowNode* workflow_node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_target();
  if (workflow_node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::flyteidl::core::WorkflowNode>::GetOwningArena(workflow_node);
    if (message_arena != submessage_arena) {
      workflow_node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, workflow_node, submessage_arena);
    }
    set_has_workflow_node();
    target_.workflow_node_ = workflow_node;
  }
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.Node.workflow_node)
}
void Node::set_allocated_branch_node(::flyteidl::core::BranchNode* branch_node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_target();
  if (branch_node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::flyteidl::core::BranchNode>::GetOwningArena(branch_node);
    if (message_arena != submessage_arena) {
      branch_node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, branch_node, submessage_arena);
    }
    set_has_branch_node();
    target_.branch_node_ = branch_node;
  }
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.Node.branch_node)
}
Node::Node(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  inputs_(arena),
  upstream_node_ids_(arena),
  output_aliases_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:flyteidl.core.Node)
}
Node::Node(const Node& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      inputs_(from.inputs_),
      upstream_node_ids_(from.upstream_node_ids_),
      output_aliases_(from.output_aliases_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_id().empty()) {
    id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_id(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_metadata()) {
    metadata_ = new ::flyteidl::core::NodeMetadata(*from.metadata_);
  } else {
    metadata_ = nullptr;
  }
  clear_has_target();
  switch (from.target_case()) {
    case kTaskNode: {
      _internal_mutable_task_node()->::flyteidl::core::TaskNode::MergeFrom(from._internal_task_node());
      break;
    }
    case kWorkflowNode: {
      _internal_mutable_workflow_node()->::flyteidl::core::WorkflowNode::MergeFrom(from._internal_workflow_node());
      break;
    }
    case kBranchNode: {
      _internal_mutable_branch_node()->::flyteidl::core::BranchNode::MergeFrom(from._internal_branch_node());
      break;
    }
    case TARGET_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:flyteidl.core.Node)
}

inline void Node::SharedCtor() {
id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
metadata_ = nullptr;
clear_has_target();
}

Node::~Node() {
  // @@protoc_insertion_point(destructor:flyteidl.core.Node)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Node::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete metadata_;
  if (has_target()) {
    clear_target();
  }
}

void Node::ArenaDtor(void* object) {
  Node* _this = reinterpret_cast< Node* >(object);
  (void)_this;
}
void Node::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Node::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Node::clear_target() {
// @@protoc_insertion_point(one_of_clear_start:flyteidl.core.Node)
  switch (target_case()) {
    case kTaskNode: {
      if (GetArenaForAllocation() == nullptr) {
        delete target_.task_node_;
      }
      break;
    }
    case kWorkflowNode: {
      if (GetArenaForAllocation() == nullptr) {
        delete target_.workflow_node_;
      }
      break;
    }
    case kBranchNode: {
      if (GetArenaForAllocation() == nullptr) {
        delete target_.branch_node_;
      }
      break;
    }
    case TARGET_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = TARGET_NOT_SET;
}


void Node::InternalSwap(Node* other) {
  using std::swap;
  GetReflection()->Swap(this, other);}

::PROTOBUF_NAMESPACE_ID::Metadata Node::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_flyteidl_2fcore_2fworkflow_2eproto_getter, &descriptor_table_flyteidl_2fcore_2fworkflow_2eproto_once,
      file_level_metadata_flyteidl_2fcore_2fworkflow_2eproto[7]);
}

// ===================================================================

class WorkflowMetadata::_Internal {
 public:
  static const ::flyteidl::core::QualityOfService& quality_of_service(const WorkflowMetadata* msg);
};

const ::flyteidl::core::QualityOfService&
WorkflowMetadata::_Internal::quality_of_service(const WorkflowMetadata* msg) {
  return *msg->quality_of_service_;
}
void WorkflowMetadata::clear_quality_of_service() {
  if (GetArenaForAllocation() == nullptr && quality_of_service_ != nullptr) {
    delete quality_of_service_;
  }
  quality_of_service_ = nullptr;
}
WorkflowMetadata::WorkflowMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:flyteidl.core.WorkflowMetadata)
}
WorkflowMetadata::WorkflowMetadata(const WorkflowMetadata& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_quality_of_service()) {
    quality_of_service_ = new ::flyteidl::core::QualityOfService(*from.quality_of_service_);
  } else {
    quality_of_service_ = nullptr;
  }
  on_failure_ = from.on_failure_;
  // @@protoc_insertion_point(copy_constructor:flyteidl.core.WorkflowMetadata)
}

inline void WorkflowMetadata::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&quality_of_service_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&on_failure_) -
    reinterpret_cast<char*>(&quality_of_service_)) + sizeof(on_failure_));
}

WorkflowMetadata::~WorkflowMetadata() {
  // @@protoc_insertion_point(destructor:flyteidl.core.WorkflowMetadata)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void WorkflowMetadata::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete quality_of_service_;
}

void WorkflowMetadata::ArenaDtor(void* object) {
  WorkflowMetadata* _this = reinterpret_cast< WorkflowMetadata* >(object);
  (void)_this;
}
void WorkflowMetadata::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void WorkflowMetadata::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void WorkflowMetadata::InternalSwap(WorkflowMetadata* other) {
  using std::swap;
  GetReflection()->Swap(this, other);}

::PROTOBUF_NAMESPACE_ID::Metadata WorkflowMetadata::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_flyteidl_2fcore_2fworkflow_2eproto_getter, &descriptor_table_flyteidl_2fcore_2fworkflow_2eproto_once,
      file_level_metadata_flyteidl_2fcore_2fworkflow_2eproto[8]);
}

// ===================================================================

class WorkflowMetadataDefaults::_Internal {
 public:
};

WorkflowMetadataDefaults::WorkflowMetadataDefaults(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:flyteidl.core.WorkflowMetadataDefaults)
}
WorkflowMetadataDefaults::WorkflowMetadataDefaults(const WorkflowMetadataDefaults& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  interruptible_ = from.interruptible_;
  // @@protoc_insertion_point(copy_constructor:flyteidl.core.WorkflowMetadataDefaults)
}

inline void WorkflowMetadataDefaults::SharedCtor() {
interruptible_ = false;
}

WorkflowMetadataDefaults::~WorkflowMetadataDefaults() {
  // @@protoc_insertion_point(destructor:flyteidl.core.WorkflowMetadataDefaults)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void WorkflowMetadataDefaults::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void WorkflowMetadataDefaults::ArenaDtor(void* object) {
  WorkflowMetadataDefaults* _this = reinterpret_cast< WorkflowMetadataDefaults* >(object);
  (void)_this;
}
void WorkflowMetadataDefaults::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void WorkflowMetadataDefaults::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void WorkflowMetadataDefaults::InternalSwap(WorkflowMetadataDefaults* other) {
  using std::swap;
  GetReflection()->Swap(this, other);}

::PROTOBUF_NAMESPACE_ID::Metadata WorkflowMetadataDefaults::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_flyteidl_2fcore_2fworkflow_2eproto_getter, &descriptor_table_flyteidl_2fcore_2fworkflow_2eproto_once,
      file_level_metadata_flyteidl_2fcore_2fworkflow_2eproto[9]);
}

// ===================================================================

class WorkflowTemplate::_Internal {
 public:
  static const ::flyteidl::core::Identifier& id(const WorkflowTemplate* msg);
  static const ::flyteidl::core::WorkflowMetadata& metadata(const WorkflowTemplate* msg);
  static const ::flyteidl::core::TypedInterface& interface(const WorkflowTemplate* msg);
  static const ::flyteidl::core::Node& failure_node(const WorkflowTemplate* msg);
  static const ::flyteidl::core::WorkflowMetadataDefaults& metadata_defaults(const WorkflowTemplate* msg);
};

const ::flyteidl::core::Identifier&
WorkflowTemplate::_Internal::id(const WorkflowTemplate* msg) {
  return *msg->id_;
}
const ::flyteidl::core::WorkflowMetadata&
WorkflowTemplate::_Internal::metadata(const WorkflowTemplate* msg) {
  return *msg->metadata_;
}
const ::flyteidl::core::TypedInterface&
WorkflowTemplate::_Internal::interface(const WorkflowTemplate* msg) {
  return *msg->interface_;
}
const ::flyteidl::core::Node&
WorkflowTemplate::_Internal::failure_node(const WorkflowTemplate* msg) {
  return *msg->failure_node_;
}
const ::flyteidl::core::WorkflowMetadataDefaults&
WorkflowTemplate::_Internal::metadata_defaults(const WorkflowTemplate* msg) {
  return *msg->metadata_defaults_;
}
void WorkflowTemplate::clear_id() {
  if (GetArenaForAllocation() == nullptr && id_ != nullptr) {
    delete id_;
  }
  id_ = nullptr;
}
void WorkflowTemplate::clear_interface() {
  if (GetArenaForAllocation() == nullptr && interface_ != nullptr) {
    delete interface_;
  }
  interface_ = nullptr;
}
void WorkflowTemplate::clear_outputs() {
  outputs_.Clear();
}
WorkflowTemplate::WorkflowTemplate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  nodes_(arena),
  outputs_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:flyteidl.core.WorkflowTemplate)
}
WorkflowTemplate::WorkflowTemplate(const WorkflowTemplate& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      nodes_(from.nodes_),
      outputs_(from.outputs_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_id()) {
    id_ = new ::flyteidl::core::Identifier(*from.id_);
  } else {
    id_ = nullptr;
  }
  if (from._internal_has_metadata()) {
    metadata_ = new ::flyteidl::core::WorkflowMetadata(*from.metadata_);
  } else {
    metadata_ = nullptr;
  }
  if (from._internal_has_interface()) {
    interface_ = new ::flyteidl::core::TypedInterface(*from.interface_);
  } else {
    interface_ = nullptr;
  }
  if (from._internal_has_failure_node()) {
    failure_node_ = new ::flyteidl::core::Node(*from.failure_node_);
  } else {
    failure_node_ = nullptr;
  }
  if (from._internal_has_metadata_defaults()) {
    metadata_defaults_ = new ::flyteidl::core::WorkflowMetadataDefaults(*from.metadata_defaults_);
  } else {
    metadata_defaults_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:flyteidl.core.WorkflowTemplate)
}

inline void WorkflowTemplate::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&metadata_defaults_) -
    reinterpret_cast<char*>(&id_)) + sizeof(metadata_defaults_));
}

WorkflowTemplate::~WorkflowTemplate() {
  // @@protoc_insertion_point(destructor:flyteidl.core.WorkflowTemplate)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void WorkflowTemplate::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete id_;
  if (this != internal_default_instance()) delete metadata_;
  if (this != internal_default_instance()) delete interface_;
  if (this != internal_default_instance()) delete failure_node_;
  if (this != internal_default_instance()) delete metadata_defaults_;
}

void WorkflowTemplate::ArenaDtor(void* object) {
  WorkflowTemplate* _this = reinterpret_cast< WorkflowTemplate* >(object);
  (void)_this;
}
void WorkflowTemplate::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void WorkflowTemplate::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void WorkflowTemplate::InternalSwap(WorkflowTemplate* other) {
  using std::swap;
  GetReflection()->Swap(this, other);}

::PROTOBUF_NAMESPACE_ID::Metadata WorkflowTemplate::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_flyteidl_2fcore_2fworkflow_2eproto_getter, &descriptor_table_flyteidl_2fcore_2fworkflow_2eproto_once,
      file_level_metadata_flyteidl_2fcore_2fworkflow_2eproto[10]);
}

// ===================================================================

class TaskNodeOverrides::_Internal {
 public:
  static const ::flyteidl::core::Resources& resources(const TaskNodeOverrides* msg);
};

const ::flyteidl::core::Resources&
TaskNodeOverrides::_Internal::resources(const TaskNodeOverrides* msg) {
  return *msg->resources_;
}
void TaskNodeOverrides::clear_resources() {
  if (GetArenaForAllocation() == nullptr && resources_ != nullptr) {
    delete resources_;
  }
  resources_ = nullptr;
}
TaskNodeOverrides::TaskNodeOverrides(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:flyteidl.core.TaskNodeOverrides)
}
TaskNodeOverrides::TaskNodeOverrides(const TaskNodeOverrides& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_resources()) {
    resources_ = new ::flyteidl::core::Resources(*from.resources_);
  } else {
    resources_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:flyteidl.core.TaskNodeOverrides)
}

inline void TaskNodeOverrides::SharedCtor() {
resources_ = nullptr;
}

TaskNodeOverrides::~TaskNodeOverrides() {
  // @@protoc_insertion_point(destructor:flyteidl.core.TaskNodeOverrides)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void TaskNodeOverrides::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete resources_;
}

void TaskNodeOverrides::ArenaDtor(void* object) {
  TaskNodeOverrides* _this = reinterpret_cast< TaskNodeOverrides* >(object);
  (void)_this;
}
void TaskNodeOverrides::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TaskNodeOverrides::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TaskNodeOverrides::InternalSwap(TaskNodeOverrides* other) {
  using std::swap;
  GetReflection()->Swap(this, other);}

::PROTOBUF_NAMESPACE_ID::Metadata TaskNodeOverrides::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_flyteidl_2fcore_2fworkflow_2eproto_getter, &descriptor_table_flyteidl_2fcore_2fworkflow_2eproto_once,
      file_level_metadata_flyteidl_2fcore_2fworkflow_2eproto[11]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace core
}  // namespace flyteidl
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::flyteidl::core::IfBlock* Arena::CreateMaybeMessage< ::flyteidl::core::IfBlock >(Arena* arena) {
  return Arena::CreateMessageInternal< ::flyteidl::core::IfBlock >(arena);
}
template<> PROTOBUF_NOINLINE ::flyteidl::core::IfElseBlock* Arena::CreateMaybeMessage< ::flyteidl::core::IfElseBlock >(Arena* arena) {
  return Arena::CreateMessageInternal< ::flyteidl::core::IfElseBlock >(arena);
}
template<> PROTOBUF_NOINLINE ::flyteidl::core::BranchNode* Arena::CreateMaybeMessage< ::flyteidl::core::BranchNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::flyteidl::core::BranchNode >(arena);
}
template<> PROTOBUF_NOINLINE ::flyteidl::core::TaskNode* Arena::CreateMaybeMessage< ::flyteidl::core::TaskNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::flyteidl::core::TaskNode >(arena);
}
template<> PROTOBUF_NOINLINE ::flyteidl::core::WorkflowNode* Arena::CreateMaybeMessage< ::flyteidl::core::WorkflowNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::flyteidl::core::WorkflowNode >(arena);
}
template<> PROTOBUF_NOINLINE ::flyteidl::core::NodeMetadata* Arena::CreateMaybeMessage< ::flyteidl::core::NodeMetadata >(Arena* arena) {
  return Arena::CreateMessageInternal< ::flyteidl::core::NodeMetadata >(arena);
}
template<> PROTOBUF_NOINLINE ::flyteidl::core::Alias* Arena::CreateMaybeMessage< ::flyteidl::core::Alias >(Arena* arena) {
  return Arena::CreateMessageInternal< ::flyteidl::core::Alias >(arena);
}
template<> PROTOBUF_NOINLINE ::flyteidl::core::Node* Arena::CreateMaybeMessage< ::flyteidl::core::Node >(Arena* arena) {
  return Arena::CreateMessageInternal< ::flyteidl::core::Node >(arena);
}
template<> PROTOBUF_NOINLINE ::flyteidl::core::WorkflowMetadata* Arena::CreateMaybeMessage< ::flyteidl::core::WorkflowMetadata >(Arena* arena) {
  return Arena::CreateMessageInternal< ::flyteidl::core::WorkflowMetadata >(arena);
}
template<> PROTOBUF_NOINLINE ::flyteidl::core::WorkflowMetadataDefaults* Arena::CreateMaybeMessage< ::flyteidl::core::WorkflowMetadataDefaults >(Arena* arena) {
  return Arena::CreateMessageInternal< ::flyteidl::core::WorkflowMetadataDefaults >(arena);
}
template<> PROTOBUF_NOINLINE ::flyteidl::core::WorkflowTemplate* Arena::CreateMaybeMessage< ::flyteidl::core::WorkflowTemplate >(Arena* arena) {
  return Arena::CreateMessageInternal< ::flyteidl::core::WorkflowTemplate >(arena);
}
template<> PROTOBUF_NOINLINE ::flyteidl::core::TaskNodeOverrides* Arena::CreateMaybeMessage< ::flyteidl::core::TaskNodeOverrides >(Arena* arena) {
  return Arena::CreateMessageInternal< ::flyteidl::core::TaskNodeOverrides >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
