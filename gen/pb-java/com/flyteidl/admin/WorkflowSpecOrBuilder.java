// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: flyteidl/admin/workflow.proto

package com.flyteidl.admin;

public interface WorkflowSpecOrBuilder extends
    // @@protoc_insertion_point(interface_extends:flyteidl.admin.WorkflowSpec)
    com.google.protobuf.MessageOrBuilder {

  /**
   * <pre>
   * Template of the task that encapsulates all the metadata of the workflow.
   * </pre>
   *
   * <code>.flyteidl.core.WorkflowTemplate template = 1 [json_name = "template"];</code>
   * @return Whether the template field is set.
   */
  boolean hasTemplate();
  /**
   * <pre>
   * Template of the task that encapsulates all the metadata of the workflow.
   * </pre>
   *
   * <code>.flyteidl.core.WorkflowTemplate template = 1 [json_name = "template"];</code>
   * @return The template.
   */
  com.flyteidl.core.WorkflowTemplate getTemplate();
  /**
   * <pre>
   * Template of the task that encapsulates all the metadata of the workflow.
   * </pre>
   *
   * <code>.flyteidl.core.WorkflowTemplate template = 1 [json_name = "template"];</code>
   */
  com.flyteidl.core.WorkflowTemplateOrBuilder getTemplateOrBuilder();

  /**
   * <pre>
   * Workflows that are embedded into other workflows need to be passed alongside the parent workflow to the
   * propeller compiler (since the compiler doesn't have any knowledge of other workflows - ie, it doesn't reach out
   * to Admin to see other registered workflows).  In fact, subworkflows do not even need to be registered.
   * </pre>
   *
   * <code>repeated .flyteidl.core.WorkflowTemplate sub_workflows = 2 [json_name = "subWorkflows"];</code>
   */
  java.util.List<com.flyteidl.core.WorkflowTemplate> 
      getSubWorkflowsList();
  /**
   * <pre>
   * Workflows that are embedded into other workflows need to be passed alongside the parent workflow to the
   * propeller compiler (since the compiler doesn't have any knowledge of other workflows - ie, it doesn't reach out
   * to Admin to see other registered workflows).  In fact, subworkflows do not even need to be registered.
   * </pre>
   *
   * <code>repeated .flyteidl.core.WorkflowTemplate sub_workflows = 2 [json_name = "subWorkflows"];</code>
   */
  com.flyteidl.core.WorkflowTemplate getSubWorkflows(int index);
  /**
   * <pre>
   * Workflows that are embedded into other workflows need to be passed alongside the parent workflow to the
   * propeller compiler (since the compiler doesn't have any knowledge of other workflows - ie, it doesn't reach out
   * to Admin to see other registered workflows).  In fact, subworkflows do not even need to be registered.
   * </pre>
   *
   * <code>repeated .flyteidl.core.WorkflowTemplate sub_workflows = 2 [json_name = "subWorkflows"];</code>
   */
  int getSubWorkflowsCount();
  /**
   * <pre>
   * Workflows that are embedded into other workflows need to be passed alongside the parent workflow to the
   * propeller compiler (since the compiler doesn't have any knowledge of other workflows - ie, it doesn't reach out
   * to Admin to see other registered workflows).  In fact, subworkflows do not even need to be registered.
   * </pre>
   *
   * <code>repeated .flyteidl.core.WorkflowTemplate sub_workflows = 2 [json_name = "subWorkflows"];</code>
   */
  java.util.List<? extends com.flyteidl.core.WorkflowTemplateOrBuilder> 
      getSubWorkflowsOrBuilderList();
  /**
   * <pre>
   * Workflows that are embedded into other workflows need to be passed alongside the parent workflow to the
   * propeller compiler (since the compiler doesn't have any knowledge of other workflows - ie, it doesn't reach out
   * to Admin to see other registered workflows).  In fact, subworkflows do not even need to be registered.
   * </pre>
   *
   * <code>repeated .flyteidl.core.WorkflowTemplate sub_workflows = 2 [json_name = "subWorkflows"];</code>
   */
  com.flyteidl.core.WorkflowTemplateOrBuilder getSubWorkflowsOrBuilder(
      int index);
}
