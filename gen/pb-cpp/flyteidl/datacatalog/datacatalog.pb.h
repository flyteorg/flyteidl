// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: flyteidl/datacatalog/datacatalog.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_flyteidl_2fdatacatalog_2fdatacatalog_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_flyteidl_2fdatacatalog_2fdatacatalog_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "flyteidl/core/literals.pb.h"
#include <google/protobuf/duration.pb.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_flyteidl_2fdatacatalog_2fdatacatalog_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_flyteidl_2fdatacatalog_2fdatacatalog_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[36]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_flyteidl_2fdatacatalog_2fdatacatalog_2eproto;
namespace datacatalog {
class AddTagRequest;
struct AddTagRequestDefaultTypeInternal;
extern AddTagRequestDefaultTypeInternal _AddTagRequest_default_instance_;
class AddTagResponse;
struct AddTagResponseDefaultTypeInternal;
extern AddTagResponseDefaultTypeInternal _AddTagResponse_default_instance_;
class Artifact;
struct ArtifactDefaultTypeInternal;
extern ArtifactDefaultTypeInternal _Artifact_default_instance_;
class ArtifactData;
struct ArtifactDataDefaultTypeInternal;
extern ArtifactDataDefaultTypeInternal _ArtifactData_default_instance_;
class ArtifactPropertyFilter;
struct ArtifactPropertyFilterDefaultTypeInternal;
extern ArtifactPropertyFilterDefaultTypeInternal _ArtifactPropertyFilter_default_instance_;
class CreateArtifactRequest;
struct CreateArtifactRequestDefaultTypeInternal;
extern CreateArtifactRequestDefaultTypeInternal _CreateArtifactRequest_default_instance_;
class CreateArtifactResponse;
struct CreateArtifactResponseDefaultTypeInternal;
extern CreateArtifactResponseDefaultTypeInternal _CreateArtifactResponse_default_instance_;
class CreateDatasetRequest;
struct CreateDatasetRequestDefaultTypeInternal;
extern CreateDatasetRequestDefaultTypeInternal _CreateDatasetRequest_default_instance_;
class CreateDatasetResponse;
struct CreateDatasetResponseDefaultTypeInternal;
extern CreateDatasetResponseDefaultTypeInternal _CreateDatasetResponse_default_instance_;
class Dataset;
struct DatasetDefaultTypeInternal;
extern DatasetDefaultTypeInternal _Dataset_default_instance_;
class DatasetID;
struct DatasetIDDefaultTypeInternal;
extern DatasetIDDefaultTypeInternal _DatasetID_default_instance_;
class DatasetPropertyFilter;
struct DatasetPropertyFilterDefaultTypeInternal;
extern DatasetPropertyFilterDefaultTypeInternal _DatasetPropertyFilter_default_instance_;
class FilterExpression;
struct FilterExpressionDefaultTypeInternal;
extern FilterExpressionDefaultTypeInternal _FilterExpression_default_instance_;
class GetArtifactRequest;
struct GetArtifactRequestDefaultTypeInternal;
extern GetArtifactRequestDefaultTypeInternal _GetArtifactRequest_default_instance_;
class GetArtifactResponse;
struct GetArtifactResponseDefaultTypeInternal;
extern GetArtifactResponseDefaultTypeInternal _GetArtifactResponse_default_instance_;
class GetDatasetRequest;
struct GetDatasetRequestDefaultTypeInternal;
extern GetDatasetRequestDefaultTypeInternal _GetDatasetRequest_default_instance_;
class GetDatasetResponse;
struct GetDatasetResponseDefaultTypeInternal;
extern GetDatasetResponseDefaultTypeInternal _GetDatasetResponse_default_instance_;
class GetOrExtendReservationRequest;
struct GetOrExtendReservationRequestDefaultTypeInternal;
extern GetOrExtendReservationRequestDefaultTypeInternal _GetOrExtendReservationRequest_default_instance_;
class GetOrExtendReservationResponse;
struct GetOrExtendReservationResponseDefaultTypeInternal;
extern GetOrExtendReservationResponseDefaultTypeInternal _GetOrExtendReservationResponse_default_instance_;
class KeyValuePair;
struct KeyValuePairDefaultTypeInternal;
extern KeyValuePairDefaultTypeInternal _KeyValuePair_default_instance_;
class ListArtifactsRequest;
struct ListArtifactsRequestDefaultTypeInternal;
extern ListArtifactsRequestDefaultTypeInternal _ListArtifactsRequest_default_instance_;
class ListArtifactsResponse;
struct ListArtifactsResponseDefaultTypeInternal;
extern ListArtifactsResponseDefaultTypeInternal _ListArtifactsResponse_default_instance_;
class ListDatasetsRequest;
struct ListDatasetsRequestDefaultTypeInternal;
extern ListDatasetsRequestDefaultTypeInternal _ListDatasetsRequest_default_instance_;
class ListDatasetsResponse;
struct ListDatasetsResponseDefaultTypeInternal;
extern ListDatasetsResponseDefaultTypeInternal _ListDatasetsResponse_default_instance_;
class Metadata;
struct MetadataDefaultTypeInternal;
extern MetadataDefaultTypeInternal _Metadata_default_instance_;
class Metadata_KeyMapEntry_DoNotUse;
struct Metadata_KeyMapEntry_DoNotUseDefaultTypeInternal;
extern Metadata_KeyMapEntry_DoNotUseDefaultTypeInternal _Metadata_KeyMapEntry_DoNotUse_default_instance_;
class PaginationOptions;
struct PaginationOptionsDefaultTypeInternal;
extern PaginationOptionsDefaultTypeInternal _PaginationOptions_default_instance_;
class Partition;
struct PartitionDefaultTypeInternal;
extern PartitionDefaultTypeInternal _Partition_default_instance_;
class PartitionPropertyFilter;
struct PartitionPropertyFilterDefaultTypeInternal;
extern PartitionPropertyFilterDefaultTypeInternal _PartitionPropertyFilter_default_instance_;
class ReleaseReservationRequest;
struct ReleaseReservationRequestDefaultTypeInternal;
extern ReleaseReservationRequestDefaultTypeInternal _ReleaseReservationRequest_default_instance_;
class ReleaseReservationResponse;
struct ReleaseReservationResponseDefaultTypeInternal;
extern ReleaseReservationResponseDefaultTypeInternal _ReleaseReservationResponse_default_instance_;
class Reservation;
struct ReservationDefaultTypeInternal;
extern ReservationDefaultTypeInternal _Reservation_default_instance_;
class ReservationID;
struct ReservationIDDefaultTypeInternal;
extern ReservationIDDefaultTypeInternal _ReservationID_default_instance_;
class SinglePropertyFilter;
struct SinglePropertyFilterDefaultTypeInternal;
extern SinglePropertyFilterDefaultTypeInternal _SinglePropertyFilter_default_instance_;
class Tag;
struct TagDefaultTypeInternal;
extern TagDefaultTypeInternal _Tag_default_instance_;
class TagPropertyFilter;
struct TagPropertyFilterDefaultTypeInternal;
extern TagPropertyFilterDefaultTypeInternal _TagPropertyFilter_default_instance_;
}  // namespace datacatalog
PROTOBUF_NAMESPACE_OPEN
template<> ::datacatalog::AddTagRequest* Arena::CreateMaybeMessage<::datacatalog::AddTagRequest>(Arena*);
template<> ::datacatalog::AddTagResponse* Arena::CreateMaybeMessage<::datacatalog::AddTagResponse>(Arena*);
template<> ::datacatalog::Artifact* Arena::CreateMaybeMessage<::datacatalog::Artifact>(Arena*);
template<> ::datacatalog::ArtifactData* Arena::CreateMaybeMessage<::datacatalog::ArtifactData>(Arena*);
template<> ::datacatalog::ArtifactPropertyFilter* Arena::CreateMaybeMessage<::datacatalog::ArtifactPropertyFilter>(Arena*);
template<> ::datacatalog::CreateArtifactRequest* Arena::CreateMaybeMessage<::datacatalog::CreateArtifactRequest>(Arena*);
template<> ::datacatalog::CreateArtifactResponse* Arena::CreateMaybeMessage<::datacatalog::CreateArtifactResponse>(Arena*);
template<> ::datacatalog::CreateDatasetRequest* Arena::CreateMaybeMessage<::datacatalog::CreateDatasetRequest>(Arena*);
template<> ::datacatalog::CreateDatasetResponse* Arena::CreateMaybeMessage<::datacatalog::CreateDatasetResponse>(Arena*);
template<> ::datacatalog::Dataset* Arena::CreateMaybeMessage<::datacatalog::Dataset>(Arena*);
template<> ::datacatalog::DatasetID* Arena::CreateMaybeMessage<::datacatalog::DatasetID>(Arena*);
template<> ::datacatalog::DatasetPropertyFilter* Arena::CreateMaybeMessage<::datacatalog::DatasetPropertyFilter>(Arena*);
template<> ::datacatalog::FilterExpression* Arena::CreateMaybeMessage<::datacatalog::FilterExpression>(Arena*);
template<> ::datacatalog::GetArtifactRequest* Arena::CreateMaybeMessage<::datacatalog::GetArtifactRequest>(Arena*);
template<> ::datacatalog::GetArtifactResponse* Arena::CreateMaybeMessage<::datacatalog::GetArtifactResponse>(Arena*);
template<> ::datacatalog::GetDatasetRequest* Arena::CreateMaybeMessage<::datacatalog::GetDatasetRequest>(Arena*);
template<> ::datacatalog::GetDatasetResponse* Arena::CreateMaybeMessage<::datacatalog::GetDatasetResponse>(Arena*);
template<> ::datacatalog::GetOrExtendReservationRequest* Arena::CreateMaybeMessage<::datacatalog::GetOrExtendReservationRequest>(Arena*);
template<> ::datacatalog::GetOrExtendReservationResponse* Arena::CreateMaybeMessage<::datacatalog::GetOrExtendReservationResponse>(Arena*);
template<> ::datacatalog::KeyValuePair* Arena::CreateMaybeMessage<::datacatalog::KeyValuePair>(Arena*);
template<> ::datacatalog::ListArtifactsRequest* Arena::CreateMaybeMessage<::datacatalog::ListArtifactsRequest>(Arena*);
template<> ::datacatalog::ListArtifactsResponse* Arena::CreateMaybeMessage<::datacatalog::ListArtifactsResponse>(Arena*);
template<> ::datacatalog::ListDatasetsRequest* Arena::CreateMaybeMessage<::datacatalog::ListDatasetsRequest>(Arena*);
template<> ::datacatalog::ListDatasetsResponse* Arena::CreateMaybeMessage<::datacatalog::ListDatasetsResponse>(Arena*);
template<> ::datacatalog::Metadata* Arena::CreateMaybeMessage<::datacatalog::Metadata>(Arena*);
template<> ::datacatalog::Metadata_KeyMapEntry_DoNotUse* Arena::CreateMaybeMessage<::datacatalog::Metadata_KeyMapEntry_DoNotUse>(Arena*);
template<> ::datacatalog::PaginationOptions* Arena::CreateMaybeMessage<::datacatalog::PaginationOptions>(Arena*);
template<> ::datacatalog::Partition* Arena::CreateMaybeMessage<::datacatalog::Partition>(Arena*);
template<> ::datacatalog::PartitionPropertyFilter* Arena::CreateMaybeMessage<::datacatalog::PartitionPropertyFilter>(Arena*);
template<> ::datacatalog::ReleaseReservationRequest* Arena::CreateMaybeMessage<::datacatalog::ReleaseReservationRequest>(Arena*);
template<> ::datacatalog::ReleaseReservationResponse* Arena::CreateMaybeMessage<::datacatalog::ReleaseReservationResponse>(Arena*);
template<> ::datacatalog::Reservation* Arena::CreateMaybeMessage<::datacatalog::Reservation>(Arena*);
template<> ::datacatalog::ReservationID* Arena::CreateMaybeMessage<::datacatalog::ReservationID>(Arena*);
template<> ::datacatalog::SinglePropertyFilter* Arena::CreateMaybeMessage<::datacatalog::SinglePropertyFilter>(Arena*);
template<> ::datacatalog::Tag* Arena::CreateMaybeMessage<::datacatalog::Tag>(Arena*);
template<> ::datacatalog::TagPropertyFilter* Arena::CreateMaybeMessage<::datacatalog::TagPropertyFilter>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace datacatalog {

enum SinglePropertyFilter_ComparisonOperator : int {
  SinglePropertyFilter_ComparisonOperator_EQUALS = 0,
  SinglePropertyFilter_ComparisonOperator_SinglePropertyFilter_ComparisonOperator_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SinglePropertyFilter_ComparisonOperator_SinglePropertyFilter_ComparisonOperator_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SinglePropertyFilter_ComparisonOperator_IsValid(int value);
constexpr SinglePropertyFilter_ComparisonOperator SinglePropertyFilter_ComparisonOperator_ComparisonOperator_MIN = SinglePropertyFilter_ComparisonOperator_EQUALS;
constexpr SinglePropertyFilter_ComparisonOperator SinglePropertyFilter_ComparisonOperator_ComparisonOperator_MAX = SinglePropertyFilter_ComparisonOperator_EQUALS;
constexpr int SinglePropertyFilter_ComparisonOperator_ComparisonOperator_ARRAYSIZE = SinglePropertyFilter_ComparisonOperator_ComparisonOperator_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SinglePropertyFilter_ComparisonOperator_descriptor();
template<typename T>
inline const std::string& SinglePropertyFilter_ComparisonOperator_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SinglePropertyFilter_ComparisonOperator>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SinglePropertyFilter_ComparisonOperator_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SinglePropertyFilter_ComparisonOperator_descriptor(), enum_t_value);
}
inline bool SinglePropertyFilter_ComparisonOperator_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SinglePropertyFilter_ComparisonOperator* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SinglePropertyFilter_ComparisonOperator>(
    SinglePropertyFilter_ComparisonOperator_descriptor(), name, value);
}
enum PaginationOptions_SortOrder : int {
  PaginationOptions_SortOrder_DESCENDING = 0,
  PaginationOptions_SortOrder_ASCENDING = 1,
  PaginationOptions_SortOrder_PaginationOptions_SortOrder_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PaginationOptions_SortOrder_PaginationOptions_SortOrder_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PaginationOptions_SortOrder_IsValid(int value);
constexpr PaginationOptions_SortOrder PaginationOptions_SortOrder_SortOrder_MIN = PaginationOptions_SortOrder_DESCENDING;
constexpr PaginationOptions_SortOrder PaginationOptions_SortOrder_SortOrder_MAX = PaginationOptions_SortOrder_ASCENDING;
constexpr int PaginationOptions_SortOrder_SortOrder_ARRAYSIZE = PaginationOptions_SortOrder_SortOrder_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PaginationOptions_SortOrder_descriptor();
template<typename T>
inline const std::string& PaginationOptions_SortOrder_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PaginationOptions_SortOrder>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PaginationOptions_SortOrder_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PaginationOptions_SortOrder_descriptor(), enum_t_value);
}
inline bool PaginationOptions_SortOrder_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PaginationOptions_SortOrder* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PaginationOptions_SortOrder>(
    PaginationOptions_SortOrder_descriptor(), name, value);
}
enum PaginationOptions_SortKey : int {
  PaginationOptions_SortKey_CREATION_TIME = 0,
  PaginationOptions_SortKey_PaginationOptions_SortKey_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PaginationOptions_SortKey_PaginationOptions_SortKey_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PaginationOptions_SortKey_IsValid(int value);
constexpr PaginationOptions_SortKey PaginationOptions_SortKey_SortKey_MIN = PaginationOptions_SortKey_CREATION_TIME;
constexpr PaginationOptions_SortKey PaginationOptions_SortKey_SortKey_MAX = PaginationOptions_SortKey_CREATION_TIME;
constexpr int PaginationOptions_SortKey_SortKey_ARRAYSIZE = PaginationOptions_SortKey_SortKey_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PaginationOptions_SortKey_descriptor();
template<typename T>
inline const std::string& PaginationOptions_SortKey_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PaginationOptions_SortKey>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PaginationOptions_SortKey_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PaginationOptions_SortKey_descriptor(), enum_t_value);
}
inline bool PaginationOptions_SortKey_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PaginationOptions_SortKey* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PaginationOptions_SortKey>(
    PaginationOptions_SortKey_descriptor(), name, value);
}
// ===================================================================

class CreateDatasetRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:datacatalog.CreateDatasetRequest) */ {
 public:
  inline CreateDatasetRequest() : CreateDatasetRequest(nullptr) {}
  ~CreateDatasetRequest() override;
  explicit constexpr CreateDatasetRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateDatasetRequest(const CreateDatasetRequest& from);
  CreateDatasetRequest(CreateDatasetRequest&& from) noexcept
    : CreateDatasetRequest() {
    *this = ::std::move(from);
  }

  inline CreateDatasetRequest& operator=(const CreateDatasetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateDatasetRequest& operator=(CreateDatasetRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateDatasetRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateDatasetRequest* internal_default_instance() {
    return reinterpret_cast<const CreateDatasetRequest*>(
               &_CreateDatasetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CreateDatasetRequest& a, CreateDatasetRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateDatasetRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateDatasetRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateDatasetRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateDatasetRequest>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateDatasetRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "datacatalog.CreateDatasetRequest";
  }
  protected:
  explicit CreateDatasetRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDatasetFieldNumber = 1,
  };
  // .datacatalog.Dataset dataset = 1 [json_name = "dataset"];
  bool has_dataset() const;
  private:
  bool _internal_has_dataset() const;
  public:
  void clear_dataset();
  const ::datacatalog::Dataset& dataset() const;
  PROTOBUF_NODISCARD ::datacatalog::Dataset* release_dataset();
  ::datacatalog::Dataset* mutable_dataset();
  void set_allocated_dataset(::datacatalog::Dataset* dataset);
  private:
  const ::datacatalog::Dataset& _internal_dataset() const;
  ::datacatalog::Dataset* _internal_mutable_dataset();
  public:
  void unsafe_arena_set_allocated_dataset(
      ::datacatalog::Dataset* dataset);
  ::datacatalog::Dataset* unsafe_arena_release_dataset();

  // @@protoc_insertion_point(class_scope:datacatalog.CreateDatasetRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::datacatalog::Dataset* dataset_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fdatacatalog_2fdatacatalog_2eproto;
};
// -------------------------------------------------------------------

class CreateDatasetResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:datacatalog.CreateDatasetResponse) */ {
 public:
  inline CreateDatasetResponse() : CreateDatasetResponse(nullptr) {}
  explicit constexpr CreateDatasetResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateDatasetResponse(const CreateDatasetResponse& from);
  CreateDatasetResponse(CreateDatasetResponse&& from) noexcept
    : CreateDatasetResponse() {
    *this = ::std::move(from);
  }

  inline CreateDatasetResponse& operator=(const CreateDatasetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateDatasetResponse& operator=(CreateDatasetResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateDatasetResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateDatasetResponse* internal_default_instance() {
    return reinterpret_cast<const CreateDatasetResponse*>(
               &_CreateDatasetResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CreateDatasetResponse& a, CreateDatasetResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateDatasetResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateDatasetResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateDatasetResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateDatasetResponse>(arena);
  }

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "datacatalog.CreateDatasetResponse";
  }
  protected:
  explicit CreateDatasetResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:datacatalog.CreateDatasetResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fdatacatalog_2fdatacatalog_2eproto;
};
// -------------------------------------------------------------------

class GetDatasetRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:datacatalog.GetDatasetRequest) */ {
 public:
  inline GetDatasetRequest() : GetDatasetRequest(nullptr) {}
  ~GetDatasetRequest() override;
  explicit constexpr GetDatasetRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetDatasetRequest(const GetDatasetRequest& from);
  GetDatasetRequest(GetDatasetRequest&& from) noexcept
    : GetDatasetRequest() {
    *this = ::std::move(from);
  }

  inline GetDatasetRequest& operator=(const GetDatasetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetDatasetRequest& operator=(GetDatasetRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetDatasetRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetDatasetRequest* internal_default_instance() {
    return reinterpret_cast<const GetDatasetRequest*>(
               &_GetDatasetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(GetDatasetRequest& a, GetDatasetRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetDatasetRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetDatasetRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetDatasetRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetDatasetRequest>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetDatasetRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "datacatalog.GetDatasetRequest";
  }
  protected:
  explicit GetDatasetRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDatasetFieldNumber = 1,
  };
  // .datacatalog.DatasetID dataset = 1 [json_name = "dataset"];
  bool has_dataset() const;
  private:
  bool _internal_has_dataset() const;
  public:
  void clear_dataset();
  const ::datacatalog::DatasetID& dataset() const;
  PROTOBUF_NODISCARD ::datacatalog::DatasetID* release_dataset();
  ::datacatalog::DatasetID* mutable_dataset();
  void set_allocated_dataset(::datacatalog::DatasetID* dataset);
  private:
  const ::datacatalog::DatasetID& _internal_dataset() const;
  ::datacatalog::DatasetID* _internal_mutable_dataset();
  public:
  void unsafe_arena_set_allocated_dataset(
      ::datacatalog::DatasetID* dataset);
  ::datacatalog::DatasetID* unsafe_arena_release_dataset();

  // @@protoc_insertion_point(class_scope:datacatalog.GetDatasetRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::datacatalog::DatasetID* dataset_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fdatacatalog_2fdatacatalog_2eproto;
};
// -------------------------------------------------------------------

class GetDatasetResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:datacatalog.GetDatasetResponse) */ {
 public:
  inline GetDatasetResponse() : GetDatasetResponse(nullptr) {}
  ~GetDatasetResponse() override;
  explicit constexpr GetDatasetResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetDatasetResponse(const GetDatasetResponse& from);
  GetDatasetResponse(GetDatasetResponse&& from) noexcept
    : GetDatasetResponse() {
    *this = ::std::move(from);
  }

  inline GetDatasetResponse& operator=(const GetDatasetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetDatasetResponse& operator=(GetDatasetResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetDatasetResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetDatasetResponse* internal_default_instance() {
    return reinterpret_cast<const GetDatasetResponse*>(
               &_GetDatasetResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(GetDatasetResponse& a, GetDatasetResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetDatasetResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetDatasetResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetDatasetResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetDatasetResponse>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetDatasetResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "datacatalog.GetDatasetResponse";
  }
  protected:
  explicit GetDatasetResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDatasetFieldNumber = 1,
  };
  // .datacatalog.Dataset dataset = 1 [json_name = "dataset"];
  bool has_dataset() const;
  private:
  bool _internal_has_dataset() const;
  public:
  void clear_dataset();
  const ::datacatalog::Dataset& dataset() const;
  PROTOBUF_NODISCARD ::datacatalog::Dataset* release_dataset();
  ::datacatalog::Dataset* mutable_dataset();
  void set_allocated_dataset(::datacatalog::Dataset* dataset);
  private:
  const ::datacatalog::Dataset& _internal_dataset() const;
  ::datacatalog::Dataset* _internal_mutable_dataset();
  public:
  void unsafe_arena_set_allocated_dataset(
      ::datacatalog::Dataset* dataset);
  ::datacatalog::Dataset* unsafe_arena_release_dataset();

  // @@protoc_insertion_point(class_scope:datacatalog.GetDatasetResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::datacatalog::Dataset* dataset_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fdatacatalog_2fdatacatalog_2eproto;
};
// -------------------------------------------------------------------

class GetArtifactRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:datacatalog.GetArtifactRequest) */ {
 public:
  inline GetArtifactRequest() : GetArtifactRequest(nullptr) {}
  ~GetArtifactRequest() override;
  explicit constexpr GetArtifactRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetArtifactRequest(const GetArtifactRequest& from);
  GetArtifactRequest(GetArtifactRequest&& from) noexcept
    : GetArtifactRequest() {
    *this = ::std::move(from);
  }

  inline GetArtifactRequest& operator=(const GetArtifactRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetArtifactRequest& operator=(GetArtifactRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetArtifactRequest& default_instance() {
    return *internal_default_instance();
  }
  enum QueryHandleCase {
    kArtifactId = 2,
    kTagName = 3,
    QUERY_HANDLE_NOT_SET = 0,
  };

  static inline const GetArtifactRequest* internal_default_instance() {
    return reinterpret_cast<const GetArtifactRequest*>(
               &_GetArtifactRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GetArtifactRequest& a, GetArtifactRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetArtifactRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetArtifactRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetArtifactRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetArtifactRequest>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetArtifactRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "datacatalog.GetArtifactRequest";
  }
  protected:
  explicit GetArtifactRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDatasetFieldNumber = 1,
    kArtifactIdFieldNumber = 2,
    kTagNameFieldNumber = 3,
  };
  // .datacatalog.DatasetID dataset = 1 [json_name = "dataset"];
  bool has_dataset() const;
  private:
  bool _internal_has_dataset() const;
  public:
  void clear_dataset();
  const ::datacatalog::DatasetID& dataset() const;
  PROTOBUF_NODISCARD ::datacatalog::DatasetID* release_dataset();
  ::datacatalog::DatasetID* mutable_dataset();
  void set_allocated_dataset(::datacatalog::DatasetID* dataset);
  private:
  const ::datacatalog::DatasetID& _internal_dataset() const;
  ::datacatalog::DatasetID* _internal_mutable_dataset();
  public:
  void unsafe_arena_set_allocated_dataset(
      ::datacatalog::DatasetID* dataset);
  ::datacatalog::DatasetID* unsafe_arena_release_dataset();

  // string artifact_id = 2 [json_name = "artifactId"];
  bool has_artifact_id() const;
  private:
  bool _internal_has_artifact_id() const;
  public:
  void clear_artifact_id();
  const std::string& artifact_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_artifact_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_artifact_id();
  PROTOBUF_NODISCARD std::string* release_artifact_id();
  void set_allocated_artifact_id(std::string* artifact_id);
  private:
  const std::string& _internal_artifact_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_artifact_id(const std::string& value);
  std::string* _internal_mutable_artifact_id();
  public:

  // string tag_name = 3 [json_name = "tagName"];
  bool has_tag_name() const;
  private:
  bool _internal_has_tag_name() const;
  public:
  void clear_tag_name();
  const std::string& tag_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tag_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tag_name();
  PROTOBUF_NODISCARD std::string* release_tag_name();
  void set_allocated_tag_name(std::string* tag_name);
  private:
  const std::string& _internal_tag_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tag_name(const std::string& value);
  std::string* _internal_mutable_tag_name();
  public:

  void clear_query_handle();
  QueryHandleCase query_handle_case() const;
  // @@protoc_insertion_point(class_scope:datacatalog.GetArtifactRequest)
 private:
  class _Internal;
  void set_has_artifact_id();
  void set_has_tag_name();

  inline bool has_query_handle() const;
  inline void clear_has_query_handle();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::datacatalog::DatasetID* dataset_;
  union QueryHandleUnion {
    constexpr QueryHandleUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr artifact_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_name_;
  } query_handle_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_flyteidl_2fdatacatalog_2fdatacatalog_2eproto;
};
// -------------------------------------------------------------------

class GetArtifactResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:datacatalog.GetArtifactResponse) */ {
 public:
  inline GetArtifactResponse() : GetArtifactResponse(nullptr) {}
  ~GetArtifactResponse() override;
  explicit constexpr GetArtifactResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetArtifactResponse(const GetArtifactResponse& from);
  GetArtifactResponse(GetArtifactResponse&& from) noexcept
    : GetArtifactResponse() {
    *this = ::std::move(from);
  }

  inline GetArtifactResponse& operator=(const GetArtifactResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetArtifactResponse& operator=(GetArtifactResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetArtifactResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetArtifactResponse* internal_default_instance() {
    return reinterpret_cast<const GetArtifactResponse*>(
               &_GetArtifactResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GetArtifactResponse& a, GetArtifactResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetArtifactResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetArtifactResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetArtifactResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetArtifactResponse>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetArtifactResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "datacatalog.GetArtifactResponse";
  }
  protected:
  explicit GetArtifactResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArtifactFieldNumber = 1,
  };
  // .datacatalog.Artifact artifact = 1 [json_name = "artifact"];
  bool has_artifact() const;
  private:
  bool _internal_has_artifact() const;
  public:
  void clear_artifact();
  const ::datacatalog::Artifact& artifact() const;
  PROTOBUF_NODISCARD ::datacatalog::Artifact* release_artifact();
  ::datacatalog::Artifact* mutable_artifact();
  void set_allocated_artifact(::datacatalog::Artifact* artifact);
  private:
  const ::datacatalog::Artifact& _internal_artifact() const;
  ::datacatalog::Artifact* _internal_mutable_artifact();
  public:
  void unsafe_arena_set_allocated_artifact(
      ::datacatalog::Artifact* artifact);
  ::datacatalog::Artifact* unsafe_arena_release_artifact();

  // @@protoc_insertion_point(class_scope:datacatalog.GetArtifactResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::datacatalog::Artifact* artifact_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fdatacatalog_2fdatacatalog_2eproto;
};
// -------------------------------------------------------------------

class CreateArtifactRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:datacatalog.CreateArtifactRequest) */ {
 public:
  inline CreateArtifactRequest() : CreateArtifactRequest(nullptr) {}
  ~CreateArtifactRequest() override;
  explicit constexpr CreateArtifactRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateArtifactRequest(const CreateArtifactRequest& from);
  CreateArtifactRequest(CreateArtifactRequest&& from) noexcept
    : CreateArtifactRequest() {
    *this = ::std::move(from);
  }

  inline CreateArtifactRequest& operator=(const CreateArtifactRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateArtifactRequest& operator=(CreateArtifactRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateArtifactRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateArtifactRequest* internal_default_instance() {
    return reinterpret_cast<const CreateArtifactRequest*>(
               &_CreateArtifactRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(CreateArtifactRequest& a, CreateArtifactRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateArtifactRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateArtifactRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateArtifactRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateArtifactRequest>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateArtifactRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "datacatalog.CreateArtifactRequest";
  }
  protected:
  explicit CreateArtifactRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArtifactFieldNumber = 1,
  };
  // .datacatalog.Artifact artifact = 1 [json_name = "artifact"];
  bool has_artifact() const;
  private:
  bool _internal_has_artifact() const;
  public:
  void clear_artifact();
  const ::datacatalog::Artifact& artifact() const;
  PROTOBUF_NODISCARD ::datacatalog::Artifact* release_artifact();
  ::datacatalog::Artifact* mutable_artifact();
  void set_allocated_artifact(::datacatalog::Artifact* artifact);
  private:
  const ::datacatalog::Artifact& _internal_artifact() const;
  ::datacatalog::Artifact* _internal_mutable_artifact();
  public:
  void unsafe_arena_set_allocated_artifact(
      ::datacatalog::Artifact* artifact);
  ::datacatalog::Artifact* unsafe_arena_release_artifact();

  // @@protoc_insertion_point(class_scope:datacatalog.CreateArtifactRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::datacatalog::Artifact* artifact_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fdatacatalog_2fdatacatalog_2eproto;
};
// -------------------------------------------------------------------

class CreateArtifactResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:datacatalog.CreateArtifactResponse) */ {
 public:
  inline CreateArtifactResponse() : CreateArtifactResponse(nullptr) {}
  explicit constexpr CreateArtifactResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateArtifactResponse(const CreateArtifactResponse& from);
  CreateArtifactResponse(CreateArtifactResponse&& from) noexcept
    : CreateArtifactResponse() {
    *this = ::std::move(from);
  }

  inline CreateArtifactResponse& operator=(const CreateArtifactResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateArtifactResponse& operator=(CreateArtifactResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateArtifactResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateArtifactResponse* internal_default_instance() {
    return reinterpret_cast<const CreateArtifactResponse*>(
               &_CreateArtifactResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CreateArtifactResponse& a, CreateArtifactResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateArtifactResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateArtifactResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateArtifactResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateArtifactResponse>(arena);
  }

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "datacatalog.CreateArtifactResponse";
  }
  protected:
  explicit CreateArtifactResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:datacatalog.CreateArtifactResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fdatacatalog_2fdatacatalog_2eproto;
};
// -------------------------------------------------------------------

class AddTagRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:datacatalog.AddTagRequest) */ {
 public:
  inline AddTagRequest() : AddTagRequest(nullptr) {}
  ~AddTagRequest() override;
  explicit constexpr AddTagRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddTagRequest(const AddTagRequest& from);
  AddTagRequest(AddTagRequest&& from) noexcept
    : AddTagRequest() {
    *this = ::std::move(from);
  }

  inline AddTagRequest& operator=(const AddTagRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddTagRequest& operator=(AddTagRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddTagRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddTagRequest* internal_default_instance() {
    return reinterpret_cast<const AddTagRequest*>(
               &_AddTagRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(AddTagRequest& a, AddTagRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AddTagRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddTagRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddTagRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddTagRequest>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddTagRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "datacatalog.AddTagRequest";
  }
  protected:
  explicit AddTagRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagFieldNumber = 1,
  };
  // .datacatalog.Tag tag = 1 [json_name = "tag"];
  bool has_tag() const;
  private:
  bool _internal_has_tag() const;
  public:
  void clear_tag();
  const ::datacatalog::Tag& tag() const;
  PROTOBUF_NODISCARD ::datacatalog::Tag* release_tag();
  ::datacatalog::Tag* mutable_tag();
  void set_allocated_tag(::datacatalog::Tag* tag);
  private:
  const ::datacatalog::Tag& _internal_tag() const;
  ::datacatalog::Tag* _internal_mutable_tag();
  public:
  void unsafe_arena_set_allocated_tag(
      ::datacatalog::Tag* tag);
  ::datacatalog::Tag* unsafe_arena_release_tag();

  // @@protoc_insertion_point(class_scope:datacatalog.AddTagRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::datacatalog::Tag* tag_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fdatacatalog_2fdatacatalog_2eproto;
};
// -------------------------------------------------------------------

class AddTagResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:datacatalog.AddTagResponse) */ {
 public:
  inline AddTagResponse() : AddTagResponse(nullptr) {}
  explicit constexpr AddTagResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddTagResponse(const AddTagResponse& from);
  AddTagResponse(AddTagResponse&& from) noexcept
    : AddTagResponse() {
    *this = ::std::move(from);
  }

  inline AddTagResponse& operator=(const AddTagResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddTagResponse& operator=(AddTagResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddTagResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddTagResponse* internal_default_instance() {
    return reinterpret_cast<const AddTagResponse*>(
               &_AddTagResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(AddTagResponse& a, AddTagResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AddTagResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddTagResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddTagResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddTagResponse>(arena);
  }

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "datacatalog.AddTagResponse";
  }
  protected:
  explicit AddTagResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:datacatalog.AddTagResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fdatacatalog_2fdatacatalog_2eproto;
};
// -------------------------------------------------------------------

class ListArtifactsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:datacatalog.ListArtifactsRequest) */ {
 public:
  inline ListArtifactsRequest() : ListArtifactsRequest(nullptr) {}
  ~ListArtifactsRequest() override;
  explicit constexpr ListArtifactsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListArtifactsRequest(const ListArtifactsRequest& from);
  ListArtifactsRequest(ListArtifactsRequest&& from) noexcept
    : ListArtifactsRequest() {
    *this = ::std::move(from);
  }

  inline ListArtifactsRequest& operator=(const ListArtifactsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListArtifactsRequest& operator=(ListArtifactsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListArtifactsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListArtifactsRequest* internal_default_instance() {
    return reinterpret_cast<const ListArtifactsRequest*>(
               &_ListArtifactsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ListArtifactsRequest& a, ListArtifactsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListArtifactsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListArtifactsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListArtifactsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListArtifactsRequest>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListArtifactsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "datacatalog.ListArtifactsRequest";
  }
  protected:
  explicit ListArtifactsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDatasetFieldNumber = 1,
    kFilterFieldNumber = 2,
    kPaginationFieldNumber = 3,
  };
  // .datacatalog.DatasetID dataset = 1 [json_name = "dataset"];
  bool has_dataset() const;
  private:
  bool _internal_has_dataset() const;
  public:
  void clear_dataset();
  const ::datacatalog::DatasetID& dataset() const;
  PROTOBUF_NODISCARD ::datacatalog::DatasetID* release_dataset();
  ::datacatalog::DatasetID* mutable_dataset();
  void set_allocated_dataset(::datacatalog::DatasetID* dataset);
  private:
  const ::datacatalog::DatasetID& _internal_dataset() const;
  ::datacatalog::DatasetID* _internal_mutable_dataset();
  public:
  void unsafe_arena_set_allocated_dataset(
      ::datacatalog::DatasetID* dataset);
  ::datacatalog::DatasetID* unsafe_arena_release_dataset();

  // .datacatalog.FilterExpression filter = 2 [json_name = "filter"];
  bool has_filter() const;
  private:
  bool _internal_has_filter() const;
  public:
  void clear_filter();
  const ::datacatalog::FilterExpression& filter() const;
  PROTOBUF_NODISCARD ::datacatalog::FilterExpression* release_filter();
  ::datacatalog::FilterExpression* mutable_filter();
  void set_allocated_filter(::datacatalog::FilterExpression* filter);
  private:
  const ::datacatalog::FilterExpression& _internal_filter() const;
  ::datacatalog::FilterExpression* _internal_mutable_filter();
  public:
  void unsafe_arena_set_allocated_filter(
      ::datacatalog::FilterExpression* filter);
  ::datacatalog::FilterExpression* unsafe_arena_release_filter();

  // .datacatalog.PaginationOptions pagination = 3 [json_name = "pagination"];
  bool has_pagination() const;
  private:
  bool _internal_has_pagination() const;
  public:
  void clear_pagination();
  const ::datacatalog::PaginationOptions& pagination() const;
  PROTOBUF_NODISCARD ::datacatalog::PaginationOptions* release_pagination();
  ::datacatalog::PaginationOptions* mutable_pagination();
  void set_allocated_pagination(::datacatalog::PaginationOptions* pagination);
  private:
  const ::datacatalog::PaginationOptions& _internal_pagination() const;
  ::datacatalog::PaginationOptions* _internal_mutable_pagination();
  public:
  void unsafe_arena_set_allocated_pagination(
      ::datacatalog::PaginationOptions* pagination);
  ::datacatalog::PaginationOptions* unsafe_arena_release_pagination();

  // @@protoc_insertion_point(class_scope:datacatalog.ListArtifactsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::datacatalog::DatasetID* dataset_;
  ::datacatalog::FilterExpression* filter_;
  ::datacatalog::PaginationOptions* pagination_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fdatacatalog_2fdatacatalog_2eproto;
};
// -------------------------------------------------------------------

class ListArtifactsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:datacatalog.ListArtifactsResponse) */ {
 public:
  inline ListArtifactsResponse() : ListArtifactsResponse(nullptr) {}
  ~ListArtifactsResponse() override;
  explicit constexpr ListArtifactsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListArtifactsResponse(const ListArtifactsResponse& from);
  ListArtifactsResponse(ListArtifactsResponse&& from) noexcept
    : ListArtifactsResponse() {
    *this = ::std::move(from);
  }

  inline ListArtifactsResponse& operator=(const ListArtifactsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListArtifactsResponse& operator=(ListArtifactsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListArtifactsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListArtifactsResponse* internal_default_instance() {
    return reinterpret_cast<const ListArtifactsResponse*>(
               &_ListArtifactsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ListArtifactsResponse& a, ListArtifactsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListArtifactsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListArtifactsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListArtifactsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListArtifactsResponse>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListArtifactsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "datacatalog.ListArtifactsResponse";
  }
  protected:
  explicit ListArtifactsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArtifactsFieldNumber = 1,
    kNextTokenFieldNumber = 2,
  };
  // repeated .datacatalog.Artifact artifacts = 1 [json_name = "artifacts"];
  int artifacts_size() const;
  private:
  int _internal_artifacts_size() const;
  public:
  void clear_artifacts();
  ::datacatalog::Artifact* mutable_artifacts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::datacatalog::Artifact >*
      mutable_artifacts();
  private:
  const ::datacatalog::Artifact& _internal_artifacts(int index) const;
  ::datacatalog::Artifact* _internal_add_artifacts();
  public:
  const ::datacatalog::Artifact& artifacts(int index) const;
  ::datacatalog::Artifact* add_artifacts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::datacatalog::Artifact >&
      artifacts() const;

  // string next_token = 2 [json_name = "nextToken"];
  void clear_next_token();
  const std::string& next_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_next_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_next_token();
  PROTOBUF_NODISCARD std::string* release_next_token();
  void set_allocated_next_token(std::string* next_token);
  private:
  const std::string& _internal_next_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_token(const std::string& value);
  std::string* _internal_mutable_next_token();
  public:

  // @@protoc_insertion_point(class_scope:datacatalog.ListArtifactsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::datacatalog::Artifact > artifacts_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_token_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fdatacatalog_2fdatacatalog_2eproto;
};
// -------------------------------------------------------------------

class ListDatasetsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:datacatalog.ListDatasetsRequest) */ {
 public:
  inline ListDatasetsRequest() : ListDatasetsRequest(nullptr) {}
  ~ListDatasetsRequest() override;
  explicit constexpr ListDatasetsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListDatasetsRequest(const ListDatasetsRequest& from);
  ListDatasetsRequest(ListDatasetsRequest&& from) noexcept
    : ListDatasetsRequest() {
    *this = ::std::move(from);
  }

  inline ListDatasetsRequest& operator=(const ListDatasetsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListDatasetsRequest& operator=(ListDatasetsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListDatasetsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListDatasetsRequest* internal_default_instance() {
    return reinterpret_cast<const ListDatasetsRequest*>(
               &_ListDatasetsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ListDatasetsRequest& a, ListDatasetsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListDatasetsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListDatasetsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListDatasetsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListDatasetsRequest>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListDatasetsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "datacatalog.ListDatasetsRequest";
  }
  protected:
  explicit ListDatasetsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilterFieldNumber = 1,
    kPaginationFieldNumber = 2,
  };
  // .datacatalog.FilterExpression filter = 1 [json_name = "filter"];
  bool has_filter() const;
  private:
  bool _internal_has_filter() const;
  public:
  void clear_filter();
  const ::datacatalog::FilterExpression& filter() const;
  PROTOBUF_NODISCARD ::datacatalog::FilterExpression* release_filter();
  ::datacatalog::FilterExpression* mutable_filter();
  void set_allocated_filter(::datacatalog::FilterExpression* filter);
  private:
  const ::datacatalog::FilterExpression& _internal_filter() const;
  ::datacatalog::FilterExpression* _internal_mutable_filter();
  public:
  void unsafe_arena_set_allocated_filter(
      ::datacatalog::FilterExpression* filter);
  ::datacatalog::FilterExpression* unsafe_arena_release_filter();

  // .datacatalog.PaginationOptions pagination = 2 [json_name = "pagination"];
  bool has_pagination() const;
  private:
  bool _internal_has_pagination() const;
  public:
  void clear_pagination();
  const ::datacatalog::PaginationOptions& pagination() const;
  PROTOBUF_NODISCARD ::datacatalog::PaginationOptions* release_pagination();
  ::datacatalog::PaginationOptions* mutable_pagination();
  void set_allocated_pagination(::datacatalog::PaginationOptions* pagination);
  private:
  const ::datacatalog::PaginationOptions& _internal_pagination() const;
  ::datacatalog::PaginationOptions* _internal_mutable_pagination();
  public:
  void unsafe_arena_set_allocated_pagination(
      ::datacatalog::PaginationOptions* pagination);
  ::datacatalog::PaginationOptions* unsafe_arena_release_pagination();

  // @@protoc_insertion_point(class_scope:datacatalog.ListDatasetsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::datacatalog::FilterExpression* filter_;
  ::datacatalog::PaginationOptions* pagination_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fdatacatalog_2fdatacatalog_2eproto;
};
// -------------------------------------------------------------------

class ListDatasetsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:datacatalog.ListDatasetsResponse) */ {
 public:
  inline ListDatasetsResponse() : ListDatasetsResponse(nullptr) {}
  ~ListDatasetsResponse() override;
  explicit constexpr ListDatasetsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListDatasetsResponse(const ListDatasetsResponse& from);
  ListDatasetsResponse(ListDatasetsResponse&& from) noexcept
    : ListDatasetsResponse() {
    *this = ::std::move(from);
  }

  inline ListDatasetsResponse& operator=(const ListDatasetsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListDatasetsResponse& operator=(ListDatasetsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListDatasetsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListDatasetsResponse* internal_default_instance() {
    return reinterpret_cast<const ListDatasetsResponse*>(
               &_ListDatasetsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ListDatasetsResponse& a, ListDatasetsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListDatasetsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListDatasetsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListDatasetsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListDatasetsResponse>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListDatasetsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "datacatalog.ListDatasetsResponse";
  }
  protected:
  explicit ListDatasetsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDatasetsFieldNumber = 1,
    kNextTokenFieldNumber = 2,
  };
  // repeated .datacatalog.Dataset datasets = 1 [json_name = "datasets"];
  int datasets_size() const;
  private:
  int _internal_datasets_size() const;
  public:
  void clear_datasets();
  ::datacatalog::Dataset* mutable_datasets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::datacatalog::Dataset >*
      mutable_datasets();
  private:
  const ::datacatalog::Dataset& _internal_datasets(int index) const;
  ::datacatalog::Dataset* _internal_add_datasets();
  public:
  const ::datacatalog::Dataset& datasets(int index) const;
  ::datacatalog::Dataset* add_datasets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::datacatalog::Dataset >&
      datasets() const;

  // string next_token = 2 [json_name = "nextToken"];
  void clear_next_token();
  const std::string& next_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_next_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_next_token();
  PROTOBUF_NODISCARD std::string* release_next_token();
  void set_allocated_next_token(std::string* next_token);
  private:
  const std::string& _internal_next_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_token(const std::string& value);
  std::string* _internal_mutable_next_token();
  public:

  // @@protoc_insertion_point(class_scope:datacatalog.ListDatasetsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::datacatalog::Dataset > datasets_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_token_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fdatacatalog_2fdatacatalog_2eproto;
};
// -------------------------------------------------------------------

class ReservationID final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:datacatalog.ReservationID) */ {
 public:
  inline ReservationID() : ReservationID(nullptr) {}
  ~ReservationID() override;
  explicit constexpr ReservationID(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReservationID(const ReservationID& from);
  ReservationID(ReservationID&& from) noexcept
    : ReservationID() {
    *this = ::std::move(from);
  }

  inline ReservationID& operator=(const ReservationID& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReservationID& operator=(ReservationID&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReservationID& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReservationID* internal_default_instance() {
    return reinterpret_cast<const ReservationID*>(
               &_ReservationID_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ReservationID& a, ReservationID& b) {
    a.Swap(&b);
  }
  inline void Swap(ReservationID* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReservationID* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReservationID* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReservationID>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReservationID* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "datacatalog.ReservationID";
  }
  protected:
  explicit ReservationID(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagNameFieldNumber = 2,
    kDatasetIdFieldNumber = 1,
  };
  // string tag_name = 2 [json_name = "tagName"];
  void clear_tag_name();
  const std::string& tag_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tag_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tag_name();
  PROTOBUF_NODISCARD std::string* release_tag_name();
  void set_allocated_tag_name(std::string* tag_name);
  private:
  const std::string& _internal_tag_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tag_name(const std::string& value);
  std::string* _internal_mutable_tag_name();
  public:

  // .datacatalog.DatasetID dataset_id = 1 [json_name = "datasetId"];
  bool has_dataset_id() const;
  private:
  bool _internal_has_dataset_id() const;
  public:
  void clear_dataset_id();
  const ::datacatalog::DatasetID& dataset_id() const;
  PROTOBUF_NODISCARD ::datacatalog::DatasetID* release_dataset_id();
  ::datacatalog::DatasetID* mutable_dataset_id();
  void set_allocated_dataset_id(::datacatalog::DatasetID* dataset_id);
  private:
  const ::datacatalog::DatasetID& _internal_dataset_id() const;
  ::datacatalog::DatasetID* _internal_mutable_dataset_id();
  public:
  void unsafe_arena_set_allocated_dataset_id(
      ::datacatalog::DatasetID* dataset_id);
  ::datacatalog::DatasetID* unsafe_arena_release_dataset_id();

  // @@protoc_insertion_point(class_scope:datacatalog.ReservationID)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_name_;
  ::datacatalog::DatasetID* dataset_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fdatacatalog_2fdatacatalog_2eproto;
};
// -------------------------------------------------------------------

class GetOrExtendReservationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:datacatalog.GetOrExtendReservationRequest) */ {
 public:
  inline GetOrExtendReservationRequest() : GetOrExtendReservationRequest(nullptr) {}
  ~GetOrExtendReservationRequest() override;
  explicit constexpr GetOrExtendReservationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetOrExtendReservationRequest(const GetOrExtendReservationRequest& from);
  GetOrExtendReservationRequest(GetOrExtendReservationRequest&& from) noexcept
    : GetOrExtendReservationRequest() {
    *this = ::std::move(from);
  }

  inline GetOrExtendReservationRequest& operator=(const GetOrExtendReservationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetOrExtendReservationRequest& operator=(GetOrExtendReservationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetOrExtendReservationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetOrExtendReservationRequest* internal_default_instance() {
    return reinterpret_cast<const GetOrExtendReservationRequest*>(
               &_GetOrExtendReservationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(GetOrExtendReservationRequest& a, GetOrExtendReservationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetOrExtendReservationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetOrExtendReservationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetOrExtendReservationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetOrExtendReservationRequest>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetOrExtendReservationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "datacatalog.GetOrExtendReservationRequest";
  }
  protected:
  explicit GetOrExtendReservationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerIdFieldNumber = 2,
    kReservationIdFieldNumber = 1,
    kHeartbeatIntervalFieldNumber = 3,
  };
  // string owner_id = 2 [json_name = "ownerId"];
  void clear_owner_id();
  const std::string& owner_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_id();
  PROTOBUF_NODISCARD std::string* release_owner_id();
  void set_allocated_owner_id(std::string* owner_id);
  private:
  const std::string& _internal_owner_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_id(const std::string& value);
  std::string* _internal_mutable_owner_id();
  public:

  // .datacatalog.ReservationID reservation_id = 1 [json_name = "reservationId"];
  bool has_reservation_id() const;
  private:
  bool _internal_has_reservation_id() const;
  public:
  void clear_reservation_id();
  const ::datacatalog::ReservationID& reservation_id() const;
  PROTOBUF_NODISCARD ::datacatalog::ReservationID* release_reservation_id();
  ::datacatalog::ReservationID* mutable_reservation_id();
  void set_allocated_reservation_id(::datacatalog::ReservationID* reservation_id);
  private:
  const ::datacatalog::ReservationID& _internal_reservation_id() const;
  ::datacatalog::ReservationID* _internal_mutable_reservation_id();
  public:
  void unsafe_arena_set_allocated_reservation_id(
      ::datacatalog::ReservationID* reservation_id);
  ::datacatalog::ReservationID* unsafe_arena_release_reservation_id();

  // .google.protobuf.Duration heartbeat_interval = 3 [json_name = "heartbeatInterval"];
  bool has_heartbeat_interval() const;
  private:
  bool _internal_has_heartbeat_interval() const;
  public:
  void clear_heartbeat_interval();
  const ::PROTOBUF_NAMESPACE_ID::Duration& heartbeat_interval() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_heartbeat_interval();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_heartbeat_interval();
  void set_allocated_heartbeat_interval(::PROTOBUF_NAMESPACE_ID::Duration* heartbeat_interval);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_heartbeat_interval() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_heartbeat_interval();
  public:
  void unsafe_arena_set_allocated_heartbeat_interval(
      ::PROTOBUF_NAMESPACE_ID::Duration* heartbeat_interval);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_heartbeat_interval();

  // @@protoc_insertion_point(class_scope:datacatalog.GetOrExtendReservationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_id_;
  ::datacatalog::ReservationID* reservation_id_;
  ::PROTOBUF_NAMESPACE_ID::Duration* heartbeat_interval_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fdatacatalog_2fdatacatalog_2eproto;
};
// -------------------------------------------------------------------

class Reservation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:datacatalog.Reservation) */ {
 public:
  inline Reservation() : Reservation(nullptr) {}
  ~Reservation() override;
  explicit constexpr Reservation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Reservation(const Reservation& from);
  Reservation(Reservation&& from) noexcept
    : Reservation() {
    *this = ::std::move(from);
  }

  inline Reservation& operator=(const Reservation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Reservation& operator=(Reservation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Reservation& default_instance() {
    return *internal_default_instance();
  }
  static inline const Reservation* internal_default_instance() {
    return reinterpret_cast<const Reservation*>(
               &_Reservation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(Reservation& a, Reservation& b) {
    a.Swap(&b);
  }
  inline void Swap(Reservation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Reservation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Reservation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Reservation>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Reservation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "datacatalog.Reservation";
  }
  protected:
  explicit Reservation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerIdFieldNumber = 2,
    kReservationIdFieldNumber = 1,
    kHeartbeatIntervalFieldNumber = 3,
    kExpiresAtFieldNumber = 4,
    kMetadataFieldNumber = 6,
  };
  // string owner_id = 2 [json_name = "ownerId"];
  void clear_owner_id();
  const std::string& owner_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_id();
  PROTOBUF_NODISCARD std::string* release_owner_id();
  void set_allocated_owner_id(std::string* owner_id);
  private:
  const std::string& _internal_owner_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_id(const std::string& value);
  std::string* _internal_mutable_owner_id();
  public:

  // .datacatalog.ReservationID reservation_id = 1 [json_name = "reservationId"];
  bool has_reservation_id() const;
  private:
  bool _internal_has_reservation_id() const;
  public:
  void clear_reservation_id();
  const ::datacatalog::ReservationID& reservation_id() const;
  PROTOBUF_NODISCARD ::datacatalog::ReservationID* release_reservation_id();
  ::datacatalog::ReservationID* mutable_reservation_id();
  void set_allocated_reservation_id(::datacatalog::ReservationID* reservation_id);
  private:
  const ::datacatalog::ReservationID& _internal_reservation_id() const;
  ::datacatalog::ReservationID* _internal_mutable_reservation_id();
  public:
  void unsafe_arena_set_allocated_reservation_id(
      ::datacatalog::ReservationID* reservation_id);
  ::datacatalog::ReservationID* unsafe_arena_release_reservation_id();

  // .google.protobuf.Duration heartbeat_interval = 3 [json_name = "heartbeatInterval"];
  bool has_heartbeat_interval() const;
  private:
  bool _internal_has_heartbeat_interval() const;
  public:
  void clear_heartbeat_interval();
  const ::PROTOBUF_NAMESPACE_ID::Duration& heartbeat_interval() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_heartbeat_interval();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_heartbeat_interval();
  void set_allocated_heartbeat_interval(::PROTOBUF_NAMESPACE_ID::Duration* heartbeat_interval);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_heartbeat_interval() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_heartbeat_interval();
  public:
  void unsafe_arena_set_allocated_heartbeat_interval(
      ::PROTOBUF_NAMESPACE_ID::Duration* heartbeat_interval);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_heartbeat_interval();

  // .google.protobuf.Timestamp expires_at = 4 [json_name = "expiresAt"];
  bool has_expires_at() const;
  private:
  bool _internal_has_expires_at() const;
  public:
  void clear_expires_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& expires_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_expires_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_expires_at();
  void set_allocated_expires_at(::PROTOBUF_NAMESPACE_ID::Timestamp* expires_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_expires_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_expires_at();
  public:
  void unsafe_arena_set_allocated_expires_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* expires_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_expires_at();

  // .datacatalog.Metadata metadata = 6 [json_name = "metadata"];
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::datacatalog::Metadata& metadata() const;
  PROTOBUF_NODISCARD ::datacatalog::Metadata* release_metadata();
  ::datacatalog::Metadata* mutable_metadata();
  void set_allocated_metadata(::datacatalog::Metadata* metadata);
  private:
  const ::datacatalog::Metadata& _internal_metadata() const;
  ::datacatalog::Metadata* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::datacatalog::Metadata* metadata);
  ::datacatalog::Metadata* unsafe_arena_release_metadata();

  // @@protoc_insertion_point(class_scope:datacatalog.Reservation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_id_;
  ::datacatalog::ReservationID* reservation_id_;
  ::PROTOBUF_NAMESPACE_ID::Duration* heartbeat_interval_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* expires_at_;
  ::datacatalog::Metadata* metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fdatacatalog_2fdatacatalog_2eproto;
};
// -------------------------------------------------------------------

class GetOrExtendReservationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:datacatalog.GetOrExtendReservationResponse) */ {
 public:
  inline GetOrExtendReservationResponse() : GetOrExtendReservationResponse(nullptr) {}
  ~GetOrExtendReservationResponse() override;
  explicit constexpr GetOrExtendReservationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetOrExtendReservationResponse(const GetOrExtendReservationResponse& from);
  GetOrExtendReservationResponse(GetOrExtendReservationResponse&& from) noexcept
    : GetOrExtendReservationResponse() {
    *this = ::std::move(from);
  }

  inline GetOrExtendReservationResponse& operator=(const GetOrExtendReservationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetOrExtendReservationResponse& operator=(GetOrExtendReservationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetOrExtendReservationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetOrExtendReservationResponse* internal_default_instance() {
    return reinterpret_cast<const GetOrExtendReservationResponse*>(
               &_GetOrExtendReservationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(GetOrExtendReservationResponse& a, GetOrExtendReservationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetOrExtendReservationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetOrExtendReservationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetOrExtendReservationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetOrExtendReservationResponse>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetOrExtendReservationResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "datacatalog.GetOrExtendReservationResponse";
  }
  protected:
  explicit GetOrExtendReservationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReservationFieldNumber = 1,
  };
  // .datacatalog.Reservation reservation = 1 [json_name = "reservation"];
  bool has_reservation() const;
  private:
  bool _internal_has_reservation() const;
  public:
  void clear_reservation();
  const ::datacatalog::Reservation& reservation() const;
  PROTOBUF_NODISCARD ::datacatalog::Reservation* release_reservation();
  ::datacatalog::Reservation* mutable_reservation();
  void set_allocated_reservation(::datacatalog::Reservation* reservation);
  private:
  const ::datacatalog::Reservation& _internal_reservation() const;
  ::datacatalog::Reservation* _internal_mutable_reservation();
  public:
  void unsafe_arena_set_allocated_reservation(
      ::datacatalog::Reservation* reservation);
  ::datacatalog::Reservation* unsafe_arena_release_reservation();

  // @@protoc_insertion_point(class_scope:datacatalog.GetOrExtendReservationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::datacatalog::Reservation* reservation_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fdatacatalog_2fdatacatalog_2eproto;
};
// -------------------------------------------------------------------

class ReleaseReservationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:datacatalog.ReleaseReservationRequest) */ {
 public:
  inline ReleaseReservationRequest() : ReleaseReservationRequest(nullptr) {}
  ~ReleaseReservationRequest() override;
  explicit constexpr ReleaseReservationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReleaseReservationRequest(const ReleaseReservationRequest& from);
  ReleaseReservationRequest(ReleaseReservationRequest&& from) noexcept
    : ReleaseReservationRequest() {
    *this = ::std::move(from);
  }

  inline ReleaseReservationRequest& operator=(const ReleaseReservationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReleaseReservationRequest& operator=(ReleaseReservationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReleaseReservationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReleaseReservationRequest* internal_default_instance() {
    return reinterpret_cast<const ReleaseReservationRequest*>(
               &_ReleaseReservationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ReleaseReservationRequest& a, ReleaseReservationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ReleaseReservationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReleaseReservationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReleaseReservationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReleaseReservationRequest>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReleaseReservationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "datacatalog.ReleaseReservationRequest";
  }
  protected:
  explicit ReleaseReservationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerIdFieldNumber = 2,
    kReservationIdFieldNumber = 1,
  };
  // string owner_id = 2 [json_name = "ownerId"];
  void clear_owner_id();
  const std::string& owner_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_id();
  PROTOBUF_NODISCARD std::string* release_owner_id();
  void set_allocated_owner_id(std::string* owner_id);
  private:
  const std::string& _internal_owner_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_id(const std::string& value);
  std::string* _internal_mutable_owner_id();
  public:

  // .datacatalog.ReservationID reservation_id = 1 [json_name = "reservationId"];
  bool has_reservation_id() const;
  private:
  bool _internal_has_reservation_id() const;
  public:
  void clear_reservation_id();
  const ::datacatalog::ReservationID& reservation_id() const;
  PROTOBUF_NODISCARD ::datacatalog::ReservationID* release_reservation_id();
  ::datacatalog::ReservationID* mutable_reservation_id();
  void set_allocated_reservation_id(::datacatalog::ReservationID* reservation_id);
  private:
  const ::datacatalog::ReservationID& _internal_reservation_id() const;
  ::datacatalog::ReservationID* _internal_mutable_reservation_id();
  public:
  void unsafe_arena_set_allocated_reservation_id(
      ::datacatalog::ReservationID* reservation_id);
  ::datacatalog::ReservationID* unsafe_arena_release_reservation_id();

  // @@protoc_insertion_point(class_scope:datacatalog.ReleaseReservationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_id_;
  ::datacatalog::ReservationID* reservation_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fdatacatalog_2fdatacatalog_2eproto;
};
// -------------------------------------------------------------------

class ReleaseReservationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:datacatalog.ReleaseReservationResponse) */ {
 public:
  inline ReleaseReservationResponse() : ReleaseReservationResponse(nullptr) {}
  explicit constexpr ReleaseReservationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReleaseReservationResponse(const ReleaseReservationResponse& from);
  ReleaseReservationResponse(ReleaseReservationResponse&& from) noexcept
    : ReleaseReservationResponse() {
    *this = ::std::move(from);
  }

  inline ReleaseReservationResponse& operator=(const ReleaseReservationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReleaseReservationResponse& operator=(ReleaseReservationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReleaseReservationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReleaseReservationResponse* internal_default_instance() {
    return reinterpret_cast<const ReleaseReservationResponse*>(
               &_ReleaseReservationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ReleaseReservationResponse& a, ReleaseReservationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ReleaseReservationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReleaseReservationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReleaseReservationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReleaseReservationResponse>(arena);
  }

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "datacatalog.ReleaseReservationResponse";
  }
  protected:
  explicit ReleaseReservationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:datacatalog.ReleaseReservationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fdatacatalog_2fdatacatalog_2eproto;
};
// -------------------------------------------------------------------

class Dataset final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:datacatalog.Dataset) */ {
 public:
  inline Dataset() : Dataset(nullptr) {}
  ~Dataset() override;
  explicit constexpr Dataset(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Dataset(const Dataset& from);
  Dataset(Dataset&& from) noexcept
    : Dataset() {
    *this = ::std::move(from);
  }

  inline Dataset& operator=(const Dataset& from) {
    CopyFrom(from);
    return *this;
  }
  inline Dataset& operator=(Dataset&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Dataset& default_instance() {
    return *internal_default_instance();
  }
  static inline const Dataset* internal_default_instance() {
    return reinterpret_cast<const Dataset*>(
               &_Dataset_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(Dataset& a, Dataset& b) {
    a.Swap(&b);
  }
  inline void Swap(Dataset* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Dataset* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Dataset* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Dataset>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Dataset* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "datacatalog.Dataset";
  }
  protected:
  explicit Dataset(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartitionKeysFieldNumber = 3,
    kIdFieldNumber = 1,
    kMetadataFieldNumber = 2,
  };
  // repeated string partitionKeys = 3 [json_name = "partitionKeys"];
  int partitionkeys_size() const;
  private:
  int _internal_partitionkeys_size() const;
  public:
  void clear_partitionkeys();
  const std::string& partitionkeys(int index) const;
  std::string* mutable_partitionkeys(int index);
  void set_partitionkeys(int index, const std::string& value);
  void set_partitionkeys(int index, std::string&& value);
  void set_partitionkeys(int index, const char* value);
  void set_partitionkeys(int index, const char* value, size_t size);
  std::string* add_partitionkeys();
  void add_partitionkeys(const std::string& value);
  void add_partitionkeys(std::string&& value);
  void add_partitionkeys(const char* value);
  void add_partitionkeys(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& partitionkeys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_partitionkeys();
  private:
  const std::string& _internal_partitionkeys(int index) const;
  std::string* _internal_add_partitionkeys();
  public:

  // .datacatalog.DatasetID id = 1 [json_name = "id"];
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::datacatalog::DatasetID& id() const;
  PROTOBUF_NODISCARD ::datacatalog::DatasetID* release_id();
  ::datacatalog::DatasetID* mutable_id();
  void set_allocated_id(::datacatalog::DatasetID* id);
  private:
  const ::datacatalog::DatasetID& _internal_id() const;
  ::datacatalog::DatasetID* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::datacatalog::DatasetID* id);
  ::datacatalog::DatasetID* unsafe_arena_release_id();

  // .datacatalog.Metadata metadata = 2 [json_name = "metadata"];
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::datacatalog::Metadata& metadata() const;
  PROTOBUF_NODISCARD ::datacatalog::Metadata* release_metadata();
  ::datacatalog::Metadata* mutable_metadata();
  void set_allocated_metadata(::datacatalog::Metadata* metadata);
  private:
  const ::datacatalog::Metadata& _internal_metadata() const;
  ::datacatalog::Metadata* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::datacatalog::Metadata* metadata);
  ::datacatalog::Metadata* unsafe_arena_release_metadata();

  // @@protoc_insertion_point(class_scope:datacatalog.Dataset)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> partitionkeys_;
  ::datacatalog::DatasetID* id_;
  ::datacatalog::Metadata* metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fdatacatalog_2fdatacatalog_2eproto;
};
// -------------------------------------------------------------------

class Partition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:datacatalog.Partition) */ {
 public:
  inline Partition() : Partition(nullptr) {}
  ~Partition() override;
  explicit constexpr Partition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Partition(const Partition& from);
  Partition(Partition&& from) noexcept
    : Partition() {
    *this = ::std::move(from);
  }

  inline Partition& operator=(const Partition& from) {
    CopyFrom(from);
    return *this;
  }
  inline Partition& operator=(Partition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Partition& default_instance() {
    return *internal_default_instance();
  }
  static inline const Partition* internal_default_instance() {
    return reinterpret_cast<const Partition*>(
               &_Partition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(Partition& a, Partition& b) {
    a.Swap(&b);
  }
  inline void Swap(Partition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Partition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Partition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Partition>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Partition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "datacatalog.Partition";
  }
  protected:
  explicit Partition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string key = 1 [json_name = "key"];
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // string value = 2 [json_name = "value"];
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:datacatalog.Partition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fdatacatalog_2fdatacatalog_2eproto;
};
// -------------------------------------------------------------------

class DatasetID final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:datacatalog.DatasetID) */ {
 public:
  inline DatasetID() : DatasetID(nullptr) {}
  ~DatasetID() override;
  explicit constexpr DatasetID(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DatasetID(const DatasetID& from);
  DatasetID(DatasetID&& from) noexcept
    : DatasetID() {
    *this = ::std::move(from);
  }

  inline DatasetID& operator=(const DatasetID& from) {
    CopyFrom(from);
    return *this;
  }
  inline DatasetID& operator=(DatasetID&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DatasetID& default_instance() {
    return *internal_default_instance();
  }
  static inline const DatasetID* internal_default_instance() {
    return reinterpret_cast<const DatasetID*>(
               &_DatasetID_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(DatasetID& a, DatasetID& b) {
    a.Swap(&b);
  }
  inline void Swap(DatasetID* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DatasetID* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DatasetID* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DatasetID>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DatasetID* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "datacatalog.DatasetID";
  }
  protected:
  explicit DatasetID(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProjectFieldNumber = 1,
    kNameFieldNumber = 2,
    kDomainFieldNumber = 3,
    kVersionFieldNumber = 4,
    kUUIDFieldNumber = 5,
  };
  // string project = 1 [json_name = "project"];
  void clear_project();
  const std::string& project() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_project(ArgT0&& arg0, ArgT... args);
  std::string* mutable_project();
  PROTOBUF_NODISCARD std::string* release_project();
  void set_allocated_project(std::string* project);
  private:
  const std::string& _internal_project() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_project(const std::string& value);
  std::string* _internal_mutable_project();
  public:

  // string name = 2 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string domain = 3 [json_name = "domain"];
  void clear_domain();
  const std::string& domain() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_domain(ArgT0&& arg0, ArgT... args);
  std::string* mutable_domain();
  PROTOBUF_NODISCARD std::string* release_domain();
  void set_allocated_domain(std::string* domain);
  private:
  const std::string& _internal_domain() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_domain(const std::string& value);
  std::string* _internal_mutable_domain();
  public:

  // string version = 4 [json_name = "version"];
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string UUID = 5 [json_name = "UUID"];
  void clear_uuid();
  const std::string& uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uuid();
  PROTOBUF_NODISCARD std::string* release_uuid();
  void set_allocated_uuid(std::string* uuid);
  private:
  const std::string& _internal_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uuid(const std::string& value);
  std::string* _internal_mutable_uuid();
  public:

  // @@protoc_insertion_point(class_scope:datacatalog.DatasetID)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr project_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr domain_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uuid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fdatacatalog_2fdatacatalog_2eproto;
};
// -------------------------------------------------------------------

class Artifact final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:datacatalog.Artifact) */ {
 public:
  inline Artifact() : Artifact(nullptr) {}
  ~Artifact() override;
  explicit constexpr Artifact(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Artifact(const Artifact& from);
  Artifact(Artifact&& from) noexcept
    : Artifact() {
    *this = ::std::move(from);
  }

  inline Artifact& operator=(const Artifact& from) {
    CopyFrom(from);
    return *this;
  }
  inline Artifact& operator=(Artifact&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Artifact& default_instance() {
    return *internal_default_instance();
  }
  static inline const Artifact* internal_default_instance() {
    return reinterpret_cast<const Artifact*>(
               &_Artifact_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(Artifact& a, Artifact& b) {
    a.Swap(&b);
  }
  inline void Swap(Artifact* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Artifact* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Artifact* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Artifact>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Artifact* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "datacatalog.Artifact";
  }
  protected:
  explicit Artifact(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 3,
    kPartitionsFieldNumber = 5,
    kTagsFieldNumber = 6,
    kIdFieldNumber = 1,
    kDatasetFieldNumber = 2,
    kMetadataFieldNumber = 4,
    kCreatedAtFieldNumber = 7,
  };
  // repeated .datacatalog.ArtifactData data = 3 [json_name = "data"];
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  ::datacatalog::ArtifactData* mutable_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::datacatalog::ArtifactData >*
      mutable_data();
  private:
  const ::datacatalog::ArtifactData& _internal_data(int index) const;
  ::datacatalog::ArtifactData* _internal_add_data();
  public:
  const ::datacatalog::ArtifactData& data(int index) const;
  ::datacatalog::ArtifactData* add_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::datacatalog::ArtifactData >&
      data() const;

  // repeated .datacatalog.Partition partitions = 5 [json_name = "partitions"];
  int partitions_size() const;
  private:
  int _internal_partitions_size() const;
  public:
  void clear_partitions();
  ::datacatalog::Partition* mutable_partitions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::datacatalog::Partition >*
      mutable_partitions();
  private:
  const ::datacatalog::Partition& _internal_partitions(int index) const;
  ::datacatalog::Partition* _internal_add_partitions();
  public:
  const ::datacatalog::Partition& partitions(int index) const;
  ::datacatalog::Partition* add_partitions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::datacatalog::Partition >&
      partitions() const;

  // repeated .datacatalog.Tag tags = 6 [json_name = "tags"];
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  ::datacatalog::Tag* mutable_tags(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::datacatalog::Tag >*
      mutable_tags();
  private:
  const ::datacatalog::Tag& _internal_tags(int index) const;
  ::datacatalog::Tag* _internal_add_tags();
  public:
  const ::datacatalog::Tag& tags(int index) const;
  ::datacatalog::Tag* add_tags();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::datacatalog::Tag >&
      tags() const;

  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .datacatalog.DatasetID dataset = 2 [json_name = "dataset"];
  bool has_dataset() const;
  private:
  bool _internal_has_dataset() const;
  public:
  void clear_dataset();
  const ::datacatalog::DatasetID& dataset() const;
  PROTOBUF_NODISCARD ::datacatalog::DatasetID* release_dataset();
  ::datacatalog::DatasetID* mutable_dataset();
  void set_allocated_dataset(::datacatalog::DatasetID* dataset);
  private:
  const ::datacatalog::DatasetID& _internal_dataset() const;
  ::datacatalog::DatasetID* _internal_mutable_dataset();
  public:
  void unsafe_arena_set_allocated_dataset(
      ::datacatalog::DatasetID* dataset);
  ::datacatalog::DatasetID* unsafe_arena_release_dataset();

  // .datacatalog.Metadata metadata = 4 [json_name = "metadata"];
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::datacatalog::Metadata& metadata() const;
  PROTOBUF_NODISCARD ::datacatalog::Metadata* release_metadata();
  ::datacatalog::Metadata* mutable_metadata();
  void set_allocated_metadata(::datacatalog::Metadata* metadata);
  private:
  const ::datacatalog::Metadata& _internal_metadata() const;
  ::datacatalog::Metadata* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::datacatalog::Metadata* metadata);
  ::datacatalog::Metadata* unsafe_arena_release_metadata();

  // .google.protobuf.Timestamp created_at = 7 [json_name = "createdAt"];
  bool has_created_at() const;
  private:
  bool _internal_has_created_at() const;
  public:
  void clear_created_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_at();
  void set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_at();
  public:
  void unsafe_arena_set_allocated_created_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_at();

  // @@protoc_insertion_point(class_scope:datacatalog.Artifact)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::datacatalog::ArtifactData > data_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::datacatalog::Partition > partitions_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::datacatalog::Tag > tags_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::datacatalog::DatasetID* dataset_;
  ::datacatalog::Metadata* metadata_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fdatacatalog_2fdatacatalog_2eproto;
};
// -------------------------------------------------------------------

class ArtifactData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:datacatalog.ArtifactData) */ {
 public:
  inline ArtifactData() : ArtifactData(nullptr) {}
  ~ArtifactData() override;
  explicit constexpr ArtifactData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ArtifactData(const ArtifactData& from);
  ArtifactData(ArtifactData&& from) noexcept
    : ArtifactData() {
    *this = ::std::move(from);
  }

  inline ArtifactData& operator=(const ArtifactData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ArtifactData& operator=(ArtifactData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ArtifactData& default_instance() {
    return *internal_default_instance();
  }
  static inline const ArtifactData* internal_default_instance() {
    return reinterpret_cast<const ArtifactData*>(
               &_ArtifactData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(ArtifactData& a, ArtifactData& b) {
    a.Swap(&b);
  }
  inline void Swap(ArtifactData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ArtifactData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ArtifactData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ArtifactData>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArtifactData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "datacatalog.ArtifactData";
  }
  protected:
  explicit ArtifactData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .flyteidl.core.Literal value = 2 [json_name = "value"];
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::flyteidl::core::Literal& value() const;
  PROTOBUF_NODISCARD ::flyteidl::core::Literal* release_value();
  ::flyteidl::core::Literal* mutable_value();
  void set_allocated_value(::flyteidl::core::Literal* value);
  private:
  const ::flyteidl::core::Literal& _internal_value() const;
  ::flyteidl::core::Literal* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::flyteidl::core::Literal* value);
  ::flyteidl::core::Literal* unsafe_arena_release_value();

  // @@protoc_insertion_point(class_scope:datacatalog.ArtifactData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::flyteidl::core::Literal* value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fdatacatalog_2fdatacatalog_2eproto;
};
// -------------------------------------------------------------------

class Tag final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:datacatalog.Tag) */ {
 public:
  inline Tag() : Tag(nullptr) {}
  ~Tag() override;
  explicit constexpr Tag(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Tag(const Tag& from);
  Tag(Tag&& from) noexcept
    : Tag() {
    *this = ::std::move(from);
  }

  inline Tag& operator=(const Tag& from) {
    CopyFrom(from);
    return *this;
  }
  inline Tag& operator=(Tag&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Tag& default_instance() {
    return *internal_default_instance();
  }
  static inline const Tag* internal_default_instance() {
    return reinterpret_cast<const Tag*>(
               &_Tag_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(Tag& a, Tag& b) {
    a.Swap(&b);
  }
  inline void Swap(Tag* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Tag* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Tag* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Tag>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Tag* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "datacatalog.Tag";
  }
  protected:
  explicit Tag(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kArtifactIdFieldNumber = 2,
    kDatasetFieldNumber = 3,
  };
  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string artifact_id = 2 [json_name = "artifactId"];
  void clear_artifact_id();
  const std::string& artifact_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_artifact_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_artifact_id();
  PROTOBUF_NODISCARD std::string* release_artifact_id();
  void set_allocated_artifact_id(std::string* artifact_id);
  private:
  const std::string& _internal_artifact_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_artifact_id(const std::string& value);
  std::string* _internal_mutable_artifact_id();
  public:

  // .datacatalog.DatasetID dataset = 3 [json_name = "dataset"];
  bool has_dataset() const;
  private:
  bool _internal_has_dataset() const;
  public:
  void clear_dataset();
  const ::datacatalog::DatasetID& dataset() const;
  PROTOBUF_NODISCARD ::datacatalog::DatasetID* release_dataset();
  ::datacatalog::DatasetID* mutable_dataset();
  void set_allocated_dataset(::datacatalog::DatasetID* dataset);
  private:
  const ::datacatalog::DatasetID& _internal_dataset() const;
  ::datacatalog::DatasetID* _internal_mutable_dataset();
  public:
  void unsafe_arena_set_allocated_dataset(
      ::datacatalog::DatasetID* dataset);
  ::datacatalog::DatasetID* unsafe_arena_release_dataset();

  // @@protoc_insertion_point(class_scope:datacatalog.Tag)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr artifact_id_;
  ::datacatalog::DatasetID* dataset_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fdatacatalog_2fdatacatalog_2eproto;
};
// -------------------------------------------------------------------

class Metadata_KeyMapEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Metadata_KeyMapEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Metadata_KeyMapEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  Metadata_KeyMapEntry_DoNotUse();
  explicit constexpr Metadata_KeyMapEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Metadata_KeyMapEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Metadata_KeyMapEntry_DoNotUse& other);
  static const Metadata_KeyMapEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Metadata_KeyMapEntry_DoNotUse*>(&_Metadata_KeyMapEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "datacatalog.Metadata.KeyMapEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "datacatalog.Metadata.KeyMapEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class Metadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:datacatalog.Metadata) */ {
 public:
  inline Metadata() : Metadata(nullptr) {}
  ~Metadata() override;
  explicit constexpr Metadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Metadata(const Metadata& from);
  Metadata(Metadata&& from) noexcept
    : Metadata() {
    *this = ::std::move(from);
  }

  inline Metadata& operator=(const Metadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline Metadata& operator=(Metadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Metadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const Metadata* internal_default_instance() {
    return reinterpret_cast<const Metadata*>(
               &_Metadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(Metadata& a, Metadata& b) {
    a.Swap(&b);
  }
  inline void Swap(Metadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Metadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Metadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Metadata>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Metadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "datacatalog.Metadata";
  }
  protected:
  explicit Metadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kKeyMapFieldNumber = 1,
  };
  // map<string, string> key_map = 1 [json_name = "keyMap"];
  int key_map_size() const;
  private:
  int _internal_key_map_size() const;
  public:
  void clear_key_map();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_key_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_key_map();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      key_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_key_map();

  // @@protoc_insertion_point(class_scope:datacatalog.Metadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Metadata_KeyMapEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> key_map_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fdatacatalog_2fdatacatalog_2eproto;
};
// -------------------------------------------------------------------

class FilterExpression final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:datacatalog.FilterExpression) */ {
 public:
  inline FilterExpression() : FilterExpression(nullptr) {}
  ~FilterExpression() override;
  explicit constexpr FilterExpression(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FilterExpression(const FilterExpression& from);
  FilterExpression(FilterExpression&& from) noexcept
    : FilterExpression() {
    *this = ::std::move(from);
  }

  inline FilterExpression& operator=(const FilterExpression& from) {
    CopyFrom(from);
    return *this;
  }
  inline FilterExpression& operator=(FilterExpression&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FilterExpression& default_instance() {
    return *internal_default_instance();
  }
  static inline const FilterExpression* internal_default_instance() {
    return reinterpret_cast<const FilterExpression*>(
               &_FilterExpression_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(FilterExpression& a, FilterExpression& b) {
    a.Swap(&b);
  }
  inline void Swap(FilterExpression* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FilterExpression* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FilterExpression* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FilterExpression>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FilterExpression* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "datacatalog.FilterExpression";
  }
  protected:
  explicit FilterExpression(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFiltersFieldNumber = 1,
  };
  // repeated .datacatalog.SinglePropertyFilter filters = 1 [json_name = "filters"];
  int filters_size() const;
  private:
  int _internal_filters_size() const;
  public:
  void clear_filters();
  ::datacatalog::SinglePropertyFilter* mutable_filters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::datacatalog::SinglePropertyFilter >*
      mutable_filters();
  private:
  const ::datacatalog::SinglePropertyFilter& _internal_filters(int index) const;
  ::datacatalog::SinglePropertyFilter* _internal_add_filters();
  public:
  const ::datacatalog::SinglePropertyFilter& filters(int index) const;
  ::datacatalog::SinglePropertyFilter* add_filters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::datacatalog::SinglePropertyFilter >&
      filters() const;

  // @@protoc_insertion_point(class_scope:datacatalog.FilterExpression)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::datacatalog::SinglePropertyFilter > filters_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fdatacatalog_2fdatacatalog_2eproto;
};
// -------------------------------------------------------------------

class SinglePropertyFilter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:datacatalog.SinglePropertyFilter) */ {
 public:
  inline SinglePropertyFilter() : SinglePropertyFilter(nullptr) {}
  ~SinglePropertyFilter() override;
  explicit constexpr SinglePropertyFilter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SinglePropertyFilter(const SinglePropertyFilter& from);
  SinglePropertyFilter(SinglePropertyFilter&& from) noexcept
    : SinglePropertyFilter() {
    *this = ::std::move(from);
  }

  inline SinglePropertyFilter& operator=(const SinglePropertyFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline SinglePropertyFilter& operator=(SinglePropertyFilter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SinglePropertyFilter& default_instance() {
    return *internal_default_instance();
  }
  enum PropertyFilterCase {
    kTagFilter = 1,
    kPartitionFilter = 2,
    kArtifactFilter = 3,
    kDatasetFilter = 4,
    PROPERTY_FILTER_NOT_SET = 0,
  };

  static inline const SinglePropertyFilter* internal_default_instance() {
    return reinterpret_cast<const SinglePropertyFilter*>(
               &_SinglePropertyFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(SinglePropertyFilter& a, SinglePropertyFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(SinglePropertyFilter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SinglePropertyFilter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SinglePropertyFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SinglePropertyFilter>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SinglePropertyFilter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "datacatalog.SinglePropertyFilter";
  }
  protected:
  explicit SinglePropertyFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SinglePropertyFilter_ComparisonOperator ComparisonOperator;
  static constexpr ComparisonOperator EQUALS =
    SinglePropertyFilter_ComparisonOperator_EQUALS;
  static inline bool ComparisonOperator_IsValid(int value) {
    return SinglePropertyFilter_ComparisonOperator_IsValid(value);
  }
  static constexpr ComparisonOperator ComparisonOperator_MIN =
    SinglePropertyFilter_ComparisonOperator_ComparisonOperator_MIN;
  static constexpr ComparisonOperator ComparisonOperator_MAX =
    SinglePropertyFilter_ComparisonOperator_ComparisonOperator_MAX;
  static constexpr int ComparisonOperator_ARRAYSIZE =
    SinglePropertyFilter_ComparisonOperator_ComparisonOperator_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ComparisonOperator_descriptor() {
    return SinglePropertyFilter_ComparisonOperator_descriptor();
  }
  template<typename T>
  static inline const std::string& ComparisonOperator_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ComparisonOperator>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ComparisonOperator_Name.");
    return SinglePropertyFilter_ComparisonOperator_Name(enum_t_value);
  }
  static inline bool ComparisonOperator_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ComparisonOperator* value) {
    return SinglePropertyFilter_ComparisonOperator_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kOperatorFieldNumber = 10,
    kTagFilterFieldNumber = 1,
    kPartitionFilterFieldNumber = 2,
    kArtifactFilterFieldNumber = 3,
    kDatasetFilterFieldNumber = 4,
  };
  // .datacatalog.SinglePropertyFilter.ComparisonOperator operator = 10 [json_name = "operator"];
  void clear_operator_();
  ::datacatalog::SinglePropertyFilter_ComparisonOperator operator_() const;
  void set_operator_(::datacatalog::SinglePropertyFilter_ComparisonOperator value);
  private:
  ::datacatalog::SinglePropertyFilter_ComparisonOperator _internal_operator_() const;
  void _internal_set_operator_(::datacatalog::SinglePropertyFilter_ComparisonOperator value);
  public:

  // .datacatalog.TagPropertyFilter tag_filter = 1 [json_name = "tagFilter"];
  bool has_tag_filter() const;
  private:
  bool _internal_has_tag_filter() const;
  public:
  void clear_tag_filter();
  const ::datacatalog::TagPropertyFilter& tag_filter() const;
  PROTOBUF_NODISCARD ::datacatalog::TagPropertyFilter* release_tag_filter();
  ::datacatalog::TagPropertyFilter* mutable_tag_filter();
  void set_allocated_tag_filter(::datacatalog::TagPropertyFilter* tag_filter);
  private:
  const ::datacatalog::TagPropertyFilter& _internal_tag_filter() const;
  ::datacatalog::TagPropertyFilter* _internal_mutable_tag_filter();
  public:
  void unsafe_arena_set_allocated_tag_filter(
      ::datacatalog::TagPropertyFilter* tag_filter);
  ::datacatalog::TagPropertyFilter* unsafe_arena_release_tag_filter();

  // .datacatalog.PartitionPropertyFilter partition_filter = 2 [json_name = "partitionFilter"];
  bool has_partition_filter() const;
  private:
  bool _internal_has_partition_filter() const;
  public:
  void clear_partition_filter();
  const ::datacatalog::PartitionPropertyFilter& partition_filter() const;
  PROTOBUF_NODISCARD ::datacatalog::PartitionPropertyFilter* release_partition_filter();
  ::datacatalog::PartitionPropertyFilter* mutable_partition_filter();
  void set_allocated_partition_filter(::datacatalog::PartitionPropertyFilter* partition_filter);
  private:
  const ::datacatalog::PartitionPropertyFilter& _internal_partition_filter() const;
  ::datacatalog::PartitionPropertyFilter* _internal_mutable_partition_filter();
  public:
  void unsafe_arena_set_allocated_partition_filter(
      ::datacatalog::PartitionPropertyFilter* partition_filter);
  ::datacatalog::PartitionPropertyFilter* unsafe_arena_release_partition_filter();

  // .datacatalog.ArtifactPropertyFilter artifact_filter = 3 [json_name = "artifactFilter"];
  bool has_artifact_filter() const;
  private:
  bool _internal_has_artifact_filter() const;
  public:
  void clear_artifact_filter();
  const ::datacatalog::ArtifactPropertyFilter& artifact_filter() const;
  PROTOBUF_NODISCARD ::datacatalog::ArtifactPropertyFilter* release_artifact_filter();
  ::datacatalog::ArtifactPropertyFilter* mutable_artifact_filter();
  void set_allocated_artifact_filter(::datacatalog::ArtifactPropertyFilter* artifact_filter);
  private:
  const ::datacatalog::ArtifactPropertyFilter& _internal_artifact_filter() const;
  ::datacatalog::ArtifactPropertyFilter* _internal_mutable_artifact_filter();
  public:
  void unsafe_arena_set_allocated_artifact_filter(
      ::datacatalog::ArtifactPropertyFilter* artifact_filter);
  ::datacatalog::ArtifactPropertyFilter* unsafe_arena_release_artifact_filter();

  // .datacatalog.DatasetPropertyFilter dataset_filter = 4 [json_name = "datasetFilter"];
  bool has_dataset_filter() const;
  private:
  bool _internal_has_dataset_filter() const;
  public:
  void clear_dataset_filter();
  const ::datacatalog::DatasetPropertyFilter& dataset_filter() const;
  PROTOBUF_NODISCARD ::datacatalog::DatasetPropertyFilter* release_dataset_filter();
  ::datacatalog::DatasetPropertyFilter* mutable_dataset_filter();
  void set_allocated_dataset_filter(::datacatalog::DatasetPropertyFilter* dataset_filter);
  private:
  const ::datacatalog::DatasetPropertyFilter& _internal_dataset_filter() const;
  ::datacatalog::DatasetPropertyFilter* _internal_mutable_dataset_filter();
  public:
  void unsafe_arena_set_allocated_dataset_filter(
      ::datacatalog::DatasetPropertyFilter* dataset_filter);
  ::datacatalog::DatasetPropertyFilter* unsafe_arena_release_dataset_filter();

  void clear_property_filter();
  PropertyFilterCase property_filter_case() const;
  // @@protoc_insertion_point(class_scope:datacatalog.SinglePropertyFilter)
 private:
  class _Internal;
  void set_has_tag_filter();
  void set_has_partition_filter();
  void set_has_artifact_filter();
  void set_has_dataset_filter();

  inline bool has_property_filter() const;
  inline void clear_has_property_filter();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int operator__;
  union PropertyFilterUnion {
    constexpr PropertyFilterUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::datacatalog::TagPropertyFilter* tag_filter_;
    ::datacatalog::PartitionPropertyFilter* partition_filter_;
    ::datacatalog::ArtifactPropertyFilter* artifact_filter_;
    ::datacatalog::DatasetPropertyFilter* dataset_filter_;
  } property_filter_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_flyteidl_2fdatacatalog_2fdatacatalog_2eproto;
};
// -------------------------------------------------------------------

class ArtifactPropertyFilter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:datacatalog.ArtifactPropertyFilter) */ {
 public:
  inline ArtifactPropertyFilter() : ArtifactPropertyFilter(nullptr) {}
  ~ArtifactPropertyFilter() override;
  explicit constexpr ArtifactPropertyFilter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ArtifactPropertyFilter(const ArtifactPropertyFilter& from);
  ArtifactPropertyFilter(ArtifactPropertyFilter&& from) noexcept
    : ArtifactPropertyFilter() {
    *this = ::std::move(from);
  }

  inline ArtifactPropertyFilter& operator=(const ArtifactPropertyFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline ArtifactPropertyFilter& operator=(ArtifactPropertyFilter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ArtifactPropertyFilter& default_instance() {
    return *internal_default_instance();
  }
  enum PropertyCase {
    kArtifactId = 1,
    PROPERTY_NOT_SET = 0,
  };

  static inline const ArtifactPropertyFilter* internal_default_instance() {
    return reinterpret_cast<const ArtifactPropertyFilter*>(
               &_ArtifactPropertyFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(ArtifactPropertyFilter& a, ArtifactPropertyFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(ArtifactPropertyFilter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ArtifactPropertyFilter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ArtifactPropertyFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ArtifactPropertyFilter>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArtifactPropertyFilter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "datacatalog.ArtifactPropertyFilter";
  }
  protected:
  explicit ArtifactPropertyFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArtifactIdFieldNumber = 1,
  };
  // string artifact_id = 1 [json_name = "artifactId"];
  bool has_artifact_id() const;
  private:
  bool _internal_has_artifact_id() const;
  public:
  void clear_artifact_id();
  const std::string& artifact_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_artifact_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_artifact_id();
  PROTOBUF_NODISCARD std::string* release_artifact_id();
  void set_allocated_artifact_id(std::string* artifact_id);
  private:
  const std::string& _internal_artifact_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_artifact_id(const std::string& value);
  std::string* _internal_mutable_artifact_id();
  public:

  void clear_property();
  PropertyCase property_case() const;
  // @@protoc_insertion_point(class_scope:datacatalog.ArtifactPropertyFilter)
 private:
  class _Internal;
  void set_has_artifact_id();

  inline bool has_property() const;
  inline void clear_has_property();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union PropertyUnion {
    constexpr PropertyUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr artifact_id_;
  } property_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_flyteidl_2fdatacatalog_2fdatacatalog_2eproto;
};
// -------------------------------------------------------------------

class TagPropertyFilter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:datacatalog.TagPropertyFilter) */ {
 public:
  inline TagPropertyFilter() : TagPropertyFilter(nullptr) {}
  ~TagPropertyFilter() override;
  explicit constexpr TagPropertyFilter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TagPropertyFilter(const TagPropertyFilter& from);
  TagPropertyFilter(TagPropertyFilter&& from) noexcept
    : TagPropertyFilter() {
    *this = ::std::move(from);
  }

  inline TagPropertyFilter& operator=(const TagPropertyFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline TagPropertyFilter& operator=(TagPropertyFilter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TagPropertyFilter& default_instance() {
    return *internal_default_instance();
  }
  enum PropertyCase {
    kTagName = 1,
    PROPERTY_NOT_SET = 0,
  };

  static inline const TagPropertyFilter* internal_default_instance() {
    return reinterpret_cast<const TagPropertyFilter*>(
               &_TagPropertyFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(TagPropertyFilter& a, TagPropertyFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(TagPropertyFilter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TagPropertyFilter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TagPropertyFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TagPropertyFilter>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TagPropertyFilter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "datacatalog.TagPropertyFilter";
  }
  protected:
  explicit TagPropertyFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagNameFieldNumber = 1,
  };
  // string tag_name = 1 [json_name = "tagName"];
  bool has_tag_name() const;
  private:
  bool _internal_has_tag_name() const;
  public:
  void clear_tag_name();
  const std::string& tag_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tag_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tag_name();
  PROTOBUF_NODISCARD std::string* release_tag_name();
  void set_allocated_tag_name(std::string* tag_name);
  private:
  const std::string& _internal_tag_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tag_name(const std::string& value);
  std::string* _internal_mutable_tag_name();
  public:

  void clear_property();
  PropertyCase property_case() const;
  // @@protoc_insertion_point(class_scope:datacatalog.TagPropertyFilter)
 private:
  class _Internal;
  void set_has_tag_name();

  inline bool has_property() const;
  inline void clear_has_property();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union PropertyUnion {
    constexpr PropertyUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_name_;
  } property_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_flyteidl_2fdatacatalog_2fdatacatalog_2eproto;
};
// -------------------------------------------------------------------

class PartitionPropertyFilter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:datacatalog.PartitionPropertyFilter) */ {
 public:
  inline PartitionPropertyFilter() : PartitionPropertyFilter(nullptr) {}
  ~PartitionPropertyFilter() override;
  explicit constexpr PartitionPropertyFilter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PartitionPropertyFilter(const PartitionPropertyFilter& from);
  PartitionPropertyFilter(PartitionPropertyFilter&& from) noexcept
    : PartitionPropertyFilter() {
    *this = ::std::move(from);
  }

  inline PartitionPropertyFilter& operator=(const PartitionPropertyFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline PartitionPropertyFilter& operator=(PartitionPropertyFilter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PartitionPropertyFilter& default_instance() {
    return *internal_default_instance();
  }
  enum PropertyCase {
    kKeyVal = 1,
    PROPERTY_NOT_SET = 0,
  };

  static inline const PartitionPropertyFilter* internal_default_instance() {
    return reinterpret_cast<const PartitionPropertyFilter*>(
               &_PartitionPropertyFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(PartitionPropertyFilter& a, PartitionPropertyFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(PartitionPropertyFilter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PartitionPropertyFilter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PartitionPropertyFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PartitionPropertyFilter>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PartitionPropertyFilter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "datacatalog.PartitionPropertyFilter";
  }
  protected:
  explicit PartitionPropertyFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyValFieldNumber = 1,
  };
  // .datacatalog.KeyValuePair key_val = 1 [json_name = "keyVal"];
  bool has_key_val() const;
  private:
  bool _internal_has_key_val() const;
  public:
  void clear_key_val();
  const ::datacatalog::KeyValuePair& key_val() const;
  PROTOBUF_NODISCARD ::datacatalog::KeyValuePair* release_key_val();
  ::datacatalog::KeyValuePair* mutable_key_val();
  void set_allocated_key_val(::datacatalog::KeyValuePair* key_val);
  private:
  const ::datacatalog::KeyValuePair& _internal_key_val() const;
  ::datacatalog::KeyValuePair* _internal_mutable_key_val();
  public:
  void unsafe_arena_set_allocated_key_val(
      ::datacatalog::KeyValuePair* key_val);
  ::datacatalog::KeyValuePair* unsafe_arena_release_key_val();

  void clear_property();
  PropertyCase property_case() const;
  // @@protoc_insertion_point(class_scope:datacatalog.PartitionPropertyFilter)
 private:
  class _Internal;
  void set_has_key_val();

  inline bool has_property() const;
  inline void clear_has_property();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union PropertyUnion {
    constexpr PropertyUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::datacatalog::KeyValuePair* key_val_;
  } property_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_flyteidl_2fdatacatalog_2fdatacatalog_2eproto;
};
// -------------------------------------------------------------------

class KeyValuePair final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:datacatalog.KeyValuePair) */ {
 public:
  inline KeyValuePair() : KeyValuePair(nullptr) {}
  ~KeyValuePair() override;
  explicit constexpr KeyValuePair(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KeyValuePair(const KeyValuePair& from);
  KeyValuePair(KeyValuePair&& from) noexcept
    : KeyValuePair() {
    *this = ::std::move(from);
  }

  inline KeyValuePair& operator=(const KeyValuePair& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyValuePair& operator=(KeyValuePair&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeyValuePair& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeyValuePair* internal_default_instance() {
    return reinterpret_cast<const KeyValuePair*>(
               &_KeyValuePair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(KeyValuePair& a, KeyValuePair& b) {
    a.Swap(&b);
  }
  inline void Swap(KeyValuePair* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyValuePair* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeyValuePair* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KeyValuePair>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyValuePair* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "datacatalog.KeyValuePair";
  }
  protected:
  explicit KeyValuePair(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string key = 1 [json_name = "key"];
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // string value = 2 [json_name = "value"];
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:datacatalog.KeyValuePair)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fdatacatalog_2fdatacatalog_2eproto;
};
// -------------------------------------------------------------------

class DatasetPropertyFilter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:datacatalog.DatasetPropertyFilter) */ {
 public:
  inline DatasetPropertyFilter() : DatasetPropertyFilter(nullptr) {}
  ~DatasetPropertyFilter() override;
  explicit constexpr DatasetPropertyFilter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DatasetPropertyFilter(const DatasetPropertyFilter& from);
  DatasetPropertyFilter(DatasetPropertyFilter&& from) noexcept
    : DatasetPropertyFilter() {
    *this = ::std::move(from);
  }

  inline DatasetPropertyFilter& operator=(const DatasetPropertyFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline DatasetPropertyFilter& operator=(DatasetPropertyFilter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DatasetPropertyFilter& default_instance() {
    return *internal_default_instance();
  }
  enum PropertyCase {
    kProject = 1,
    kName = 2,
    kDomain = 3,
    kVersion = 4,
    PROPERTY_NOT_SET = 0,
  };

  static inline const DatasetPropertyFilter* internal_default_instance() {
    return reinterpret_cast<const DatasetPropertyFilter*>(
               &_DatasetPropertyFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(DatasetPropertyFilter& a, DatasetPropertyFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(DatasetPropertyFilter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DatasetPropertyFilter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DatasetPropertyFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DatasetPropertyFilter>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DatasetPropertyFilter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "datacatalog.DatasetPropertyFilter";
  }
  protected:
  explicit DatasetPropertyFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProjectFieldNumber = 1,
    kNameFieldNumber = 2,
    kDomainFieldNumber = 3,
    kVersionFieldNumber = 4,
  };
  // string project = 1 [json_name = "project"];
  bool has_project() const;
  private:
  bool _internal_has_project() const;
  public:
  void clear_project();
  const std::string& project() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_project(ArgT0&& arg0, ArgT... args);
  std::string* mutable_project();
  PROTOBUF_NODISCARD std::string* release_project();
  void set_allocated_project(std::string* project);
  private:
  const std::string& _internal_project() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_project(const std::string& value);
  std::string* _internal_mutable_project();
  public:

  // string name = 2 [json_name = "name"];
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string domain = 3 [json_name = "domain"];
  bool has_domain() const;
  private:
  bool _internal_has_domain() const;
  public:
  void clear_domain();
  const std::string& domain() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_domain(ArgT0&& arg0, ArgT... args);
  std::string* mutable_domain();
  PROTOBUF_NODISCARD std::string* release_domain();
  void set_allocated_domain(std::string* domain);
  private:
  const std::string& _internal_domain() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_domain(const std::string& value);
  std::string* _internal_mutable_domain();
  public:

  // string version = 4 [json_name = "version"];
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  void clear_property();
  PropertyCase property_case() const;
  // @@protoc_insertion_point(class_scope:datacatalog.DatasetPropertyFilter)
 private:
  class _Internal;
  void set_has_project();
  void set_has_name();
  void set_has_domain();
  void set_has_version();

  inline bool has_property() const;
  inline void clear_has_property();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union PropertyUnion {
    constexpr PropertyUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr project_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr domain_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  } property_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_flyteidl_2fdatacatalog_2fdatacatalog_2eproto;
};
// -------------------------------------------------------------------

class PaginationOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:datacatalog.PaginationOptions) */ {
 public:
  inline PaginationOptions() : PaginationOptions(nullptr) {}
  ~PaginationOptions() override;
  explicit constexpr PaginationOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PaginationOptions(const PaginationOptions& from);
  PaginationOptions(PaginationOptions&& from) noexcept
    : PaginationOptions() {
    *this = ::std::move(from);
  }

  inline PaginationOptions& operator=(const PaginationOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline PaginationOptions& operator=(PaginationOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PaginationOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const PaginationOptions* internal_default_instance() {
    return reinterpret_cast<const PaginationOptions*>(
               &_PaginationOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(PaginationOptions& a, PaginationOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(PaginationOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PaginationOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PaginationOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PaginationOptions>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PaginationOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "datacatalog.PaginationOptions";
  }
  protected:
  explicit PaginationOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PaginationOptions_SortOrder SortOrder;
  static constexpr SortOrder DESCENDING =
    PaginationOptions_SortOrder_DESCENDING;
  static constexpr SortOrder ASCENDING =
    PaginationOptions_SortOrder_ASCENDING;
  static inline bool SortOrder_IsValid(int value) {
    return PaginationOptions_SortOrder_IsValid(value);
  }
  static constexpr SortOrder SortOrder_MIN =
    PaginationOptions_SortOrder_SortOrder_MIN;
  static constexpr SortOrder SortOrder_MAX =
    PaginationOptions_SortOrder_SortOrder_MAX;
  static constexpr int SortOrder_ARRAYSIZE =
    PaginationOptions_SortOrder_SortOrder_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SortOrder_descriptor() {
    return PaginationOptions_SortOrder_descriptor();
  }
  template<typename T>
  static inline const std::string& SortOrder_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SortOrder>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SortOrder_Name.");
    return PaginationOptions_SortOrder_Name(enum_t_value);
  }
  static inline bool SortOrder_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SortOrder* value) {
    return PaginationOptions_SortOrder_Parse(name, value);
  }

  typedef PaginationOptions_SortKey SortKey;
  static constexpr SortKey CREATION_TIME =
    PaginationOptions_SortKey_CREATION_TIME;
  static inline bool SortKey_IsValid(int value) {
    return PaginationOptions_SortKey_IsValid(value);
  }
  static constexpr SortKey SortKey_MIN =
    PaginationOptions_SortKey_SortKey_MIN;
  static constexpr SortKey SortKey_MAX =
    PaginationOptions_SortKey_SortKey_MAX;
  static constexpr int SortKey_ARRAYSIZE =
    PaginationOptions_SortKey_SortKey_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SortKey_descriptor() {
    return PaginationOptions_SortKey_descriptor();
  }
  template<typename T>
  static inline const std::string& SortKey_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SortKey>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SortKey_Name.");
    return PaginationOptions_SortKey_Name(enum_t_value);
  }
  static inline bool SortKey_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SortKey* value) {
    return PaginationOptions_SortKey_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 2,
    kLimitFieldNumber = 1,
    kSortKeyFieldNumber = 3,
    kSortOrderFieldNumber = 4,
  };
  // string token = 2 [json_name = "token"];
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // uint32 limit = 1 [json_name = "limit"];
  void clear_limit();
  uint32_t limit() const;
  void set_limit(uint32_t value);
  private:
  uint32_t _internal_limit() const;
  void _internal_set_limit(uint32_t value);
  public:

  // .datacatalog.PaginationOptions.SortKey sortKey = 3 [json_name = "sortKey"];
  void clear_sortkey();
  ::datacatalog::PaginationOptions_SortKey sortkey() const;
  void set_sortkey(::datacatalog::PaginationOptions_SortKey value);
  private:
  ::datacatalog::PaginationOptions_SortKey _internal_sortkey() const;
  void _internal_set_sortkey(::datacatalog::PaginationOptions_SortKey value);
  public:

  // .datacatalog.PaginationOptions.SortOrder sortOrder = 4 [json_name = "sortOrder"];
  void clear_sortorder();
  ::datacatalog::PaginationOptions_SortOrder sortorder() const;
  void set_sortorder(::datacatalog::PaginationOptions_SortOrder value);
  private:
  ::datacatalog::PaginationOptions_SortOrder _internal_sortorder() const;
  void _internal_set_sortorder(::datacatalog::PaginationOptions_SortOrder value);
  public:

  // @@protoc_insertion_point(class_scope:datacatalog.PaginationOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
  uint32_t limit_;
  int sortkey_;
  int sortorder_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fdatacatalog_2fdatacatalog_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CreateDatasetRequest

// .datacatalog.Dataset dataset = 1 [json_name = "dataset"];
inline bool CreateDatasetRequest::_internal_has_dataset() const {
  return this != internal_default_instance() && dataset_ != nullptr;
}
inline bool CreateDatasetRequest::has_dataset() const {
  return _internal_has_dataset();
}
inline void CreateDatasetRequest::clear_dataset() {
  if (GetArenaForAllocation() == nullptr && dataset_ != nullptr) {
    delete dataset_;
  }
  dataset_ = nullptr;
}
inline const ::datacatalog::Dataset& CreateDatasetRequest::_internal_dataset() const {
  const ::datacatalog::Dataset* p = dataset_;
  return p != nullptr ? *p : reinterpret_cast<const ::datacatalog::Dataset&>(
      ::datacatalog::_Dataset_default_instance_);
}
inline const ::datacatalog::Dataset& CreateDatasetRequest::dataset() const {
  // @@protoc_insertion_point(field_get:datacatalog.CreateDatasetRequest.dataset)
  return _internal_dataset();
}
inline void CreateDatasetRequest::unsafe_arena_set_allocated_dataset(
    ::datacatalog::Dataset* dataset) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dataset_);
  }
  dataset_ = dataset;
  if (dataset) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:datacatalog.CreateDatasetRequest.dataset)
}
inline ::datacatalog::Dataset* CreateDatasetRequest::release_dataset() {
  
  ::datacatalog::Dataset* temp = dataset_;
  dataset_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::datacatalog::Dataset* CreateDatasetRequest::unsafe_arena_release_dataset() {
  // @@protoc_insertion_point(field_release:datacatalog.CreateDatasetRequest.dataset)
  
  ::datacatalog::Dataset* temp = dataset_;
  dataset_ = nullptr;
  return temp;
}
inline ::datacatalog::Dataset* CreateDatasetRequest::_internal_mutable_dataset() {
  
  if (dataset_ == nullptr) {
    auto* p = CreateMaybeMessage<::datacatalog::Dataset>(GetArenaForAllocation());
    dataset_ = p;
  }
  return dataset_;
}
inline ::datacatalog::Dataset* CreateDatasetRequest::mutable_dataset() {
  ::datacatalog::Dataset* _msg = _internal_mutable_dataset();
  // @@protoc_insertion_point(field_mutable:datacatalog.CreateDatasetRequest.dataset)
  return _msg;
}
inline void CreateDatasetRequest::set_allocated_dataset(::datacatalog::Dataset* dataset) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete dataset_;
  }
  if (dataset) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::datacatalog::Dataset>::GetOwningArena(dataset);
    if (message_arena != submessage_arena) {
      dataset = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dataset, submessage_arena);
    }
    
  } else {
    
  }
  dataset_ = dataset;
  // @@protoc_insertion_point(field_set_allocated:datacatalog.CreateDatasetRequest.dataset)
}

// -------------------------------------------------------------------

// CreateDatasetResponse

// -------------------------------------------------------------------

// GetDatasetRequest

// .datacatalog.DatasetID dataset = 1 [json_name = "dataset"];
inline bool GetDatasetRequest::_internal_has_dataset() const {
  return this != internal_default_instance() && dataset_ != nullptr;
}
inline bool GetDatasetRequest::has_dataset() const {
  return _internal_has_dataset();
}
inline void GetDatasetRequest::clear_dataset() {
  if (GetArenaForAllocation() == nullptr && dataset_ != nullptr) {
    delete dataset_;
  }
  dataset_ = nullptr;
}
inline const ::datacatalog::DatasetID& GetDatasetRequest::_internal_dataset() const {
  const ::datacatalog::DatasetID* p = dataset_;
  return p != nullptr ? *p : reinterpret_cast<const ::datacatalog::DatasetID&>(
      ::datacatalog::_DatasetID_default_instance_);
}
inline const ::datacatalog::DatasetID& GetDatasetRequest::dataset() const {
  // @@protoc_insertion_point(field_get:datacatalog.GetDatasetRequest.dataset)
  return _internal_dataset();
}
inline void GetDatasetRequest::unsafe_arena_set_allocated_dataset(
    ::datacatalog::DatasetID* dataset) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dataset_);
  }
  dataset_ = dataset;
  if (dataset) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:datacatalog.GetDatasetRequest.dataset)
}
inline ::datacatalog::DatasetID* GetDatasetRequest::release_dataset() {
  
  ::datacatalog::DatasetID* temp = dataset_;
  dataset_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::datacatalog::DatasetID* GetDatasetRequest::unsafe_arena_release_dataset() {
  // @@protoc_insertion_point(field_release:datacatalog.GetDatasetRequest.dataset)
  
  ::datacatalog::DatasetID* temp = dataset_;
  dataset_ = nullptr;
  return temp;
}
inline ::datacatalog::DatasetID* GetDatasetRequest::_internal_mutable_dataset() {
  
  if (dataset_ == nullptr) {
    auto* p = CreateMaybeMessage<::datacatalog::DatasetID>(GetArenaForAllocation());
    dataset_ = p;
  }
  return dataset_;
}
inline ::datacatalog::DatasetID* GetDatasetRequest::mutable_dataset() {
  ::datacatalog::DatasetID* _msg = _internal_mutable_dataset();
  // @@protoc_insertion_point(field_mutable:datacatalog.GetDatasetRequest.dataset)
  return _msg;
}
inline void GetDatasetRequest::set_allocated_dataset(::datacatalog::DatasetID* dataset) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete dataset_;
  }
  if (dataset) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::datacatalog::DatasetID>::GetOwningArena(dataset);
    if (message_arena != submessage_arena) {
      dataset = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dataset, submessage_arena);
    }
    
  } else {
    
  }
  dataset_ = dataset;
  // @@protoc_insertion_point(field_set_allocated:datacatalog.GetDatasetRequest.dataset)
}

// -------------------------------------------------------------------

// GetDatasetResponse

// .datacatalog.Dataset dataset = 1 [json_name = "dataset"];
inline bool GetDatasetResponse::_internal_has_dataset() const {
  return this != internal_default_instance() && dataset_ != nullptr;
}
inline bool GetDatasetResponse::has_dataset() const {
  return _internal_has_dataset();
}
inline void GetDatasetResponse::clear_dataset() {
  if (GetArenaForAllocation() == nullptr && dataset_ != nullptr) {
    delete dataset_;
  }
  dataset_ = nullptr;
}
inline const ::datacatalog::Dataset& GetDatasetResponse::_internal_dataset() const {
  const ::datacatalog::Dataset* p = dataset_;
  return p != nullptr ? *p : reinterpret_cast<const ::datacatalog::Dataset&>(
      ::datacatalog::_Dataset_default_instance_);
}
inline const ::datacatalog::Dataset& GetDatasetResponse::dataset() const {
  // @@protoc_insertion_point(field_get:datacatalog.GetDatasetResponse.dataset)
  return _internal_dataset();
}
inline void GetDatasetResponse::unsafe_arena_set_allocated_dataset(
    ::datacatalog::Dataset* dataset) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dataset_);
  }
  dataset_ = dataset;
  if (dataset) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:datacatalog.GetDatasetResponse.dataset)
}
inline ::datacatalog::Dataset* GetDatasetResponse::release_dataset() {
  
  ::datacatalog::Dataset* temp = dataset_;
  dataset_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::datacatalog::Dataset* GetDatasetResponse::unsafe_arena_release_dataset() {
  // @@protoc_insertion_point(field_release:datacatalog.GetDatasetResponse.dataset)
  
  ::datacatalog::Dataset* temp = dataset_;
  dataset_ = nullptr;
  return temp;
}
inline ::datacatalog::Dataset* GetDatasetResponse::_internal_mutable_dataset() {
  
  if (dataset_ == nullptr) {
    auto* p = CreateMaybeMessage<::datacatalog::Dataset>(GetArenaForAllocation());
    dataset_ = p;
  }
  return dataset_;
}
inline ::datacatalog::Dataset* GetDatasetResponse::mutable_dataset() {
  ::datacatalog::Dataset* _msg = _internal_mutable_dataset();
  // @@protoc_insertion_point(field_mutable:datacatalog.GetDatasetResponse.dataset)
  return _msg;
}
inline void GetDatasetResponse::set_allocated_dataset(::datacatalog::Dataset* dataset) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete dataset_;
  }
  if (dataset) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::datacatalog::Dataset>::GetOwningArena(dataset);
    if (message_arena != submessage_arena) {
      dataset = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dataset, submessage_arena);
    }
    
  } else {
    
  }
  dataset_ = dataset;
  // @@protoc_insertion_point(field_set_allocated:datacatalog.GetDatasetResponse.dataset)
}

// -------------------------------------------------------------------

// GetArtifactRequest

// .datacatalog.DatasetID dataset = 1 [json_name = "dataset"];
inline bool GetArtifactRequest::_internal_has_dataset() const {
  return this != internal_default_instance() && dataset_ != nullptr;
}
inline bool GetArtifactRequest::has_dataset() const {
  return _internal_has_dataset();
}
inline void GetArtifactRequest::clear_dataset() {
  if (GetArenaForAllocation() == nullptr && dataset_ != nullptr) {
    delete dataset_;
  }
  dataset_ = nullptr;
}
inline const ::datacatalog::DatasetID& GetArtifactRequest::_internal_dataset() const {
  const ::datacatalog::DatasetID* p = dataset_;
  return p != nullptr ? *p : reinterpret_cast<const ::datacatalog::DatasetID&>(
      ::datacatalog::_DatasetID_default_instance_);
}
inline const ::datacatalog::DatasetID& GetArtifactRequest::dataset() const {
  // @@protoc_insertion_point(field_get:datacatalog.GetArtifactRequest.dataset)
  return _internal_dataset();
}
inline void GetArtifactRequest::unsafe_arena_set_allocated_dataset(
    ::datacatalog::DatasetID* dataset) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dataset_);
  }
  dataset_ = dataset;
  if (dataset) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:datacatalog.GetArtifactRequest.dataset)
}
inline ::datacatalog::DatasetID* GetArtifactRequest::release_dataset() {
  
  ::datacatalog::DatasetID* temp = dataset_;
  dataset_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::datacatalog::DatasetID* GetArtifactRequest::unsafe_arena_release_dataset() {
  // @@protoc_insertion_point(field_release:datacatalog.GetArtifactRequest.dataset)
  
  ::datacatalog::DatasetID* temp = dataset_;
  dataset_ = nullptr;
  return temp;
}
inline ::datacatalog::DatasetID* GetArtifactRequest::_internal_mutable_dataset() {
  
  if (dataset_ == nullptr) {
    auto* p = CreateMaybeMessage<::datacatalog::DatasetID>(GetArenaForAllocation());
    dataset_ = p;
  }
  return dataset_;
}
inline ::datacatalog::DatasetID* GetArtifactRequest::mutable_dataset() {
  ::datacatalog::DatasetID* _msg = _internal_mutable_dataset();
  // @@protoc_insertion_point(field_mutable:datacatalog.GetArtifactRequest.dataset)
  return _msg;
}
inline void GetArtifactRequest::set_allocated_dataset(::datacatalog::DatasetID* dataset) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete dataset_;
  }
  if (dataset) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::datacatalog::DatasetID>::GetOwningArena(dataset);
    if (message_arena != submessage_arena) {
      dataset = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dataset, submessage_arena);
    }
    
  } else {
    
  }
  dataset_ = dataset;
  // @@protoc_insertion_point(field_set_allocated:datacatalog.GetArtifactRequest.dataset)
}

// string artifact_id = 2 [json_name = "artifactId"];
inline bool GetArtifactRequest::_internal_has_artifact_id() const {
  return query_handle_case() == kArtifactId;
}
inline bool GetArtifactRequest::has_artifact_id() const {
  return _internal_has_artifact_id();
}
inline void GetArtifactRequest::set_has_artifact_id() {
  _oneof_case_[0] = kArtifactId;
}
inline void GetArtifactRequest::clear_artifact_id() {
  if (_internal_has_artifact_id()) {
    query_handle_.artifact_id_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_query_handle();
  }
}
inline const std::string& GetArtifactRequest::artifact_id() const {
  // @@protoc_insertion_point(field_get:datacatalog.GetArtifactRequest.artifact_id)
  return _internal_artifact_id();
}
template <typename ArgT0, typename... ArgT>
inline void GetArtifactRequest::set_artifact_id(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_artifact_id()) {
    clear_query_handle();
    set_has_artifact_id();
    query_handle_.artifact_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  query_handle_.artifact_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:datacatalog.GetArtifactRequest.artifact_id)
}
inline std::string* GetArtifactRequest::mutable_artifact_id() {
  std::string* _s = _internal_mutable_artifact_id();
  // @@protoc_insertion_point(field_mutable:datacatalog.GetArtifactRequest.artifact_id)
  return _s;
}
inline const std::string& GetArtifactRequest::_internal_artifact_id() const {
  if (_internal_has_artifact_id()) {
    return query_handle_.artifact_id_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void GetArtifactRequest::_internal_set_artifact_id(const std::string& value) {
  if (!_internal_has_artifact_id()) {
    clear_query_handle();
    set_has_artifact_id();
    query_handle_.artifact_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  query_handle_.artifact_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetArtifactRequest::_internal_mutable_artifact_id() {
  if (!_internal_has_artifact_id()) {
    clear_query_handle();
    set_has_artifact_id();
    query_handle_.artifact_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return query_handle_.artifact_id_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetArtifactRequest::release_artifact_id() {
  // @@protoc_insertion_point(field_release:datacatalog.GetArtifactRequest.artifact_id)
  if (_internal_has_artifact_id()) {
    clear_has_query_handle();
    return query_handle_.artifact_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void GetArtifactRequest::set_allocated_artifact_id(std::string* artifact_id) {
  if (has_query_handle()) {
    clear_query_handle();
  }
  if (artifact_id != nullptr) {
    set_has_artifact_id();
    query_handle_.artifact_id_.UnsafeSetDefault(artifact_id);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(artifact_id);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:datacatalog.GetArtifactRequest.artifact_id)
}

// string tag_name = 3 [json_name = "tagName"];
inline bool GetArtifactRequest::_internal_has_tag_name() const {
  return query_handle_case() == kTagName;
}
inline bool GetArtifactRequest::has_tag_name() const {
  return _internal_has_tag_name();
}
inline void GetArtifactRequest::set_has_tag_name() {
  _oneof_case_[0] = kTagName;
}
inline void GetArtifactRequest::clear_tag_name() {
  if (_internal_has_tag_name()) {
    query_handle_.tag_name_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_query_handle();
  }
}
inline const std::string& GetArtifactRequest::tag_name() const {
  // @@protoc_insertion_point(field_get:datacatalog.GetArtifactRequest.tag_name)
  return _internal_tag_name();
}
template <typename ArgT0, typename... ArgT>
inline void GetArtifactRequest::set_tag_name(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_tag_name()) {
    clear_query_handle();
    set_has_tag_name();
    query_handle_.tag_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  query_handle_.tag_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:datacatalog.GetArtifactRequest.tag_name)
}
inline std::string* GetArtifactRequest::mutable_tag_name() {
  std::string* _s = _internal_mutable_tag_name();
  // @@protoc_insertion_point(field_mutable:datacatalog.GetArtifactRequest.tag_name)
  return _s;
}
inline const std::string& GetArtifactRequest::_internal_tag_name() const {
  if (_internal_has_tag_name()) {
    return query_handle_.tag_name_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void GetArtifactRequest::_internal_set_tag_name(const std::string& value) {
  if (!_internal_has_tag_name()) {
    clear_query_handle();
    set_has_tag_name();
    query_handle_.tag_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  query_handle_.tag_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetArtifactRequest::_internal_mutable_tag_name() {
  if (!_internal_has_tag_name()) {
    clear_query_handle();
    set_has_tag_name();
    query_handle_.tag_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return query_handle_.tag_name_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetArtifactRequest::release_tag_name() {
  // @@protoc_insertion_point(field_release:datacatalog.GetArtifactRequest.tag_name)
  if (_internal_has_tag_name()) {
    clear_has_query_handle();
    return query_handle_.tag_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void GetArtifactRequest::set_allocated_tag_name(std::string* tag_name) {
  if (has_query_handle()) {
    clear_query_handle();
  }
  if (tag_name != nullptr) {
    set_has_tag_name();
    query_handle_.tag_name_.UnsafeSetDefault(tag_name);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(tag_name);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:datacatalog.GetArtifactRequest.tag_name)
}

inline bool GetArtifactRequest::has_query_handle() const {
  return query_handle_case() != QUERY_HANDLE_NOT_SET;
}
inline void GetArtifactRequest::clear_has_query_handle() {
  _oneof_case_[0] = QUERY_HANDLE_NOT_SET;
}
inline GetArtifactRequest::QueryHandleCase GetArtifactRequest::query_handle_case() const {
  return GetArtifactRequest::QueryHandleCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// GetArtifactResponse

// .datacatalog.Artifact artifact = 1 [json_name = "artifact"];
inline bool GetArtifactResponse::_internal_has_artifact() const {
  return this != internal_default_instance() && artifact_ != nullptr;
}
inline bool GetArtifactResponse::has_artifact() const {
  return _internal_has_artifact();
}
inline void GetArtifactResponse::clear_artifact() {
  if (GetArenaForAllocation() == nullptr && artifact_ != nullptr) {
    delete artifact_;
  }
  artifact_ = nullptr;
}
inline const ::datacatalog::Artifact& GetArtifactResponse::_internal_artifact() const {
  const ::datacatalog::Artifact* p = artifact_;
  return p != nullptr ? *p : reinterpret_cast<const ::datacatalog::Artifact&>(
      ::datacatalog::_Artifact_default_instance_);
}
inline const ::datacatalog::Artifact& GetArtifactResponse::artifact() const {
  // @@protoc_insertion_point(field_get:datacatalog.GetArtifactResponse.artifact)
  return _internal_artifact();
}
inline void GetArtifactResponse::unsafe_arena_set_allocated_artifact(
    ::datacatalog::Artifact* artifact) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(artifact_);
  }
  artifact_ = artifact;
  if (artifact) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:datacatalog.GetArtifactResponse.artifact)
}
inline ::datacatalog::Artifact* GetArtifactResponse::release_artifact() {
  
  ::datacatalog::Artifact* temp = artifact_;
  artifact_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::datacatalog::Artifact* GetArtifactResponse::unsafe_arena_release_artifact() {
  // @@protoc_insertion_point(field_release:datacatalog.GetArtifactResponse.artifact)
  
  ::datacatalog::Artifact* temp = artifact_;
  artifact_ = nullptr;
  return temp;
}
inline ::datacatalog::Artifact* GetArtifactResponse::_internal_mutable_artifact() {
  
  if (artifact_ == nullptr) {
    auto* p = CreateMaybeMessage<::datacatalog::Artifact>(GetArenaForAllocation());
    artifact_ = p;
  }
  return artifact_;
}
inline ::datacatalog::Artifact* GetArtifactResponse::mutable_artifact() {
  ::datacatalog::Artifact* _msg = _internal_mutable_artifact();
  // @@protoc_insertion_point(field_mutable:datacatalog.GetArtifactResponse.artifact)
  return _msg;
}
inline void GetArtifactResponse::set_allocated_artifact(::datacatalog::Artifact* artifact) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete artifact_;
  }
  if (artifact) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::datacatalog::Artifact>::GetOwningArena(artifact);
    if (message_arena != submessage_arena) {
      artifact = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, artifact, submessage_arena);
    }
    
  } else {
    
  }
  artifact_ = artifact;
  // @@protoc_insertion_point(field_set_allocated:datacatalog.GetArtifactResponse.artifact)
}

// -------------------------------------------------------------------

// CreateArtifactRequest

// .datacatalog.Artifact artifact = 1 [json_name = "artifact"];
inline bool CreateArtifactRequest::_internal_has_artifact() const {
  return this != internal_default_instance() && artifact_ != nullptr;
}
inline bool CreateArtifactRequest::has_artifact() const {
  return _internal_has_artifact();
}
inline void CreateArtifactRequest::clear_artifact() {
  if (GetArenaForAllocation() == nullptr && artifact_ != nullptr) {
    delete artifact_;
  }
  artifact_ = nullptr;
}
inline const ::datacatalog::Artifact& CreateArtifactRequest::_internal_artifact() const {
  const ::datacatalog::Artifact* p = artifact_;
  return p != nullptr ? *p : reinterpret_cast<const ::datacatalog::Artifact&>(
      ::datacatalog::_Artifact_default_instance_);
}
inline const ::datacatalog::Artifact& CreateArtifactRequest::artifact() const {
  // @@protoc_insertion_point(field_get:datacatalog.CreateArtifactRequest.artifact)
  return _internal_artifact();
}
inline void CreateArtifactRequest::unsafe_arena_set_allocated_artifact(
    ::datacatalog::Artifact* artifact) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(artifact_);
  }
  artifact_ = artifact;
  if (artifact) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:datacatalog.CreateArtifactRequest.artifact)
}
inline ::datacatalog::Artifact* CreateArtifactRequest::release_artifact() {
  
  ::datacatalog::Artifact* temp = artifact_;
  artifact_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::datacatalog::Artifact* CreateArtifactRequest::unsafe_arena_release_artifact() {
  // @@protoc_insertion_point(field_release:datacatalog.CreateArtifactRequest.artifact)
  
  ::datacatalog::Artifact* temp = artifact_;
  artifact_ = nullptr;
  return temp;
}
inline ::datacatalog::Artifact* CreateArtifactRequest::_internal_mutable_artifact() {
  
  if (artifact_ == nullptr) {
    auto* p = CreateMaybeMessage<::datacatalog::Artifact>(GetArenaForAllocation());
    artifact_ = p;
  }
  return artifact_;
}
inline ::datacatalog::Artifact* CreateArtifactRequest::mutable_artifact() {
  ::datacatalog::Artifact* _msg = _internal_mutable_artifact();
  // @@protoc_insertion_point(field_mutable:datacatalog.CreateArtifactRequest.artifact)
  return _msg;
}
inline void CreateArtifactRequest::set_allocated_artifact(::datacatalog::Artifact* artifact) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete artifact_;
  }
  if (artifact) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::datacatalog::Artifact>::GetOwningArena(artifact);
    if (message_arena != submessage_arena) {
      artifact = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, artifact, submessage_arena);
    }
    
  } else {
    
  }
  artifact_ = artifact;
  // @@protoc_insertion_point(field_set_allocated:datacatalog.CreateArtifactRequest.artifact)
}

// -------------------------------------------------------------------

// CreateArtifactResponse

// -------------------------------------------------------------------

// AddTagRequest

// .datacatalog.Tag tag = 1 [json_name = "tag"];
inline bool AddTagRequest::_internal_has_tag() const {
  return this != internal_default_instance() && tag_ != nullptr;
}
inline bool AddTagRequest::has_tag() const {
  return _internal_has_tag();
}
inline void AddTagRequest::clear_tag() {
  if (GetArenaForAllocation() == nullptr && tag_ != nullptr) {
    delete tag_;
  }
  tag_ = nullptr;
}
inline const ::datacatalog::Tag& AddTagRequest::_internal_tag() const {
  const ::datacatalog::Tag* p = tag_;
  return p != nullptr ? *p : reinterpret_cast<const ::datacatalog::Tag&>(
      ::datacatalog::_Tag_default_instance_);
}
inline const ::datacatalog::Tag& AddTagRequest::tag() const {
  // @@protoc_insertion_point(field_get:datacatalog.AddTagRequest.tag)
  return _internal_tag();
}
inline void AddTagRequest::unsafe_arena_set_allocated_tag(
    ::datacatalog::Tag* tag) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tag_);
  }
  tag_ = tag;
  if (tag) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:datacatalog.AddTagRequest.tag)
}
inline ::datacatalog::Tag* AddTagRequest::release_tag() {
  
  ::datacatalog::Tag* temp = tag_;
  tag_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::datacatalog::Tag* AddTagRequest::unsafe_arena_release_tag() {
  // @@protoc_insertion_point(field_release:datacatalog.AddTagRequest.tag)
  
  ::datacatalog::Tag* temp = tag_;
  tag_ = nullptr;
  return temp;
}
inline ::datacatalog::Tag* AddTagRequest::_internal_mutable_tag() {
  
  if (tag_ == nullptr) {
    auto* p = CreateMaybeMessage<::datacatalog::Tag>(GetArenaForAllocation());
    tag_ = p;
  }
  return tag_;
}
inline ::datacatalog::Tag* AddTagRequest::mutable_tag() {
  ::datacatalog::Tag* _msg = _internal_mutable_tag();
  // @@protoc_insertion_point(field_mutable:datacatalog.AddTagRequest.tag)
  return _msg;
}
inline void AddTagRequest::set_allocated_tag(::datacatalog::Tag* tag) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete tag_;
  }
  if (tag) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::datacatalog::Tag>::GetOwningArena(tag);
    if (message_arena != submessage_arena) {
      tag = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tag, submessage_arena);
    }
    
  } else {
    
  }
  tag_ = tag;
  // @@protoc_insertion_point(field_set_allocated:datacatalog.AddTagRequest.tag)
}

// -------------------------------------------------------------------

// AddTagResponse

// -------------------------------------------------------------------

// ListArtifactsRequest

// .datacatalog.DatasetID dataset = 1 [json_name = "dataset"];
inline bool ListArtifactsRequest::_internal_has_dataset() const {
  return this != internal_default_instance() && dataset_ != nullptr;
}
inline bool ListArtifactsRequest::has_dataset() const {
  return _internal_has_dataset();
}
inline void ListArtifactsRequest::clear_dataset() {
  if (GetArenaForAllocation() == nullptr && dataset_ != nullptr) {
    delete dataset_;
  }
  dataset_ = nullptr;
}
inline const ::datacatalog::DatasetID& ListArtifactsRequest::_internal_dataset() const {
  const ::datacatalog::DatasetID* p = dataset_;
  return p != nullptr ? *p : reinterpret_cast<const ::datacatalog::DatasetID&>(
      ::datacatalog::_DatasetID_default_instance_);
}
inline const ::datacatalog::DatasetID& ListArtifactsRequest::dataset() const {
  // @@protoc_insertion_point(field_get:datacatalog.ListArtifactsRequest.dataset)
  return _internal_dataset();
}
inline void ListArtifactsRequest::unsafe_arena_set_allocated_dataset(
    ::datacatalog::DatasetID* dataset) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dataset_);
  }
  dataset_ = dataset;
  if (dataset) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:datacatalog.ListArtifactsRequest.dataset)
}
inline ::datacatalog::DatasetID* ListArtifactsRequest::release_dataset() {
  
  ::datacatalog::DatasetID* temp = dataset_;
  dataset_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::datacatalog::DatasetID* ListArtifactsRequest::unsafe_arena_release_dataset() {
  // @@protoc_insertion_point(field_release:datacatalog.ListArtifactsRequest.dataset)
  
  ::datacatalog::DatasetID* temp = dataset_;
  dataset_ = nullptr;
  return temp;
}
inline ::datacatalog::DatasetID* ListArtifactsRequest::_internal_mutable_dataset() {
  
  if (dataset_ == nullptr) {
    auto* p = CreateMaybeMessage<::datacatalog::DatasetID>(GetArenaForAllocation());
    dataset_ = p;
  }
  return dataset_;
}
inline ::datacatalog::DatasetID* ListArtifactsRequest::mutable_dataset() {
  ::datacatalog::DatasetID* _msg = _internal_mutable_dataset();
  // @@protoc_insertion_point(field_mutable:datacatalog.ListArtifactsRequest.dataset)
  return _msg;
}
inline void ListArtifactsRequest::set_allocated_dataset(::datacatalog::DatasetID* dataset) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete dataset_;
  }
  if (dataset) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::datacatalog::DatasetID>::GetOwningArena(dataset);
    if (message_arena != submessage_arena) {
      dataset = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dataset, submessage_arena);
    }
    
  } else {
    
  }
  dataset_ = dataset;
  // @@protoc_insertion_point(field_set_allocated:datacatalog.ListArtifactsRequest.dataset)
}

// .datacatalog.FilterExpression filter = 2 [json_name = "filter"];
inline bool ListArtifactsRequest::_internal_has_filter() const {
  return this != internal_default_instance() && filter_ != nullptr;
}
inline bool ListArtifactsRequest::has_filter() const {
  return _internal_has_filter();
}
inline void ListArtifactsRequest::clear_filter() {
  if (GetArenaForAllocation() == nullptr && filter_ != nullptr) {
    delete filter_;
  }
  filter_ = nullptr;
}
inline const ::datacatalog::FilterExpression& ListArtifactsRequest::_internal_filter() const {
  const ::datacatalog::FilterExpression* p = filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::datacatalog::FilterExpression&>(
      ::datacatalog::_FilterExpression_default_instance_);
}
inline const ::datacatalog::FilterExpression& ListArtifactsRequest::filter() const {
  // @@protoc_insertion_point(field_get:datacatalog.ListArtifactsRequest.filter)
  return _internal_filter();
}
inline void ListArtifactsRequest::unsafe_arena_set_allocated_filter(
    ::datacatalog::FilterExpression* filter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(filter_);
  }
  filter_ = filter;
  if (filter) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:datacatalog.ListArtifactsRequest.filter)
}
inline ::datacatalog::FilterExpression* ListArtifactsRequest::release_filter() {
  
  ::datacatalog::FilterExpression* temp = filter_;
  filter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::datacatalog::FilterExpression* ListArtifactsRequest::unsafe_arena_release_filter() {
  // @@protoc_insertion_point(field_release:datacatalog.ListArtifactsRequest.filter)
  
  ::datacatalog::FilterExpression* temp = filter_;
  filter_ = nullptr;
  return temp;
}
inline ::datacatalog::FilterExpression* ListArtifactsRequest::_internal_mutable_filter() {
  
  if (filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::datacatalog::FilterExpression>(GetArenaForAllocation());
    filter_ = p;
  }
  return filter_;
}
inline ::datacatalog::FilterExpression* ListArtifactsRequest::mutable_filter() {
  ::datacatalog::FilterExpression* _msg = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:datacatalog.ListArtifactsRequest.filter)
  return _msg;
}
inline void ListArtifactsRequest::set_allocated_filter(::datacatalog::FilterExpression* filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete filter_;
  }
  if (filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::datacatalog::FilterExpression>::GetOwningArena(filter);
    if (message_arena != submessage_arena) {
      filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, filter, submessage_arena);
    }
    
  } else {
    
  }
  filter_ = filter;
  // @@protoc_insertion_point(field_set_allocated:datacatalog.ListArtifactsRequest.filter)
}

// .datacatalog.PaginationOptions pagination = 3 [json_name = "pagination"];
inline bool ListArtifactsRequest::_internal_has_pagination() const {
  return this != internal_default_instance() && pagination_ != nullptr;
}
inline bool ListArtifactsRequest::has_pagination() const {
  return _internal_has_pagination();
}
inline void ListArtifactsRequest::clear_pagination() {
  if (GetArenaForAllocation() == nullptr && pagination_ != nullptr) {
    delete pagination_;
  }
  pagination_ = nullptr;
}
inline const ::datacatalog::PaginationOptions& ListArtifactsRequest::_internal_pagination() const {
  const ::datacatalog::PaginationOptions* p = pagination_;
  return p != nullptr ? *p : reinterpret_cast<const ::datacatalog::PaginationOptions&>(
      ::datacatalog::_PaginationOptions_default_instance_);
}
inline const ::datacatalog::PaginationOptions& ListArtifactsRequest::pagination() const {
  // @@protoc_insertion_point(field_get:datacatalog.ListArtifactsRequest.pagination)
  return _internal_pagination();
}
inline void ListArtifactsRequest::unsafe_arena_set_allocated_pagination(
    ::datacatalog::PaginationOptions* pagination) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pagination_);
  }
  pagination_ = pagination;
  if (pagination) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:datacatalog.ListArtifactsRequest.pagination)
}
inline ::datacatalog::PaginationOptions* ListArtifactsRequest::release_pagination() {
  
  ::datacatalog::PaginationOptions* temp = pagination_;
  pagination_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::datacatalog::PaginationOptions* ListArtifactsRequest::unsafe_arena_release_pagination() {
  // @@protoc_insertion_point(field_release:datacatalog.ListArtifactsRequest.pagination)
  
  ::datacatalog::PaginationOptions* temp = pagination_;
  pagination_ = nullptr;
  return temp;
}
inline ::datacatalog::PaginationOptions* ListArtifactsRequest::_internal_mutable_pagination() {
  
  if (pagination_ == nullptr) {
    auto* p = CreateMaybeMessage<::datacatalog::PaginationOptions>(GetArenaForAllocation());
    pagination_ = p;
  }
  return pagination_;
}
inline ::datacatalog::PaginationOptions* ListArtifactsRequest::mutable_pagination() {
  ::datacatalog::PaginationOptions* _msg = _internal_mutable_pagination();
  // @@protoc_insertion_point(field_mutable:datacatalog.ListArtifactsRequest.pagination)
  return _msg;
}
inline void ListArtifactsRequest::set_allocated_pagination(::datacatalog::PaginationOptions* pagination) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete pagination_;
  }
  if (pagination) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::datacatalog::PaginationOptions>::GetOwningArena(pagination);
    if (message_arena != submessage_arena) {
      pagination = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pagination, submessage_arena);
    }
    
  } else {
    
  }
  pagination_ = pagination;
  // @@protoc_insertion_point(field_set_allocated:datacatalog.ListArtifactsRequest.pagination)
}

// -------------------------------------------------------------------

// ListArtifactsResponse

// repeated .datacatalog.Artifact artifacts = 1 [json_name = "artifacts"];
inline int ListArtifactsResponse::_internal_artifacts_size() const {
  return artifacts_.size();
}
inline int ListArtifactsResponse::artifacts_size() const {
  return _internal_artifacts_size();
}
inline void ListArtifactsResponse::clear_artifacts() {
  artifacts_.Clear();
}
inline ::datacatalog::Artifact* ListArtifactsResponse::mutable_artifacts(int index) {
  // @@protoc_insertion_point(field_mutable:datacatalog.ListArtifactsResponse.artifacts)
  return artifacts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::datacatalog::Artifact >*
ListArtifactsResponse::mutable_artifacts() {
  // @@protoc_insertion_point(field_mutable_list:datacatalog.ListArtifactsResponse.artifacts)
  return &artifacts_;
}
inline const ::datacatalog::Artifact& ListArtifactsResponse::_internal_artifacts(int index) const {
  return artifacts_.Get(index);
}
inline const ::datacatalog::Artifact& ListArtifactsResponse::artifacts(int index) const {
  // @@protoc_insertion_point(field_get:datacatalog.ListArtifactsResponse.artifacts)
  return _internal_artifacts(index);
}
inline ::datacatalog::Artifact* ListArtifactsResponse::_internal_add_artifacts() {
  return artifacts_.Add();
}
inline ::datacatalog::Artifact* ListArtifactsResponse::add_artifacts() {
  ::datacatalog::Artifact* _add = _internal_add_artifacts();
  // @@protoc_insertion_point(field_add:datacatalog.ListArtifactsResponse.artifacts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::datacatalog::Artifact >&
ListArtifactsResponse::artifacts() const {
  // @@protoc_insertion_point(field_list:datacatalog.ListArtifactsResponse.artifacts)
  return artifacts_;
}

// string next_token = 2 [json_name = "nextToken"];
inline void ListArtifactsResponse::clear_next_token() {
  next_token_.ClearToEmpty();
}
inline const std::string& ListArtifactsResponse::next_token() const {
  // @@protoc_insertion_point(field_get:datacatalog.ListArtifactsResponse.next_token)
  return _internal_next_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListArtifactsResponse::set_next_token(ArgT0&& arg0, ArgT... args) {
 
 next_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:datacatalog.ListArtifactsResponse.next_token)
}
inline std::string* ListArtifactsResponse::mutable_next_token() {
  std::string* _s = _internal_mutable_next_token();
  // @@protoc_insertion_point(field_mutable:datacatalog.ListArtifactsResponse.next_token)
  return _s;
}
inline const std::string& ListArtifactsResponse::_internal_next_token() const {
  return next_token_.Get();
}
inline void ListArtifactsResponse::_internal_set_next_token(const std::string& value) {
  
  next_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ListArtifactsResponse::_internal_mutable_next_token() {
  
  return next_token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ListArtifactsResponse::release_next_token() {
  // @@protoc_insertion_point(field_release:datacatalog.ListArtifactsResponse.next_token)
  return next_token_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ListArtifactsResponse::set_allocated_next_token(std::string* next_token) {
  if (next_token != nullptr) {
    
  } else {
    
  }
  next_token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), next_token,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (next_token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    next_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:datacatalog.ListArtifactsResponse.next_token)
}

// -------------------------------------------------------------------

// ListDatasetsRequest

// .datacatalog.FilterExpression filter = 1 [json_name = "filter"];
inline bool ListDatasetsRequest::_internal_has_filter() const {
  return this != internal_default_instance() && filter_ != nullptr;
}
inline bool ListDatasetsRequest::has_filter() const {
  return _internal_has_filter();
}
inline void ListDatasetsRequest::clear_filter() {
  if (GetArenaForAllocation() == nullptr && filter_ != nullptr) {
    delete filter_;
  }
  filter_ = nullptr;
}
inline const ::datacatalog::FilterExpression& ListDatasetsRequest::_internal_filter() const {
  const ::datacatalog::FilterExpression* p = filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::datacatalog::FilterExpression&>(
      ::datacatalog::_FilterExpression_default_instance_);
}
inline const ::datacatalog::FilterExpression& ListDatasetsRequest::filter() const {
  // @@protoc_insertion_point(field_get:datacatalog.ListDatasetsRequest.filter)
  return _internal_filter();
}
inline void ListDatasetsRequest::unsafe_arena_set_allocated_filter(
    ::datacatalog::FilterExpression* filter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(filter_);
  }
  filter_ = filter;
  if (filter) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:datacatalog.ListDatasetsRequest.filter)
}
inline ::datacatalog::FilterExpression* ListDatasetsRequest::release_filter() {
  
  ::datacatalog::FilterExpression* temp = filter_;
  filter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::datacatalog::FilterExpression* ListDatasetsRequest::unsafe_arena_release_filter() {
  // @@protoc_insertion_point(field_release:datacatalog.ListDatasetsRequest.filter)
  
  ::datacatalog::FilterExpression* temp = filter_;
  filter_ = nullptr;
  return temp;
}
inline ::datacatalog::FilterExpression* ListDatasetsRequest::_internal_mutable_filter() {
  
  if (filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::datacatalog::FilterExpression>(GetArenaForAllocation());
    filter_ = p;
  }
  return filter_;
}
inline ::datacatalog::FilterExpression* ListDatasetsRequest::mutable_filter() {
  ::datacatalog::FilterExpression* _msg = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:datacatalog.ListDatasetsRequest.filter)
  return _msg;
}
inline void ListDatasetsRequest::set_allocated_filter(::datacatalog::FilterExpression* filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete filter_;
  }
  if (filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::datacatalog::FilterExpression>::GetOwningArena(filter);
    if (message_arena != submessage_arena) {
      filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, filter, submessage_arena);
    }
    
  } else {
    
  }
  filter_ = filter;
  // @@protoc_insertion_point(field_set_allocated:datacatalog.ListDatasetsRequest.filter)
}

// .datacatalog.PaginationOptions pagination = 2 [json_name = "pagination"];
inline bool ListDatasetsRequest::_internal_has_pagination() const {
  return this != internal_default_instance() && pagination_ != nullptr;
}
inline bool ListDatasetsRequest::has_pagination() const {
  return _internal_has_pagination();
}
inline void ListDatasetsRequest::clear_pagination() {
  if (GetArenaForAllocation() == nullptr && pagination_ != nullptr) {
    delete pagination_;
  }
  pagination_ = nullptr;
}
inline const ::datacatalog::PaginationOptions& ListDatasetsRequest::_internal_pagination() const {
  const ::datacatalog::PaginationOptions* p = pagination_;
  return p != nullptr ? *p : reinterpret_cast<const ::datacatalog::PaginationOptions&>(
      ::datacatalog::_PaginationOptions_default_instance_);
}
inline const ::datacatalog::PaginationOptions& ListDatasetsRequest::pagination() const {
  // @@protoc_insertion_point(field_get:datacatalog.ListDatasetsRequest.pagination)
  return _internal_pagination();
}
inline void ListDatasetsRequest::unsafe_arena_set_allocated_pagination(
    ::datacatalog::PaginationOptions* pagination) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pagination_);
  }
  pagination_ = pagination;
  if (pagination) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:datacatalog.ListDatasetsRequest.pagination)
}
inline ::datacatalog::PaginationOptions* ListDatasetsRequest::release_pagination() {
  
  ::datacatalog::PaginationOptions* temp = pagination_;
  pagination_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::datacatalog::PaginationOptions* ListDatasetsRequest::unsafe_arena_release_pagination() {
  // @@protoc_insertion_point(field_release:datacatalog.ListDatasetsRequest.pagination)
  
  ::datacatalog::PaginationOptions* temp = pagination_;
  pagination_ = nullptr;
  return temp;
}
inline ::datacatalog::PaginationOptions* ListDatasetsRequest::_internal_mutable_pagination() {
  
  if (pagination_ == nullptr) {
    auto* p = CreateMaybeMessage<::datacatalog::PaginationOptions>(GetArenaForAllocation());
    pagination_ = p;
  }
  return pagination_;
}
inline ::datacatalog::PaginationOptions* ListDatasetsRequest::mutable_pagination() {
  ::datacatalog::PaginationOptions* _msg = _internal_mutable_pagination();
  // @@protoc_insertion_point(field_mutable:datacatalog.ListDatasetsRequest.pagination)
  return _msg;
}
inline void ListDatasetsRequest::set_allocated_pagination(::datacatalog::PaginationOptions* pagination) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete pagination_;
  }
  if (pagination) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::datacatalog::PaginationOptions>::GetOwningArena(pagination);
    if (message_arena != submessage_arena) {
      pagination = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pagination, submessage_arena);
    }
    
  } else {
    
  }
  pagination_ = pagination;
  // @@protoc_insertion_point(field_set_allocated:datacatalog.ListDatasetsRequest.pagination)
}

// -------------------------------------------------------------------

// ListDatasetsResponse

// repeated .datacatalog.Dataset datasets = 1 [json_name = "datasets"];
inline int ListDatasetsResponse::_internal_datasets_size() const {
  return datasets_.size();
}
inline int ListDatasetsResponse::datasets_size() const {
  return _internal_datasets_size();
}
inline void ListDatasetsResponse::clear_datasets() {
  datasets_.Clear();
}
inline ::datacatalog::Dataset* ListDatasetsResponse::mutable_datasets(int index) {
  // @@protoc_insertion_point(field_mutable:datacatalog.ListDatasetsResponse.datasets)
  return datasets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::datacatalog::Dataset >*
ListDatasetsResponse::mutable_datasets() {
  // @@protoc_insertion_point(field_mutable_list:datacatalog.ListDatasetsResponse.datasets)
  return &datasets_;
}
inline const ::datacatalog::Dataset& ListDatasetsResponse::_internal_datasets(int index) const {
  return datasets_.Get(index);
}
inline const ::datacatalog::Dataset& ListDatasetsResponse::datasets(int index) const {
  // @@protoc_insertion_point(field_get:datacatalog.ListDatasetsResponse.datasets)
  return _internal_datasets(index);
}
inline ::datacatalog::Dataset* ListDatasetsResponse::_internal_add_datasets() {
  return datasets_.Add();
}
inline ::datacatalog::Dataset* ListDatasetsResponse::add_datasets() {
  ::datacatalog::Dataset* _add = _internal_add_datasets();
  // @@protoc_insertion_point(field_add:datacatalog.ListDatasetsResponse.datasets)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::datacatalog::Dataset >&
ListDatasetsResponse::datasets() const {
  // @@protoc_insertion_point(field_list:datacatalog.ListDatasetsResponse.datasets)
  return datasets_;
}

// string next_token = 2 [json_name = "nextToken"];
inline void ListDatasetsResponse::clear_next_token() {
  next_token_.ClearToEmpty();
}
inline const std::string& ListDatasetsResponse::next_token() const {
  // @@protoc_insertion_point(field_get:datacatalog.ListDatasetsResponse.next_token)
  return _internal_next_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListDatasetsResponse::set_next_token(ArgT0&& arg0, ArgT... args) {
 
 next_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:datacatalog.ListDatasetsResponse.next_token)
}
inline std::string* ListDatasetsResponse::mutable_next_token() {
  std::string* _s = _internal_mutable_next_token();
  // @@protoc_insertion_point(field_mutable:datacatalog.ListDatasetsResponse.next_token)
  return _s;
}
inline const std::string& ListDatasetsResponse::_internal_next_token() const {
  return next_token_.Get();
}
inline void ListDatasetsResponse::_internal_set_next_token(const std::string& value) {
  
  next_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ListDatasetsResponse::_internal_mutable_next_token() {
  
  return next_token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ListDatasetsResponse::release_next_token() {
  // @@protoc_insertion_point(field_release:datacatalog.ListDatasetsResponse.next_token)
  return next_token_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ListDatasetsResponse::set_allocated_next_token(std::string* next_token) {
  if (next_token != nullptr) {
    
  } else {
    
  }
  next_token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), next_token,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (next_token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    next_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:datacatalog.ListDatasetsResponse.next_token)
}

// -------------------------------------------------------------------

// ReservationID

// .datacatalog.DatasetID dataset_id = 1 [json_name = "datasetId"];
inline bool ReservationID::_internal_has_dataset_id() const {
  return this != internal_default_instance() && dataset_id_ != nullptr;
}
inline bool ReservationID::has_dataset_id() const {
  return _internal_has_dataset_id();
}
inline void ReservationID::clear_dataset_id() {
  if (GetArenaForAllocation() == nullptr && dataset_id_ != nullptr) {
    delete dataset_id_;
  }
  dataset_id_ = nullptr;
}
inline const ::datacatalog::DatasetID& ReservationID::_internal_dataset_id() const {
  const ::datacatalog::DatasetID* p = dataset_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::datacatalog::DatasetID&>(
      ::datacatalog::_DatasetID_default_instance_);
}
inline const ::datacatalog::DatasetID& ReservationID::dataset_id() const {
  // @@protoc_insertion_point(field_get:datacatalog.ReservationID.dataset_id)
  return _internal_dataset_id();
}
inline void ReservationID::unsafe_arena_set_allocated_dataset_id(
    ::datacatalog::DatasetID* dataset_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dataset_id_);
  }
  dataset_id_ = dataset_id;
  if (dataset_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:datacatalog.ReservationID.dataset_id)
}
inline ::datacatalog::DatasetID* ReservationID::release_dataset_id() {
  
  ::datacatalog::DatasetID* temp = dataset_id_;
  dataset_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::datacatalog::DatasetID* ReservationID::unsafe_arena_release_dataset_id() {
  // @@protoc_insertion_point(field_release:datacatalog.ReservationID.dataset_id)
  
  ::datacatalog::DatasetID* temp = dataset_id_;
  dataset_id_ = nullptr;
  return temp;
}
inline ::datacatalog::DatasetID* ReservationID::_internal_mutable_dataset_id() {
  
  if (dataset_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::datacatalog::DatasetID>(GetArenaForAllocation());
    dataset_id_ = p;
  }
  return dataset_id_;
}
inline ::datacatalog::DatasetID* ReservationID::mutable_dataset_id() {
  ::datacatalog::DatasetID* _msg = _internal_mutable_dataset_id();
  // @@protoc_insertion_point(field_mutable:datacatalog.ReservationID.dataset_id)
  return _msg;
}
inline void ReservationID::set_allocated_dataset_id(::datacatalog::DatasetID* dataset_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete dataset_id_;
  }
  if (dataset_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::datacatalog::DatasetID>::GetOwningArena(dataset_id);
    if (message_arena != submessage_arena) {
      dataset_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dataset_id, submessage_arena);
    }
    
  } else {
    
  }
  dataset_id_ = dataset_id;
  // @@protoc_insertion_point(field_set_allocated:datacatalog.ReservationID.dataset_id)
}

// string tag_name = 2 [json_name = "tagName"];
inline void ReservationID::clear_tag_name() {
  tag_name_.ClearToEmpty();
}
inline const std::string& ReservationID::tag_name() const {
  // @@protoc_insertion_point(field_get:datacatalog.ReservationID.tag_name)
  return _internal_tag_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReservationID::set_tag_name(ArgT0&& arg0, ArgT... args) {
 
 tag_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:datacatalog.ReservationID.tag_name)
}
inline std::string* ReservationID::mutable_tag_name() {
  std::string* _s = _internal_mutable_tag_name();
  // @@protoc_insertion_point(field_mutable:datacatalog.ReservationID.tag_name)
  return _s;
}
inline const std::string& ReservationID::_internal_tag_name() const {
  return tag_name_.Get();
}
inline void ReservationID::_internal_set_tag_name(const std::string& value) {
  
  tag_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ReservationID::_internal_mutable_tag_name() {
  
  return tag_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ReservationID::release_tag_name() {
  // @@protoc_insertion_point(field_release:datacatalog.ReservationID.tag_name)
  return tag_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ReservationID::set_allocated_tag_name(std::string* tag_name) {
  if (tag_name != nullptr) {
    
  } else {
    
  }
  tag_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tag_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tag_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    tag_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:datacatalog.ReservationID.tag_name)
}

// -------------------------------------------------------------------

// GetOrExtendReservationRequest

// .datacatalog.ReservationID reservation_id = 1 [json_name = "reservationId"];
inline bool GetOrExtendReservationRequest::_internal_has_reservation_id() const {
  return this != internal_default_instance() && reservation_id_ != nullptr;
}
inline bool GetOrExtendReservationRequest::has_reservation_id() const {
  return _internal_has_reservation_id();
}
inline void GetOrExtendReservationRequest::clear_reservation_id() {
  if (GetArenaForAllocation() == nullptr && reservation_id_ != nullptr) {
    delete reservation_id_;
  }
  reservation_id_ = nullptr;
}
inline const ::datacatalog::ReservationID& GetOrExtendReservationRequest::_internal_reservation_id() const {
  const ::datacatalog::ReservationID* p = reservation_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::datacatalog::ReservationID&>(
      ::datacatalog::_ReservationID_default_instance_);
}
inline const ::datacatalog::ReservationID& GetOrExtendReservationRequest::reservation_id() const {
  // @@protoc_insertion_point(field_get:datacatalog.GetOrExtendReservationRequest.reservation_id)
  return _internal_reservation_id();
}
inline void GetOrExtendReservationRequest::unsafe_arena_set_allocated_reservation_id(
    ::datacatalog::ReservationID* reservation_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(reservation_id_);
  }
  reservation_id_ = reservation_id;
  if (reservation_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:datacatalog.GetOrExtendReservationRequest.reservation_id)
}
inline ::datacatalog::ReservationID* GetOrExtendReservationRequest::release_reservation_id() {
  
  ::datacatalog::ReservationID* temp = reservation_id_;
  reservation_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::datacatalog::ReservationID* GetOrExtendReservationRequest::unsafe_arena_release_reservation_id() {
  // @@protoc_insertion_point(field_release:datacatalog.GetOrExtendReservationRequest.reservation_id)
  
  ::datacatalog::ReservationID* temp = reservation_id_;
  reservation_id_ = nullptr;
  return temp;
}
inline ::datacatalog::ReservationID* GetOrExtendReservationRequest::_internal_mutable_reservation_id() {
  
  if (reservation_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::datacatalog::ReservationID>(GetArenaForAllocation());
    reservation_id_ = p;
  }
  return reservation_id_;
}
inline ::datacatalog::ReservationID* GetOrExtendReservationRequest::mutable_reservation_id() {
  ::datacatalog::ReservationID* _msg = _internal_mutable_reservation_id();
  // @@protoc_insertion_point(field_mutable:datacatalog.GetOrExtendReservationRequest.reservation_id)
  return _msg;
}
inline void GetOrExtendReservationRequest::set_allocated_reservation_id(::datacatalog::ReservationID* reservation_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reservation_id_;
  }
  if (reservation_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::datacatalog::ReservationID>::GetOwningArena(reservation_id);
    if (message_arena != submessage_arena) {
      reservation_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reservation_id, submessage_arena);
    }
    
  } else {
    
  }
  reservation_id_ = reservation_id;
  // @@protoc_insertion_point(field_set_allocated:datacatalog.GetOrExtendReservationRequest.reservation_id)
}

// string owner_id = 2 [json_name = "ownerId"];
inline void GetOrExtendReservationRequest::clear_owner_id() {
  owner_id_.ClearToEmpty();
}
inline const std::string& GetOrExtendReservationRequest::owner_id() const {
  // @@protoc_insertion_point(field_get:datacatalog.GetOrExtendReservationRequest.owner_id)
  return _internal_owner_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetOrExtendReservationRequest::set_owner_id(ArgT0&& arg0, ArgT... args) {
 
 owner_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:datacatalog.GetOrExtendReservationRequest.owner_id)
}
inline std::string* GetOrExtendReservationRequest::mutable_owner_id() {
  std::string* _s = _internal_mutable_owner_id();
  // @@protoc_insertion_point(field_mutable:datacatalog.GetOrExtendReservationRequest.owner_id)
  return _s;
}
inline const std::string& GetOrExtendReservationRequest::_internal_owner_id() const {
  return owner_id_.Get();
}
inline void GetOrExtendReservationRequest::_internal_set_owner_id(const std::string& value) {
  
  owner_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetOrExtendReservationRequest::_internal_mutable_owner_id() {
  
  return owner_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetOrExtendReservationRequest::release_owner_id() {
  // @@protoc_insertion_point(field_release:datacatalog.GetOrExtendReservationRequest.owner_id)
  return owner_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetOrExtendReservationRequest::set_allocated_owner_id(std::string* owner_id) {
  if (owner_id != nullptr) {
    
  } else {
    
  }
  owner_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), owner_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (owner_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    owner_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:datacatalog.GetOrExtendReservationRequest.owner_id)
}

// .google.protobuf.Duration heartbeat_interval = 3 [json_name = "heartbeatInterval"];
inline bool GetOrExtendReservationRequest::_internal_has_heartbeat_interval() const {
  return this != internal_default_instance() && heartbeat_interval_ != nullptr;
}
inline bool GetOrExtendReservationRequest::has_heartbeat_interval() const {
  return _internal_has_heartbeat_interval();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& GetOrExtendReservationRequest::_internal_heartbeat_interval() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = heartbeat_interval_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& GetOrExtendReservationRequest::heartbeat_interval() const {
  // @@protoc_insertion_point(field_get:datacatalog.GetOrExtendReservationRequest.heartbeat_interval)
  return _internal_heartbeat_interval();
}
inline void GetOrExtendReservationRequest::unsafe_arena_set_allocated_heartbeat_interval(
    ::PROTOBUF_NAMESPACE_ID::Duration* heartbeat_interval) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(heartbeat_interval_);
  }
  heartbeat_interval_ = heartbeat_interval;
  if (heartbeat_interval) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:datacatalog.GetOrExtendReservationRequest.heartbeat_interval)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* GetOrExtendReservationRequest::release_heartbeat_interval() {
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = heartbeat_interval_;
  heartbeat_interval_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* GetOrExtendReservationRequest::unsafe_arena_release_heartbeat_interval() {
  // @@protoc_insertion_point(field_release:datacatalog.GetOrExtendReservationRequest.heartbeat_interval)
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = heartbeat_interval_;
  heartbeat_interval_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* GetOrExtendReservationRequest::_internal_mutable_heartbeat_interval() {
  
  if (heartbeat_interval_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    heartbeat_interval_ = p;
  }
  return heartbeat_interval_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* GetOrExtendReservationRequest::mutable_heartbeat_interval() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_heartbeat_interval();
  // @@protoc_insertion_point(field_mutable:datacatalog.GetOrExtendReservationRequest.heartbeat_interval)
  return _msg;
}
inline void GetOrExtendReservationRequest::set_allocated_heartbeat_interval(::PROTOBUF_NAMESPACE_ID::Duration* heartbeat_interval) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(heartbeat_interval_);
  }
  if (heartbeat_interval) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(heartbeat_interval));
    if (message_arena != submessage_arena) {
      heartbeat_interval = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, heartbeat_interval, submessage_arena);
    }
    
  } else {
    
  }
  heartbeat_interval_ = heartbeat_interval;
  // @@protoc_insertion_point(field_set_allocated:datacatalog.GetOrExtendReservationRequest.heartbeat_interval)
}

// -------------------------------------------------------------------

// Reservation

// .datacatalog.ReservationID reservation_id = 1 [json_name = "reservationId"];
inline bool Reservation::_internal_has_reservation_id() const {
  return this != internal_default_instance() && reservation_id_ != nullptr;
}
inline bool Reservation::has_reservation_id() const {
  return _internal_has_reservation_id();
}
inline void Reservation::clear_reservation_id() {
  if (GetArenaForAllocation() == nullptr && reservation_id_ != nullptr) {
    delete reservation_id_;
  }
  reservation_id_ = nullptr;
}
inline const ::datacatalog::ReservationID& Reservation::_internal_reservation_id() const {
  const ::datacatalog::ReservationID* p = reservation_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::datacatalog::ReservationID&>(
      ::datacatalog::_ReservationID_default_instance_);
}
inline const ::datacatalog::ReservationID& Reservation::reservation_id() const {
  // @@protoc_insertion_point(field_get:datacatalog.Reservation.reservation_id)
  return _internal_reservation_id();
}
inline void Reservation::unsafe_arena_set_allocated_reservation_id(
    ::datacatalog::ReservationID* reservation_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(reservation_id_);
  }
  reservation_id_ = reservation_id;
  if (reservation_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:datacatalog.Reservation.reservation_id)
}
inline ::datacatalog::ReservationID* Reservation::release_reservation_id() {
  
  ::datacatalog::ReservationID* temp = reservation_id_;
  reservation_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::datacatalog::ReservationID* Reservation::unsafe_arena_release_reservation_id() {
  // @@protoc_insertion_point(field_release:datacatalog.Reservation.reservation_id)
  
  ::datacatalog::ReservationID* temp = reservation_id_;
  reservation_id_ = nullptr;
  return temp;
}
inline ::datacatalog::ReservationID* Reservation::_internal_mutable_reservation_id() {
  
  if (reservation_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::datacatalog::ReservationID>(GetArenaForAllocation());
    reservation_id_ = p;
  }
  return reservation_id_;
}
inline ::datacatalog::ReservationID* Reservation::mutable_reservation_id() {
  ::datacatalog::ReservationID* _msg = _internal_mutable_reservation_id();
  // @@protoc_insertion_point(field_mutable:datacatalog.Reservation.reservation_id)
  return _msg;
}
inline void Reservation::set_allocated_reservation_id(::datacatalog::ReservationID* reservation_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reservation_id_;
  }
  if (reservation_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::datacatalog::ReservationID>::GetOwningArena(reservation_id);
    if (message_arena != submessage_arena) {
      reservation_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reservation_id, submessage_arena);
    }
    
  } else {
    
  }
  reservation_id_ = reservation_id;
  // @@protoc_insertion_point(field_set_allocated:datacatalog.Reservation.reservation_id)
}

// string owner_id = 2 [json_name = "ownerId"];
inline void Reservation::clear_owner_id() {
  owner_id_.ClearToEmpty();
}
inline const std::string& Reservation::owner_id() const {
  // @@protoc_insertion_point(field_get:datacatalog.Reservation.owner_id)
  return _internal_owner_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Reservation::set_owner_id(ArgT0&& arg0, ArgT... args) {
 
 owner_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:datacatalog.Reservation.owner_id)
}
inline std::string* Reservation::mutable_owner_id() {
  std::string* _s = _internal_mutable_owner_id();
  // @@protoc_insertion_point(field_mutable:datacatalog.Reservation.owner_id)
  return _s;
}
inline const std::string& Reservation::_internal_owner_id() const {
  return owner_id_.Get();
}
inline void Reservation::_internal_set_owner_id(const std::string& value) {
  
  owner_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Reservation::_internal_mutable_owner_id() {
  
  return owner_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Reservation::release_owner_id() {
  // @@protoc_insertion_point(field_release:datacatalog.Reservation.owner_id)
  return owner_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Reservation::set_allocated_owner_id(std::string* owner_id) {
  if (owner_id != nullptr) {
    
  } else {
    
  }
  owner_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), owner_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (owner_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    owner_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:datacatalog.Reservation.owner_id)
}

// .google.protobuf.Duration heartbeat_interval = 3 [json_name = "heartbeatInterval"];
inline bool Reservation::_internal_has_heartbeat_interval() const {
  return this != internal_default_instance() && heartbeat_interval_ != nullptr;
}
inline bool Reservation::has_heartbeat_interval() const {
  return _internal_has_heartbeat_interval();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& Reservation::_internal_heartbeat_interval() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = heartbeat_interval_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& Reservation::heartbeat_interval() const {
  // @@protoc_insertion_point(field_get:datacatalog.Reservation.heartbeat_interval)
  return _internal_heartbeat_interval();
}
inline void Reservation::unsafe_arena_set_allocated_heartbeat_interval(
    ::PROTOBUF_NAMESPACE_ID::Duration* heartbeat_interval) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(heartbeat_interval_);
  }
  heartbeat_interval_ = heartbeat_interval;
  if (heartbeat_interval) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:datacatalog.Reservation.heartbeat_interval)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* Reservation::release_heartbeat_interval() {
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = heartbeat_interval_;
  heartbeat_interval_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* Reservation::unsafe_arena_release_heartbeat_interval() {
  // @@protoc_insertion_point(field_release:datacatalog.Reservation.heartbeat_interval)
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = heartbeat_interval_;
  heartbeat_interval_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* Reservation::_internal_mutable_heartbeat_interval() {
  
  if (heartbeat_interval_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    heartbeat_interval_ = p;
  }
  return heartbeat_interval_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* Reservation::mutable_heartbeat_interval() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_heartbeat_interval();
  // @@protoc_insertion_point(field_mutable:datacatalog.Reservation.heartbeat_interval)
  return _msg;
}
inline void Reservation::set_allocated_heartbeat_interval(::PROTOBUF_NAMESPACE_ID::Duration* heartbeat_interval) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(heartbeat_interval_);
  }
  if (heartbeat_interval) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(heartbeat_interval));
    if (message_arena != submessage_arena) {
      heartbeat_interval = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, heartbeat_interval, submessage_arena);
    }
    
  } else {
    
  }
  heartbeat_interval_ = heartbeat_interval;
  // @@protoc_insertion_point(field_set_allocated:datacatalog.Reservation.heartbeat_interval)
}

// .google.protobuf.Timestamp expires_at = 4 [json_name = "expiresAt"];
inline bool Reservation::_internal_has_expires_at() const {
  return this != internal_default_instance() && expires_at_ != nullptr;
}
inline bool Reservation::has_expires_at() const {
  return _internal_has_expires_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Reservation::_internal_expires_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = expires_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Reservation::expires_at() const {
  // @@protoc_insertion_point(field_get:datacatalog.Reservation.expires_at)
  return _internal_expires_at();
}
inline void Reservation::unsafe_arena_set_allocated_expires_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* expires_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(expires_at_);
  }
  expires_at_ = expires_at;
  if (expires_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:datacatalog.Reservation.expires_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Reservation::release_expires_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = expires_at_;
  expires_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Reservation::unsafe_arena_release_expires_at() {
  // @@protoc_insertion_point(field_release:datacatalog.Reservation.expires_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = expires_at_;
  expires_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Reservation::_internal_mutable_expires_at() {
  
  if (expires_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    expires_at_ = p;
  }
  return expires_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Reservation::mutable_expires_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_expires_at();
  // @@protoc_insertion_point(field_mutable:datacatalog.Reservation.expires_at)
  return _msg;
}
inline void Reservation::set_allocated_expires_at(::PROTOBUF_NAMESPACE_ID::Timestamp* expires_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(expires_at_);
  }
  if (expires_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(expires_at));
    if (message_arena != submessage_arena) {
      expires_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, expires_at, submessage_arena);
    }
    
  } else {
    
  }
  expires_at_ = expires_at;
  // @@protoc_insertion_point(field_set_allocated:datacatalog.Reservation.expires_at)
}

// .datacatalog.Metadata metadata = 6 [json_name = "metadata"];
inline bool Reservation::_internal_has_metadata() const {
  return this != internal_default_instance() && metadata_ != nullptr;
}
inline bool Reservation::has_metadata() const {
  return _internal_has_metadata();
}
inline void Reservation::clear_metadata() {
  if (GetArenaForAllocation() == nullptr && metadata_ != nullptr) {
    delete metadata_;
  }
  metadata_ = nullptr;
}
inline const ::datacatalog::Metadata& Reservation::_internal_metadata() const {
  const ::datacatalog::Metadata* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::datacatalog::Metadata&>(
      ::datacatalog::_Metadata_default_instance_);
}
inline const ::datacatalog::Metadata& Reservation::metadata() const {
  // @@protoc_insertion_point(field_get:datacatalog.Reservation.metadata)
  return _internal_metadata();
}
inline void Reservation::unsafe_arena_set_allocated_metadata(
    ::datacatalog::Metadata* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:datacatalog.Reservation.metadata)
}
inline ::datacatalog::Metadata* Reservation::release_metadata() {
  
  ::datacatalog::Metadata* temp = metadata_;
  metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::datacatalog::Metadata* Reservation::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:datacatalog.Reservation.metadata)
  
  ::datacatalog::Metadata* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::datacatalog::Metadata* Reservation::_internal_mutable_metadata() {
  
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::datacatalog::Metadata>(GetArenaForAllocation());
    metadata_ = p;
  }
  return metadata_;
}
inline ::datacatalog::Metadata* Reservation::mutable_metadata() {
  ::datacatalog::Metadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:datacatalog.Reservation.metadata)
  return _msg;
}
inline void Reservation::set_allocated_metadata(::datacatalog::Metadata* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete metadata_;
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::datacatalog::Metadata>::GetOwningArena(metadata);
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:datacatalog.Reservation.metadata)
}

// -------------------------------------------------------------------

// GetOrExtendReservationResponse

// .datacatalog.Reservation reservation = 1 [json_name = "reservation"];
inline bool GetOrExtendReservationResponse::_internal_has_reservation() const {
  return this != internal_default_instance() && reservation_ != nullptr;
}
inline bool GetOrExtendReservationResponse::has_reservation() const {
  return _internal_has_reservation();
}
inline void GetOrExtendReservationResponse::clear_reservation() {
  if (GetArenaForAllocation() == nullptr && reservation_ != nullptr) {
    delete reservation_;
  }
  reservation_ = nullptr;
}
inline const ::datacatalog::Reservation& GetOrExtendReservationResponse::_internal_reservation() const {
  const ::datacatalog::Reservation* p = reservation_;
  return p != nullptr ? *p : reinterpret_cast<const ::datacatalog::Reservation&>(
      ::datacatalog::_Reservation_default_instance_);
}
inline const ::datacatalog::Reservation& GetOrExtendReservationResponse::reservation() const {
  // @@protoc_insertion_point(field_get:datacatalog.GetOrExtendReservationResponse.reservation)
  return _internal_reservation();
}
inline void GetOrExtendReservationResponse::unsafe_arena_set_allocated_reservation(
    ::datacatalog::Reservation* reservation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(reservation_);
  }
  reservation_ = reservation;
  if (reservation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:datacatalog.GetOrExtendReservationResponse.reservation)
}
inline ::datacatalog::Reservation* GetOrExtendReservationResponse::release_reservation() {
  
  ::datacatalog::Reservation* temp = reservation_;
  reservation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::datacatalog::Reservation* GetOrExtendReservationResponse::unsafe_arena_release_reservation() {
  // @@protoc_insertion_point(field_release:datacatalog.GetOrExtendReservationResponse.reservation)
  
  ::datacatalog::Reservation* temp = reservation_;
  reservation_ = nullptr;
  return temp;
}
inline ::datacatalog::Reservation* GetOrExtendReservationResponse::_internal_mutable_reservation() {
  
  if (reservation_ == nullptr) {
    auto* p = CreateMaybeMessage<::datacatalog::Reservation>(GetArenaForAllocation());
    reservation_ = p;
  }
  return reservation_;
}
inline ::datacatalog::Reservation* GetOrExtendReservationResponse::mutable_reservation() {
  ::datacatalog::Reservation* _msg = _internal_mutable_reservation();
  // @@protoc_insertion_point(field_mutable:datacatalog.GetOrExtendReservationResponse.reservation)
  return _msg;
}
inline void GetOrExtendReservationResponse::set_allocated_reservation(::datacatalog::Reservation* reservation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reservation_;
  }
  if (reservation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::datacatalog::Reservation>::GetOwningArena(reservation);
    if (message_arena != submessage_arena) {
      reservation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reservation, submessage_arena);
    }
    
  } else {
    
  }
  reservation_ = reservation;
  // @@protoc_insertion_point(field_set_allocated:datacatalog.GetOrExtendReservationResponse.reservation)
}

// -------------------------------------------------------------------

// ReleaseReservationRequest

// .datacatalog.ReservationID reservation_id = 1 [json_name = "reservationId"];
inline bool ReleaseReservationRequest::_internal_has_reservation_id() const {
  return this != internal_default_instance() && reservation_id_ != nullptr;
}
inline bool ReleaseReservationRequest::has_reservation_id() const {
  return _internal_has_reservation_id();
}
inline void ReleaseReservationRequest::clear_reservation_id() {
  if (GetArenaForAllocation() == nullptr && reservation_id_ != nullptr) {
    delete reservation_id_;
  }
  reservation_id_ = nullptr;
}
inline const ::datacatalog::ReservationID& ReleaseReservationRequest::_internal_reservation_id() const {
  const ::datacatalog::ReservationID* p = reservation_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::datacatalog::ReservationID&>(
      ::datacatalog::_ReservationID_default_instance_);
}
inline const ::datacatalog::ReservationID& ReleaseReservationRequest::reservation_id() const {
  // @@protoc_insertion_point(field_get:datacatalog.ReleaseReservationRequest.reservation_id)
  return _internal_reservation_id();
}
inline void ReleaseReservationRequest::unsafe_arena_set_allocated_reservation_id(
    ::datacatalog::ReservationID* reservation_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(reservation_id_);
  }
  reservation_id_ = reservation_id;
  if (reservation_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:datacatalog.ReleaseReservationRequest.reservation_id)
}
inline ::datacatalog::ReservationID* ReleaseReservationRequest::release_reservation_id() {
  
  ::datacatalog::ReservationID* temp = reservation_id_;
  reservation_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::datacatalog::ReservationID* ReleaseReservationRequest::unsafe_arena_release_reservation_id() {
  // @@protoc_insertion_point(field_release:datacatalog.ReleaseReservationRequest.reservation_id)
  
  ::datacatalog::ReservationID* temp = reservation_id_;
  reservation_id_ = nullptr;
  return temp;
}
inline ::datacatalog::ReservationID* ReleaseReservationRequest::_internal_mutable_reservation_id() {
  
  if (reservation_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::datacatalog::ReservationID>(GetArenaForAllocation());
    reservation_id_ = p;
  }
  return reservation_id_;
}
inline ::datacatalog::ReservationID* ReleaseReservationRequest::mutable_reservation_id() {
  ::datacatalog::ReservationID* _msg = _internal_mutable_reservation_id();
  // @@protoc_insertion_point(field_mutable:datacatalog.ReleaseReservationRequest.reservation_id)
  return _msg;
}
inline void ReleaseReservationRequest::set_allocated_reservation_id(::datacatalog::ReservationID* reservation_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reservation_id_;
  }
  if (reservation_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::datacatalog::ReservationID>::GetOwningArena(reservation_id);
    if (message_arena != submessage_arena) {
      reservation_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reservation_id, submessage_arena);
    }
    
  } else {
    
  }
  reservation_id_ = reservation_id;
  // @@protoc_insertion_point(field_set_allocated:datacatalog.ReleaseReservationRequest.reservation_id)
}

// string owner_id = 2 [json_name = "ownerId"];
inline void ReleaseReservationRequest::clear_owner_id() {
  owner_id_.ClearToEmpty();
}
inline const std::string& ReleaseReservationRequest::owner_id() const {
  // @@protoc_insertion_point(field_get:datacatalog.ReleaseReservationRequest.owner_id)
  return _internal_owner_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReleaseReservationRequest::set_owner_id(ArgT0&& arg0, ArgT... args) {
 
 owner_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:datacatalog.ReleaseReservationRequest.owner_id)
}
inline std::string* ReleaseReservationRequest::mutable_owner_id() {
  std::string* _s = _internal_mutable_owner_id();
  // @@protoc_insertion_point(field_mutable:datacatalog.ReleaseReservationRequest.owner_id)
  return _s;
}
inline const std::string& ReleaseReservationRequest::_internal_owner_id() const {
  return owner_id_.Get();
}
inline void ReleaseReservationRequest::_internal_set_owner_id(const std::string& value) {
  
  owner_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ReleaseReservationRequest::_internal_mutable_owner_id() {
  
  return owner_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ReleaseReservationRequest::release_owner_id() {
  // @@protoc_insertion_point(field_release:datacatalog.ReleaseReservationRequest.owner_id)
  return owner_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ReleaseReservationRequest::set_allocated_owner_id(std::string* owner_id) {
  if (owner_id != nullptr) {
    
  } else {
    
  }
  owner_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), owner_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (owner_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    owner_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:datacatalog.ReleaseReservationRequest.owner_id)
}

// -------------------------------------------------------------------

// ReleaseReservationResponse

// -------------------------------------------------------------------

// Dataset

// .datacatalog.DatasetID id = 1 [json_name = "id"];
inline bool Dataset::_internal_has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline bool Dataset::has_id() const {
  return _internal_has_id();
}
inline void Dataset::clear_id() {
  if (GetArenaForAllocation() == nullptr && id_ != nullptr) {
    delete id_;
  }
  id_ = nullptr;
}
inline const ::datacatalog::DatasetID& Dataset::_internal_id() const {
  const ::datacatalog::DatasetID* p = id_;
  return p != nullptr ? *p : reinterpret_cast<const ::datacatalog::DatasetID&>(
      ::datacatalog::_DatasetID_default_instance_);
}
inline const ::datacatalog::DatasetID& Dataset::id() const {
  // @@protoc_insertion_point(field_get:datacatalog.Dataset.id)
  return _internal_id();
}
inline void Dataset::unsafe_arena_set_allocated_id(
    ::datacatalog::DatasetID* id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:datacatalog.Dataset.id)
}
inline ::datacatalog::DatasetID* Dataset::release_id() {
  
  ::datacatalog::DatasetID* temp = id_;
  id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::datacatalog::DatasetID* Dataset::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:datacatalog.Dataset.id)
  
  ::datacatalog::DatasetID* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::datacatalog::DatasetID* Dataset::_internal_mutable_id() {
  
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::datacatalog::DatasetID>(GetArenaForAllocation());
    id_ = p;
  }
  return id_;
}
inline ::datacatalog::DatasetID* Dataset::mutable_id() {
  ::datacatalog::DatasetID* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:datacatalog.Dataset.id)
  return _msg;
}
inline void Dataset::set_allocated_id(::datacatalog::DatasetID* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete id_;
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::datacatalog::DatasetID>::GetOwningArena(id);
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:datacatalog.Dataset.id)
}

// .datacatalog.Metadata metadata = 2 [json_name = "metadata"];
inline bool Dataset::_internal_has_metadata() const {
  return this != internal_default_instance() && metadata_ != nullptr;
}
inline bool Dataset::has_metadata() const {
  return _internal_has_metadata();
}
inline void Dataset::clear_metadata() {
  if (GetArenaForAllocation() == nullptr && metadata_ != nullptr) {
    delete metadata_;
  }
  metadata_ = nullptr;
}
inline const ::datacatalog::Metadata& Dataset::_internal_metadata() const {
  const ::datacatalog::Metadata* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::datacatalog::Metadata&>(
      ::datacatalog::_Metadata_default_instance_);
}
inline const ::datacatalog::Metadata& Dataset::metadata() const {
  // @@protoc_insertion_point(field_get:datacatalog.Dataset.metadata)
  return _internal_metadata();
}
inline void Dataset::unsafe_arena_set_allocated_metadata(
    ::datacatalog::Metadata* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:datacatalog.Dataset.metadata)
}
inline ::datacatalog::Metadata* Dataset::release_metadata() {
  
  ::datacatalog::Metadata* temp = metadata_;
  metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::datacatalog::Metadata* Dataset::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:datacatalog.Dataset.metadata)
  
  ::datacatalog::Metadata* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::datacatalog::Metadata* Dataset::_internal_mutable_metadata() {
  
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::datacatalog::Metadata>(GetArenaForAllocation());
    metadata_ = p;
  }
  return metadata_;
}
inline ::datacatalog::Metadata* Dataset::mutable_metadata() {
  ::datacatalog::Metadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:datacatalog.Dataset.metadata)
  return _msg;
}
inline void Dataset::set_allocated_metadata(::datacatalog::Metadata* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete metadata_;
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::datacatalog::Metadata>::GetOwningArena(metadata);
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:datacatalog.Dataset.metadata)
}

// repeated string partitionKeys = 3 [json_name = "partitionKeys"];
inline int Dataset::_internal_partitionkeys_size() const {
  return partitionkeys_.size();
}
inline int Dataset::partitionkeys_size() const {
  return _internal_partitionkeys_size();
}
inline void Dataset::clear_partitionkeys() {
  partitionkeys_.Clear();
}
inline std::string* Dataset::add_partitionkeys() {
  std::string* _s = _internal_add_partitionkeys();
  // @@protoc_insertion_point(field_add_mutable:datacatalog.Dataset.partitionKeys)
  return _s;
}
inline const std::string& Dataset::_internal_partitionkeys(int index) const {
  return partitionkeys_.Get(index);
}
inline const std::string& Dataset::partitionkeys(int index) const {
  // @@protoc_insertion_point(field_get:datacatalog.Dataset.partitionKeys)
  return _internal_partitionkeys(index);
}
inline std::string* Dataset::mutable_partitionkeys(int index) {
  // @@protoc_insertion_point(field_mutable:datacatalog.Dataset.partitionKeys)
  return partitionkeys_.Mutable(index);
}
inline void Dataset::set_partitionkeys(int index, const std::string& value) {
  partitionkeys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:datacatalog.Dataset.partitionKeys)
}
inline void Dataset::set_partitionkeys(int index, std::string&& value) {
  partitionkeys_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:datacatalog.Dataset.partitionKeys)
}
inline void Dataset::set_partitionkeys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  partitionkeys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:datacatalog.Dataset.partitionKeys)
}
inline void Dataset::set_partitionkeys(int index, const char* value, size_t size) {
  partitionkeys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:datacatalog.Dataset.partitionKeys)
}
inline std::string* Dataset::_internal_add_partitionkeys() {
  return partitionkeys_.Add();
}
inline void Dataset::add_partitionkeys(const std::string& value) {
  partitionkeys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:datacatalog.Dataset.partitionKeys)
}
inline void Dataset::add_partitionkeys(std::string&& value) {
  partitionkeys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:datacatalog.Dataset.partitionKeys)
}
inline void Dataset::add_partitionkeys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  partitionkeys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:datacatalog.Dataset.partitionKeys)
}
inline void Dataset::add_partitionkeys(const char* value, size_t size) {
  partitionkeys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:datacatalog.Dataset.partitionKeys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Dataset::partitionkeys() const {
  // @@protoc_insertion_point(field_list:datacatalog.Dataset.partitionKeys)
  return partitionkeys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Dataset::mutable_partitionkeys() {
  // @@protoc_insertion_point(field_mutable_list:datacatalog.Dataset.partitionKeys)
  return &partitionkeys_;
}

// -------------------------------------------------------------------

// Partition

// string key = 1 [json_name = "key"];
inline void Partition::clear_key() {
  key_.ClearToEmpty();
}
inline const std::string& Partition::key() const {
  // @@protoc_insertion_point(field_get:datacatalog.Partition.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Partition::set_key(ArgT0&& arg0, ArgT... args) {
 
 key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:datacatalog.Partition.key)
}
inline std::string* Partition::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:datacatalog.Partition.key)
  return _s;
}
inline const std::string& Partition::_internal_key() const {
  return key_.Get();
}
inline void Partition::_internal_set_key(const std::string& value) {
  
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Partition::_internal_mutable_key() {
  
  return key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Partition::release_key() {
  // @@protoc_insertion_point(field_release:datacatalog.Partition.key)
  return key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Partition::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:datacatalog.Partition.key)
}

// string value = 2 [json_name = "value"];
inline void Partition::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& Partition::value() const {
  // @@protoc_insertion_point(field_get:datacatalog.Partition.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Partition::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:datacatalog.Partition.value)
}
inline std::string* Partition::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:datacatalog.Partition.value)
  return _s;
}
inline const std::string& Partition::_internal_value() const {
  return value_.Get();
}
inline void Partition::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Partition::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Partition::release_value() {
  // @@protoc_insertion_point(field_release:datacatalog.Partition.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Partition::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (value_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:datacatalog.Partition.value)
}

// -------------------------------------------------------------------

// DatasetID

// string project = 1 [json_name = "project"];
inline void DatasetID::clear_project() {
  project_.ClearToEmpty();
}
inline const std::string& DatasetID::project() const {
  // @@protoc_insertion_point(field_get:datacatalog.DatasetID.project)
  return _internal_project();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DatasetID::set_project(ArgT0&& arg0, ArgT... args) {
 
 project_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:datacatalog.DatasetID.project)
}
inline std::string* DatasetID::mutable_project() {
  std::string* _s = _internal_mutable_project();
  // @@protoc_insertion_point(field_mutable:datacatalog.DatasetID.project)
  return _s;
}
inline const std::string& DatasetID::_internal_project() const {
  return project_.Get();
}
inline void DatasetID::_internal_set_project(const std::string& value) {
  
  project_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DatasetID::_internal_mutable_project() {
  
  return project_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DatasetID::release_project() {
  // @@protoc_insertion_point(field_release:datacatalog.DatasetID.project)
  return project_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DatasetID::set_allocated_project(std::string* project) {
  if (project != nullptr) {
    
  } else {
    
  }
  project_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), project,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (project_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    project_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:datacatalog.DatasetID.project)
}

// string name = 2 [json_name = "name"];
inline void DatasetID::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& DatasetID::name() const {
  // @@protoc_insertion_point(field_get:datacatalog.DatasetID.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DatasetID::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:datacatalog.DatasetID.name)
}
inline std::string* DatasetID::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:datacatalog.DatasetID.name)
  return _s;
}
inline const std::string& DatasetID::_internal_name() const {
  return name_.Get();
}
inline void DatasetID::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DatasetID::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DatasetID::release_name() {
  // @@protoc_insertion_point(field_release:datacatalog.DatasetID.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DatasetID::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:datacatalog.DatasetID.name)
}

// string domain = 3 [json_name = "domain"];
inline void DatasetID::clear_domain() {
  domain_.ClearToEmpty();
}
inline const std::string& DatasetID::domain() const {
  // @@protoc_insertion_point(field_get:datacatalog.DatasetID.domain)
  return _internal_domain();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DatasetID::set_domain(ArgT0&& arg0, ArgT... args) {
 
 domain_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:datacatalog.DatasetID.domain)
}
inline std::string* DatasetID::mutable_domain() {
  std::string* _s = _internal_mutable_domain();
  // @@protoc_insertion_point(field_mutable:datacatalog.DatasetID.domain)
  return _s;
}
inline const std::string& DatasetID::_internal_domain() const {
  return domain_.Get();
}
inline void DatasetID::_internal_set_domain(const std::string& value) {
  
  domain_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DatasetID::_internal_mutable_domain() {
  
  return domain_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DatasetID::release_domain() {
  // @@protoc_insertion_point(field_release:datacatalog.DatasetID.domain)
  return domain_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DatasetID::set_allocated_domain(std::string* domain) {
  if (domain != nullptr) {
    
  } else {
    
  }
  domain_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), domain,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (domain_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    domain_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:datacatalog.DatasetID.domain)
}

// string version = 4 [json_name = "version"];
inline void DatasetID::clear_version() {
  version_.ClearToEmpty();
}
inline const std::string& DatasetID::version() const {
  // @@protoc_insertion_point(field_get:datacatalog.DatasetID.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DatasetID::set_version(ArgT0&& arg0, ArgT... args) {
 
 version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:datacatalog.DatasetID.version)
}
inline std::string* DatasetID::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:datacatalog.DatasetID.version)
  return _s;
}
inline const std::string& DatasetID::_internal_version() const {
  return version_.Get();
}
inline void DatasetID::_internal_set_version(const std::string& value) {
  
  version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DatasetID::_internal_mutable_version() {
  
  return version_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DatasetID::release_version() {
  // @@protoc_insertion_point(field_release:datacatalog.DatasetID.version)
  return version_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DatasetID::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), version,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (version_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:datacatalog.DatasetID.version)
}

// string UUID = 5 [json_name = "UUID"];
inline void DatasetID::clear_uuid() {
  uuid_.ClearToEmpty();
}
inline const std::string& DatasetID::uuid() const {
  // @@protoc_insertion_point(field_get:datacatalog.DatasetID.UUID)
  return _internal_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DatasetID::set_uuid(ArgT0&& arg0, ArgT... args) {
 
 uuid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:datacatalog.DatasetID.UUID)
}
inline std::string* DatasetID::mutable_uuid() {
  std::string* _s = _internal_mutable_uuid();
  // @@protoc_insertion_point(field_mutable:datacatalog.DatasetID.UUID)
  return _s;
}
inline const std::string& DatasetID::_internal_uuid() const {
  return uuid_.Get();
}
inline void DatasetID::_internal_set_uuid(const std::string& value) {
  
  uuid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DatasetID::_internal_mutable_uuid() {
  
  return uuid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DatasetID::release_uuid() {
  // @@protoc_insertion_point(field_release:datacatalog.DatasetID.UUID)
  return uuid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DatasetID::set_allocated_uuid(std::string* uuid) {
  if (uuid != nullptr) {
    
  } else {
    
  }
  uuid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uuid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (uuid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    uuid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:datacatalog.DatasetID.UUID)
}

// -------------------------------------------------------------------

// Artifact

// string id = 1 [json_name = "id"];
inline void Artifact::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& Artifact::id() const {
  // @@protoc_insertion_point(field_get:datacatalog.Artifact.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Artifact::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:datacatalog.Artifact.id)
}
inline std::string* Artifact::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:datacatalog.Artifact.id)
  return _s;
}
inline const std::string& Artifact::_internal_id() const {
  return id_.Get();
}
inline void Artifact::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Artifact::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Artifact::release_id() {
  // @@protoc_insertion_point(field_release:datacatalog.Artifact.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Artifact::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:datacatalog.Artifact.id)
}

// .datacatalog.DatasetID dataset = 2 [json_name = "dataset"];
inline bool Artifact::_internal_has_dataset() const {
  return this != internal_default_instance() && dataset_ != nullptr;
}
inline bool Artifact::has_dataset() const {
  return _internal_has_dataset();
}
inline void Artifact::clear_dataset() {
  if (GetArenaForAllocation() == nullptr && dataset_ != nullptr) {
    delete dataset_;
  }
  dataset_ = nullptr;
}
inline const ::datacatalog::DatasetID& Artifact::_internal_dataset() const {
  const ::datacatalog::DatasetID* p = dataset_;
  return p != nullptr ? *p : reinterpret_cast<const ::datacatalog::DatasetID&>(
      ::datacatalog::_DatasetID_default_instance_);
}
inline const ::datacatalog::DatasetID& Artifact::dataset() const {
  // @@protoc_insertion_point(field_get:datacatalog.Artifact.dataset)
  return _internal_dataset();
}
inline void Artifact::unsafe_arena_set_allocated_dataset(
    ::datacatalog::DatasetID* dataset) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dataset_);
  }
  dataset_ = dataset;
  if (dataset) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:datacatalog.Artifact.dataset)
}
inline ::datacatalog::DatasetID* Artifact::release_dataset() {
  
  ::datacatalog::DatasetID* temp = dataset_;
  dataset_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::datacatalog::DatasetID* Artifact::unsafe_arena_release_dataset() {
  // @@protoc_insertion_point(field_release:datacatalog.Artifact.dataset)
  
  ::datacatalog::DatasetID* temp = dataset_;
  dataset_ = nullptr;
  return temp;
}
inline ::datacatalog::DatasetID* Artifact::_internal_mutable_dataset() {
  
  if (dataset_ == nullptr) {
    auto* p = CreateMaybeMessage<::datacatalog::DatasetID>(GetArenaForAllocation());
    dataset_ = p;
  }
  return dataset_;
}
inline ::datacatalog::DatasetID* Artifact::mutable_dataset() {
  ::datacatalog::DatasetID* _msg = _internal_mutable_dataset();
  // @@protoc_insertion_point(field_mutable:datacatalog.Artifact.dataset)
  return _msg;
}
inline void Artifact::set_allocated_dataset(::datacatalog::DatasetID* dataset) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete dataset_;
  }
  if (dataset) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::datacatalog::DatasetID>::GetOwningArena(dataset);
    if (message_arena != submessage_arena) {
      dataset = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dataset, submessage_arena);
    }
    
  } else {
    
  }
  dataset_ = dataset;
  // @@protoc_insertion_point(field_set_allocated:datacatalog.Artifact.dataset)
}

// repeated .datacatalog.ArtifactData data = 3 [json_name = "data"];
inline int Artifact::_internal_data_size() const {
  return data_.size();
}
inline int Artifact::data_size() const {
  return _internal_data_size();
}
inline void Artifact::clear_data() {
  data_.Clear();
}
inline ::datacatalog::ArtifactData* Artifact::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:datacatalog.Artifact.data)
  return data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::datacatalog::ArtifactData >*
Artifact::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:datacatalog.Artifact.data)
  return &data_;
}
inline const ::datacatalog::ArtifactData& Artifact::_internal_data(int index) const {
  return data_.Get(index);
}
inline const ::datacatalog::ArtifactData& Artifact::data(int index) const {
  // @@protoc_insertion_point(field_get:datacatalog.Artifact.data)
  return _internal_data(index);
}
inline ::datacatalog::ArtifactData* Artifact::_internal_add_data() {
  return data_.Add();
}
inline ::datacatalog::ArtifactData* Artifact::add_data() {
  ::datacatalog::ArtifactData* _add = _internal_add_data();
  // @@protoc_insertion_point(field_add:datacatalog.Artifact.data)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::datacatalog::ArtifactData >&
Artifact::data() const {
  // @@protoc_insertion_point(field_list:datacatalog.Artifact.data)
  return data_;
}

// .datacatalog.Metadata metadata = 4 [json_name = "metadata"];
inline bool Artifact::_internal_has_metadata() const {
  return this != internal_default_instance() && metadata_ != nullptr;
}
inline bool Artifact::has_metadata() const {
  return _internal_has_metadata();
}
inline void Artifact::clear_metadata() {
  if (GetArenaForAllocation() == nullptr && metadata_ != nullptr) {
    delete metadata_;
  }
  metadata_ = nullptr;
}
inline const ::datacatalog::Metadata& Artifact::_internal_metadata() const {
  const ::datacatalog::Metadata* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::datacatalog::Metadata&>(
      ::datacatalog::_Metadata_default_instance_);
}
inline const ::datacatalog::Metadata& Artifact::metadata() const {
  // @@protoc_insertion_point(field_get:datacatalog.Artifact.metadata)
  return _internal_metadata();
}
inline void Artifact::unsafe_arena_set_allocated_metadata(
    ::datacatalog::Metadata* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:datacatalog.Artifact.metadata)
}
inline ::datacatalog::Metadata* Artifact::release_metadata() {
  
  ::datacatalog::Metadata* temp = metadata_;
  metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::datacatalog::Metadata* Artifact::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:datacatalog.Artifact.metadata)
  
  ::datacatalog::Metadata* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::datacatalog::Metadata* Artifact::_internal_mutable_metadata() {
  
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::datacatalog::Metadata>(GetArenaForAllocation());
    metadata_ = p;
  }
  return metadata_;
}
inline ::datacatalog::Metadata* Artifact::mutable_metadata() {
  ::datacatalog::Metadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:datacatalog.Artifact.metadata)
  return _msg;
}
inline void Artifact::set_allocated_metadata(::datacatalog::Metadata* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete metadata_;
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::datacatalog::Metadata>::GetOwningArena(metadata);
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:datacatalog.Artifact.metadata)
}

// repeated .datacatalog.Partition partitions = 5 [json_name = "partitions"];
inline int Artifact::_internal_partitions_size() const {
  return partitions_.size();
}
inline int Artifact::partitions_size() const {
  return _internal_partitions_size();
}
inline void Artifact::clear_partitions() {
  partitions_.Clear();
}
inline ::datacatalog::Partition* Artifact::mutable_partitions(int index) {
  // @@protoc_insertion_point(field_mutable:datacatalog.Artifact.partitions)
  return partitions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::datacatalog::Partition >*
Artifact::mutable_partitions() {
  // @@protoc_insertion_point(field_mutable_list:datacatalog.Artifact.partitions)
  return &partitions_;
}
inline const ::datacatalog::Partition& Artifact::_internal_partitions(int index) const {
  return partitions_.Get(index);
}
inline const ::datacatalog::Partition& Artifact::partitions(int index) const {
  // @@protoc_insertion_point(field_get:datacatalog.Artifact.partitions)
  return _internal_partitions(index);
}
inline ::datacatalog::Partition* Artifact::_internal_add_partitions() {
  return partitions_.Add();
}
inline ::datacatalog::Partition* Artifact::add_partitions() {
  ::datacatalog::Partition* _add = _internal_add_partitions();
  // @@protoc_insertion_point(field_add:datacatalog.Artifact.partitions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::datacatalog::Partition >&
Artifact::partitions() const {
  // @@protoc_insertion_point(field_list:datacatalog.Artifact.partitions)
  return partitions_;
}

// repeated .datacatalog.Tag tags = 6 [json_name = "tags"];
inline int Artifact::_internal_tags_size() const {
  return tags_.size();
}
inline int Artifact::tags_size() const {
  return _internal_tags_size();
}
inline void Artifact::clear_tags() {
  tags_.Clear();
}
inline ::datacatalog::Tag* Artifact::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:datacatalog.Artifact.tags)
  return tags_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::datacatalog::Tag >*
Artifact::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:datacatalog.Artifact.tags)
  return &tags_;
}
inline const ::datacatalog::Tag& Artifact::_internal_tags(int index) const {
  return tags_.Get(index);
}
inline const ::datacatalog::Tag& Artifact::tags(int index) const {
  // @@protoc_insertion_point(field_get:datacatalog.Artifact.tags)
  return _internal_tags(index);
}
inline ::datacatalog::Tag* Artifact::_internal_add_tags() {
  return tags_.Add();
}
inline ::datacatalog::Tag* Artifact::add_tags() {
  ::datacatalog::Tag* _add = _internal_add_tags();
  // @@protoc_insertion_point(field_add:datacatalog.Artifact.tags)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::datacatalog::Tag >&
Artifact::tags() const {
  // @@protoc_insertion_point(field_list:datacatalog.Artifact.tags)
  return tags_;
}

// .google.protobuf.Timestamp created_at = 7 [json_name = "createdAt"];
inline bool Artifact::_internal_has_created_at() const {
  return this != internal_default_instance() && created_at_ != nullptr;
}
inline bool Artifact::has_created_at() const {
  return _internal_has_created_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Artifact::_internal_created_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Artifact::created_at() const {
  // @@protoc_insertion_point(field_get:datacatalog.Artifact.created_at)
  return _internal_created_at();
}
inline void Artifact::unsafe_arena_set_allocated_created_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at_);
  }
  created_at_ = created_at;
  if (created_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:datacatalog.Artifact.created_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Artifact::release_created_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_at_;
  created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Artifact::unsafe_arena_release_created_at() {
  // @@protoc_insertion_point(field_release:datacatalog.Artifact.created_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_at_;
  created_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Artifact::_internal_mutable_created_at() {
  
  if (created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    created_at_ = p;
  }
  return created_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Artifact::mutable_created_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:datacatalog.Artifact.created_at)
  return _msg;
}
inline void Artifact::set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at_);
  }
  if (created_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at));
    if (message_arena != submessage_arena) {
      created_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_at, submessage_arena);
    }
    
  } else {
    
  }
  created_at_ = created_at;
  // @@protoc_insertion_point(field_set_allocated:datacatalog.Artifact.created_at)
}

// -------------------------------------------------------------------

// ArtifactData

// string name = 1 [json_name = "name"];
inline void ArtifactData::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& ArtifactData::name() const {
  // @@protoc_insertion_point(field_get:datacatalog.ArtifactData.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ArtifactData::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:datacatalog.ArtifactData.name)
}
inline std::string* ArtifactData::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:datacatalog.ArtifactData.name)
  return _s;
}
inline const std::string& ArtifactData::_internal_name() const {
  return name_.Get();
}
inline void ArtifactData::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ArtifactData::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ArtifactData::release_name() {
  // @@protoc_insertion_point(field_release:datacatalog.ArtifactData.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ArtifactData::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:datacatalog.ArtifactData.name)
}

// .flyteidl.core.Literal value = 2 [json_name = "value"];
inline bool ArtifactData::_internal_has_value() const {
  return this != internal_default_instance() && value_ != nullptr;
}
inline bool ArtifactData::has_value() const {
  return _internal_has_value();
}
inline const ::flyteidl::core::Literal& ArtifactData::_internal_value() const {
  const ::flyteidl::core::Literal* p = value_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::core::Literal&>(
      ::flyteidl::core::_Literal_default_instance_);
}
inline const ::flyteidl::core::Literal& ArtifactData::value() const {
  // @@protoc_insertion_point(field_get:datacatalog.ArtifactData.value)
  return _internal_value();
}
inline void ArtifactData::unsafe_arena_set_allocated_value(
    ::flyteidl::core::Literal* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:datacatalog.ArtifactData.value)
}
inline ::flyteidl::core::Literal* ArtifactData::release_value() {
  
  ::flyteidl::core::Literal* temp = value_;
  value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::core::Literal* ArtifactData::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:datacatalog.ArtifactData.value)
  
  ::flyteidl::core::Literal* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::flyteidl::core::Literal* ArtifactData::_internal_mutable_value() {
  
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::Literal>(GetArenaForAllocation());
    value_ = p;
  }
  return value_;
}
inline ::flyteidl::core::Literal* ArtifactData::mutable_value() {
  ::flyteidl::core::Literal* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:datacatalog.ArtifactData.value)
  return _msg;
}
inline void ArtifactData::set_allocated_value(::flyteidl::core::Literal* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:datacatalog.ArtifactData.value)
}

// -------------------------------------------------------------------

// Tag

// string name = 1 [json_name = "name"];
inline void Tag::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Tag::name() const {
  // @@protoc_insertion_point(field_get:datacatalog.Tag.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Tag::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:datacatalog.Tag.name)
}
inline std::string* Tag::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:datacatalog.Tag.name)
  return _s;
}
inline const std::string& Tag::_internal_name() const {
  return name_.Get();
}
inline void Tag::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Tag::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Tag::release_name() {
  // @@protoc_insertion_point(field_release:datacatalog.Tag.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Tag::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:datacatalog.Tag.name)
}

// string artifact_id = 2 [json_name = "artifactId"];
inline void Tag::clear_artifact_id() {
  artifact_id_.ClearToEmpty();
}
inline const std::string& Tag::artifact_id() const {
  // @@protoc_insertion_point(field_get:datacatalog.Tag.artifact_id)
  return _internal_artifact_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Tag::set_artifact_id(ArgT0&& arg0, ArgT... args) {
 
 artifact_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:datacatalog.Tag.artifact_id)
}
inline std::string* Tag::mutable_artifact_id() {
  std::string* _s = _internal_mutable_artifact_id();
  // @@protoc_insertion_point(field_mutable:datacatalog.Tag.artifact_id)
  return _s;
}
inline const std::string& Tag::_internal_artifact_id() const {
  return artifact_id_.Get();
}
inline void Tag::_internal_set_artifact_id(const std::string& value) {
  
  artifact_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Tag::_internal_mutable_artifact_id() {
  
  return artifact_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Tag::release_artifact_id() {
  // @@protoc_insertion_point(field_release:datacatalog.Tag.artifact_id)
  return artifact_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Tag::set_allocated_artifact_id(std::string* artifact_id) {
  if (artifact_id != nullptr) {
    
  } else {
    
  }
  artifact_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), artifact_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (artifact_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    artifact_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:datacatalog.Tag.artifact_id)
}

// .datacatalog.DatasetID dataset = 3 [json_name = "dataset"];
inline bool Tag::_internal_has_dataset() const {
  return this != internal_default_instance() && dataset_ != nullptr;
}
inline bool Tag::has_dataset() const {
  return _internal_has_dataset();
}
inline void Tag::clear_dataset() {
  if (GetArenaForAllocation() == nullptr && dataset_ != nullptr) {
    delete dataset_;
  }
  dataset_ = nullptr;
}
inline const ::datacatalog::DatasetID& Tag::_internal_dataset() const {
  const ::datacatalog::DatasetID* p = dataset_;
  return p != nullptr ? *p : reinterpret_cast<const ::datacatalog::DatasetID&>(
      ::datacatalog::_DatasetID_default_instance_);
}
inline const ::datacatalog::DatasetID& Tag::dataset() const {
  // @@protoc_insertion_point(field_get:datacatalog.Tag.dataset)
  return _internal_dataset();
}
inline void Tag::unsafe_arena_set_allocated_dataset(
    ::datacatalog::DatasetID* dataset) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dataset_);
  }
  dataset_ = dataset;
  if (dataset) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:datacatalog.Tag.dataset)
}
inline ::datacatalog::DatasetID* Tag::release_dataset() {
  
  ::datacatalog::DatasetID* temp = dataset_;
  dataset_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::datacatalog::DatasetID* Tag::unsafe_arena_release_dataset() {
  // @@protoc_insertion_point(field_release:datacatalog.Tag.dataset)
  
  ::datacatalog::DatasetID* temp = dataset_;
  dataset_ = nullptr;
  return temp;
}
inline ::datacatalog::DatasetID* Tag::_internal_mutable_dataset() {
  
  if (dataset_ == nullptr) {
    auto* p = CreateMaybeMessage<::datacatalog::DatasetID>(GetArenaForAllocation());
    dataset_ = p;
  }
  return dataset_;
}
inline ::datacatalog::DatasetID* Tag::mutable_dataset() {
  ::datacatalog::DatasetID* _msg = _internal_mutable_dataset();
  // @@protoc_insertion_point(field_mutable:datacatalog.Tag.dataset)
  return _msg;
}
inline void Tag::set_allocated_dataset(::datacatalog::DatasetID* dataset) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete dataset_;
  }
  if (dataset) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::datacatalog::DatasetID>::GetOwningArena(dataset);
    if (message_arena != submessage_arena) {
      dataset = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dataset, submessage_arena);
    }
    
  } else {
    
  }
  dataset_ = dataset;
  // @@protoc_insertion_point(field_set_allocated:datacatalog.Tag.dataset)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Metadata

// map<string, string> key_map = 1 [json_name = "keyMap"];
inline int Metadata::_internal_key_map_size() const {
  return key_map_.size();
}
inline int Metadata::key_map_size() const {
  return _internal_key_map_size();
}
inline void Metadata::clear_key_map() {
  key_map_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Metadata::_internal_key_map() const {
  return key_map_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Metadata::key_map() const {
  // @@protoc_insertion_point(field_map:datacatalog.Metadata.key_map)
  return _internal_key_map();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Metadata::_internal_mutable_key_map() {
  return key_map_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Metadata::mutable_key_map() {
  // @@protoc_insertion_point(field_mutable_map:datacatalog.Metadata.key_map)
  return _internal_mutable_key_map();
}

// -------------------------------------------------------------------

// FilterExpression

// repeated .datacatalog.SinglePropertyFilter filters = 1 [json_name = "filters"];
inline int FilterExpression::_internal_filters_size() const {
  return filters_.size();
}
inline int FilterExpression::filters_size() const {
  return _internal_filters_size();
}
inline void FilterExpression::clear_filters() {
  filters_.Clear();
}
inline ::datacatalog::SinglePropertyFilter* FilterExpression::mutable_filters(int index) {
  // @@protoc_insertion_point(field_mutable:datacatalog.FilterExpression.filters)
  return filters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::datacatalog::SinglePropertyFilter >*
FilterExpression::mutable_filters() {
  // @@protoc_insertion_point(field_mutable_list:datacatalog.FilterExpression.filters)
  return &filters_;
}
inline const ::datacatalog::SinglePropertyFilter& FilterExpression::_internal_filters(int index) const {
  return filters_.Get(index);
}
inline const ::datacatalog::SinglePropertyFilter& FilterExpression::filters(int index) const {
  // @@protoc_insertion_point(field_get:datacatalog.FilterExpression.filters)
  return _internal_filters(index);
}
inline ::datacatalog::SinglePropertyFilter* FilterExpression::_internal_add_filters() {
  return filters_.Add();
}
inline ::datacatalog::SinglePropertyFilter* FilterExpression::add_filters() {
  ::datacatalog::SinglePropertyFilter* _add = _internal_add_filters();
  // @@protoc_insertion_point(field_add:datacatalog.FilterExpression.filters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::datacatalog::SinglePropertyFilter >&
FilterExpression::filters() const {
  // @@protoc_insertion_point(field_list:datacatalog.FilterExpression.filters)
  return filters_;
}

// -------------------------------------------------------------------

// SinglePropertyFilter

// .datacatalog.TagPropertyFilter tag_filter = 1 [json_name = "tagFilter"];
inline bool SinglePropertyFilter::_internal_has_tag_filter() const {
  return property_filter_case() == kTagFilter;
}
inline bool SinglePropertyFilter::has_tag_filter() const {
  return _internal_has_tag_filter();
}
inline void SinglePropertyFilter::set_has_tag_filter() {
  _oneof_case_[0] = kTagFilter;
}
inline void SinglePropertyFilter::clear_tag_filter() {
  if (_internal_has_tag_filter()) {
    if (GetArenaForAllocation() == nullptr) {
      delete property_filter_.tag_filter_;
    }
    clear_has_property_filter();
  }
}
inline ::datacatalog::TagPropertyFilter* SinglePropertyFilter::release_tag_filter() {
  // @@protoc_insertion_point(field_release:datacatalog.SinglePropertyFilter.tag_filter)
  if (_internal_has_tag_filter()) {
    clear_has_property_filter();
      ::datacatalog::TagPropertyFilter* temp = property_filter_.tag_filter_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    property_filter_.tag_filter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::datacatalog::TagPropertyFilter& SinglePropertyFilter::_internal_tag_filter() const {
  return _internal_has_tag_filter()
      ? *property_filter_.tag_filter_
      : reinterpret_cast< ::datacatalog::TagPropertyFilter&>(::datacatalog::_TagPropertyFilter_default_instance_);
}
inline const ::datacatalog::TagPropertyFilter& SinglePropertyFilter::tag_filter() const {
  // @@protoc_insertion_point(field_get:datacatalog.SinglePropertyFilter.tag_filter)
  return _internal_tag_filter();
}
inline ::datacatalog::TagPropertyFilter* SinglePropertyFilter::unsafe_arena_release_tag_filter() {
  // @@protoc_insertion_point(field_unsafe_arena_release:datacatalog.SinglePropertyFilter.tag_filter)
  if (_internal_has_tag_filter()) {
    clear_has_property_filter();
    ::datacatalog::TagPropertyFilter* temp = property_filter_.tag_filter_;
    property_filter_.tag_filter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SinglePropertyFilter::unsafe_arena_set_allocated_tag_filter(::datacatalog::TagPropertyFilter* tag_filter) {
  clear_property_filter();
  if (tag_filter) {
    set_has_tag_filter();
    property_filter_.tag_filter_ = tag_filter;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:datacatalog.SinglePropertyFilter.tag_filter)
}
inline ::datacatalog::TagPropertyFilter* SinglePropertyFilter::_internal_mutable_tag_filter() {
  if (!_internal_has_tag_filter()) {
    clear_property_filter();
    set_has_tag_filter();
    property_filter_.tag_filter_ = CreateMaybeMessage< ::datacatalog::TagPropertyFilter >(GetArenaForAllocation());
  }
  return property_filter_.tag_filter_;
}
inline ::datacatalog::TagPropertyFilter* SinglePropertyFilter::mutable_tag_filter() {
  ::datacatalog::TagPropertyFilter* _msg = _internal_mutable_tag_filter();
  // @@protoc_insertion_point(field_mutable:datacatalog.SinglePropertyFilter.tag_filter)
  return _msg;
}

// .datacatalog.PartitionPropertyFilter partition_filter = 2 [json_name = "partitionFilter"];
inline bool SinglePropertyFilter::_internal_has_partition_filter() const {
  return property_filter_case() == kPartitionFilter;
}
inline bool SinglePropertyFilter::has_partition_filter() const {
  return _internal_has_partition_filter();
}
inline void SinglePropertyFilter::set_has_partition_filter() {
  _oneof_case_[0] = kPartitionFilter;
}
inline void SinglePropertyFilter::clear_partition_filter() {
  if (_internal_has_partition_filter()) {
    if (GetArenaForAllocation() == nullptr) {
      delete property_filter_.partition_filter_;
    }
    clear_has_property_filter();
  }
}
inline ::datacatalog::PartitionPropertyFilter* SinglePropertyFilter::release_partition_filter() {
  // @@protoc_insertion_point(field_release:datacatalog.SinglePropertyFilter.partition_filter)
  if (_internal_has_partition_filter()) {
    clear_has_property_filter();
      ::datacatalog::PartitionPropertyFilter* temp = property_filter_.partition_filter_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    property_filter_.partition_filter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::datacatalog::PartitionPropertyFilter& SinglePropertyFilter::_internal_partition_filter() const {
  return _internal_has_partition_filter()
      ? *property_filter_.partition_filter_
      : reinterpret_cast< ::datacatalog::PartitionPropertyFilter&>(::datacatalog::_PartitionPropertyFilter_default_instance_);
}
inline const ::datacatalog::PartitionPropertyFilter& SinglePropertyFilter::partition_filter() const {
  // @@protoc_insertion_point(field_get:datacatalog.SinglePropertyFilter.partition_filter)
  return _internal_partition_filter();
}
inline ::datacatalog::PartitionPropertyFilter* SinglePropertyFilter::unsafe_arena_release_partition_filter() {
  // @@protoc_insertion_point(field_unsafe_arena_release:datacatalog.SinglePropertyFilter.partition_filter)
  if (_internal_has_partition_filter()) {
    clear_has_property_filter();
    ::datacatalog::PartitionPropertyFilter* temp = property_filter_.partition_filter_;
    property_filter_.partition_filter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SinglePropertyFilter::unsafe_arena_set_allocated_partition_filter(::datacatalog::PartitionPropertyFilter* partition_filter) {
  clear_property_filter();
  if (partition_filter) {
    set_has_partition_filter();
    property_filter_.partition_filter_ = partition_filter;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:datacatalog.SinglePropertyFilter.partition_filter)
}
inline ::datacatalog::PartitionPropertyFilter* SinglePropertyFilter::_internal_mutable_partition_filter() {
  if (!_internal_has_partition_filter()) {
    clear_property_filter();
    set_has_partition_filter();
    property_filter_.partition_filter_ = CreateMaybeMessage< ::datacatalog::PartitionPropertyFilter >(GetArenaForAllocation());
  }
  return property_filter_.partition_filter_;
}
inline ::datacatalog::PartitionPropertyFilter* SinglePropertyFilter::mutable_partition_filter() {
  ::datacatalog::PartitionPropertyFilter* _msg = _internal_mutable_partition_filter();
  // @@protoc_insertion_point(field_mutable:datacatalog.SinglePropertyFilter.partition_filter)
  return _msg;
}

// .datacatalog.ArtifactPropertyFilter artifact_filter = 3 [json_name = "artifactFilter"];
inline bool SinglePropertyFilter::_internal_has_artifact_filter() const {
  return property_filter_case() == kArtifactFilter;
}
inline bool SinglePropertyFilter::has_artifact_filter() const {
  return _internal_has_artifact_filter();
}
inline void SinglePropertyFilter::set_has_artifact_filter() {
  _oneof_case_[0] = kArtifactFilter;
}
inline void SinglePropertyFilter::clear_artifact_filter() {
  if (_internal_has_artifact_filter()) {
    if (GetArenaForAllocation() == nullptr) {
      delete property_filter_.artifact_filter_;
    }
    clear_has_property_filter();
  }
}
inline ::datacatalog::ArtifactPropertyFilter* SinglePropertyFilter::release_artifact_filter() {
  // @@protoc_insertion_point(field_release:datacatalog.SinglePropertyFilter.artifact_filter)
  if (_internal_has_artifact_filter()) {
    clear_has_property_filter();
      ::datacatalog::ArtifactPropertyFilter* temp = property_filter_.artifact_filter_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    property_filter_.artifact_filter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::datacatalog::ArtifactPropertyFilter& SinglePropertyFilter::_internal_artifact_filter() const {
  return _internal_has_artifact_filter()
      ? *property_filter_.artifact_filter_
      : reinterpret_cast< ::datacatalog::ArtifactPropertyFilter&>(::datacatalog::_ArtifactPropertyFilter_default_instance_);
}
inline const ::datacatalog::ArtifactPropertyFilter& SinglePropertyFilter::artifact_filter() const {
  // @@protoc_insertion_point(field_get:datacatalog.SinglePropertyFilter.artifact_filter)
  return _internal_artifact_filter();
}
inline ::datacatalog::ArtifactPropertyFilter* SinglePropertyFilter::unsafe_arena_release_artifact_filter() {
  // @@protoc_insertion_point(field_unsafe_arena_release:datacatalog.SinglePropertyFilter.artifact_filter)
  if (_internal_has_artifact_filter()) {
    clear_has_property_filter();
    ::datacatalog::ArtifactPropertyFilter* temp = property_filter_.artifact_filter_;
    property_filter_.artifact_filter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SinglePropertyFilter::unsafe_arena_set_allocated_artifact_filter(::datacatalog::ArtifactPropertyFilter* artifact_filter) {
  clear_property_filter();
  if (artifact_filter) {
    set_has_artifact_filter();
    property_filter_.artifact_filter_ = artifact_filter;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:datacatalog.SinglePropertyFilter.artifact_filter)
}
inline ::datacatalog::ArtifactPropertyFilter* SinglePropertyFilter::_internal_mutable_artifact_filter() {
  if (!_internal_has_artifact_filter()) {
    clear_property_filter();
    set_has_artifact_filter();
    property_filter_.artifact_filter_ = CreateMaybeMessage< ::datacatalog::ArtifactPropertyFilter >(GetArenaForAllocation());
  }
  return property_filter_.artifact_filter_;
}
inline ::datacatalog::ArtifactPropertyFilter* SinglePropertyFilter::mutable_artifact_filter() {
  ::datacatalog::ArtifactPropertyFilter* _msg = _internal_mutable_artifact_filter();
  // @@protoc_insertion_point(field_mutable:datacatalog.SinglePropertyFilter.artifact_filter)
  return _msg;
}

// .datacatalog.DatasetPropertyFilter dataset_filter = 4 [json_name = "datasetFilter"];
inline bool SinglePropertyFilter::_internal_has_dataset_filter() const {
  return property_filter_case() == kDatasetFilter;
}
inline bool SinglePropertyFilter::has_dataset_filter() const {
  return _internal_has_dataset_filter();
}
inline void SinglePropertyFilter::set_has_dataset_filter() {
  _oneof_case_[0] = kDatasetFilter;
}
inline void SinglePropertyFilter::clear_dataset_filter() {
  if (_internal_has_dataset_filter()) {
    if (GetArenaForAllocation() == nullptr) {
      delete property_filter_.dataset_filter_;
    }
    clear_has_property_filter();
  }
}
inline ::datacatalog::DatasetPropertyFilter* SinglePropertyFilter::release_dataset_filter() {
  // @@protoc_insertion_point(field_release:datacatalog.SinglePropertyFilter.dataset_filter)
  if (_internal_has_dataset_filter()) {
    clear_has_property_filter();
      ::datacatalog::DatasetPropertyFilter* temp = property_filter_.dataset_filter_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    property_filter_.dataset_filter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::datacatalog::DatasetPropertyFilter& SinglePropertyFilter::_internal_dataset_filter() const {
  return _internal_has_dataset_filter()
      ? *property_filter_.dataset_filter_
      : reinterpret_cast< ::datacatalog::DatasetPropertyFilter&>(::datacatalog::_DatasetPropertyFilter_default_instance_);
}
inline const ::datacatalog::DatasetPropertyFilter& SinglePropertyFilter::dataset_filter() const {
  // @@protoc_insertion_point(field_get:datacatalog.SinglePropertyFilter.dataset_filter)
  return _internal_dataset_filter();
}
inline ::datacatalog::DatasetPropertyFilter* SinglePropertyFilter::unsafe_arena_release_dataset_filter() {
  // @@protoc_insertion_point(field_unsafe_arena_release:datacatalog.SinglePropertyFilter.dataset_filter)
  if (_internal_has_dataset_filter()) {
    clear_has_property_filter();
    ::datacatalog::DatasetPropertyFilter* temp = property_filter_.dataset_filter_;
    property_filter_.dataset_filter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SinglePropertyFilter::unsafe_arena_set_allocated_dataset_filter(::datacatalog::DatasetPropertyFilter* dataset_filter) {
  clear_property_filter();
  if (dataset_filter) {
    set_has_dataset_filter();
    property_filter_.dataset_filter_ = dataset_filter;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:datacatalog.SinglePropertyFilter.dataset_filter)
}
inline ::datacatalog::DatasetPropertyFilter* SinglePropertyFilter::_internal_mutable_dataset_filter() {
  if (!_internal_has_dataset_filter()) {
    clear_property_filter();
    set_has_dataset_filter();
    property_filter_.dataset_filter_ = CreateMaybeMessage< ::datacatalog::DatasetPropertyFilter >(GetArenaForAllocation());
  }
  return property_filter_.dataset_filter_;
}
inline ::datacatalog::DatasetPropertyFilter* SinglePropertyFilter::mutable_dataset_filter() {
  ::datacatalog::DatasetPropertyFilter* _msg = _internal_mutable_dataset_filter();
  // @@protoc_insertion_point(field_mutable:datacatalog.SinglePropertyFilter.dataset_filter)
  return _msg;
}

// .datacatalog.SinglePropertyFilter.ComparisonOperator operator = 10 [json_name = "operator"];
inline void SinglePropertyFilter::clear_operator_() {
  operator__ = 0;
}
inline ::datacatalog::SinglePropertyFilter_ComparisonOperator SinglePropertyFilter::_internal_operator_() const {
  return static_cast< ::datacatalog::SinglePropertyFilter_ComparisonOperator >(operator__);
}
inline ::datacatalog::SinglePropertyFilter_ComparisonOperator SinglePropertyFilter::operator_() const {
  // @@protoc_insertion_point(field_get:datacatalog.SinglePropertyFilter.operator)
  return _internal_operator_();
}
inline void SinglePropertyFilter::_internal_set_operator_(::datacatalog::SinglePropertyFilter_ComparisonOperator value) {
  
  operator__ = value;
}
inline void SinglePropertyFilter::set_operator_(::datacatalog::SinglePropertyFilter_ComparisonOperator value) {
  _internal_set_operator_(value);
  // @@protoc_insertion_point(field_set:datacatalog.SinglePropertyFilter.operator)
}

inline bool SinglePropertyFilter::has_property_filter() const {
  return property_filter_case() != PROPERTY_FILTER_NOT_SET;
}
inline void SinglePropertyFilter::clear_has_property_filter() {
  _oneof_case_[0] = PROPERTY_FILTER_NOT_SET;
}
inline SinglePropertyFilter::PropertyFilterCase SinglePropertyFilter::property_filter_case() const {
  return SinglePropertyFilter::PropertyFilterCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ArtifactPropertyFilter

// string artifact_id = 1 [json_name = "artifactId"];
inline bool ArtifactPropertyFilter::_internal_has_artifact_id() const {
  return property_case() == kArtifactId;
}
inline bool ArtifactPropertyFilter::has_artifact_id() const {
  return _internal_has_artifact_id();
}
inline void ArtifactPropertyFilter::set_has_artifact_id() {
  _oneof_case_[0] = kArtifactId;
}
inline void ArtifactPropertyFilter::clear_artifact_id() {
  if (_internal_has_artifact_id()) {
    property_.artifact_id_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_property();
  }
}
inline const std::string& ArtifactPropertyFilter::artifact_id() const {
  // @@protoc_insertion_point(field_get:datacatalog.ArtifactPropertyFilter.artifact_id)
  return _internal_artifact_id();
}
template <typename ArgT0, typename... ArgT>
inline void ArtifactPropertyFilter::set_artifact_id(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_artifact_id()) {
    clear_property();
    set_has_artifact_id();
    property_.artifact_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  property_.artifact_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:datacatalog.ArtifactPropertyFilter.artifact_id)
}
inline std::string* ArtifactPropertyFilter::mutable_artifact_id() {
  std::string* _s = _internal_mutable_artifact_id();
  // @@protoc_insertion_point(field_mutable:datacatalog.ArtifactPropertyFilter.artifact_id)
  return _s;
}
inline const std::string& ArtifactPropertyFilter::_internal_artifact_id() const {
  if (_internal_has_artifact_id()) {
    return property_.artifact_id_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void ArtifactPropertyFilter::_internal_set_artifact_id(const std::string& value) {
  if (!_internal_has_artifact_id()) {
    clear_property();
    set_has_artifact_id();
    property_.artifact_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  property_.artifact_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ArtifactPropertyFilter::_internal_mutable_artifact_id() {
  if (!_internal_has_artifact_id()) {
    clear_property();
    set_has_artifact_id();
    property_.artifact_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return property_.artifact_id_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ArtifactPropertyFilter::release_artifact_id() {
  // @@protoc_insertion_point(field_release:datacatalog.ArtifactPropertyFilter.artifact_id)
  if (_internal_has_artifact_id()) {
    clear_has_property();
    return property_.artifact_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void ArtifactPropertyFilter::set_allocated_artifact_id(std::string* artifact_id) {
  if (has_property()) {
    clear_property();
  }
  if (artifact_id != nullptr) {
    set_has_artifact_id();
    property_.artifact_id_.UnsafeSetDefault(artifact_id);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(artifact_id);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:datacatalog.ArtifactPropertyFilter.artifact_id)
}

inline bool ArtifactPropertyFilter::has_property() const {
  return property_case() != PROPERTY_NOT_SET;
}
inline void ArtifactPropertyFilter::clear_has_property() {
  _oneof_case_[0] = PROPERTY_NOT_SET;
}
inline ArtifactPropertyFilter::PropertyCase ArtifactPropertyFilter::property_case() const {
  return ArtifactPropertyFilter::PropertyCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// TagPropertyFilter

// string tag_name = 1 [json_name = "tagName"];
inline bool TagPropertyFilter::_internal_has_tag_name() const {
  return property_case() == kTagName;
}
inline bool TagPropertyFilter::has_tag_name() const {
  return _internal_has_tag_name();
}
inline void TagPropertyFilter::set_has_tag_name() {
  _oneof_case_[0] = kTagName;
}
inline void TagPropertyFilter::clear_tag_name() {
  if (_internal_has_tag_name()) {
    property_.tag_name_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_property();
  }
}
inline const std::string& TagPropertyFilter::tag_name() const {
  // @@protoc_insertion_point(field_get:datacatalog.TagPropertyFilter.tag_name)
  return _internal_tag_name();
}
template <typename ArgT0, typename... ArgT>
inline void TagPropertyFilter::set_tag_name(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_tag_name()) {
    clear_property();
    set_has_tag_name();
    property_.tag_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  property_.tag_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:datacatalog.TagPropertyFilter.tag_name)
}
inline std::string* TagPropertyFilter::mutable_tag_name() {
  std::string* _s = _internal_mutable_tag_name();
  // @@protoc_insertion_point(field_mutable:datacatalog.TagPropertyFilter.tag_name)
  return _s;
}
inline const std::string& TagPropertyFilter::_internal_tag_name() const {
  if (_internal_has_tag_name()) {
    return property_.tag_name_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void TagPropertyFilter::_internal_set_tag_name(const std::string& value) {
  if (!_internal_has_tag_name()) {
    clear_property();
    set_has_tag_name();
    property_.tag_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  property_.tag_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TagPropertyFilter::_internal_mutable_tag_name() {
  if (!_internal_has_tag_name()) {
    clear_property();
    set_has_tag_name();
    property_.tag_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return property_.tag_name_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TagPropertyFilter::release_tag_name() {
  // @@protoc_insertion_point(field_release:datacatalog.TagPropertyFilter.tag_name)
  if (_internal_has_tag_name()) {
    clear_has_property();
    return property_.tag_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void TagPropertyFilter::set_allocated_tag_name(std::string* tag_name) {
  if (has_property()) {
    clear_property();
  }
  if (tag_name != nullptr) {
    set_has_tag_name();
    property_.tag_name_.UnsafeSetDefault(tag_name);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(tag_name);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:datacatalog.TagPropertyFilter.tag_name)
}

inline bool TagPropertyFilter::has_property() const {
  return property_case() != PROPERTY_NOT_SET;
}
inline void TagPropertyFilter::clear_has_property() {
  _oneof_case_[0] = PROPERTY_NOT_SET;
}
inline TagPropertyFilter::PropertyCase TagPropertyFilter::property_case() const {
  return TagPropertyFilter::PropertyCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// PartitionPropertyFilter

// .datacatalog.KeyValuePair key_val = 1 [json_name = "keyVal"];
inline bool PartitionPropertyFilter::_internal_has_key_val() const {
  return property_case() == kKeyVal;
}
inline bool PartitionPropertyFilter::has_key_val() const {
  return _internal_has_key_val();
}
inline void PartitionPropertyFilter::set_has_key_val() {
  _oneof_case_[0] = kKeyVal;
}
inline void PartitionPropertyFilter::clear_key_val() {
  if (_internal_has_key_val()) {
    if (GetArenaForAllocation() == nullptr) {
      delete property_.key_val_;
    }
    clear_has_property();
  }
}
inline ::datacatalog::KeyValuePair* PartitionPropertyFilter::release_key_val() {
  // @@protoc_insertion_point(field_release:datacatalog.PartitionPropertyFilter.key_val)
  if (_internal_has_key_val()) {
    clear_has_property();
      ::datacatalog::KeyValuePair* temp = property_.key_val_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    property_.key_val_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::datacatalog::KeyValuePair& PartitionPropertyFilter::_internal_key_val() const {
  return _internal_has_key_val()
      ? *property_.key_val_
      : reinterpret_cast< ::datacatalog::KeyValuePair&>(::datacatalog::_KeyValuePair_default_instance_);
}
inline const ::datacatalog::KeyValuePair& PartitionPropertyFilter::key_val() const {
  // @@protoc_insertion_point(field_get:datacatalog.PartitionPropertyFilter.key_val)
  return _internal_key_val();
}
inline ::datacatalog::KeyValuePair* PartitionPropertyFilter::unsafe_arena_release_key_val() {
  // @@protoc_insertion_point(field_unsafe_arena_release:datacatalog.PartitionPropertyFilter.key_val)
  if (_internal_has_key_val()) {
    clear_has_property();
    ::datacatalog::KeyValuePair* temp = property_.key_val_;
    property_.key_val_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PartitionPropertyFilter::unsafe_arena_set_allocated_key_val(::datacatalog::KeyValuePair* key_val) {
  clear_property();
  if (key_val) {
    set_has_key_val();
    property_.key_val_ = key_val;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:datacatalog.PartitionPropertyFilter.key_val)
}
inline ::datacatalog::KeyValuePair* PartitionPropertyFilter::_internal_mutable_key_val() {
  if (!_internal_has_key_val()) {
    clear_property();
    set_has_key_val();
    property_.key_val_ = CreateMaybeMessage< ::datacatalog::KeyValuePair >(GetArenaForAllocation());
  }
  return property_.key_val_;
}
inline ::datacatalog::KeyValuePair* PartitionPropertyFilter::mutable_key_val() {
  ::datacatalog::KeyValuePair* _msg = _internal_mutable_key_val();
  // @@protoc_insertion_point(field_mutable:datacatalog.PartitionPropertyFilter.key_val)
  return _msg;
}

inline bool PartitionPropertyFilter::has_property() const {
  return property_case() != PROPERTY_NOT_SET;
}
inline void PartitionPropertyFilter::clear_has_property() {
  _oneof_case_[0] = PROPERTY_NOT_SET;
}
inline PartitionPropertyFilter::PropertyCase PartitionPropertyFilter::property_case() const {
  return PartitionPropertyFilter::PropertyCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// KeyValuePair

// string key = 1 [json_name = "key"];
inline void KeyValuePair::clear_key() {
  key_.ClearToEmpty();
}
inline const std::string& KeyValuePair::key() const {
  // @@protoc_insertion_point(field_get:datacatalog.KeyValuePair.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KeyValuePair::set_key(ArgT0&& arg0, ArgT... args) {
 
 key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:datacatalog.KeyValuePair.key)
}
inline std::string* KeyValuePair::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:datacatalog.KeyValuePair.key)
  return _s;
}
inline const std::string& KeyValuePair::_internal_key() const {
  return key_.Get();
}
inline void KeyValuePair::_internal_set_key(const std::string& value) {
  
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* KeyValuePair::_internal_mutable_key() {
  
  return key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* KeyValuePair::release_key() {
  // @@protoc_insertion_point(field_release:datacatalog.KeyValuePair.key)
  return key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void KeyValuePair::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:datacatalog.KeyValuePair.key)
}

// string value = 2 [json_name = "value"];
inline void KeyValuePair::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& KeyValuePair::value() const {
  // @@protoc_insertion_point(field_get:datacatalog.KeyValuePair.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KeyValuePair::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:datacatalog.KeyValuePair.value)
}
inline std::string* KeyValuePair::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:datacatalog.KeyValuePair.value)
  return _s;
}
inline const std::string& KeyValuePair::_internal_value() const {
  return value_.Get();
}
inline void KeyValuePair::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* KeyValuePair::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* KeyValuePair::release_value() {
  // @@protoc_insertion_point(field_release:datacatalog.KeyValuePair.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void KeyValuePair::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (value_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:datacatalog.KeyValuePair.value)
}

// -------------------------------------------------------------------

// DatasetPropertyFilter

// string project = 1 [json_name = "project"];
inline bool DatasetPropertyFilter::_internal_has_project() const {
  return property_case() == kProject;
}
inline bool DatasetPropertyFilter::has_project() const {
  return _internal_has_project();
}
inline void DatasetPropertyFilter::set_has_project() {
  _oneof_case_[0] = kProject;
}
inline void DatasetPropertyFilter::clear_project() {
  if (_internal_has_project()) {
    property_.project_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_property();
  }
}
inline const std::string& DatasetPropertyFilter::project() const {
  // @@protoc_insertion_point(field_get:datacatalog.DatasetPropertyFilter.project)
  return _internal_project();
}
template <typename ArgT0, typename... ArgT>
inline void DatasetPropertyFilter::set_project(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_project()) {
    clear_property();
    set_has_project();
    property_.project_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  property_.project_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:datacatalog.DatasetPropertyFilter.project)
}
inline std::string* DatasetPropertyFilter::mutable_project() {
  std::string* _s = _internal_mutable_project();
  // @@protoc_insertion_point(field_mutable:datacatalog.DatasetPropertyFilter.project)
  return _s;
}
inline const std::string& DatasetPropertyFilter::_internal_project() const {
  if (_internal_has_project()) {
    return property_.project_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void DatasetPropertyFilter::_internal_set_project(const std::string& value) {
  if (!_internal_has_project()) {
    clear_property();
    set_has_project();
    property_.project_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  property_.project_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DatasetPropertyFilter::_internal_mutable_project() {
  if (!_internal_has_project()) {
    clear_property();
    set_has_project();
    property_.project_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return property_.project_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DatasetPropertyFilter::release_project() {
  // @@protoc_insertion_point(field_release:datacatalog.DatasetPropertyFilter.project)
  if (_internal_has_project()) {
    clear_has_property();
    return property_.project_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void DatasetPropertyFilter::set_allocated_project(std::string* project) {
  if (has_property()) {
    clear_property();
  }
  if (project != nullptr) {
    set_has_project();
    property_.project_.UnsafeSetDefault(project);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(project);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:datacatalog.DatasetPropertyFilter.project)
}

// string name = 2 [json_name = "name"];
inline bool DatasetPropertyFilter::_internal_has_name() const {
  return property_case() == kName;
}
inline bool DatasetPropertyFilter::has_name() const {
  return _internal_has_name();
}
inline void DatasetPropertyFilter::set_has_name() {
  _oneof_case_[0] = kName;
}
inline void DatasetPropertyFilter::clear_name() {
  if (_internal_has_name()) {
    property_.name_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_property();
  }
}
inline const std::string& DatasetPropertyFilter::name() const {
  // @@protoc_insertion_point(field_get:datacatalog.DatasetPropertyFilter.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline void DatasetPropertyFilter::set_name(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_name()) {
    clear_property();
    set_has_name();
    property_.name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  property_.name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:datacatalog.DatasetPropertyFilter.name)
}
inline std::string* DatasetPropertyFilter::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:datacatalog.DatasetPropertyFilter.name)
  return _s;
}
inline const std::string& DatasetPropertyFilter::_internal_name() const {
  if (_internal_has_name()) {
    return property_.name_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void DatasetPropertyFilter::_internal_set_name(const std::string& value) {
  if (!_internal_has_name()) {
    clear_property();
    set_has_name();
    property_.name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  property_.name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DatasetPropertyFilter::_internal_mutable_name() {
  if (!_internal_has_name()) {
    clear_property();
    set_has_name();
    property_.name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return property_.name_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DatasetPropertyFilter::release_name() {
  // @@protoc_insertion_point(field_release:datacatalog.DatasetPropertyFilter.name)
  if (_internal_has_name()) {
    clear_has_property();
    return property_.name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void DatasetPropertyFilter::set_allocated_name(std::string* name) {
  if (has_property()) {
    clear_property();
  }
  if (name != nullptr) {
    set_has_name();
    property_.name_.UnsafeSetDefault(name);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(name);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:datacatalog.DatasetPropertyFilter.name)
}

// string domain = 3 [json_name = "domain"];
inline bool DatasetPropertyFilter::_internal_has_domain() const {
  return property_case() == kDomain;
}
inline bool DatasetPropertyFilter::has_domain() const {
  return _internal_has_domain();
}
inline void DatasetPropertyFilter::set_has_domain() {
  _oneof_case_[0] = kDomain;
}
inline void DatasetPropertyFilter::clear_domain() {
  if (_internal_has_domain()) {
    property_.domain_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_property();
  }
}
inline const std::string& DatasetPropertyFilter::domain() const {
  // @@protoc_insertion_point(field_get:datacatalog.DatasetPropertyFilter.domain)
  return _internal_domain();
}
template <typename ArgT0, typename... ArgT>
inline void DatasetPropertyFilter::set_domain(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_domain()) {
    clear_property();
    set_has_domain();
    property_.domain_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  property_.domain_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:datacatalog.DatasetPropertyFilter.domain)
}
inline std::string* DatasetPropertyFilter::mutable_domain() {
  std::string* _s = _internal_mutable_domain();
  // @@protoc_insertion_point(field_mutable:datacatalog.DatasetPropertyFilter.domain)
  return _s;
}
inline const std::string& DatasetPropertyFilter::_internal_domain() const {
  if (_internal_has_domain()) {
    return property_.domain_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void DatasetPropertyFilter::_internal_set_domain(const std::string& value) {
  if (!_internal_has_domain()) {
    clear_property();
    set_has_domain();
    property_.domain_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  property_.domain_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DatasetPropertyFilter::_internal_mutable_domain() {
  if (!_internal_has_domain()) {
    clear_property();
    set_has_domain();
    property_.domain_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return property_.domain_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DatasetPropertyFilter::release_domain() {
  // @@protoc_insertion_point(field_release:datacatalog.DatasetPropertyFilter.domain)
  if (_internal_has_domain()) {
    clear_has_property();
    return property_.domain_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void DatasetPropertyFilter::set_allocated_domain(std::string* domain) {
  if (has_property()) {
    clear_property();
  }
  if (domain != nullptr) {
    set_has_domain();
    property_.domain_.UnsafeSetDefault(domain);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(domain);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:datacatalog.DatasetPropertyFilter.domain)
}

// string version = 4 [json_name = "version"];
inline bool DatasetPropertyFilter::_internal_has_version() const {
  return property_case() == kVersion;
}
inline bool DatasetPropertyFilter::has_version() const {
  return _internal_has_version();
}
inline void DatasetPropertyFilter::set_has_version() {
  _oneof_case_[0] = kVersion;
}
inline void DatasetPropertyFilter::clear_version() {
  if (_internal_has_version()) {
    property_.version_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_property();
  }
}
inline const std::string& DatasetPropertyFilter::version() const {
  // @@protoc_insertion_point(field_get:datacatalog.DatasetPropertyFilter.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline void DatasetPropertyFilter::set_version(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_version()) {
    clear_property();
    set_has_version();
    property_.version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  property_.version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:datacatalog.DatasetPropertyFilter.version)
}
inline std::string* DatasetPropertyFilter::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:datacatalog.DatasetPropertyFilter.version)
  return _s;
}
inline const std::string& DatasetPropertyFilter::_internal_version() const {
  if (_internal_has_version()) {
    return property_.version_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void DatasetPropertyFilter::_internal_set_version(const std::string& value) {
  if (!_internal_has_version()) {
    clear_property();
    set_has_version();
    property_.version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  property_.version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DatasetPropertyFilter::_internal_mutable_version() {
  if (!_internal_has_version()) {
    clear_property();
    set_has_version();
    property_.version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return property_.version_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DatasetPropertyFilter::release_version() {
  // @@protoc_insertion_point(field_release:datacatalog.DatasetPropertyFilter.version)
  if (_internal_has_version()) {
    clear_has_property();
    return property_.version_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void DatasetPropertyFilter::set_allocated_version(std::string* version) {
  if (has_property()) {
    clear_property();
  }
  if (version != nullptr) {
    set_has_version();
    property_.version_.UnsafeSetDefault(version);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(version);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:datacatalog.DatasetPropertyFilter.version)
}

inline bool DatasetPropertyFilter::has_property() const {
  return property_case() != PROPERTY_NOT_SET;
}
inline void DatasetPropertyFilter::clear_has_property() {
  _oneof_case_[0] = PROPERTY_NOT_SET;
}
inline DatasetPropertyFilter::PropertyCase DatasetPropertyFilter::property_case() const {
  return DatasetPropertyFilter::PropertyCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// PaginationOptions

// uint32 limit = 1 [json_name = "limit"];
inline void PaginationOptions::clear_limit() {
  limit_ = 0u;
}
inline uint32_t PaginationOptions::_internal_limit() const {
  return limit_;
}
inline uint32_t PaginationOptions::limit() const {
  // @@protoc_insertion_point(field_get:datacatalog.PaginationOptions.limit)
  return _internal_limit();
}
inline void PaginationOptions::_internal_set_limit(uint32_t value) {
  
  limit_ = value;
}
inline void PaginationOptions::set_limit(uint32_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:datacatalog.PaginationOptions.limit)
}

// string token = 2 [json_name = "token"];
inline void PaginationOptions::clear_token() {
  token_.ClearToEmpty();
}
inline const std::string& PaginationOptions::token() const {
  // @@protoc_insertion_point(field_get:datacatalog.PaginationOptions.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PaginationOptions::set_token(ArgT0&& arg0, ArgT... args) {
 
 token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:datacatalog.PaginationOptions.token)
}
inline std::string* PaginationOptions::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:datacatalog.PaginationOptions.token)
  return _s;
}
inline const std::string& PaginationOptions::_internal_token() const {
  return token_.Get();
}
inline void PaginationOptions::_internal_set_token(const std::string& value) {
  
  token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PaginationOptions::_internal_mutable_token() {
  
  return token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PaginationOptions::release_token() {
  // @@protoc_insertion_point(field_release:datacatalog.PaginationOptions.token)
  return token_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PaginationOptions::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:datacatalog.PaginationOptions.token)
}

// .datacatalog.PaginationOptions.SortKey sortKey = 3 [json_name = "sortKey"];
inline void PaginationOptions::clear_sortkey() {
  sortkey_ = 0;
}
inline ::datacatalog::PaginationOptions_SortKey PaginationOptions::_internal_sortkey() const {
  return static_cast< ::datacatalog::PaginationOptions_SortKey >(sortkey_);
}
inline ::datacatalog::PaginationOptions_SortKey PaginationOptions::sortkey() const {
  // @@protoc_insertion_point(field_get:datacatalog.PaginationOptions.sortKey)
  return _internal_sortkey();
}
inline void PaginationOptions::_internal_set_sortkey(::datacatalog::PaginationOptions_SortKey value) {
  
  sortkey_ = value;
}
inline void PaginationOptions::set_sortkey(::datacatalog::PaginationOptions_SortKey value) {
  _internal_set_sortkey(value);
  // @@protoc_insertion_point(field_set:datacatalog.PaginationOptions.sortKey)
}

// .datacatalog.PaginationOptions.SortOrder sortOrder = 4 [json_name = "sortOrder"];
inline void PaginationOptions::clear_sortorder() {
  sortorder_ = 0;
}
inline ::datacatalog::PaginationOptions_SortOrder PaginationOptions::_internal_sortorder() const {
  return static_cast< ::datacatalog::PaginationOptions_SortOrder >(sortorder_);
}
inline ::datacatalog::PaginationOptions_SortOrder PaginationOptions::sortorder() const {
  // @@protoc_insertion_point(field_get:datacatalog.PaginationOptions.sortOrder)
  return _internal_sortorder();
}
inline void PaginationOptions::_internal_set_sortorder(::datacatalog::PaginationOptions_SortOrder value) {
  
  sortorder_ = value;
}
inline void PaginationOptions::set_sortorder(::datacatalog::PaginationOptions_SortOrder value) {
  _internal_set_sortorder(value);
  // @@protoc_insertion_point(field_set:datacatalog.PaginationOptions.sortOrder)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace datacatalog

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::datacatalog::SinglePropertyFilter_ComparisonOperator> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::datacatalog::SinglePropertyFilter_ComparisonOperator>() {
  return ::datacatalog::SinglePropertyFilter_ComparisonOperator_descriptor();
}
template <> struct is_proto_enum< ::datacatalog::PaginationOptions_SortOrder> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::datacatalog::PaginationOptions_SortOrder>() {
  return ::datacatalog::PaginationOptions_SortOrder_descriptor();
}
template <> struct is_proto_enum< ::datacatalog::PaginationOptions_SortKey> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::datacatalog::PaginationOptions_SortKey>() {
  return ::datacatalog::PaginationOptions_SortKey_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_flyteidl_2fdatacatalog_2fdatacatalog_2eproto
