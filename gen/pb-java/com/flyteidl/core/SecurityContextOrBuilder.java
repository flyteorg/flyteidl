// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: flyteidl/core/security.proto

package com.flyteidl.core;

public interface SecurityContextOrBuilder extends
    // @@protoc_insertion_point(interface_extends:flyteidl.core.SecurityContext)
    com.google.protobuf.MessageOrBuilder {

  /**
   * <pre>
   * run_as encapsulates the identity a pod should run as. If the task fills in multiple fields here, it'll be up to the
   * backend plugin to choose the appropriate identity for the execution engine the task will run on.
   * </pre>
   *
   * <code>.flyteidl.core.Identity run_as = 1 [json_name = "runAs"];</code>
   * @return Whether the runAs field is set.
   */
  boolean hasRunAs();
  /**
   * <pre>
   * run_as encapsulates the identity a pod should run as. If the task fills in multiple fields here, it'll be up to the
   * backend plugin to choose the appropriate identity for the execution engine the task will run on.
   * </pre>
   *
   * <code>.flyteidl.core.Identity run_as = 1 [json_name = "runAs"];</code>
   * @return The runAs.
   */
  com.flyteidl.core.Identity getRunAs();
  /**
   * <pre>
   * run_as encapsulates the identity a pod should run as. If the task fills in multiple fields here, it'll be up to the
   * backend plugin to choose the appropriate identity for the execution engine the task will run on.
   * </pre>
   *
   * <code>.flyteidl.core.Identity run_as = 1 [json_name = "runAs"];</code>
   */
  com.flyteidl.core.IdentityOrBuilder getRunAsOrBuilder();

  /**
   * <pre>
   * secrets indicate the list of secrets the task needs in order to proceed. Secrets will be mounted/passed to the
   * pod as it starts. If the plugin responsible for kicking of the task will not run it on a flyte cluster (e.g. AWS
   * Batch), it's the responsibility of the plugin to fetch the secret (which means propeller identity will need access
   * to the secret) and to pass it to the remote execution engine.
   * </pre>
   *
   * <code>repeated .flyteidl.core.Secret secrets = 2 [json_name = "secrets"];</code>
   */
  java.util.List<com.flyteidl.core.Secret> 
      getSecretsList();
  /**
   * <pre>
   * secrets indicate the list of secrets the task needs in order to proceed. Secrets will be mounted/passed to the
   * pod as it starts. If the plugin responsible for kicking of the task will not run it on a flyte cluster (e.g. AWS
   * Batch), it's the responsibility of the plugin to fetch the secret (which means propeller identity will need access
   * to the secret) and to pass it to the remote execution engine.
   * </pre>
   *
   * <code>repeated .flyteidl.core.Secret secrets = 2 [json_name = "secrets"];</code>
   */
  com.flyteidl.core.Secret getSecrets(int index);
  /**
   * <pre>
   * secrets indicate the list of secrets the task needs in order to proceed. Secrets will be mounted/passed to the
   * pod as it starts. If the plugin responsible for kicking of the task will not run it on a flyte cluster (e.g. AWS
   * Batch), it's the responsibility of the plugin to fetch the secret (which means propeller identity will need access
   * to the secret) and to pass it to the remote execution engine.
   * </pre>
   *
   * <code>repeated .flyteidl.core.Secret secrets = 2 [json_name = "secrets"];</code>
   */
  int getSecretsCount();
  /**
   * <pre>
   * secrets indicate the list of secrets the task needs in order to proceed. Secrets will be mounted/passed to the
   * pod as it starts. If the plugin responsible for kicking of the task will not run it on a flyte cluster (e.g. AWS
   * Batch), it's the responsibility of the plugin to fetch the secret (which means propeller identity will need access
   * to the secret) and to pass it to the remote execution engine.
   * </pre>
   *
   * <code>repeated .flyteidl.core.Secret secrets = 2 [json_name = "secrets"];</code>
   */
  java.util.List<? extends com.flyteidl.core.SecretOrBuilder> 
      getSecretsOrBuilderList();
  /**
   * <pre>
   * secrets indicate the list of secrets the task needs in order to proceed. Secrets will be mounted/passed to the
   * pod as it starts. If the plugin responsible for kicking of the task will not run it on a flyte cluster (e.g. AWS
   * Batch), it's the responsibility of the plugin to fetch the secret (which means propeller identity will need access
   * to the secret) and to pass it to the remote execution engine.
   * </pre>
   *
   * <code>repeated .flyteidl.core.Secret secrets = 2 [json_name = "secrets"];</code>
   */
  com.flyteidl.core.SecretOrBuilder getSecretsOrBuilder(
      int index);

  /**
   * <pre>
   * tokens indicate the list of token requests the task needs in order to proceed. Tokens will be mounted/passed to the
   * pod as it starts. If the plugin responsible for kicking of the task will not run it on a flyte cluster (e.g. AWS
   * Batch), it's the responsibility of the plugin to fetch the secret (which means propeller identity will need access
   * to the secret) and to pass it to the remote execution engine.
   * </pre>
   *
   * <code>repeated .flyteidl.core.OAuth2TokenRequest tokens = 3 [json_name = "tokens"];</code>
   */
  java.util.List<com.flyteidl.core.OAuth2TokenRequest> 
      getTokensList();
  /**
   * <pre>
   * tokens indicate the list of token requests the task needs in order to proceed. Tokens will be mounted/passed to the
   * pod as it starts. If the plugin responsible for kicking of the task will not run it on a flyte cluster (e.g. AWS
   * Batch), it's the responsibility of the plugin to fetch the secret (which means propeller identity will need access
   * to the secret) and to pass it to the remote execution engine.
   * </pre>
   *
   * <code>repeated .flyteidl.core.OAuth2TokenRequest tokens = 3 [json_name = "tokens"];</code>
   */
  com.flyteidl.core.OAuth2TokenRequest getTokens(int index);
  /**
   * <pre>
   * tokens indicate the list of token requests the task needs in order to proceed. Tokens will be mounted/passed to the
   * pod as it starts. If the plugin responsible for kicking of the task will not run it on a flyte cluster (e.g. AWS
   * Batch), it's the responsibility of the plugin to fetch the secret (which means propeller identity will need access
   * to the secret) and to pass it to the remote execution engine.
   * </pre>
   *
   * <code>repeated .flyteidl.core.OAuth2TokenRequest tokens = 3 [json_name = "tokens"];</code>
   */
  int getTokensCount();
  /**
   * <pre>
   * tokens indicate the list of token requests the task needs in order to proceed. Tokens will be mounted/passed to the
   * pod as it starts. If the plugin responsible for kicking of the task will not run it on a flyte cluster (e.g. AWS
   * Batch), it's the responsibility of the plugin to fetch the secret (which means propeller identity will need access
   * to the secret) and to pass it to the remote execution engine.
   * </pre>
   *
   * <code>repeated .flyteidl.core.OAuth2TokenRequest tokens = 3 [json_name = "tokens"];</code>
   */
  java.util.List<? extends com.flyteidl.core.OAuth2TokenRequestOrBuilder> 
      getTokensOrBuilderList();
  /**
   * <pre>
   * tokens indicate the list of token requests the task needs in order to proceed. Tokens will be mounted/passed to the
   * pod as it starts. If the plugin responsible for kicking of the task will not run it on a flyte cluster (e.g. AWS
   * Batch), it's the responsibility of the plugin to fetch the secret (which means propeller identity will need access
   * to the secret) and to pass it to the remote execution engine.
   * </pre>
   *
   * <code>repeated .flyteidl.core.OAuth2TokenRequest tokens = 3 [json_name = "tokens"];</code>
   */
  com.flyteidl.core.OAuth2TokenRequestOrBuilder getTokensOrBuilder(
      int index);
}
