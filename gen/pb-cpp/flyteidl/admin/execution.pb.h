// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: flyteidl/admin/execution.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_flyteidl_2fadmin_2fexecution_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_flyteidl_2fadmin_2fexecution_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "flyteidl/admin/cluster_assignment.pb.h"
#include "flyteidl/admin/common.pb.h"
#include "flyteidl/core/literals.pb.h"
#include "flyteidl/core/execution.pb.h"
#include "flyteidl/core/identifier.pb.h"
#include "flyteidl/core/security.pb.h"
#include <google/protobuf/duration.pb.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_flyteidl_2fadmin_2fexecution_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_flyteidl_2fadmin_2fexecution_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[21]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_flyteidl_2fadmin_2fexecution_2eproto;
namespace flyteidl {
namespace admin {
class AbortMetadata;
struct AbortMetadataDefaultTypeInternal;
extern AbortMetadataDefaultTypeInternal _AbortMetadata_default_instance_;
class Execution;
struct ExecutionDefaultTypeInternal;
extern ExecutionDefaultTypeInternal _Execution_default_instance_;
class ExecutionClosure;
struct ExecutionClosureDefaultTypeInternal;
extern ExecutionClosureDefaultTypeInternal _ExecutionClosure_default_instance_;
class ExecutionCreateRequest;
struct ExecutionCreateRequestDefaultTypeInternal;
extern ExecutionCreateRequestDefaultTypeInternal _ExecutionCreateRequest_default_instance_;
class ExecutionCreateResponse;
struct ExecutionCreateResponseDefaultTypeInternal;
extern ExecutionCreateResponseDefaultTypeInternal _ExecutionCreateResponse_default_instance_;
class ExecutionList;
struct ExecutionListDefaultTypeInternal;
extern ExecutionListDefaultTypeInternal _ExecutionList_default_instance_;
class ExecutionMetadata;
struct ExecutionMetadataDefaultTypeInternal;
extern ExecutionMetadataDefaultTypeInternal _ExecutionMetadata_default_instance_;
class ExecutionRecoverRequest;
struct ExecutionRecoverRequestDefaultTypeInternal;
extern ExecutionRecoverRequestDefaultTypeInternal _ExecutionRecoverRequest_default_instance_;
class ExecutionRelaunchRequest;
struct ExecutionRelaunchRequestDefaultTypeInternal;
extern ExecutionRelaunchRequestDefaultTypeInternal _ExecutionRelaunchRequest_default_instance_;
class ExecutionSpec;
struct ExecutionSpecDefaultTypeInternal;
extern ExecutionSpecDefaultTypeInternal _ExecutionSpec_default_instance_;
class ExecutionStateChangeDetails;
struct ExecutionStateChangeDetailsDefaultTypeInternal;
extern ExecutionStateChangeDetailsDefaultTypeInternal _ExecutionStateChangeDetails_default_instance_;
class ExecutionTerminateRequest;
struct ExecutionTerminateRequestDefaultTypeInternal;
extern ExecutionTerminateRequestDefaultTypeInternal _ExecutionTerminateRequest_default_instance_;
class ExecutionTerminateResponse;
struct ExecutionTerminateResponseDefaultTypeInternal;
extern ExecutionTerminateResponseDefaultTypeInternal _ExecutionTerminateResponse_default_instance_;
class ExecutionUpdateRequest;
struct ExecutionUpdateRequestDefaultTypeInternal;
extern ExecutionUpdateRequestDefaultTypeInternal _ExecutionUpdateRequest_default_instance_;
class ExecutionUpdateResponse;
struct ExecutionUpdateResponseDefaultTypeInternal;
extern ExecutionUpdateResponseDefaultTypeInternal _ExecutionUpdateResponse_default_instance_;
class LiteralMapBlob;
struct LiteralMapBlobDefaultTypeInternal;
extern LiteralMapBlobDefaultTypeInternal _LiteralMapBlob_default_instance_;
class NotificationList;
struct NotificationListDefaultTypeInternal;
extern NotificationListDefaultTypeInternal _NotificationList_default_instance_;
class SystemMetadata;
struct SystemMetadataDefaultTypeInternal;
extern SystemMetadataDefaultTypeInternal _SystemMetadata_default_instance_;
class WorkflowExecutionGetDataRequest;
struct WorkflowExecutionGetDataRequestDefaultTypeInternal;
extern WorkflowExecutionGetDataRequestDefaultTypeInternal _WorkflowExecutionGetDataRequest_default_instance_;
class WorkflowExecutionGetDataResponse;
struct WorkflowExecutionGetDataResponseDefaultTypeInternal;
extern WorkflowExecutionGetDataResponseDefaultTypeInternal _WorkflowExecutionGetDataResponse_default_instance_;
class WorkflowExecutionGetRequest;
struct WorkflowExecutionGetRequestDefaultTypeInternal;
extern WorkflowExecutionGetRequestDefaultTypeInternal _WorkflowExecutionGetRequest_default_instance_;
}  // namespace admin
}  // namespace flyteidl
PROTOBUF_NAMESPACE_OPEN
template<> ::flyteidl::admin::AbortMetadata* Arena::CreateMaybeMessage<::flyteidl::admin::AbortMetadata>(Arena*);
template<> ::flyteidl::admin::Execution* Arena::CreateMaybeMessage<::flyteidl::admin::Execution>(Arena*);
template<> ::flyteidl::admin::ExecutionClosure* Arena::CreateMaybeMessage<::flyteidl::admin::ExecutionClosure>(Arena*);
template<> ::flyteidl::admin::ExecutionCreateRequest* Arena::CreateMaybeMessage<::flyteidl::admin::ExecutionCreateRequest>(Arena*);
template<> ::flyteidl::admin::ExecutionCreateResponse* Arena::CreateMaybeMessage<::flyteidl::admin::ExecutionCreateResponse>(Arena*);
template<> ::flyteidl::admin::ExecutionList* Arena::CreateMaybeMessage<::flyteidl::admin::ExecutionList>(Arena*);
template<> ::flyteidl::admin::ExecutionMetadata* Arena::CreateMaybeMessage<::flyteidl::admin::ExecutionMetadata>(Arena*);
template<> ::flyteidl::admin::ExecutionRecoverRequest* Arena::CreateMaybeMessage<::flyteidl::admin::ExecutionRecoverRequest>(Arena*);
template<> ::flyteidl::admin::ExecutionRelaunchRequest* Arena::CreateMaybeMessage<::flyteidl::admin::ExecutionRelaunchRequest>(Arena*);
template<> ::flyteidl::admin::ExecutionSpec* Arena::CreateMaybeMessage<::flyteidl::admin::ExecutionSpec>(Arena*);
template<> ::flyteidl::admin::ExecutionStateChangeDetails* Arena::CreateMaybeMessage<::flyteidl::admin::ExecutionStateChangeDetails>(Arena*);
template<> ::flyteidl::admin::ExecutionTerminateRequest* Arena::CreateMaybeMessage<::flyteidl::admin::ExecutionTerminateRequest>(Arena*);
template<> ::flyteidl::admin::ExecutionTerminateResponse* Arena::CreateMaybeMessage<::flyteidl::admin::ExecutionTerminateResponse>(Arena*);
template<> ::flyteidl::admin::ExecutionUpdateRequest* Arena::CreateMaybeMessage<::flyteidl::admin::ExecutionUpdateRequest>(Arena*);
template<> ::flyteidl::admin::ExecutionUpdateResponse* Arena::CreateMaybeMessage<::flyteidl::admin::ExecutionUpdateResponse>(Arena*);
template<> ::flyteidl::admin::LiteralMapBlob* Arena::CreateMaybeMessage<::flyteidl::admin::LiteralMapBlob>(Arena*);
template<> ::flyteidl::admin::NotificationList* Arena::CreateMaybeMessage<::flyteidl::admin::NotificationList>(Arena*);
template<> ::flyteidl::admin::SystemMetadata* Arena::CreateMaybeMessage<::flyteidl::admin::SystemMetadata>(Arena*);
template<> ::flyteidl::admin::WorkflowExecutionGetDataRequest* Arena::CreateMaybeMessage<::flyteidl::admin::WorkflowExecutionGetDataRequest>(Arena*);
template<> ::flyteidl::admin::WorkflowExecutionGetDataResponse* Arena::CreateMaybeMessage<::flyteidl::admin::WorkflowExecutionGetDataResponse>(Arena*);
template<> ::flyteidl::admin::WorkflowExecutionGetRequest* Arena::CreateMaybeMessage<::flyteidl::admin::WorkflowExecutionGetRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace flyteidl {
namespace admin {

enum ExecutionMetadata_ExecutionMode : int {
  ExecutionMetadata_ExecutionMode_MANUAL = 0,
  ExecutionMetadata_ExecutionMode_SCHEDULED = 1,
  ExecutionMetadata_ExecutionMode_SYSTEM = 2,
  ExecutionMetadata_ExecutionMode_RELAUNCH = 3,
  ExecutionMetadata_ExecutionMode_CHILD_WORKFLOW = 4,
  ExecutionMetadata_ExecutionMode_RECOVERED = 5,
  ExecutionMetadata_ExecutionMode_ExecutionMetadata_ExecutionMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ExecutionMetadata_ExecutionMode_ExecutionMetadata_ExecutionMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ExecutionMetadata_ExecutionMode_IsValid(int value);
constexpr ExecutionMetadata_ExecutionMode ExecutionMetadata_ExecutionMode_ExecutionMode_MIN = ExecutionMetadata_ExecutionMode_MANUAL;
constexpr ExecutionMetadata_ExecutionMode ExecutionMetadata_ExecutionMode_ExecutionMode_MAX = ExecutionMetadata_ExecutionMode_RECOVERED;
constexpr int ExecutionMetadata_ExecutionMode_ExecutionMode_ARRAYSIZE = ExecutionMetadata_ExecutionMode_ExecutionMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ExecutionMetadata_ExecutionMode_descriptor();
template<typename T>
inline const std::string& ExecutionMetadata_ExecutionMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ExecutionMetadata_ExecutionMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ExecutionMetadata_ExecutionMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ExecutionMetadata_ExecutionMode_descriptor(), enum_t_value);
}
inline bool ExecutionMetadata_ExecutionMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ExecutionMetadata_ExecutionMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ExecutionMetadata_ExecutionMode>(
    ExecutionMetadata_ExecutionMode_descriptor(), name, value);
}
enum ExecutionState : int {
  EXECUTION_ACTIVE = 0,
  EXECUTION_ARCHIVED = 1,
  ExecutionState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ExecutionState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ExecutionState_IsValid(int value);
constexpr ExecutionState ExecutionState_MIN = EXECUTION_ACTIVE;
constexpr ExecutionState ExecutionState_MAX = EXECUTION_ARCHIVED;
constexpr int ExecutionState_ARRAYSIZE = ExecutionState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ExecutionState_descriptor();
template<typename T>
inline const std::string& ExecutionState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ExecutionState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ExecutionState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ExecutionState_descriptor(), enum_t_value);
}
inline bool ExecutionState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ExecutionState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ExecutionState>(
    ExecutionState_descriptor(), name, value);
}
// ===================================================================

class ExecutionCreateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.admin.ExecutionCreateRequest) */ {
 public:
  inline ExecutionCreateRequest() : ExecutionCreateRequest(nullptr) {}
  ~ExecutionCreateRequest() override;
  explicit constexpr ExecutionCreateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExecutionCreateRequest(const ExecutionCreateRequest& from);
  ExecutionCreateRequest(ExecutionCreateRequest&& from) noexcept
    : ExecutionCreateRequest() {
    *this = ::std::move(from);
  }

  inline ExecutionCreateRequest& operator=(const ExecutionCreateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecutionCreateRequest& operator=(ExecutionCreateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecutionCreateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecutionCreateRequest* internal_default_instance() {
    return reinterpret_cast<const ExecutionCreateRequest*>(
               &_ExecutionCreateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ExecutionCreateRequest& a, ExecutionCreateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ExecutionCreateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecutionCreateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExecutionCreateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExecutionCreateRequest>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecutionCreateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.admin.ExecutionCreateRequest";
  }
  protected:
  explicit ExecutionCreateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProjectFieldNumber = 1,
    kDomainFieldNumber = 2,
    kNameFieldNumber = 3,
    kSpecFieldNumber = 4,
    kInputsFieldNumber = 5,
  };
  // string project = 1 [json_name = "project"];
  void clear_project();
  const std::string& project() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_project(ArgT0&& arg0, ArgT... args);
  std::string* mutable_project();
  PROTOBUF_NODISCARD std::string* release_project();
  void set_allocated_project(std::string* project);
  private:
  const std::string& _internal_project() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_project(const std::string& value);
  std::string* _internal_mutable_project();
  public:

  // string domain = 2 [json_name = "domain"];
  void clear_domain();
  const std::string& domain() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_domain(ArgT0&& arg0, ArgT... args);
  std::string* mutable_domain();
  PROTOBUF_NODISCARD std::string* release_domain();
  void set_allocated_domain(std::string* domain);
  private:
  const std::string& _internal_domain() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_domain(const std::string& value);
  std::string* _internal_mutable_domain();
  public:

  // string name = 3 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .flyteidl.admin.ExecutionSpec spec = 4 [json_name = "spec"];
  bool has_spec() const;
  private:
  bool _internal_has_spec() const;
  public:
  void clear_spec();
  const ::flyteidl::admin::ExecutionSpec& spec() const;
  PROTOBUF_NODISCARD ::flyteidl::admin::ExecutionSpec* release_spec();
  ::flyteidl::admin::ExecutionSpec* mutable_spec();
  void set_allocated_spec(::flyteidl::admin::ExecutionSpec* spec);
  private:
  const ::flyteidl::admin::ExecutionSpec& _internal_spec() const;
  ::flyteidl::admin::ExecutionSpec* _internal_mutable_spec();
  public:
  void unsafe_arena_set_allocated_spec(
      ::flyteidl::admin::ExecutionSpec* spec);
  ::flyteidl::admin::ExecutionSpec* unsafe_arena_release_spec();

  // .flyteidl.core.LiteralMap inputs = 5 [json_name = "inputs"];
  bool has_inputs() const;
  private:
  bool _internal_has_inputs() const;
  public:
  void clear_inputs();
  const ::flyteidl::core::LiteralMap& inputs() const;
  PROTOBUF_NODISCARD ::flyteidl::core::LiteralMap* release_inputs();
  ::flyteidl::core::LiteralMap* mutable_inputs();
  void set_allocated_inputs(::flyteidl::core::LiteralMap* inputs);
  private:
  const ::flyteidl::core::LiteralMap& _internal_inputs() const;
  ::flyteidl::core::LiteralMap* _internal_mutable_inputs();
  public:
  void unsafe_arena_set_allocated_inputs(
      ::flyteidl::core::LiteralMap* inputs);
  ::flyteidl::core::LiteralMap* unsafe_arena_release_inputs();

  // @@protoc_insertion_point(class_scope:flyteidl.admin.ExecutionCreateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr project_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr domain_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::flyteidl::admin::ExecutionSpec* spec_;
  ::flyteidl::core::LiteralMap* inputs_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fadmin_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class ExecutionRelaunchRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.admin.ExecutionRelaunchRequest) */ {
 public:
  inline ExecutionRelaunchRequest() : ExecutionRelaunchRequest(nullptr) {}
  ~ExecutionRelaunchRequest() override;
  explicit constexpr ExecutionRelaunchRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExecutionRelaunchRequest(const ExecutionRelaunchRequest& from);
  ExecutionRelaunchRequest(ExecutionRelaunchRequest&& from) noexcept
    : ExecutionRelaunchRequest() {
    *this = ::std::move(from);
  }

  inline ExecutionRelaunchRequest& operator=(const ExecutionRelaunchRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecutionRelaunchRequest& operator=(ExecutionRelaunchRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecutionRelaunchRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecutionRelaunchRequest* internal_default_instance() {
    return reinterpret_cast<const ExecutionRelaunchRequest*>(
               &_ExecutionRelaunchRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ExecutionRelaunchRequest& a, ExecutionRelaunchRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ExecutionRelaunchRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecutionRelaunchRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExecutionRelaunchRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExecutionRelaunchRequest>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecutionRelaunchRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.admin.ExecutionRelaunchRequest";
  }
  protected:
  explicit ExecutionRelaunchRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 3,
    kIdFieldNumber = 1,
  };
  // string name = 3 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .flyteidl.core.WorkflowExecutionIdentifier id = 1 [json_name = "id"];
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::flyteidl::core::WorkflowExecutionIdentifier& id() const;
  PROTOBUF_NODISCARD ::flyteidl::core::WorkflowExecutionIdentifier* release_id();
  ::flyteidl::core::WorkflowExecutionIdentifier* mutable_id();
  void set_allocated_id(::flyteidl::core::WorkflowExecutionIdentifier* id);
  private:
  const ::flyteidl::core::WorkflowExecutionIdentifier& _internal_id() const;
  ::flyteidl::core::WorkflowExecutionIdentifier* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::flyteidl::core::WorkflowExecutionIdentifier* id);
  ::flyteidl::core::WorkflowExecutionIdentifier* unsafe_arena_release_id();

  // @@protoc_insertion_point(class_scope:flyteidl.admin.ExecutionRelaunchRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::flyteidl::core::WorkflowExecutionIdentifier* id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fadmin_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class ExecutionRecoverRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.admin.ExecutionRecoverRequest) */ {
 public:
  inline ExecutionRecoverRequest() : ExecutionRecoverRequest(nullptr) {}
  ~ExecutionRecoverRequest() override;
  explicit constexpr ExecutionRecoverRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExecutionRecoverRequest(const ExecutionRecoverRequest& from);
  ExecutionRecoverRequest(ExecutionRecoverRequest&& from) noexcept
    : ExecutionRecoverRequest() {
    *this = ::std::move(from);
  }

  inline ExecutionRecoverRequest& operator=(const ExecutionRecoverRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecutionRecoverRequest& operator=(ExecutionRecoverRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecutionRecoverRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecutionRecoverRequest* internal_default_instance() {
    return reinterpret_cast<const ExecutionRecoverRequest*>(
               &_ExecutionRecoverRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ExecutionRecoverRequest& a, ExecutionRecoverRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ExecutionRecoverRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecutionRecoverRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExecutionRecoverRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExecutionRecoverRequest>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecutionRecoverRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.admin.ExecutionRecoverRequest";
  }
  protected:
  explicit ExecutionRecoverRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kIdFieldNumber = 1,
    kMetadataFieldNumber = 3,
  };
  // string name = 2 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .flyteidl.core.WorkflowExecutionIdentifier id = 1 [json_name = "id"];
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::flyteidl::core::WorkflowExecutionIdentifier& id() const;
  PROTOBUF_NODISCARD ::flyteidl::core::WorkflowExecutionIdentifier* release_id();
  ::flyteidl::core::WorkflowExecutionIdentifier* mutable_id();
  void set_allocated_id(::flyteidl::core::WorkflowExecutionIdentifier* id);
  private:
  const ::flyteidl::core::WorkflowExecutionIdentifier& _internal_id() const;
  ::flyteidl::core::WorkflowExecutionIdentifier* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::flyteidl::core::WorkflowExecutionIdentifier* id);
  ::flyteidl::core::WorkflowExecutionIdentifier* unsafe_arena_release_id();

  // .flyteidl.admin.ExecutionMetadata metadata = 3 [json_name = "metadata"];
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::flyteidl::admin::ExecutionMetadata& metadata() const;
  PROTOBUF_NODISCARD ::flyteidl::admin::ExecutionMetadata* release_metadata();
  ::flyteidl::admin::ExecutionMetadata* mutable_metadata();
  void set_allocated_metadata(::flyteidl::admin::ExecutionMetadata* metadata);
  private:
  const ::flyteidl::admin::ExecutionMetadata& _internal_metadata() const;
  ::flyteidl::admin::ExecutionMetadata* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::flyteidl::admin::ExecutionMetadata* metadata);
  ::flyteidl::admin::ExecutionMetadata* unsafe_arena_release_metadata();

  // @@protoc_insertion_point(class_scope:flyteidl.admin.ExecutionRecoverRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::flyteidl::core::WorkflowExecutionIdentifier* id_;
  ::flyteidl::admin::ExecutionMetadata* metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fadmin_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class ExecutionCreateResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.admin.ExecutionCreateResponse) */ {
 public:
  inline ExecutionCreateResponse() : ExecutionCreateResponse(nullptr) {}
  ~ExecutionCreateResponse() override;
  explicit constexpr ExecutionCreateResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExecutionCreateResponse(const ExecutionCreateResponse& from);
  ExecutionCreateResponse(ExecutionCreateResponse&& from) noexcept
    : ExecutionCreateResponse() {
    *this = ::std::move(from);
  }

  inline ExecutionCreateResponse& operator=(const ExecutionCreateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecutionCreateResponse& operator=(ExecutionCreateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecutionCreateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecutionCreateResponse* internal_default_instance() {
    return reinterpret_cast<const ExecutionCreateResponse*>(
               &_ExecutionCreateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ExecutionCreateResponse& a, ExecutionCreateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ExecutionCreateResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecutionCreateResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExecutionCreateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExecutionCreateResponse>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecutionCreateResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.admin.ExecutionCreateResponse";
  }
  protected:
  explicit ExecutionCreateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // .flyteidl.core.WorkflowExecutionIdentifier id = 1 [json_name = "id"];
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::flyteidl::core::WorkflowExecutionIdentifier& id() const;
  PROTOBUF_NODISCARD ::flyteidl::core::WorkflowExecutionIdentifier* release_id();
  ::flyteidl::core::WorkflowExecutionIdentifier* mutable_id();
  void set_allocated_id(::flyteidl::core::WorkflowExecutionIdentifier* id);
  private:
  const ::flyteidl::core::WorkflowExecutionIdentifier& _internal_id() const;
  ::flyteidl::core::WorkflowExecutionIdentifier* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::flyteidl::core::WorkflowExecutionIdentifier* id);
  ::flyteidl::core::WorkflowExecutionIdentifier* unsafe_arena_release_id();

  // @@protoc_insertion_point(class_scope:flyteidl.admin.ExecutionCreateResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::flyteidl::core::WorkflowExecutionIdentifier* id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fadmin_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class WorkflowExecutionGetRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.admin.WorkflowExecutionGetRequest) */ {
 public:
  inline WorkflowExecutionGetRequest() : WorkflowExecutionGetRequest(nullptr) {}
  ~WorkflowExecutionGetRequest() override;
  explicit constexpr WorkflowExecutionGetRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WorkflowExecutionGetRequest(const WorkflowExecutionGetRequest& from);
  WorkflowExecutionGetRequest(WorkflowExecutionGetRequest&& from) noexcept
    : WorkflowExecutionGetRequest() {
    *this = ::std::move(from);
  }

  inline WorkflowExecutionGetRequest& operator=(const WorkflowExecutionGetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkflowExecutionGetRequest& operator=(WorkflowExecutionGetRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkflowExecutionGetRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorkflowExecutionGetRequest* internal_default_instance() {
    return reinterpret_cast<const WorkflowExecutionGetRequest*>(
               &_WorkflowExecutionGetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(WorkflowExecutionGetRequest& a, WorkflowExecutionGetRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkflowExecutionGetRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkflowExecutionGetRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorkflowExecutionGetRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WorkflowExecutionGetRequest>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkflowExecutionGetRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.admin.WorkflowExecutionGetRequest";
  }
  protected:
  explicit WorkflowExecutionGetRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // .flyteidl.core.WorkflowExecutionIdentifier id = 1 [json_name = "id"];
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::flyteidl::core::WorkflowExecutionIdentifier& id() const;
  PROTOBUF_NODISCARD ::flyteidl::core::WorkflowExecutionIdentifier* release_id();
  ::flyteidl::core::WorkflowExecutionIdentifier* mutable_id();
  void set_allocated_id(::flyteidl::core::WorkflowExecutionIdentifier* id);
  private:
  const ::flyteidl::core::WorkflowExecutionIdentifier& _internal_id() const;
  ::flyteidl::core::WorkflowExecutionIdentifier* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::flyteidl::core::WorkflowExecutionIdentifier* id);
  ::flyteidl::core::WorkflowExecutionIdentifier* unsafe_arena_release_id();

  // @@protoc_insertion_point(class_scope:flyteidl.admin.WorkflowExecutionGetRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::flyteidl::core::WorkflowExecutionIdentifier* id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fadmin_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class Execution final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.admin.Execution) */ {
 public:
  inline Execution() : Execution(nullptr) {}
  ~Execution() override;
  explicit constexpr Execution(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Execution(const Execution& from);
  Execution(Execution&& from) noexcept
    : Execution() {
    *this = ::std::move(from);
  }

  inline Execution& operator=(const Execution& from) {
    CopyFrom(from);
    return *this;
  }
  inline Execution& operator=(Execution&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Execution& default_instance() {
    return *internal_default_instance();
  }
  static inline const Execution* internal_default_instance() {
    return reinterpret_cast<const Execution*>(
               &_Execution_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Execution& a, Execution& b) {
    a.Swap(&b);
  }
  inline void Swap(Execution* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Execution* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Execution* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Execution>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Execution* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.admin.Execution";
  }
  protected:
  explicit Execution(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kSpecFieldNumber = 2,
    kClosureFieldNumber = 3,
  };
  // .flyteidl.core.WorkflowExecutionIdentifier id = 1 [json_name = "id"];
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::flyteidl::core::WorkflowExecutionIdentifier& id() const;
  PROTOBUF_NODISCARD ::flyteidl::core::WorkflowExecutionIdentifier* release_id();
  ::flyteidl::core::WorkflowExecutionIdentifier* mutable_id();
  void set_allocated_id(::flyteidl::core::WorkflowExecutionIdentifier* id);
  private:
  const ::flyteidl::core::WorkflowExecutionIdentifier& _internal_id() const;
  ::flyteidl::core::WorkflowExecutionIdentifier* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::flyteidl::core::WorkflowExecutionIdentifier* id);
  ::flyteidl::core::WorkflowExecutionIdentifier* unsafe_arena_release_id();

  // .flyteidl.admin.ExecutionSpec spec = 2 [json_name = "spec"];
  bool has_spec() const;
  private:
  bool _internal_has_spec() const;
  public:
  void clear_spec();
  const ::flyteidl::admin::ExecutionSpec& spec() const;
  PROTOBUF_NODISCARD ::flyteidl::admin::ExecutionSpec* release_spec();
  ::flyteidl::admin::ExecutionSpec* mutable_spec();
  void set_allocated_spec(::flyteidl::admin::ExecutionSpec* spec);
  private:
  const ::flyteidl::admin::ExecutionSpec& _internal_spec() const;
  ::flyteidl::admin::ExecutionSpec* _internal_mutable_spec();
  public:
  void unsafe_arena_set_allocated_spec(
      ::flyteidl::admin::ExecutionSpec* spec);
  ::flyteidl::admin::ExecutionSpec* unsafe_arena_release_spec();

  // .flyteidl.admin.ExecutionClosure closure = 3 [json_name = "closure"];
  bool has_closure() const;
  private:
  bool _internal_has_closure() const;
  public:
  void clear_closure();
  const ::flyteidl::admin::ExecutionClosure& closure() const;
  PROTOBUF_NODISCARD ::flyteidl::admin::ExecutionClosure* release_closure();
  ::flyteidl::admin::ExecutionClosure* mutable_closure();
  void set_allocated_closure(::flyteidl::admin::ExecutionClosure* closure);
  private:
  const ::flyteidl::admin::ExecutionClosure& _internal_closure() const;
  ::flyteidl::admin::ExecutionClosure* _internal_mutable_closure();
  public:
  void unsafe_arena_set_allocated_closure(
      ::flyteidl::admin::ExecutionClosure* closure);
  ::flyteidl::admin::ExecutionClosure* unsafe_arena_release_closure();

  // @@protoc_insertion_point(class_scope:flyteidl.admin.Execution)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::flyteidl::core::WorkflowExecutionIdentifier* id_;
  ::flyteidl::admin::ExecutionSpec* spec_;
  ::flyteidl::admin::ExecutionClosure* closure_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fadmin_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class ExecutionList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.admin.ExecutionList) */ {
 public:
  inline ExecutionList() : ExecutionList(nullptr) {}
  ~ExecutionList() override;
  explicit constexpr ExecutionList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExecutionList(const ExecutionList& from);
  ExecutionList(ExecutionList&& from) noexcept
    : ExecutionList() {
    *this = ::std::move(from);
  }

  inline ExecutionList& operator=(const ExecutionList& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecutionList& operator=(ExecutionList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecutionList& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecutionList* internal_default_instance() {
    return reinterpret_cast<const ExecutionList*>(
               &_ExecutionList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ExecutionList& a, ExecutionList& b) {
    a.Swap(&b);
  }
  inline void Swap(ExecutionList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecutionList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExecutionList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExecutionList>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecutionList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.admin.ExecutionList";
  }
  protected:
  explicit ExecutionList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExecutionsFieldNumber = 1,
    kTokenFieldNumber = 2,
  };
  // repeated .flyteidl.admin.Execution executions = 1 [json_name = "executions"];
  int executions_size() const;
  private:
  int _internal_executions_size() const;
  public:
  void clear_executions();
  ::flyteidl::admin::Execution* mutable_executions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::admin::Execution >*
      mutable_executions();
  private:
  const ::flyteidl::admin::Execution& _internal_executions(int index) const;
  ::flyteidl::admin::Execution* _internal_add_executions();
  public:
  const ::flyteidl::admin::Execution& executions(int index) const;
  ::flyteidl::admin::Execution* add_executions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::admin::Execution >&
      executions() const;

  // string token = 2 [json_name = "token"];
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // @@protoc_insertion_point(class_scope:flyteidl.admin.ExecutionList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::admin::Execution > executions_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fadmin_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class LiteralMapBlob final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.admin.LiteralMapBlob) */ {
 public:
  inline LiteralMapBlob() : LiteralMapBlob(nullptr) {}
  ~LiteralMapBlob() override;
  explicit constexpr LiteralMapBlob(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LiteralMapBlob(const LiteralMapBlob& from);
  LiteralMapBlob(LiteralMapBlob&& from) noexcept
    : LiteralMapBlob() {
    *this = ::std::move(from);
  }

  inline LiteralMapBlob& operator=(const LiteralMapBlob& from) {
    CopyFrom(from);
    return *this;
  }
  inline LiteralMapBlob& operator=(LiteralMapBlob&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LiteralMapBlob& default_instance() {
    return *internal_default_instance();
  }
  enum DataCase {
    kValues = 1,
    kUri = 2,
    DATA_NOT_SET = 0,
  };

  static inline const LiteralMapBlob* internal_default_instance() {
    return reinterpret_cast<const LiteralMapBlob*>(
               &_LiteralMapBlob_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(LiteralMapBlob& a, LiteralMapBlob& b) {
    a.Swap(&b);
  }
  inline void Swap(LiteralMapBlob* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LiteralMapBlob* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LiteralMapBlob* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LiteralMapBlob>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LiteralMapBlob* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.admin.LiteralMapBlob";
  }
  protected:
  explicit LiteralMapBlob(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
    kUriFieldNumber = 2,
  };
  // .flyteidl.core.LiteralMap values = 1 [json_name = "values", deprecated = true];
  PROTOBUF_DEPRECATED bool has_values() const;
  private:
  bool _internal_has_values() const;
  public:
  PROTOBUF_DEPRECATED void clear_values();
  PROTOBUF_DEPRECATED const ::flyteidl::core::LiteralMap& values() const;
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED ::flyteidl::core::LiteralMap* release_values();
  PROTOBUF_DEPRECATED ::flyteidl::core::LiteralMap* mutable_values();
  PROTOBUF_DEPRECATED void set_allocated_values(::flyteidl::core::LiteralMap* values);
  private:
  const ::flyteidl::core::LiteralMap& _internal_values() const;
  ::flyteidl::core::LiteralMap* _internal_mutable_values();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_values(
      ::flyteidl::core::LiteralMap* values);
  PROTOBUF_DEPRECATED ::flyteidl::core::LiteralMap* unsafe_arena_release_values();

  // string uri = 2 [json_name = "uri"];
  bool has_uri() const;
  private:
  bool _internal_has_uri() const;
  public:
  void clear_uri();
  const std::string& uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uri();
  PROTOBUF_NODISCARD std::string* release_uri();
  void set_allocated_uri(std::string* uri);
  private:
  const std::string& _internal_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri(const std::string& value);
  std::string* _internal_mutable_uri();
  public:

  void clear_data();
  DataCase data_case() const;
  // @@protoc_insertion_point(class_scope:flyteidl.admin.LiteralMapBlob)
 private:
  class _Internal;
  void set_has_values();
  void set_has_uri();

  inline bool has_data() const;
  inline void clear_has_data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union DataUnion {
    constexpr DataUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::flyteidl::core::LiteralMap* values_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
  } data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_flyteidl_2fadmin_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class AbortMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.admin.AbortMetadata) */ {
 public:
  inline AbortMetadata() : AbortMetadata(nullptr) {}
  ~AbortMetadata() override;
  explicit constexpr AbortMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AbortMetadata(const AbortMetadata& from);
  AbortMetadata(AbortMetadata&& from) noexcept
    : AbortMetadata() {
    *this = ::std::move(from);
  }

  inline AbortMetadata& operator=(const AbortMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline AbortMetadata& operator=(AbortMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AbortMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const AbortMetadata* internal_default_instance() {
    return reinterpret_cast<const AbortMetadata*>(
               &_AbortMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(AbortMetadata& a, AbortMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(AbortMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AbortMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AbortMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AbortMetadata>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AbortMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.admin.AbortMetadata";
  }
  protected:
  explicit AbortMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCauseFieldNumber = 1,
    kPrincipalFieldNumber = 2,
  };
  // string cause = 1 [json_name = "cause"];
  void clear_cause();
  const std::string& cause() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cause(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cause();
  PROTOBUF_NODISCARD std::string* release_cause();
  void set_allocated_cause(std::string* cause);
  private:
  const std::string& _internal_cause() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cause(const std::string& value);
  std::string* _internal_mutable_cause();
  public:

  // string principal = 2 [json_name = "principal"];
  void clear_principal();
  const std::string& principal() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_principal(ArgT0&& arg0, ArgT... args);
  std::string* mutable_principal();
  PROTOBUF_NODISCARD std::string* release_principal();
  void set_allocated_principal(std::string* principal);
  private:
  const std::string& _internal_principal() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_principal(const std::string& value);
  std::string* _internal_mutable_principal();
  public:

  // @@protoc_insertion_point(class_scope:flyteidl.admin.AbortMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cause_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr principal_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fadmin_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class ExecutionClosure final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.admin.ExecutionClosure) */ {
 public:
  inline ExecutionClosure() : ExecutionClosure(nullptr) {}
  ~ExecutionClosure() override;
  explicit constexpr ExecutionClosure(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExecutionClosure(const ExecutionClosure& from);
  ExecutionClosure(ExecutionClosure&& from) noexcept
    : ExecutionClosure() {
    *this = ::std::move(from);
  }

  inline ExecutionClosure& operator=(const ExecutionClosure& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecutionClosure& operator=(ExecutionClosure&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecutionClosure& default_instance() {
    return *internal_default_instance();
  }
  enum OutputResultCase {
    kOutputs = 1,
    kError = 2,
    kAbortCause = 10,
    kAbortMetadata = 12,
    kOutputData = 13,
    OUTPUT_RESULT_NOT_SET = 0,
  };

  static inline const ExecutionClosure* internal_default_instance() {
    return reinterpret_cast<const ExecutionClosure*>(
               &_ExecutionClosure_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ExecutionClosure& a, ExecutionClosure& b) {
    a.Swap(&b);
  }
  inline void Swap(ExecutionClosure* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecutionClosure* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExecutionClosure* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExecutionClosure>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecutionClosure* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.admin.ExecutionClosure";
  }
  protected:
  explicit ExecutionClosure(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNotificationsFieldNumber = 9,
    kComputedInputsFieldNumber = 3,
    kStartedAtFieldNumber = 5,
    kDurationFieldNumber = 6,
    kCreatedAtFieldNumber = 7,
    kUpdatedAtFieldNumber = 8,
    kWorkflowIdFieldNumber = 11,
    kStateChangeDetailsFieldNumber = 14,
    kPhaseFieldNumber = 4,
    kOutputsFieldNumber = 1,
    kErrorFieldNumber = 2,
    kAbortCauseFieldNumber = 10,
    kAbortMetadataFieldNumber = 12,
    kOutputDataFieldNumber = 13,
  };
  // repeated .flyteidl.admin.Notification notifications = 9 [json_name = "notifications"];
  int notifications_size() const;
  private:
  int _internal_notifications_size() const;
  public:
  void clear_notifications();
  ::flyteidl::admin::Notification* mutable_notifications(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::admin::Notification >*
      mutable_notifications();
  private:
  const ::flyteidl::admin::Notification& _internal_notifications(int index) const;
  ::flyteidl::admin::Notification* _internal_add_notifications();
  public:
  const ::flyteidl::admin::Notification& notifications(int index) const;
  ::flyteidl::admin::Notification* add_notifications();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::admin::Notification >&
      notifications() const;

  // .flyteidl.core.LiteralMap computed_inputs = 3 [json_name = "computedInputs", deprecated = true];
  PROTOBUF_DEPRECATED bool has_computed_inputs() const;
  private:
  bool _internal_has_computed_inputs() const;
  public:
  PROTOBUF_DEPRECATED void clear_computed_inputs();
  PROTOBUF_DEPRECATED const ::flyteidl::core::LiteralMap& computed_inputs() const;
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED ::flyteidl::core::LiteralMap* release_computed_inputs();
  PROTOBUF_DEPRECATED ::flyteidl::core::LiteralMap* mutable_computed_inputs();
  PROTOBUF_DEPRECATED void set_allocated_computed_inputs(::flyteidl::core::LiteralMap* computed_inputs);
  private:
  const ::flyteidl::core::LiteralMap& _internal_computed_inputs() const;
  ::flyteidl::core::LiteralMap* _internal_mutable_computed_inputs();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_computed_inputs(
      ::flyteidl::core::LiteralMap* computed_inputs);
  PROTOBUF_DEPRECATED ::flyteidl::core::LiteralMap* unsafe_arena_release_computed_inputs();

  // .google.protobuf.Timestamp started_at = 5 [json_name = "startedAt"];
  bool has_started_at() const;
  private:
  bool _internal_has_started_at() const;
  public:
  void clear_started_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& started_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_started_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_started_at();
  void set_allocated_started_at(::PROTOBUF_NAMESPACE_ID::Timestamp* started_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_started_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_started_at();
  public:
  void unsafe_arena_set_allocated_started_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* started_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_started_at();

  // .google.protobuf.Duration duration = 6 [json_name = "duration"];
  bool has_duration() const;
  private:
  bool _internal_has_duration() const;
  public:
  void clear_duration();
  const ::PROTOBUF_NAMESPACE_ID::Duration& duration() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_duration();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_duration();
  void set_allocated_duration(::PROTOBUF_NAMESPACE_ID::Duration* duration);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_duration() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_duration();
  public:
  void unsafe_arena_set_allocated_duration(
      ::PROTOBUF_NAMESPACE_ID::Duration* duration);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_duration();

  // .google.protobuf.Timestamp created_at = 7 [json_name = "createdAt"];
  bool has_created_at() const;
  private:
  bool _internal_has_created_at() const;
  public:
  void clear_created_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_at();
  void set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_at();
  public:
  void unsafe_arena_set_allocated_created_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_at();

  // .google.protobuf.Timestamp updated_at = 8 [json_name = "updatedAt"];
  bool has_updated_at() const;
  private:
  bool _internal_has_updated_at() const;
  public:
  void clear_updated_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& updated_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_updated_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_updated_at();
  void set_allocated_updated_at(::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_updated_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_updated_at();
  public:
  void unsafe_arena_set_allocated_updated_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_updated_at();

  // .flyteidl.core.Identifier workflow_id = 11 [json_name = "workflowId"];
  bool has_workflow_id() const;
  private:
  bool _internal_has_workflow_id() const;
  public:
  void clear_workflow_id();
  const ::flyteidl::core::Identifier& workflow_id() const;
  PROTOBUF_NODISCARD ::flyteidl::core::Identifier* release_workflow_id();
  ::flyteidl::core::Identifier* mutable_workflow_id();
  void set_allocated_workflow_id(::flyteidl::core::Identifier* workflow_id);
  private:
  const ::flyteidl::core::Identifier& _internal_workflow_id() const;
  ::flyteidl::core::Identifier* _internal_mutable_workflow_id();
  public:
  void unsafe_arena_set_allocated_workflow_id(
      ::flyteidl::core::Identifier* workflow_id);
  ::flyteidl::core::Identifier* unsafe_arena_release_workflow_id();

  // .flyteidl.admin.ExecutionStateChangeDetails state_change_details = 14 [json_name = "stateChangeDetails"];
  bool has_state_change_details() const;
  private:
  bool _internal_has_state_change_details() const;
  public:
  void clear_state_change_details();
  const ::flyteidl::admin::ExecutionStateChangeDetails& state_change_details() const;
  PROTOBUF_NODISCARD ::flyteidl::admin::ExecutionStateChangeDetails* release_state_change_details();
  ::flyteidl::admin::ExecutionStateChangeDetails* mutable_state_change_details();
  void set_allocated_state_change_details(::flyteidl::admin::ExecutionStateChangeDetails* state_change_details);
  private:
  const ::flyteidl::admin::ExecutionStateChangeDetails& _internal_state_change_details() const;
  ::flyteidl::admin::ExecutionStateChangeDetails* _internal_mutable_state_change_details();
  public:
  void unsafe_arena_set_allocated_state_change_details(
      ::flyteidl::admin::ExecutionStateChangeDetails* state_change_details);
  ::flyteidl::admin::ExecutionStateChangeDetails* unsafe_arena_release_state_change_details();

  // .flyteidl.core.WorkflowExecution.Phase phase = 4 [json_name = "phase"];
  void clear_phase();
  ::flyteidl::core::WorkflowExecution_Phase phase() const;
  void set_phase(::flyteidl::core::WorkflowExecution_Phase value);
  private:
  ::flyteidl::core::WorkflowExecution_Phase _internal_phase() const;
  void _internal_set_phase(::flyteidl::core::WorkflowExecution_Phase value);
  public:

  // .flyteidl.admin.LiteralMapBlob outputs = 1 [json_name = "outputs", deprecated = true];
  PROTOBUF_DEPRECATED bool has_outputs() const;
  private:
  bool _internal_has_outputs() const;
  public:
  PROTOBUF_DEPRECATED void clear_outputs();
  PROTOBUF_DEPRECATED const ::flyteidl::admin::LiteralMapBlob& outputs() const;
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED ::flyteidl::admin::LiteralMapBlob* release_outputs();
  PROTOBUF_DEPRECATED ::flyteidl::admin::LiteralMapBlob* mutable_outputs();
  PROTOBUF_DEPRECATED void set_allocated_outputs(::flyteidl::admin::LiteralMapBlob* outputs);
  private:
  const ::flyteidl::admin::LiteralMapBlob& _internal_outputs() const;
  ::flyteidl::admin::LiteralMapBlob* _internal_mutable_outputs();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_outputs(
      ::flyteidl::admin::LiteralMapBlob* outputs);
  PROTOBUF_DEPRECATED ::flyteidl::admin::LiteralMapBlob* unsafe_arena_release_outputs();

  // .flyteidl.core.ExecutionError error = 2 [json_name = "error"];
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::flyteidl::core::ExecutionError& error() const;
  PROTOBUF_NODISCARD ::flyteidl::core::ExecutionError* release_error();
  ::flyteidl::core::ExecutionError* mutable_error();
  void set_allocated_error(::flyteidl::core::ExecutionError* error);
  private:
  const ::flyteidl::core::ExecutionError& _internal_error() const;
  ::flyteidl::core::ExecutionError* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::flyteidl::core::ExecutionError* error);
  ::flyteidl::core::ExecutionError* unsafe_arena_release_error();

  // string abort_cause = 10 [json_name = "abortCause", deprecated = true];
  PROTOBUF_DEPRECATED bool has_abort_cause() const;
  private:
  bool _internal_has_abort_cause() const;
  public:
  PROTOBUF_DEPRECATED void clear_abort_cause();
  PROTOBUF_DEPRECATED const std::string& abort_cause() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_abort_cause(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_abort_cause();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_abort_cause();
  PROTOBUF_DEPRECATED void set_allocated_abort_cause(std::string* abort_cause);
  private:
  const std::string& _internal_abort_cause() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_abort_cause(const std::string& value);
  std::string* _internal_mutable_abort_cause();
  public:

  // .flyteidl.admin.AbortMetadata abort_metadata = 12 [json_name = "abortMetadata"];
  bool has_abort_metadata() const;
  private:
  bool _internal_has_abort_metadata() const;
  public:
  void clear_abort_metadata();
  const ::flyteidl::admin::AbortMetadata& abort_metadata() const;
  PROTOBUF_NODISCARD ::flyteidl::admin::AbortMetadata* release_abort_metadata();
  ::flyteidl::admin::AbortMetadata* mutable_abort_metadata();
  void set_allocated_abort_metadata(::flyteidl::admin::AbortMetadata* abort_metadata);
  private:
  const ::flyteidl::admin::AbortMetadata& _internal_abort_metadata() const;
  ::flyteidl::admin::AbortMetadata* _internal_mutable_abort_metadata();
  public:
  void unsafe_arena_set_allocated_abort_metadata(
      ::flyteidl::admin::AbortMetadata* abort_metadata);
  ::flyteidl::admin::AbortMetadata* unsafe_arena_release_abort_metadata();

  // .flyteidl.core.LiteralMap output_data = 13 [json_name = "outputData", deprecated = true];
  PROTOBUF_DEPRECATED bool has_output_data() const;
  private:
  bool _internal_has_output_data() const;
  public:
  PROTOBUF_DEPRECATED void clear_output_data();
  PROTOBUF_DEPRECATED const ::flyteidl::core::LiteralMap& output_data() const;
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED ::flyteidl::core::LiteralMap* release_output_data();
  PROTOBUF_DEPRECATED ::flyteidl::core::LiteralMap* mutable_output_data();
  PROTOBUF_DEPRECATED void set_allocated_output_data(::flyteidl::core::LiteralMap* output_data);
  private:
  const ::flyteidl::core::LiteralMap& _internal_output_data() const;
  ::flyteidl::core::LiteralMap* _internal_mutable_output_data();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_output_data(
      ::flyteidl::core::LiteralMap* output_data);
  PROTOBUF_DEPRECATED ::flyteidl::core::LiteralMap* unsafe_arena_release_output_data();

  void clear_output_result();
  OutputResultCase output_result_case() const;
  // @@protoc_insertion_point(class_scope:flyteidl.admin.ExecutionClosure)
 private:
  class _Internal;
  void set_has_outputs();
  void set_has_error();
  void set_has_abort_cause();
  void set_has_abort_metadata();
  void set_has_output_data();

  inline bool has_output_result() const;
  inline void clear_has_output_result();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::admin::Notification > notifications_;
  ::flyteidl::core::LiteralMap* computed_inputs_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* started_at_;
  ::PROTOBUF_NAMESPACE_ID::Duration* duration_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at_;
  ::flyteidl::core::Identifier* workflow_id_;
  ::flyteidl::admin::ExecutionStateChangeDetails* state_change_details_;
  int phase_;
  union OutputResultUnion {
    constexpr OutputResultUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::flyteidl::admin::LiteralMapBlob* outputs_;
    ::flyteidl::core::ExecutionError* error_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr abort_cause_;
    ::flyteidl::admin::AbortMetadata* abort_metadata_;
    ::flyteidl::core::LiteralMap* output_data_;
  } output_result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_flyteidl_2fadmin_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class SystemMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.admin.SystemMetadata) */ {
 public:
  inline SystemMetadata() : SystemMetadata(nullptr) {}
  ~SystemMetadata() override;
  explicit constexpr SystemMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SystemMetadata(const SystemMetadata& from);
  SystemMetadata(SystemMetadata&& from) noexcept
    : SystemMetadata() {
    *this = ::std::move(from);
  }

  inline SystemMetadata& operator=(const SystemMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline SystemMetadata& operator=(SystemMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SystemMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const SystemMetadata* internal_default_instance() {
    return reinterpret_cast<const SystemMetadata*>(
               &_SystemMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SystemMetadata& a, SystemMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(SystemMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SystemMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SystemMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SystemMetadata>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SystemMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.admin.SystemMetadata";
  }
  protected:
  explicit SystemMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExecutionClusterFieldNumber = 1,
  };
  // string execution_cluster = 1 [json_name = "executionCluster"];
  void clear_execution_cluster();
  const std::string& execution_cluster() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_execution_cluster(ArgT0&& arg0, ArgT... args);
  std::string* mutable_execution_cluster();
  PROTOBUF_NODISCARD std::string* release_execution_cluster();
  void set_allocated_execution_cluster(std::string* execution_cluster);
  private:
  const std::string& _internal_execution_cluster() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_execution_cluster(const std::string& value);
  std::string* _internal_mutable_execution_cluster();
  public:

  // @@protoc_insertion_point(class_scope:flyteidl.admin.SystemMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr execution_cluster_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fadmin_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class ExecutionMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.admin.ExecutionMetadata) */ {
 public:
  inline ExecutionMetadata() : ExecutionMetadata(nullptr) {}
  ~ExecutionMetadata() override;
  explicit constexpr ExecutionMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExecutionMetadata(const ExecutionMetadata& from);
  ExecutionMetadata(ExecutionMetadata&& from) noexcept
    : ExecutionMetadata() {
    *this = ::std::move(from);
  }

  inline ExecutionMetadata& operator=(const ExecutionMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecutionMetadata& operator=(ExecutionMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecutionMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecutionMetadata* internal_default_instance() {
    return reinterpret_cast<const ExecutionMetadata*>(
               &_ExecutionMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ExecutionMetadata& a, ExecutionMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(ExecutionMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecutionMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExecutionMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExecutionMetadata>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecutionMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.admin.ExecutionMetadata";
  }
  protected:
  explicit ExecutionMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ExecutionMetadata_ExecutionMode ExecutionMode;
  static constexpr ExecutionMode MANUAL =
    ExecutionMetadata_ExecutionMode_MANUAL;
  static constexpr ExecutionMode SCHEDULED =
    ExecutionMetadata_ExecutionMode_SCHEDULED;
  static constexpr ExecutionMode SYSTEM =
    ExecutionMetadata_ExecutionMode_SYSTEM;
  static constexpr ExecutionMode RELAUNCH =
    ExecutionMetadata_ExecutionMode_RELAUNCH;
  static constexpr ExecutionMode CHILD_WORKFLOW =
    ExecutionMetadata_ExecutionMode_CHILD_WORKFLOW;
  static constexpr ExecutionMode RECOVERED =
    ExecutionMetadata_ExecutionMode_RECOVERED;
  static inline bool ExecutionMode_IsValid(int value) {
    return ExecutionMetadata_ExecutionMode_IsValid(value);
  }
  static constexpr ExecutionMode ExecutionMode_MIN =
    ExecutionMetadata_ExecutionMode_ExecutionMode_MIN;
  static constexpr ExecutionMode ExecutionMode_MAX =
    ExecutionMetadata_ExecutionMode_ExecutionMode_MAX;
  static constexpr int ExecutionMode_ARRAYSIZE =
    ExecutionMetadata_ExecutionMode_ExecutionMode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ExecutionMode_descriptor() {
    return ExecutionMetadata_ExecutionMode_descriptor();
  }
  template<typename T>
  static inline const std::string& ExecutionMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ExecutionMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ExecutionMode_Name.");
    return ExecutionMetadata_ExecutionMode_Name(enum_t_value);
  }
  static inline bool ExecutionMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ExecutionMode* value) {
    return ExecutionMetadata_ExecutionMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPrincipalFieldNumber = 2,
    kScheduledAtFieldNumber = 4,
    kParentNodeExecutionFieldNumber = 5,
    kReferenceExecutionFieldNumber = 16,
    kSystemMetadataFieldNumber = 17,
    kModeFieldNumber = 1,
    kNestingFieldNumber = 3,
  };
  // string principal = 2 [json_name = "principal"];
  void clear_principal();
  const std::string& principal() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_principal(ArgT0&& arg0, ArgT... args);
  std::string* mutable_principal();
  PROTOBUF_NODISCARD std::string* release_principal();
  void set_allocated_principal(std::string* principal);
  private:
  const std::string& _internal_principal() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_principal(const std::string& value);
  std::string* _internal_mutable_principal();
  public:

  // .google.protobuf.Timestamp scheduled_at = 4 [json_name = "scheduledAt"];
  bool has_scheduled_at() const;
  private:
  bool _internal_has_scheduled_at() const;
  public:
  void clear_scheduled_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& scheduled_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_scheduled_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_scheduled_at();
  void set_allocated_scheduled_at(::PROTOBUF_NAMESPACE_ID::Timestamp* scheduled_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_scheduled_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_scheduled_at();
  public:
  void unsafe_arena_set_allocated_scheduled_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* scheduled_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_scheduled_at();

  // .flyteidl.core.NodeExecutionIdentifier parent_node_execution = 5 [json_name = "parentNodeExecution"];
  bool has_parent_node_execution() const;
  private:
  bool _internal_has_parent_node_execution() const;
  public:
  void clear_parent_node_execution();
  const ::flyteidl::core::NodeExecutionIdentifier& parent_node_execution() const;
  PROTOBUF_NODISCARD ::flyteidl::core::NodeExecutionIdentifier* release_parent_node_execution();
  ::flyteidl::core::NodeExecutionIdentifier* mutable_parent_node_execution();
  void set_allocated_parent_node_execution(::flyteidl::core::NodeExecutionIdentifier* parent_node_execution);
  private:
  const ::flyteidl::core::NodeExecutionIdentifier& _internal_parent_node_execution() const;
  ::flyteidl::core::NodeExecutionIdentifier* _internal_mutable_parent_node_execution();
  public:
  void unsafe_arena_set_allocated_parent_node_execution(
      ::flyteidl::core::NodeExecutionIdentifier* parent_node_execution);
  ::flyteidl::core::NodeExecutionIdentifier* unsafe_arena_release_parent_node_execution();

  // .flyteidl.core.WorkflowExecutionIdentifier reference_execution = 16 [json_name = "referenceExecution"];
  bool has_reference_execution() const;
  private:
  bool _internal_has_reference_execution() const;
  public:
  void clear_reference_execution();
  const ::flyteidl::core::WorkflowExecutionIdentifier& reference_execution() const;
  PROTOBUF_NODISCARD ::flyteidl::core::WorkflowExecutionIdentifier* release_reference_execution();
  ::flyteidl::core::WorkflowExecutionIdentifier* mutable_reference_execution();
  void set_allocated_reference_execution(::flyteidl::core::WorkflowExecutionIdentifier* reference_execution);
  private:
  const ::flyteidl::core::WorkflowExecutionIdentifier& _internal_reference_execution() const;
  ::flyteidl::core::WorkflowExecutionIdentifier* _internal_mutable_reference_execution();
  public:
  void unsafe_arena_set_allocated_reference_execution(
      ::flyteidl::core::WorkflowExecutionIdentifier* reference_execution);
  ::flyteidl::core::WorkflowExecutionIdentifier* unsafe_arena_release_reference_execution();

  // .flyteidl.admin.SystemMetadata system_metadata = 17 [json_name = "systemMetadata"];
  bool has_system_metadata() const;
  private:
  bool _internal_has_system_metadata() const;
  public:
  void clear_system_metadata();
  const ::flyteidl::admin::SystemMetadata& system_metadata() const;
  PROTOBUF_NODISCARD ::flyteidl::admin::SystemMetadata* release_system_metadata();
  ::flyteidl::admin::SystemMetadata* mutable_system_metadata();
  void set_allocated_system_metadata(::flyteidl::admin::SystemMetadata* system_metadata);
  private:
  const ::flyteidl::admin::SystemMetadata& _internal_system_metadata() const;
  ::flyteidl::admin::SystemMetadata* _internal_mutable_system_metadata();
  public:
  void unsafe_arena_set_allocated_system_metadata(
      ::flyteidl::admin::SystemMetadata* system_metadata);
  ::flyteidl::admin::SystemMetadata* unsafe_arena_release_system_metadata();

  // .flyteidl.admin.ExecutionMetadata.ExecutionMode mode = 1 [json_name = "mode"];
  void clear_mode();
  ::flyteidl::admin::ExecutionMetadata_ExecutionMode mode() const;
  void set_mode(::flyteidl::admin::ExecutionMetadata_ExecutionMode value);
  private:
  ::flyteidl::admin::ExecutionMetadata_ExecutionMode _internal_mode() const;
  void _internal_set_mode(::flyteidl::admin::ExecutionMetadata_ExecutionMode value);
  public:

  // uint32 nesting = 3 [json_name = "nesting"];
  void clear_nesting();
  uint32_t nesting() const;
  void set_nesting(uint32_t value);
  private:
  uint32_t _internal_nesting() const;
  void _internal_set_nesting(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:flyteidl.admin.ExecutionMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr principal_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* scheduled_at_;
  ::flyteidl::core::NodeExecutionIdentifier* parent_node_execution_;
  ::flyteidl::core::WorkflowExecutionIdentifier* reference_execution_;
  ::flyteidl::admin::SystemMetadata* system_metadata_;
  int mode_;
  uint32_t nesting_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fadmin_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class NotificationList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.admin.NotificationList) */ {
 public:
  inline NotificationList() : NotificationList(nullptr) {}
  ~NotificationList() override;
  explicit constexpr NotificationList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NotificationList(const NotificationList& from);
  NotificationList(NotificationList&& from) noexcept
    : NotificationList() {
    *this = ::std::move(from);
  }

  inline NotificationList& operator=(const NotificationList& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotificationList& operator=(NotificationList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotificationList& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotificationList* internal_default_instance() {
    return reinterpret_cast<const NotificationList*>(
               &_NotificationList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(NotificationList& a, NotificationList& b) {
    a.Swap(&b);
  }
  inline void Swap(NotificationList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotificationList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotificationList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NotificationList>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NotificationList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.admin.NotificationList";
  }
  protected:
  explicit NotificationList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNotificationsFieldNumber = 1,
  };
  // repeated .flyteidl.admin.Notification notifications = 1 [json_name = "notifications"];
  int notifications_size() const;
  private:
  int _internal_notifications_size() const;
  public:
  void clear_notifications();
  ::flyteidl::admin::Notification* mutable_notifications(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::admin::Notification >*
      mutable_notifications();
  private:
  const ::flyteidl::admin::Notification& _internal_notifications(int index) const;
  ::flyteidl::admin::Notification* _internal_add_notifications();
  public:
  const ::flyteidl::admin::Notification& notifications(int index) const;
  ::flyteidl::admin::Notification* add_notifications();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::admin::Notification >&
      notifications() const;

  // @@protoc_insertion_point(class_scope:flyteidl.admin.NotificationList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::admin::Notification > notifications_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fadmin_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class ExecutionSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.admin.ExecutionSpec) */ {
 public:
  inline ExecutionSpec() : ExecutionSpec(nullptr) {}
  ~ExecutionSpec() override;
  explicit constexpr ExecutionSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExecutionSpec(const ExecutionSpec& from);
  ExecutionSpec(ExecutionSpec&& from) noexcept
    : ExecutionSpec() {
    *this = ::std::move(from);
  }

  inline ExecutionSpec& operator=(const ExecutionSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecutionSpec& operator=(ExecutionSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecutionSpec& default_instance() {
    return *internal_default_instance();
  }
  enum NotificationOverridesCase {
    kNotifications = 5,
    kDisableAll = 6,
    NOTIFICATION_OVERRIDES_NOT_SET = 0,
  };

  static inline const ExecutionSpec* internal_default_instance() {
    return reinterpret_cast<const ExecutionSpec*>(
               &_ExecutionSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ExecutionSpec& a, ExecutionSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(ExecutionSpec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecutionSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExecutionSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExecutionSpec>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecutionSpec* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.admin.ExecutionSpec";
  }
  protected:
  explicit ExecutionSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLaunchPlanFieldNumber = 1,
    kInputsFieldNumber = 2,
    kMetadataFieldNumber = 3,
    kLabelsFieldNumber = 7,
    kAnnotationsFieldNumber = 8,
    kSecurityContextFieldNumber = 10,
    kAuthRoleFieldNumber = 16,
    kQualityOfServiceFieldNumber = 17,
    kRawOutputDataConfigFieldNumber = 19,
    kClusterAssignmentFieldNumber = 20,
    kMaxParallelismFieldNumber = 18,
    kNotificationsFieldNumber = 5,
    kDisableAllFieldNumber = 6,
  };
  // .flyteidl.core.Identifier launch_plan = 1 [json_name = "launchPlan"];
  bool has_launch_plan() const;
  private:
  bool _internal_has_launch_plan() const;
  public:
  void clear_launch_plan();
  const ::flyteidl::core::Identifier& launch_plan() const;
  PROTOBUF_NODISCARD ::flyteidl::core::Identifier* release_launch_plan();
  ::flyteidl::core::Identifier* mutable_launch_plan();
  void set_allocated_launch_plan(::flyteidl::core::Identifier* launch_plan);
  private:
  const ::flyteidl::core::Identifier& _internal_launch_plan() const;
  ::flyteidl::core::Identifier* _internal_mutable_launch_plan();
  public:
  void unsafe_arena_set_allocated_launch_plan(
      ::flyteidl::core::Identifier* launch_plan);
  ::flyteidl::core::Identifier* unsafe_arena_release_launch_plan();

  // .flyteidl.core.LiteralMap inputs = 2 [json_name = "inputs", deprecated = true];
  PROTOBUF_DEPRECATED bool has_inputs() const;
  private:
  bool _internal_has_inputs() const;
  public:
  PROTOBUF_DEPRECATED void clear_inputs();
  PROTOBUF_DEPRECATED const ::flyteidl::core::LiteralMap& inputs() const;
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED ::flyteidl::core::LiteralMap* release_inputs();
  PROTOBUF_DEPRECATED ::flyteidl::core::LiteralMap* mutable_inputs();
  PROTOBUF_DEPRECATED void set_allocated_inputs(::flyteidl::core::LiteralMap* inputs);
  private:
  const ::flyteidl::core::LiteralMap& _internal_inputs() const;
  ::flyteidl::core::LiteralMap* _internal_mutable_inputs();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_inputs(
      ::flyteidl::core::LiteralMap* inputs);
  PROTOBUF_DEPRECATED ::flyteidl::core::LiteralMap* unsafe_arena_release_inputs();

  // .flyteidl.admin.ExecutionMetadata metadata = 3 [json_name = "metadata"];
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::flyteidl::admin::ExecutionMetadata& metadata() const;
  PROTOBUF_NODISCARD ::flyteidl::admin::ExecutionMetadata* release_metadata();
  ::flyteidl::admin::ExecutionMetadata* mutable_metadata();
  void set_allocated_metadata(::flyteidl::admin::ExecutionMetadata* metadata);
  private:
  const ::flyteidl::admin::ExecutionMetadata& _internal_metadata() const;
  ::flyteidl::admin::ExecutionMetadata* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::flyteidl::admin::ExecutionMetadata* metadata);
  ::flyteidl::admin::ExecutionMetadata* unsafe_arena_release_metadata();

  // .flyteidl.admin.Labels labels = 7 [json_name = "labels"];
  bool has_labels() const;
  private:
  bool _internal_has_labels() const;
  public:
  void clear_labels();
  const ::flyteidl::admin::Labels& labels() const;
  PROTOBUF_NODISCARD ::flyteidl::admin::Labels* release_labels();
  ::flyteidl::admin::Labels* mutable_labels();
  void set_allocated_labels(::flyteidl::admin::Labels* labels);
  private:
  const ::flyteidl::admin::Labels& _internal_labels() const;
  ::flyteidl::admin::Labels* _internal_mutable_labels();
  public:
  void unsafe_arena_set_allocated_labels(
      ::flyteidl::admin::Labels* labels);
  ::flyteidl::admin::Labels* unsafe_arena_release_labels();

  // .flyteidl.admin.Annotations annotations = 8 [json_name = "annotations"];
  bool has_annotations() const;
  private:
  bool _internal_has_annotations() const;
  public:
  void clear_annotations();
  const ::flyteidl::admin::Annotations& annotations() const;
  PROTOBUF_NODISCARD ::flyteidl::admin::Annotations* release_annotations();
  ::flyteidl::admin::Annotations* mutable_annotations();
  void set_allocated_annotations(::flyteidl::admin::Annotations* annotations);
  private:
  const ::flyteidl::admin::Annotations& _internal_annotations() const;
  ::flyteidl::admin::Annotations* _internal_mutable_annotations();
  public:
  void unsafe_arena_set_allocated_annotations(
      ::flyteidl::admin::Annotations* annotations);
  ::flyteidl::admin::Annotations* unsafe_arena_release_annotations();

  // .flyteidl.core.SecurityContext security_context = 10 [json_name = "securityContext"];
  bool has_security_context() const;
  private:
  bool _internal_has_security_context() const;
  public:
  void clear_security_context();
  const ::flyteidl::core::SecurityContext& security_context() const;
  PROTOBUF_NODISCARD ::flyteidl::core::SecurityContext* release_security_context();
  ::flyteidl::core::SecurityContext* mutable_security_context();
  void set_allocated_security_context(::flyteidl::core::SecurityContext* security_context);
  private:
  const ::flyteidl::core::SecurityContext& _internal_security_context() const;
  ::flyteidl::core::SecurityContext* _internal_mutable_security_context();
  public:
  void unsafe_arena_set_allocated_security_context(
      ::flyteidl::core::SecurityContext* security_context);
  ::flyteidl::core::SecurityContext* unsafe_arena_release_security_context();

  // .flyteidl.admin.AuthRole auth_role = 16 [json_name = "authRole", deprecated = true];
  PROTOBUF_DEPRECATED bool has_auth_role() const;
  private:
  bool _internal_has_auth_role() const;
  public:
  PROTOBUF_DEPRECATED void clear_auth_role();
  PROTOBUF_DEPRECATED const ::flyteidl::admin::AuthRole& auth_role() const;
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED ::flyteidl::admin::AuthRole* release_auth_role();
  PROTOBUF_DEPRECATED ::flyteidl::admin::AuthRole* mutable_auth_role();
  PROTOBUF_DEPRECATED void set_allocated_auth_role(::flyteidl::admin::AuthRole* auth_role);
  private:
  const ::flyteidl::admin::AuthRole& _internal_auth_role() const;
  ::flyteidl::admin::AuthRole* _internal_mutable_auth_role();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_auth_role(
      ::flyteidl::admin::AuthRole* auth_role);
  PROTOBUF_DEPRECATED ::flyteidl::admin::AuthRole* unsafe_arena_release_auth_role();

  // .flyteidl.core.QualityOfService quality_of_service = 17 [json_name = "qualityOfService"];
  bool has_quality_of_service() const;
  private:
  bool _internal_has_quality_of_service() const;
  public:
  void clear_quality_of_service();
  const ::flyteidl::core::QualityOfService& quality_of_service() const;
  PROTOBUF_NODISCARD ::flyteidl::core::QualityOfService* release_quality_of_service();
  ::flyteidl::core::QualityOfService* mutable_quality_of_service();
  void set_allocated_quality_of_service(::flyteidl::core::QualityOfService* quality_of_service);
  private:
  const ::flyteidl::core::QualityOfService& _internal_quality_of_service() const;
  ::flyteidl::core::QualityOfService* _internal_mutable_quality_of_service();
  public:
  void unsafe_arena_set_allocated_quality_of_service(
      ::flyteidl::core::QualityOfService* quality_of_service);
  ::flyteidl::core::QualityOfService* unsafe_arena_release_quality_of_service();

  // .flyteidl.admin.RawOutputDataConfig raw_output_data_config = 19 [json_name = "rawOutputDataConfig"];
  bool has_raw_output_data_config() const;
  private:
  bool _internal_has_raw_output_data_config() const;
  public:
  void clear_raw_output_data_config();
  const ::flyteidl::admin::RawOutputDataConfig& raw_output_data_config() const;
  PROTOBUF_NODISCARD ::flyteidl::admin::RawOutputDataConfig* release_raw_output_data_config();
  ::flyteidl::admin::RawOutputDataConfig* mutable_raw_output_data_config();
  void set_allocated_raw_output_data_config(::flyteidl::admin::RawOutputDataConfig* raw_output_data_config);
  private:
  const ::flyteidl::admin::RawOutputDataConfig& _internal_raw_output_data_config() const;
  ::flyteidl::admin::RawOutputDataConfig* _internal_mutable_raw_output_data_config();
  public:
  void unsafe_arena_set_allocated_raw_output_data_config(
      ::flyteidl::admin::RawOutputDataConfig* raw_output_data_config);
  ::flyteidl::admin::RawOutputDataConfig* unsafe_arena_release_raw_output_data_config();

  // .flyteidl.admin.ClusterAssignment cluster_assignment = 20 [json_name = "clusterAssignment"];
  bool has_cluster_assignment() const;
  private:
  bool _internal_has_cluster_assignment() const;
  public:
  void clear_cluster_assignment();
  const ::flyteidl::admin::ClusterAssignment& cluster_assignment() const;
  PROTOBUF_NODISCARD ::flyteidl::admin::ClusterAssignment* release_cluster_assignment();
  ::flyteidl::admin::ClusterAssignment* mutable_cluster_assignment();
  void set_allocated_cluster_assignment(::flyteidl::admin::ClusterAssignment* cluster_assignment);
  private:
  const ::flyteidl::admin::ClusterAssignment& _internal_cluster_assignment() const;
  ::flyteidl::admin::ClusterAssignment* _internal_mutable_cluster_assignment();
  public:
  void unsafe_arena_set_allocated_cluster_assignment(
      ::flyteidl::admin::ClusterAssignment* cluster_assignment);
  ::flyteidl::admin::ClusterAssignment* unsafe_arena_release_cluster_assignment();

  // int32 max_parallelism = 18 [json_name = "maxParallelism"];
  void clear_max_parallelism();
  int32_t max_parallelism() const;
  void set_max_parallelism(int32_t value);
  private:
  int32_t _internal_max_parallelism() const;
  void _internal_set_max_parallelism(int32_t value);
  public:

  // .flyteidl.admin.NotificationList notifications = 5 [json_name = "notifications"];
  bool has_notifications() const;
  private:
  bool _internal_has_notifications() const;
  public:
  void clear_notifications();
  const ::flyteidl::admin::NotificationList& notifications() const;
  PROTOBUF_NODISCARD ::flyteidl::admin::NotificationList* release_notifications();
  ::flyteidl::admin::NotificationList* mutable_notifications();
  void set_allocated_notifications(::flyteidl::admin::NotificationList* notifications);
  private:
  const ::flyteidl::admin::NotificationList& _internal_notifications() const;
  ::flyteidl::admin::NotificationList* _internal_mutable_notifications();
  public:
  void unsafe_arena_set_allocated_notifications(
      ::flyteidl::admin::NotificationList* notifications);
  ::flyteidl::admin::NotificationList* unsafe_arena_release_notifications();

  // bool disable_all = 6 [json_name = "disableAll"];
  bool has_disable_all() const;
  private:
  bool _internal_has_disable_all() const;
  public:
  void clear_disable_all();
  bool disable_all() const;
  void set_disable_all(bool value);
  private:
  bool _internal_disable_all() const;
  void _internal_set_disable_all(bool value);
  public:

  void clear_notification_overrides();
  NotificationOverridesCase notification_overrides_case() const;
  // @@protoc_insertion_point(class_scope:flyteidl.admin.ExecutionSpec)
 private:
  class _Internal;
  void set_has_notifications();
  void set_has_disable_all();

  inline bool has_notification_overrides() const;
  inline void clear_has_notification_overrides();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::flyteidl::core::Identifier* launch_plan_;
  ::flyteidl::core::LiteralMap* inputs_;
  ::flyteidl::admin::ExecutionMetadata* metadata_;
  ::flyteidl::admin::Labels* labels_;
  ::flyteidl::admin::Annotations* annotations_;
  ::flyteidl::core::SecurityContext* security_context_;
  ::flyteidl::admin::AuthRole* auth_role_;
  ::flyteidl::core::QualityOfService* quality_of_service_;
  ::flyteidl::admin::RawOutputDataConfig* raw_output_data_config_;
  ::flyteidl::admin::ClusterAssignment* cluster_assignment_;
  int32_t max_parallelism_;
  union NotificationOverridesUnion {
    constexpr NotificationOverridesUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::flyteidl::admin::NotificationList* notifications_;
    bool disable_all_;
  } notification_overrides_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_flyteidl_2fadmin_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class ExecutionTerminateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.admin.ExecutionTerminateRequest) */ {
 public:
  inline ExecutionTerminateRequest() : ExecutionTerminateRequest(nullptr) {}
  ~ExecutionTerminateRequest() override;
  explicit constexpr ExecutionTerminateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExecutionTerminateRequest(const ExecutionTerminateRequest& from);
  ExecutionTerminateRequest(ExecutionTerminateRequest&& from) noexcept
    : ExecutionTerminateRequest() {
    *this = ::std::move(from);
  }

  inline ExecutionTerminateRequest& operator=(const ExecutionTerminateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecutionTerminateRequest& operator=(ExecutionTerminateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecutionTerminateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecutionTerminateRequest* internal_default_instance() {
    return reinterpret_cast<const ExecutionTerminateRequest*>(
               &_ExecutionTerminateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ExecutionTerminateRequest& a, ExecutionTerminateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ExecutionTerminateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecutionTerminateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExecutionTerminateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExecutionTerminateRequest>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecutionTerminateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.admin.ExecutionTerminateRequest";
  }
  protected:
  explicit ExecutionTerminateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCauseFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // string cause = 2 [json_name = "cause"];
  void clear_cause();
  const std::string& cause() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cause(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cause();
  PROTOBUF_NODISCARD std::string* release_cause();
  void set_allocated_cause(std::string* cause);
  private:
  const std::string& _internal_cause() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cause(const std::string& value);
  std::string* _internal_mutable_cause();
  public:

  // .flyteidl.core.WorkflowExecutionIdentifier id = 1 [json_name = "id"];
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::flyteidl::core::WorkflowExecutionIdentifier& id() const;
  PROTOBUF_NODISCARD ::flyteidl::core::WorkflowExecutionIdentifier* release_id();
  ::flyteidl::core::WorkflowExecutionIdentifier* mutable_id();
  void set_allocated_id(::flyteidl::core::WorkflowExecutionIdentifier* id);
  private:
  const ::flyteidl::core::WorkflowExecutionIdentifier& _internal_id() const;
  ::flyteidl::core::WorkflowExecutionIdentifier* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::flyteidl::core::WorkflowExecutionIdentifier* id);
  ::flyteidl::core::WorkflowExecutionIdentifier* unsafe_arena_release_id();

  // @@protoc_insertion_point(class_scope:flyteidl.admin.ExecutionTerminateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cause_;
  ::flyteidl::core::WorkflowExecutionIdentifier* id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fadmin_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class ExecutionTerminateResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:flyteidl.admin.ExecutionTerminateResponse) */ {
 public:
  inline ExecutionTerminateResponse() : ExecutionTerminateResponse(nullptr) {}
  explicit constexpr ExecutionTerminateResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExecutionTerminateResponse(const ExecutionTerminateResponse& from);
  ExecutionTerminateResponse(ExecutionTerminateResponse&& from) noexcept
    : ExecutionTerminateResponse() {
    *this = ::std::move(from);
  }

  inline ExecutionTerminateResponse& operator=(const ExecutionTerminateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecutionTerminateResponse& operator=(ExecutionTerminateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecutionTerminateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecutionTerminateResponse* internal_default_instance() {
    return reinterpret_cast<const ExecutionTerminateResponse*>(
               &_ExecutionTerminateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ExecutionTerminateResponse& a, ExecutionTerminateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ExecutionTerminateResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecutionTerminateResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExecutionTerminateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExecutionTerminateResponse>(arena);
  }

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.admin.ExecutionTerminateResponse";
  }
  protected:
  explicit ExecutionTerminateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:flyteidl.admin.ExecutionTerminateResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fadmin_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class WorkflowExecutionGetDataRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.admin.WorkflowExecutionGetDataRequest) */ {
 public:
  inline WorkflowExecutionGetDataRequest() : WorkflowExecutionGetDataRequest(nullptr) {}
  ~WorkflowExecutionGetDataRequest() override;
  explicit constexpr WorkflowExecutionGetDataRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WorkflowExecutionGetDataRequest(const WorkflowExecutionGetDataRequest& from);
  WorkflowExecutionGetDataRequest(WorkflowExecutionGetDataRequest&& from) noexcept
    : WorkflowExecutionGetDataRequest() {
    *this = ::std::move(from);
  }

  inline WorkflowExecutionGetDataRequest& operator=(const WorkflowExecutionGetDataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkflowExecutionGetDataRequest& operator=(WorkflowExecutionGetDataRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkflowExecutionGetDataRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorkflowExecutionGetDataRequest* internal_default_instance() {
    return reinterpret_cast<const WorkflowExecutionGetDataRequest*>(
               &_WorkflowExecutionGetDataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(WorkflowExecutionGetDataRequest& a, WorkflowExecutionGetDataRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkflowExecutionGetDataRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkflowExecutionGetDataRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorkflowExecutionGetDataRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WorkflowExecutionGetDataRequest>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkflowExecutionGetDataRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.admin.WorkflowExecutionGetDataRequest";
  }
  protected:
  explicit WorkflowExecutionGetDataRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // .flyteidl.core.WorkflowExecutionIdentifier id = 1 [json_name = "id"];
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::flyteidl::core::WorkflowExecutionIdentifier& id() const;
  PROTOBUF_NODISCARD ::flyteidl::core::WorkflowExecutionIdentifier* release_id();
  ::flyteidl::core::WorkflowExecutionIdentifier* mutable_id();
  void set_allocated_id(::flyteidl::core::WorkflowExecutionIdentifier* id);
  private:
  const ::flyteidl::core::WorkflowExecutionIdentifier& _internal_id() const;
  ::flyteidl::core::WorkflowExecutionIdentifier* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::flyteidl::core::WorkflowExecutionIdentifier* id);
  ::flyteidl::core::WorkflowExecutionIdentifier* unsafe_arena_release_id();

  // @@protoc_insertion_point(class_scope:flyteidl.admin.WorkflowExecutionGetDataRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::flyteidl::core::WorkflowExecutionIdentifier* id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fadmin_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class WorkflowExecutionGetDataResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.admin.WorkflowExecutionGetDataResponse) */ {
 public:
  inline WorkflowExecutionGetDataResponse() : WorkflowExecutionGetDataResponse(nullptr) {}
  ~WorkflowExecutionGetDataResponse() override;
  explicit constexpr WorkflowExecutionGetDataResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WorkflowExecutionGetDataResponse(const WorkflowExecutionGetDataResponse& from);
  WorkflowExecutionGetDataResponse(WorkflowExecutionGetDataResponse&& from) noexcept
    : WorkflowExecutionGetDataResponse() {
    *this = ::std::move(from);
  }

  inline WorkflowExecutionGetDataResponse& operator=(const WorkflowExecutionGetDataResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkflowExecutionGetDataResponse& operator=(WorkflowExecutionGetDataResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkflowExecutionGetDataResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorkflowExecutionGetDataResponse* internal_default_instance() {
    return reinterpret_cast<const WorkflowExecutionGetDataResponse*>(
               &_WorkflowExecutionGetDataResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(WorkflowExecutionGetDataResponse& a, WorkflowExecutionGetDataResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkflowExecutionGetDataResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkflowExecutionGetDataResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorkflowExecutionGetDataResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WorkflowExecutionGetDataResponse>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkflowExecutionGetDataResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.admin.WorkflowExecutionGetDataResponse";
  }
  protected:
  explicit WorkflowExecutionGetDataResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOutputsFieldNumber = 1,
    kInputsFieldNumber = 2,
    kFullInputsFieldNumber = 3,
    kFullOutputsFieldNumber = 4,
  };
  // .flyteidl.admin.UrlBlob outputs = 1 [json_name = "outputs", deprecated = true];
  PROTOBUF_DEPRECATED bool has_outputs() const;
  private:
  bool _internal_has_outputs() const;
  public:
  PROTOBUF_DEPRECATED void clear_outputs();
  PROTOBUF_DEPRECATED const ::flyteidl::admin::UrlBlob& outputs() const;
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED ::flyteidl::admin::UrlBlob* release_outputs();
  PROTOBUF_DEPRECATED ::flyteidl::admin::UrlBlob* mutable_outputs();
  PROTOBUF_DEPRECATED void set_allocated_outputs(::flyteidl::admin::UrlBlob* outputs);
  private:
  const ::flyteidl::admin::UrlBlob& _internal_outputs() const;
  ::flyteidl::admin::UrlBlob* _internal_mutable_outputs();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_outputs(
      ::flyteidl::admin::UrlBlob* outputs);
  PROTOBUF_DEPRECATED ::flyteidl::admin::UrlBlob* unsafe_arena_release_outputs();

  // .flyteidl.admin.UrlBlob inputs = 2 [json_name = "inputs", deprecated = true];
  PROTOBUF_DEPRECATED bool has_inputs() const;
  private:
  bool _internal_has_inputs() const;
  public:
  PROTOBUF_DEPRECATED void clear_inputs();
  PROTOBUF_DEPRECATED const ::flyteidl::admin::UrlBlob& inputs() const;
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED ::flyteidl::admin::UrlBlob* release_inputs();
  PROTOBUF_DEPRECATED ::flyteidl::admin::UrlBlob* mutable_inputs();
  PROTOBUF_DEPRECATED void set_allocated_inputs(::flyteidl::admin::UrlBlob* inputs);
  private:
  const ::flyteidl::admin::UrlBlob& _internal_inputs() const;
  ::flyteidl::admin::UrlBlob* _internal_mutable_inputs();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_inputs(
      ::flyteidl::admin::UrlBlob* inputs);
  PROTOBUF_DEPRECATED ::flyteidl::admin::UrlBlob* unsafe_arena_release_inputs();

  // .flyteidl.core.LiteralMap full_inputs = 3 [json_name = "fullInputs"];
  bool has_full_inputs() const;
  private:
  bool _internal_has_full_inputs() const;
  public:
  void clear_full_inputs();
  const ::flyteidl::core::LiteralMap& full_inputs() const;
  PROTOBUF_NODISCARD ::flyteidl::core::LiteralMap* release_full_inputs();
  ::flyteidl::core::LiteralMap* mutable_full_inputs();
  void set_allocated_full_inputs(::flyteidl::core::LiteralMap* full_inputs);
  private:
  const ::flyteidl::core::LiteralMap& _internal_full_inputs() const;
  ::flyteidl::core::LiteralMap* _internal_mutable_full_inputs();
  public:
  void unsafe_arena_set_allocated_full_inputs(
      ::flyteidl::core::LiteralMap* full_inputs);
  ::flyteidl::core::LiteralMap* unsafe_arena_release_full_inputs();

  // .flyteidl.core.LiteralMap full_outputs = 4 [json_name = "fullOutputs"];
  bool has_full_outputs() const;
  private:
  bool _internal_has_full_outputs() const;
  public:
  void clear_full_outputs();
  const ::flyteidl::core::LiteralMap& full_outputs() const;
  PROTOBUF_NODISCARD ::flyteidl::core::LiteralMap* release_full_outputs();
  ::flyteidl::core::LiteralMap* mutable_full_outputs();
  void set_allocated_full_outputs(::flyteidl::core::LiteralMap* full_outputs);
  private:
  const ::flyteidl::core::LiteralMap& _internal_full_outputs() const;
  ::flyteidl::core::LiteralMap* _internal_mutable_full_outputs();
  public:
  void unsafe_arena_set_allocated_full_outputs(
      ::flyteidl::core::LiteralMap* full_outputs);
  ::flyteidl::core::LiteralMap* unsafe_arena_release_full_outputs();

  // @@protoc_insertion_point(class_scope:flyteidl.admin.WorkflowExecutionGetDataResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::flyteidl::admin::UrlBlob* outputs_;
  ::flyteidl::admin::UrlBlob* inputs_;
  ::flyteidl::core::LiteralMap* full_inputs_;
  ::flyteidl::core::LiteralMap* full_outputs_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fadmin_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class ExecutionUpdateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.admin.ExecutionUpdateRequest) */ {
 public:
  inline ExecutionUpdateRequest() : ExecutionUpdateRequest(nullptr) {}
  ~ExecutionUpdateRequest() override;
  explicit constexpr ExecutionUpdateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExecutionUpdateRequest(const ExecutionUpdateRequest& from);
  ExecutionUpdateRequest(ExecutionUpdateRequest&& from) noexcept
    : ExecutionUpdateRequest() {
    *this = ::std::move(from);
  }

  inline ExecutionUpdateRequest& operator=(const ExecutionUpdateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecutionUpdateRequest& operator=(ExecutionUpdateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecutionUpdateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecutionUpdateRequest* internal_default_instance() {
    return reinterpret_cast<const ExecutionUpdateRequest*>(
               &_ExecutionUpdateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ExecutionUpdateRequest& a, ExecutionUpdateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ExecutionUpdateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecutionUpdateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExecutionUpdateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExecutionUpdateRequest>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecutionUpdateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.admin.ExecutionUpdateRequest";
  }
  protected:
  explicit ExecutionUpdateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kStateFieldNumber = 2,
  };
  // .flyteidl.core.WorkflowExecutionIdentifier id = 1 [json_name = "id"];
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::flyteidl::core::WorkflowExecutionIdentifier& id() const;
  PROTOBUF_NODISCARD ::flyteidl::core::WorkflowExecutionIdentifier* release_id();
  ::flyteidl::core::WorkflowExecutionIdentifier* mutable_id();
  void set_allocated_id(::flyteidl::core::WorkflowExecutionIdentifier* id);
  private:
  const ::flyteidl::core::WorkflowExecutionIdentifier& _internal_id() const;
  ::flyteidl::core::WorkflowExecutionIdentifier* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::flyteidl::core::WorkflowExecutionIdentifier* id);
  ::flyteidl::core::WorkflowExecutionIdentifier* unsafe_arena_release_id();

  // .flyteidl.admin.ExecutionState state = 2 [json_name = "state"];
  void clear_state();
  ::flyteidl::admin::ExecutionState state() const;
  void set_state(::flyteidl::admin::ExecutionState value);
  private:
  ::flyteidl::admin::ExecutionState _internal_state() const;
  void _internal_set_state(::flyteidl::admin::ExecutionState value);
  public:

  // @@protoc_insertion_point(class_scope:flyteidl.admin.ExecutionUpdateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::flyteidl::core::WorkflowExecutionIdentifier* id_;
  int state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fadmin_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class ExecutionStateChangeDetails final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.admin.ExecutionStateChangeDetails) */ {
 public:
  inline ExecutionStateChangeDetails() : ExecutionStateChangeDetails(nullptr) {}
  ~ExecutionStateChangeDetails() override;
  explicit constexpr ExecutionStateChangeDetails(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExecutionStateChangeDetails(const ExecutionStateChangeDetails& from);
  ExecutionStateChangeDetails(ExecutionStateChangeDetails&& from) noexcept
    : ExecutionStateChangeDetails() {
    *this = ::std::move(from);
  }

  inline ExecutionStateChangeDetails& operator=(const ExecutionStateChangeDetails& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecutionStateChangeDetails& operator=(ExecutionStateChangeDetails&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecutionStateChangeDetails& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecutionStateChangeDetails* internal_default_instance() {
    return reinterpret_cast<const ExecutionStateChangeDetails*>(
               &_ExecutionStateChangeDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ExecutionStateChangeDetails& a, ExecutionStateChangeDetails& b) {
    a.Swap(&b);
  }
  inline void Swap(ExecutionStateChangeDetails* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecutionStateChangeDetails* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExecutionStateChangeDetails* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExecutionStateChangeDetails>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecutionStateChangeDetails* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.admin.ExecutionStateChangeDetails";
  }
  protected:
  explicit ExecutionStateChangeDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPrincipalFieldNumber = 3,
    kOccurredAtFieldNumber = 2,
    kStateFieldNumber = 1,
  };
  // string principal = 3 [json_name = "principal"];
  void clear_principal();
  const std::string& principal() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_principal(ArgT0&& arg0, ArgT... args);
  std::string* mutable_principal();
  PROTOBUF_NODISCARD std::string* release_principal();
  void set_allocated_principal(std::string* principal);
  private:
  const std::string& _internal_principal() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_principal(const std::string& value);
  std::string* _internal_mutable_principal();
  public:

  // .google.protobuf.Timestamp occurred_at = 2 [json_name = "occurredAt"];
  bool has_occurred_at() const;
  private:
  bool _internal_has_occurred_at() const;
  public:
  void clear_occurred_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& occurred_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_occurred_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_occurred_at();
  void set_allocated_occurred_at(::PROTOBUF_NAMESPACE_ID::Timestamp* occurred_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_occurred_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_occurred_at();
  public:
  void unsafe_arena_set_allocated_occurred_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* occurred_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_occurred_at();

  // .flyteidl.admin.ExecutionState state = 1 [json_name = "state"];
  void clear_state();
  ::flyteidl::admin::ExecutionState state() const;
  void set_state(::flyteidl::admin::ExecutionState value);
  private:
  ::flyteidl::admin::ExecutionState _internal_state() const;
  void _internal_set_state(::flyteidl::admin::ExecutionState value);
  public:

  // @@protoc_insertion_point(class_scope:flyteidl.admin.ExecutionStateChangeDetails)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr principal_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* occurred_at_;
  int state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fadmin_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class ExecutionUpdateResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:flyteidl.admin.ExecutionUpdateResponse) */ {
 public:
  inline ExecutionUpdateResponse() : ExecutionUpdateResponse(nullptr) {}
  explicit constexpr ExecutionUpdateResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExecutionUpdateResponse(const ExecutionUpdateResponse& from);
  ExecutionUpdateResponse(ExecutionUpdateResponse&& from) noexcept
    : ExecutionUpdateResponse() {
    *this = ::std::move(from);
  }

  inline ExecutionUpdateResponse& operator=(const ExecutionUpdateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecutionUpdateResponse& operator=(ExecutionUpdateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecutionUpdateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecutionUpdateResponse* internal_default_instance() {
    return reinterpret_cast<const ExecutionUpdateResponse*>(
               &_ExecutionUpdateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(ExecutionUpdateResponse& a, ExecutionUpdateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ExecutionUpdateResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecutionUpdateResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExecutionUpdateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExecutionUpdateResponse>(arena);
  }

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.admin.ExecutionUpdateResponse";
  }
  protected:
  explicit ExecutionUpdateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:flyteidl.admin.ExecutionUpdateResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fadmin_2fexecution_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ExecutionCreateRequest

// string project = 1 [json_name = "project"];
inline void ExecutionCreateRequest::clear_project() {
  project_.ClearToEmpty();
}
inline const std::string& ExecutionCreateRequest::project() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.ExecutionCreateRequest.project)
  return _internal_project();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecutionCreateRequest::set_project(ArgT0&& arg0, ArgT... args) {
 
 project_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.admin.ExecutionCreateRequest.project)
}
inline std::string* ExecutionCreateRequest::mutable_project() {
  std::string* _s = _internal_mutable_project();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.ExecutionCreateRequest.project)
  return _s;
}
inline const std::string& ExecutionCreateRequest::_internal_project() const {
  return project_.Get();
}
inline void ExecutionCreateRequest::_internal_set_project(const std::string& value) {
  
  project_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ExecutionCreateRequest::_internal_mutable_project() {
  
  return project_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ExecutionCreateRequest::release_project() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.ExecutionCreateRequest.project)
  return project_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ExecutionCreateRequest::set_allocated_project(std::string* project) {
  if (project != nullptr) {
    
  } else {
    
  }
  project_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), project,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (project_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    project_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.ExecutionCreateRequest.project)
}

// string domain = 2 [json_name = "domain"];
inline void ExecutionCreateRequest::clear_domain() {
  domain_.ClearToEmpty();
}
inline const std::string& ExecutionCreateRequest::domain() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.ExecutionCreateRequest.domain)
  return _internal_domain();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecutionCreateRequest::set_domain(ArgT0&& arg0, ArgT... args) {
 
 domain_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.admin.ExecutionCreateRequest.domain)
}
inline std::string* ExecutionCreateRequest::mutable_domain() {
  std::string* _s = _internal_mutable_domain();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.ExecutionCreateRequest.domain)
  return _s;
}
inline const std::string& ExecutionCreateRequest::_internal_domain() const {
  return domain_.Get();
}
inline void ExecutionCreateRequest::_internal_set_domain(const std::string& value) {
  
  domain_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ExecutionCreateRequest::_internal_mutable_domain() {
  
  return domain_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ExecutionCreateRequest::release_domain() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.ExecutionCreateRequest.domain)
  return domain_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ExecutionCreateRequest::set_allocated_domain(std::string* domain) {
  if (domain != nullptr) {
    
  } else {
    
  }
  domain_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), domain,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (domain_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    domain_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.ExecutionCreateRequest.domain)
}

// string name = 3 [json_name = "name"];
inline void ExecutionCreateRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& ExecutionCreateRequest::name() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.ExecutionCreateRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecutionCreateRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.admin.ExecutionCreateRequest.name)
}
inline std::string* ExecutionCreateRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.ExecutionCreateRequest.name)
  return _s;
}
inline const std::string& ExecutionCreateRequest::_internal_name() const {
  return name_.Get();
}
inline void ExecutionCreateRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ExecutionCreateRequest::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ExecutionCreateRequest::release_name() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.ExecutionCreateRequest.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ExecutionCreateRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.ExecutionCreateRequest.name)
}

// .flyteidl.admin.ExecutionSpec spec = 4 [json_name = "spec"];
inline bool ExecutionCreateRequest::_internal_has_spec() const {
  return this != internal_default_instance() && spec_ != nullptr;
}
inline bool ExecutionCreateRequest::has_spec() const {
  return _internal_has_spec();
}
inline void ExecutionCreateRequest::clear_spec() {
  if (GetArenaForAllocation() == nullptr && spec_ != nullptr) {
    delete spec_;
  }
  spec_ = nullptr;
}
inline const ::flyteidl::admin::ExecutionSpec& ExecutionCreateRequest::_internal_spec() const {
  const ::flyteidl::admin::ExecutionSpec* p = spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::admin::ExecutionSpec&>(
      ::flyteidl::admin::_ExecutionSpec_default_instance_);
}
inline const ::flyteidl::admin::ExecutionSpec& ExecutionCreateRequest::spec() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.ExecutionCreateRequest.spec)
  return _internal_spec();
}
inline void ExecutionCreateRequest::unsafe_arena_set_allocated_spec(
    ::flyteidl::admin::ExecutionSpec* spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spec_);
  }
  spec_ = spec;
  if (spec) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.ExecutionCreateRequest.spec)
}
inline ::flyteidl::admin::ExecutionSpec* ExecutionCreateRequest::release_spec() {
  
  ::flyteidl::admin::ExecutionSpec* temp = spec_;
  spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::admin::ExecutionSpec* ExecutionCreateRequest::unsafe_arena_release_spec() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.ExecutionCreateRequest.spec)
  
  ::flyteidl::admin::ExecutionSpec* temp = spec_;
  spec_ = nullptr;
  return temp;
}
inline ::flyteidl::admin::ExecutionSpec* ExecutionCreateRequest::_internal_mutable_spec() {
  
  if (spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::admin::ExecutionSpec>(GetArenaForAllocation());
    spec_ = p;
  }
  return spec_;
}
inline ::flyteidl::admin::ExecutionSpec* ExecutionCreateRequest::mutable_spec() {
  ::flyteidl::admin::ExecutionSpec* _msg = _internal_mutable_spec();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.ExecutionCreateRequest.spec)
  return _msg;
}
inline void ExecutionCreateRequest::set_allocated_spec(::flyteidl::admin::ExecutionSpec* spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete spec_;
  }
  if (spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::flyteidl::admin::ExecutionSpec>::GetOwningArena(spec);
    if (message_arena != submessage_arena) {
      spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    
  } else {
    
  }
  spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.ExecutionCreateRequest.spec)
}

// .flyteidl.core.LiteralMap inputs = 5 [json_name = "inputs"];
inline bool ExecutionCreateRequest::_internal_has_inputs() const {
  return this != internal_default_instance() && inputs_ != nullptr;
}
inline bool ExecutionCreateRequest::has_inputs() const {
  return _internal_has_inputs();
}
inline const ::flyteidl::core::LiteralMap& ExecutionCreateRequest::_internal_inputs() const {
  const ::flyteidl::core::LiteralMap* p = inputs_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::core::LiteralMap&>(
      ::flyteidl::core::_LiteralMap_default_instance_);
}
inline const ::flyteidl::core::LiteralMap& ExecutionCreateRequest::inputs() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.ExecutionCreateRequest.inputs)
  return _internal_inputs();
}
inline void ExecutionCreateRequest::unsafe_arena_set_allocated_inputs(
    ::flyteidl::core::LiteralMap* inputs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(inputs_);
  }
  inputs_ = inputs;
  if (inputs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.ExecutionCreateRequest.inputs)
}
inline ::flyteidl::core::LiteralMap* ExecutionCreateRequest::release_inputs() {
  
  ::flyteidl::core::LiteralMap* temp = inputs_;
  inputs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::core::LiteralMap* ExecutionCreateRequest::unsafe_arena_release_inputs() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.ExecutionCreateRequest.inputs)
  
  ::flyteidl::core::LiteralMap* temp = inputs_;
  inputs_ = nullptr;
  return temp;
}
inline ::flyteidl::core::LiteralMap* ExecutionCreateRequest::_internal_mutable_inputs() {
  
  if (inputs_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::LiteralMap>(GetArenaForAllocation());
    inputs_ = p;
  }
  return inputs_;
}
inline ::flyteidl::core::LiteralMap* ExecutionCreateRequest::mutable_inputs() {
  ::flyteidl::core::LiteralMap* _msg = _internal_mutable_inputs();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.ExecutionCreateRequest.inputs)
  return _msg;
}
inline void ExecutionCreateRequest::set_allocated_inputs(::flyteidl::core::LiteralMap* inputs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(inputs_);
  }
  if (inputs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(inputs));
    if (message_arena != submessage_arena) {
      inputs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, inputs, submessage_arena);
    }
    
  } else {
    
  }
  inputs_ = inputs;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.ExecutionCreateRequest.inputs)
}

// -------------------------------------------------------------------

// ExecutionRelaunchRequest

// .flyteidl.core.WorkflowExecutionIdentifier id = 1 [json_name = "id"];
inline bool ExecutionRelaunchRequest::_internal_has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline bool ExecutionRelaunchRequest::has_id() const {
  return _internal_has_id();
}
inline const ::flyteidl::core::WorkflowExecutionIdentifier& ExecutionRelaunchRequest::_internal_id() const {
  const ::flyteidl::core::WorkflowExecutionIdentifier* p = id_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::core::WorkflowExecutionIdentifier&>(
      ::flyteidl::core::_WorkflowExecutionIdentifier_default_instance_);
}
inline const ::flyteidl::core::WorkflowExecutionIdentifier& ExecutionRelaunchRequest::id() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.ExecutionRelaunchRequest.id)
  return _internal_id();
}
inline void ExecutionRelaunchRequest::unsafe_arena_set_allocated_id(
    ::flyteidl::core::WorkflowExecutionIdentifier* id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.ExecutionRelaunchRequest.id)
}
inline ::flyteidl::core::WorkflowExecutionIdentifier* ExecutionRelaunchRequest::release_id() {
  
  ::flyteidl::core::WorkflowExecutionIdentifier* temp = id_;
  id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::core::WorkflowExecutionIdentifier* ExecutionRelaunchRequest::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.ExecutionRelaunchRequest.id)
  
  ::flyteidl::core::WorkflowExecutionIdentifier* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::flyteidl::core::WorkflowExecutionIdentifier* ExecutionRelaunchRequest::_internal_mutable_id() {
  
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::WorkflowExecutionIdentifier>(GetArenaForAllocation());
    id_ = p;
  }
  return id_;
}
inline ::flyteidl::core::WorkflowExecutionIdentifier* ExecutionRelaunchRequest::mutable_id() {
  ::flyteidl::core::WorkflowExecutionIdentifier* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.ExecutionRelaunchRequest.id)
  return _msg;
}
inline void ExecutionRelaunchRequest::set_allocated_id(::flyteidl::core::WorkflowExecutionIdentifier* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id));
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.ExecutionRelaunchRequest.id)
}

// string name = 3 [json_name = "name"];
inline void ExecutionRelaunchRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& ExecutionRelaunchRequest::name() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.ExecutionRelaunchRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecutionRelaunchRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.admin.ExecutionRelaunchRequest.name)
}
inline std::string* ExecutionRelaunchRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.ExecutionRelaunchRequest.name)
  return _s;
}
inline const std::string& ExecutionRelaunchRequest::_internal_name() const {
  return name_.Get();
}
inline void ExecutionRelaunchRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ExecutionRelaunchRequest::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ExecutionRelaunchRequest::release_name() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.ExecutionRelaunchRequest.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ExecutionRelaunchRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.ExecutionRelaunchRequest.name)
}

// -------------------------------------------------------------------

// ExecutionRecoverRequest

// .flyteidl.core.WorkflowExecutionIdentifier id = 1 [json_name = "id"];
inline bool ExecutionRecoverRequest::_internal_has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline bool ExecutionRecoverRequest::has_id() const {
  return _internal_has_id();
}
inline const ::flyteidl::core::WorkflowExecutionIdentifier& ExecutionRecoverRequest::_internal_id() const {
  const ::flyteidl::core::WorkflowExecutionIdentifier* p = id_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::core::WorkflowExecutionIdentifier&>(
      ::flyteidl::core::_WorkflowExecutionIdentifier_default_instance_);
}
inline const ::flyteidl::core::WorkflowExecutionIdentifier& ExecutionRecoverRequest::id() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.ExecutionRecoverRequest.id)
  return _internal_id();
}
inline void ExecutionRecoverRequest::unsafe_arena_set_allocated_id(
    ::flyteidl::core::WorkflowExecutionIdentifier* id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.ExecutionRecoverRequest.id)
}
inline ::flyteidl::core::WorkflowExecutionIdentifier* ExecutionRecoverRequest::release_id() {
  
  ::flyteidl::core::WorkflowExecutionIdentifier* temp = id_;
  id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::core::WorkflowExecutionIdentifier* ExecutionRecoverRequest::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.ExecutionRecoverRequest.id)
  
  ::flyteidl::core::WorkflowExecutionIdentifier* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::flyteidl::core::WorkflowExecutionIdentifier* ExecutionRecoverRequest::_internal_mutable_id() {
  
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::WorkflowExecutionIdentifier>(GetArenaForAllocation());
    id_ = p;
  }
  return id_;
}
inline ::flyteidl::core::WorkflowExecutionIdentifier* ExecutionRecoverRequest::mutable_id() {
  ::flyteidl::core::WorkflowExecutionIdentifier* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.ExecutionRecoverRequest.id)
  return _msg;
}
inline void ExecutionRecoverRequest::set_allocated_id(::flyteidl::core::WorkflowExecutionIdentifier* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id));
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.ExecutionRecoverRequest.id)
}

// string name = 2 [json_name = "name"];
inline void ExecutionRecoverRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& ExecutionRecoverRequest::name() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.ExecutionRecoverRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecutionRecoverRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.admin.ExecutionRecoverRequest.name)
}
inline std::string* ExecutionRecoverRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.ExecutionRecoverRequest.name)
  return _s;
}
inline const std::string& ExecutionRecoverRequest::_internal_name() const {
  return name_.Get();
}
inline void ExecutionRecoverRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ExecutionRecoverRequest::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ExecutionRecoverRequest::release_name() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.ExecutionRecoverRequest.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ExecutionRecoverRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.ExecutionRecoverRequest.name)
}

// .flyteidl.admin.ExecutionMetadata metadata = 3 [json_name = "metadata"];
inline bool ExecutionRecoverRequest::_internal_has_metadata() const {
  return this != internal_default_instance() && metadata_ != nullptr;
}
inline bool ExecutionRecoverRequest::has_metadata() const {
  return _internal_has_metadata();
}
inline void ExecutionRecoverRequest::clear_metadata() {
  if (GetArenaForAllocation() == nullptr && metadata_ != nullptr) {
    delete metadata_;
  }
  metadata_ = nullptr;
}
inline const ::flyteidl::admin::ExecutionMetadata& ExecutionRecoverRequest::_internal_metadata() const {
  const ::flyteidl::admin::ExecutionMetadata* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::admin::ExecutionMetadata&>(
      ::flyteidl::admin::_ExecutionMetadata_default_instance_);
}
inline const ::flyteidl::admin::ExecutionMetadata& ExecutionRecoverRequest::metadata() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.ExecutionRecoverRequest.metadata)
  return _internal_metadata();
}
inline void ExecutionRecoverRequest::unsafe_arena_set_allocated_metadata(
    ::flyteidl::admin::ExecutionMetadata* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.ExecutionRecoverRequest.metadata)
}
inline ::flyteidl::admin::ExecutionMetadata* ExecutionRecoverRequest::release_metadata() {
  
  ::flyteidl::admin::ExecutionMetadata* temp = metadata_;
  metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::admin::ExecutionMetadata* ExecutionRecoverRequest::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.ExecutionRecoverRequest.metadata)
  
  ::flyteidl::admin::ExecutionMetadata* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::flyteidl::admin::ExecutionMetadata* ExecutionRecoverRequest::_internal_mutable_metadata() {
  
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::admin::ExecutionMetadata>(GetArenaForAllocation());
    metadata_ = p;
  }
  return metadata_;
}
inline ::flyteidl::admin::ExecutionMetadata* ExecutionRecoverRequest::mutable_metadata() {
  ::flyteidl::admin::ExecutionMetadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.ExecutionRecoverRequest.metadata)
  return _msg;
}
inline void ExecutionRecoverRequest::set_allocated_metadata(::flyteidl::admin::ExecutionMetadata* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete metadata_;
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::flyteidl::admin::ExecutionMetadata>::GetOwningArena(metadata);
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.ExecutionRecoverRequest.metadata)
}

// -------------------------------------------------------------------

// ExecutionCreateResponse

// .flyteidl.core.WorkflowExecutionIdentifier id = 1 [json_name = "id"];
inline bool ExecutionCreateResponse::_internal_has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline bool ExecutionCreateResponse::has_id() const {
  return _internal_has_id();
}
inline const ::flyteidl::core::WorkflowExecutionIdentifier& ExecutionCreateResponse::_internal_id() const {
  const ::flyteidl::core::WorkflowExecutionIdentifier* p = id_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::core::WorkflowExecutionIdentifier&>(
      ::flyteidl::core::_WorkflowExecutionIdentifier_default_instance_);
}
inline const ::flyteidl::core::WorkflowExecutionIdentifier& ExecutionCreateResponse::id() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.ExecutionCreateResponse.id)
  return _internal_id();
}
inline void ExecutionCreateResponse::unsafe_arena_set_allocated_id(
    ::flyteidl::core::WorkflowExecutionIdentifier* id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.ExecutionCreateResponse.id)
}
inline ::flyteidl::core::WorkflowExecutionIdentifier* ExecutionCreateResponse::release_id() {
  
  ::flyteidl::core::WorkflowExecutionIdentifier* temp = id_;
  id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::core::WorkflowExecutionIdentifier* ExecutionCreateResponse::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.ExecutionCreateResponse.id)
  
  ::flyteidl::core::WorkflowExecutionIdentifier* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::flyteidl::core::WorkflowExecutionIdentifier* ExecutionCreateResponse::_internal_mutable_id() {
  
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::WorkflowExecutionIdentifier>(GetArenaForAllocation());
    id_ = p;
  }
  return id_;
}
inline ::flyteidl::core::WorkflowExecutionIdentifier* ExecutionCreateResponse::mutable_id() {
  ::flyteidl::core::WorkflowExecutionIdentifier* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.ExecutionCreateResponse.id)
  return _msg;
}
inline void ExecutionCreateResponse::set_allocated_id(::flyteidl::core::WorkflowExecutionIdentifier* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id));
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.ExecutionCreateResponse.id)
}

// -------------------------------------------------------------------

// WorkflowExecutionGetRequest

// .flyteidl.core.WorkflowExecutionIdentifier id = 1 [json_name = "id"];
inline bool WorkflowExecutionGetRequest::_internal_has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline bool WorkflowExecutionGetRequest::has_id() const {
  return _internal_has_id();
}
inline const ::flyteidl::core::WorkflowExecutionIdentifier& WorkflowExecutionGetRequest::_internal_id() const {
  const ::flyteidl::core::WorkflowExecutionIdentifier* p = id_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::core::WorkflowExecutionIdentifier&>(
      ::flyteidl::core::_WorkflowExecutionIdentifier_default_instance_);
}
inline const ::flyteidl::core::WorkflowExecutionIdentifier& WorkflowExecutionGetRequest::id() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.WorkflowExecutionGetRequest.id)
  return _internal_id();
}
inline void WorkflowExecutionGetRequest::unsafe_arena_set_allocated_id(
    ::flyteidl::core::WorkflowExecutionIdentifier* id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.WorkflowExecutionGetRequest.id)
}
inline ::flyteidl::core::WorkflowExecutionIdentifier* WorkflowExecutionGetRequest::release_id() {
  
  ::flyteidl::core::WorkflowExecutionIdentifier* temp = id_;
  id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::core::WorkflowExecutionIdentifier* WorkflowExecutionGetRequest::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.WorkflowExecutionGetRequest.id)
  
  ::flyteidl::core::WorkflowExecutionIdentifier* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::flyteidl::core::WorkflowExecutionIdentifier* WorkflowExecutionGetRequest::_internal_mutable_id() {
  
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::WorkflowExecutionIdentifier>(GetArenaForAllocation());
    id_ = p;
  }
  return id_;
}
inline ::flyteidl::core::WorkflowExecutionIdentifier* WorkflowExecutionGetRequest::mutable_id() {
  ::flyteidl::core::WorkflowExecutionIdentifier* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.WorkflowExecutionGetRequest.id)
  return _msg;
}
inline void WorkflowExecutionGetRequest::set_allocated_id(::flyteidl::core::WorkflowExecutionIdentifier* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id));
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.WorkflowExecutionGetRequest.id)
}

// -------------------------------------------------------------------

// Execution

// .flyteidl.core.WorkflowExecutionIdentifier id = 1 [json_name = "id"];
inline bool Execution::_internal_has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline bool Execution::has_id() const {
  return _internal_has_id();
}
inline const ::flyteidl::core::WorkflowExecutionIdentifier& Execution::_internal_id() const {
  const ::flyteidl::core::WorkflowExecutionIdentifier* p = id_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::core::WorkflowExecutionIdentifier&>(
      ::flyteidl::core::_WorkflowExecutionIdentifier_default_instance_);
}
inline const ::flyteidl::core::WorkflowExecutionIdentifier& Execution::id() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.Execution.id)
  return _internal_id();
}
inline void Execution::unsafe_arena_set_allocated_id(
    ::flyteidl::core::WorkflowExecutionIdentifier* id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.Execution.id)
}
inline ::flyteidl::core::WorkflowExecutionIdentifier* Execution::release_id() {
  
  ::flyteidl::core::WorkflowExecutionIdentifier* temp = id_;
  id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::core::WorkflowExecutionIdentifier* Execution::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.Execution.id)
  
  ::flyteidl::core::WorkflowExecutionIdentifier* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::flyteidl::core::WorkflowExecutionIdentifier* Execution::_internal_mutable_id() {
  
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::WorkflowExecutionIdentifier>(GetArenaForAllocation());
    id_ = p;
  }
  return id_;
}
inline ::flyteidl::core::WorkflowExecutionIdentifier* Execution::mutable_id() {
  ::flyteidl::core::WorkflowExecutionIdentifier* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.Execution.id)
  return _msg;
}
inline void Execution::set_allocated_id(::flyteidl::core::WorkflowExecutionIdentifier* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id));
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.Execution.id)
}

// .flyteidl.admin.ExecutionSpec spec = 2 [json_name = "spec"];
inline bool Execution::_internal_has_spec() const {
  return this != internal_default_instance() && spec_ != nullptr;
}
inline bool Execution::has_spec() const {
  return _internal_has_spec();
}
inline void Execution::clear_spec() {
  if (GetArenaForAllocation() == nullptr && spec_ != nullptr) {
    delete spec_;
  }
  spec_ = nullptr;
}
inline const ::flyteidl::admin::ExecutionSpec& Execution::_internal_spec() const {
  const ::flyteidl::admin::ExecutionSpec* p = spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::admin::ExecutionSpec&>(
      ::flyteidl::admin::_ExecutionSpec_default_instance_);
}
inline const ::flyteidl::admin::ExecutionSpec& Execution::spec() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.Execution.spec)
  return _internal_spec();
}
inline void Execution::unsafe_arena_set_allocated_spec(
    ::flyteidl::admin::ExecutionSpec* spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spec_);
  }
  spec_ = spec;
  if (spec) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.Execution.spec)
}
inline ::flyteidl::admin::ExecutionSpec* Execution::release_spec() {
  
  ::flyteidl::admin::ExecutionSpec* temp = spec_;
  spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::admin::ExecutionSpec* Execution::unsafe_arena_release_spec() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.Execution.spec)
  
  ::flyteidl::admin::ExecutionSpec* temp = spec_;
  spec_ = nullptr;
  return temp;
}
inline ::flyteidl::admin::ExecutionSpec* Execution::_internal_mutable_spec() {
  
  if (spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::admin::ExecutionSpec>(GetArenaForAllocation());
    spec_ = p;
  }
  return spec_;
}
inline ::flyteidl::admin::ExecutionSpec* Execution::mutable_spec() {
  ::flyteidl::admin::ExecutionSpec* _msg = _internal_mutable_spec();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.Execution.spec)
  return _msg;
}
inline void Execution::set_allocated_spec(::flyteidl::admin::ExecutionSpec* spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete spec_;
  }
  if (spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::flyteidl::admin::ExecutionSpec>::GetOwningArena(spec);
    if (message_arena != submessage_arena) {
      spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    
  } else {
    
  }
  spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.Execution.spec)
}

// .flyteidl.admin.ExecutionClosure closure = 3 [json_name = "closure"];
inline bool Execution::_internal_has_closure() const {
  return this != internal_default_instance() && closure_ != nullptr;
}
inline bool Execution::has_closure() const {
  return _internal_has_closure();
}
inline void Execution::clear_closure() {
  if (GetArenaForAllocation() == nullptr && closure_ != nullptr) {
    delete closure_;
  }
  closure_ = nullptr;
}
inline const ::flyteidl::admin::ExecutionClosure& Execution::_internal_closure() const {
  const ::flyteidl::admin::ExecutionClosure* p = closure_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::admin::ExecutionClosure&>(
      ::flyteidl::admin::_ExecutionClosure_default_instance_);
}
inline const ::flyteidl::admin::ExecutionClosure& Execution::closure() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.Execution.closure)
  return _internal_closure();
}
inline void Execution::unsafe_arena_set_allocated_closure(
    ::flyteidl::admin::ExecutionClosure* closure) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(closure_);
  }
  closure_ = closure;
  if (closure) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.Execution.closure)
}
inline ::flyteidl::admin::ExecutionClosure* Execution::release_closure() {
  
  ::flyteidl::admin::ExecutionClosure* temp = closure_;
  closure_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::admin::ExecutionClosure* Execution::unsafe_arena_release_closure() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.Execution.closure)
  
  ::flyteidl::admin::ExecutionClosure* temp = closure_;
  closure_ = nullptr;
  return temp;
}
inline ::flyteidl::admin::ExecutionClosure* Execution::_internal_mutable_closure() {
  
  if (closure_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::admin::ExecutionClosure>(GetArenaForAllocation());
    closure_ = p;
  }
  return closure_;
}
inline ::flyteidl::admin::ExecutionClosure* Execution::mutable_closure() {
  ::flyteidl::admin::ExecutionClosure* _msg = _internal_mutable_closure();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.Execution.closure)
  return _msg;
}
inline void Execution::set_allocated_closure(::flyteidl::admin::ExecutionClosure* closure) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete closure_;
  }
  if (closure) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::flyteidl::admin::ExecutionClosure>::GetOwningArena(closure);
    if (message_arena != submessage_arena) {
      closure = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, closure, submessage_arena);
    }
    
  } else {
    
  }
  closure_ = closure;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.Execution.closure)
}

// -------------------------------------------------------------------

// ExecutionList

// repeated .flyteidl.admin.Execution executions = 1 [json_name = "executions"];
inline int ExecutionList::_internal_executions_size() const {
  return executions_.size();
}
inline int ExecutionList::executions_size() const {
  return _internal_executions_size();
}
inline void ExecutionList::clear_executions() {
  executions_.Clear();
}
inline ::flyteidl::admin::Execution* ExecutionList::mutable_executions(int index) {
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.ExecutionList.executions)
  return executions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::admin::Execution >*
ExecutionList::mutable_executions() {
  // @@protoc_insertion_point(field_mutable_list:flyteidl.admin.ExecutionList.executions)
  return &executions_;
}
inline const ::flyteidl::admin::Execution& ExecutionList::_internal_executions(int index) const {
  return executions_.Get(index);
}
inline const ::flyteidl::admin::Execution& ExecutionList::executions(int index) const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.ExecutionList.executions)
  return _internal_executions(index);
}
inline ::flyteidl::admin::Execution* ExecutionList::_internal_add_executions() {
  return executions_.Add();
}
inline ::flyteidl::admin::Execution* ExecutionList::add_executions() {
  ::flyteidl::admin::Execution* _add = _internal_add_executions();
  // @@protoc_insertion_point(field_add:flyteidl.admin.ExecutionList.executions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::admin::Execution >&
ExecutionList::executions() const {
  // @@protoc_insertion_point(field_list:flyteidl.admin.ExecutionList.executions)
  return executions_;
}

// string token = 2 [json_name = "token"];
inline void ExecutionList::clear_token() {
  token_.ClearToEmpty();
}
inline const std::string& ExecutionList::token() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.ExecutionList.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecutionList::set_token(ArgT0&& arg0, ArgT... args) {
 
 token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.admin.ExecutionList.token)
}
inline std::string* ExecutionList::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.ExecutionList.token)
  return _s;
}
inline const std::string& ExecutionList::_internal_token() const {
  return token_.Get();
}
inline void ExecutionList::_internal_set_token(const std::string& value) {
  
  token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ExecutionList::_internal_mutable_token() {
  
  return token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ExecutionList::release_token() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.ExecutionList.token)
  return token_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ExecutionList::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.ExecutionList.token)
}

// -------------------------------------------------------------------

// LiteralMapBlob

// .flyteidl.core.LiteralMap values = 1 [json_name = "values", deprecated = true];
inline bool LiteralMapBlob::_internal_has_values() const {
  return data_case() == kValues;
}
inline bool LiteralMapBlob::has_values() const {
  return _internal_has_values();
}
inline void LiteralMapBlob::set_has_values() {
  _oneof_case_[0] = kValues;
}
inline ::flyteidl::core::LiteralMap* LiteralMapBlob::release_values() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.LiteralMapBlob.values)
  if (_internal_has_values()) {
    clear_has_data();
      ::flyteidl::core::LiteralMap* temp = data_.values_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.values_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::core::LiteralMap& LiteralMapBlob::_internal_values() const {
  return _internal_has_values()
      ? *data_.values_
      : reinterpret_cast< ::flyteidl::core::LiteralMap&>(::flyteidl::core::_LiteralMap_default_instance_);
}
inline const ::flyteidl::core::LiteralMap& LiteralMapBlob::values() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.LiteralMapBlob.values)
  return _internal_values();
}
inline ::flyteidl::core::LiteralMap* LiteralMapBlob::unsafe_arena_release_values() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flyteidl.admin.LiteralMapBlob.values)
  if (_internal_has_values()) {
    clear_has_data();
    ::flyteidl::core::LiteralMap* temp = data_.values_;
    data_.values_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LiteralMapBlob::unsafe_arena_set_allocated_values(::flyteidl::core::LiteralMap* values) {
  clear_data();
  if (values) {
    set_has_values();
    data_.values_ = values;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.LiteralMapBlob.values)
}
inline ::flyteidl::core::LiteralMap* LiteralMapBlob::_internal_mutable_values() {
  if (!_internal_has_values()) {
    clear_data();
    set_has_values();
    data_.values_ = CreateMaybeMessage< ::flyteidl::core::LiteralMap >(GetArenaForAllocation());
  }
  return data_.values_;
}
inline ::flyteidl::core::LiteralMap* LiteralMapBlob::mutable_values() {
  ::flyteidl::core::LiteralMap* _msg = _internal_mutable_values();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.LiteralMapBlob.values)
  return _msg;
}

// string uri = 2 [json_name = "uri"];
inline bool LiteralMapBlob::_internal_has_uri() const {
  return data_case() == kUri;
}
inline bool LiteralMapBlob::has_uri() const {
  return _internal_has_uri();
}
inline void LiteralMapBlob::set_has_uri() {
  _oneof_case_[0] = kUri;
}
inline void LiteralMapBlob::clear_uri() {
  if (_internal_has_uri()) {
    data_.uri_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_data();
  }
}
inline const std::string& LiteralMapBlob::uri() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.LiteralMapBlob.uri)
  return _internal_uri();
}
template <typename ArgT0, typename... ArgT>
inline void LiteralMapBlob::set_uri(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_uri()) {
    clear_data();
    set_has_uri();
    data_.uri_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  data_.uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.admin.LiteralMapBlob.uri)
}
inline std::string* LiteralMapBlob::mutable_uri() {
  std::string* _s = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.LiteralMapBlob.uri)
  return _s;
}
inline const std::string& LiteralMapBlob::_internal_uri() const {
  if (_internal_has_uri()) {
    return data_.uri_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void LiteralMapBlob::_internal_set_uri(const std::string& value) {
  if (!_internal_has_uri()) {
    clear_data();
    set_has_uri();
    data_.uri_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  data_.uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LiteralMapBlob::_internal_mutable_uri() {
  if (!_internal_has_uri()) {
    clear_data();
    set_has_uri();
    data_.uri_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return data_.uri_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LiteralMapBlob::release_uri() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.LiteralMapBlob.uri)
  if (_internal_has_uri()) {
    clear_has_data();
    return data_.uri_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void LiteralMapBlob::set_allocated_uri(std::string* uri) {
  if (has_data()) {
    clear_data();
  }
  if (uri != nullptr) {
    set_has_uri();
    data_.uri_.UnsafeSetDefault(uri);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(uri);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.LiteralMapBlob.uri)
}

inline bool LiteralMapBlob::has_data() const {
  return data_case() != DATA_NOT_SET;
}
inline void LiteralMapBlob::clear_has_data() {
  _oneof_case_[0] = DATA_NOT_SET;
}
inline LiteralMapBlob::DataCase LiteralMapBlob::data_case() const {
  return LiteralMapBlob::DataCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// AbortMetadata

// string cause = 1 [json_name = "cause"];
inline void AbortMetadata::clear_cause() {
  cause_.ClearToEmpty();
}
inline const std::string& AbortMetadata::cause() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.AbortMetadata.cause)
  return _internal_cause();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AbortMetadata::set_cause(ArgT0&& arg0, ArgT... args) {
 
 cause_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.admin.AbortMetadata.cause)
}
inline std::string* AbortMetadata::mutable_cause() {
  std::string* _s = _internal_mutable_cause();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.AbortMetadata.cause)
  return _s;
}
inline const std::string& AbortMetadata::_internal_cause() const {
  return cause_.Get();
}
inline void AbortMetadata::_internal_set_cause(const std::string& value) {
  
  cause_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AbortMetadata::_internal_mutable_cause() {
  
  return cause_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AbortMetadata::release_cause() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.AbortMetadata.cause)
  return cause_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AbortMetadata::set_allocated_cause(std::string* cause) {
  if (cause != nullptr) {
    
  } else {
    
  }
  cause_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cause,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (cause_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    cause_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.AbortMetadata.cause)
}

// string principal = 2 [json_name = "principal"];
inline void AbortMetadata::clear_principal() {
  principal_.ClearToEmpty();
}
inline const std::string& AbortMetadata::principal() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.AbortMetadata.principal)
  return _internal_principal();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AbortMetadata::set_principal(ArgT0&& arg0, ArgT... args) {
 
 principal_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.admin.AbortMetadata.principal)
}
inline std::string* AbortMetadata::mutable_principal() {
  std::string* _s = _internal_mutable_principal();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.AbortMetadata.principal)
  return _s;
}
inline const std::string& AbortMetadata::_internal_principal() const {
  return principal_.Get();
}
inline void AbortMetadata::_internal_set_principal(const std::string& value) {
  
  principal_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AbortMetadata::_internal_mutable_principal() {
  
  return principal_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AbortMetadata::release_principal() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.AbortMetadata.principal)
  return principal_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AbortMetadata::set_allocated_principal(std::string* principal) {
  if (principal != nullptr) {
    
  } else {
    
  }
  principal_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), principal,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (principal_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    principal_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.AbortMetadata.principal)
}

// -------------------------------------------------------------------

// ExecutionClosure

// .flyteidl.admin.LiteralMapBlob outputs = 1 [json_name = "outputs", deprecated = true];
inline bool ExecutionClosure::_internal_has_outputs() const {
  return output_result_case() == kOutputs;
}
inline bool ExecutionClosure::has_outputs() const {
  return _internal_has_outputs();
}
inline void ExecutionClosure::set_has_outputs() {
  _oneof_case_[0] = kOutputs;
}
inline void ExecutionClosure::clear_outputs() {
  if (_internal_has_outputs()) {
    if (GetArenaForAllocation() == nullptr) {
      delete output_result_.outputs_;
    }
    clear_has_output_result();
  }
}
inline ::flyteidl::admin::LiteralMapBlob* ExecutionClosure::release_outputs() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.ExecutionClosure.outputs)
  if (_internal_has_outputs()) {
    clear_has_output_result();
      ::flyteidl::admin::LiteralMapBlob* temp = output_result_.outputs_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    output_result_.outputs_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::admin::LiteralMapBlob& ExecutionClosure::_internal_outputs() const {
  return _internal_has_outputs()
      ? *output_result_.outputs_
      : reinterpret_cast< ::flyteidl::admin::LiteralMapBlob&>(::flyteidl::admin::_LiteralMapBlob_default_instance_);
}
inline const ::flyteidl::admin::LiteralMapBlob& ExecutionClosure::outputs() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.ExecutionClosure.outputs)
  return _internal_outputs();
}
inline ::flyteidl::admin::LiteralMapBlob* ExecutionClosure::unsafe_arena_release_outputs() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flyteidl.admin.ExecutionClosure.outputs)
  if (_internal_has_outputs()) {
    clear_has_output_result();
    ::flyteidl::admin::LiteralMapBlob* temp = output_result_.outputs_;
    output_result_.outputs_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ExecutionClosure::unsafe_arena_set_allocated_outputs(::flyteidl::admin::LiteralMapBlob* outputs) {
  clear_output_result();
  if (outputs) {
    set_has_outputs();
    output_result_.outputs_ = outputs;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.ExecutionClosure.outputs)
}
inline ::flyteidl::admin::LiteralMapBlob* ExecutionClosure::_internal_mutable_outputs() {
  if (!_internal_has_outputs()) {
    clear_output_result();
    set_has_outputs();
    output_result_.outputs_ = CreateMaybeMessage< ::flyteidl::admin::LiteralMapBlob >(GetArenaForAllocation());
  }
  return output_result_.outputs_;
}
inline ::flyteidl::admin::LiteralMapBlob* ExecutionClosure::mutable_outputs() {
  ::flyteidl::admin::LiteralMapBlob* _msg = _internal_mutable_outputs();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.ExecutionClosure.outputs)
  return _msg;
}

// .flyteidl.core.ExecutionError error = 2 [json_name = "error"];
inline bool ExecutionClosure::_internal_has_error() const {
  return output_result_case() == kError;
}
inline bool ExecutionClosure::has_error() const {
  return _internal_has_error();
}
inline void ExecutionClosure::set_has_error() {
  _oneof_case_[0] = kError;
}
inline ::flyteidl::core::ExecutionError* ExecutionClosure::release_error() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.ExecutionClosure.error)
  if (_internal_has_error()) {
    clear_has_output_result();
      ::flyteidl::core::ExecutionError* temp = output_result_.error_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    output_result_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::core::ExecutionError& ExecutionClosure::_internal_error() const {
  return _internal_has_error()
      ? *output_result_.error_
      : reinterpret_cast< ::flyteidl::core::ExecutionError&>(::flyteidl::core::_ExecutionError_default_instance_);
}
inline const ::flyteidl::core::ExecutionError& ExecutionClosure::error() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.ExecutionClosure.error)
  return _internal_error();
}
inline ::flyteidl::core::ExecutionError* ExecutionClosure::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flyteidl.admin.ExecutionClosure.error)
  if (_internal_has_error()) {
    clear_has_output_result();
    ::flyteidl::core::ExecutionError* temp = output_result_.error_;
    output_result_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ExecutionClosure::unsafe_arena_set_allocated_error(::flyteidl::core::ExecutionError* error) {
  clear_output_result();
  if (error) {
    set_has_error();
    output_result_.error_ = error;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.ExecutionClosure.error)
}
inline ::flyteidl::core::ExecutionError* ExecutionClosure::_internal_mutable_error() {
  if (!_internal_has_error()) {
    clear_output_result();
    set_has_error();
    output_result_.error_ = CreateMaybeMessage< ::flyteidl::core::ExecutionError >(GetArenaForAllocation());
  }
  return output_result_.error_;
}
inline ::flyteidl::core::ExecutionError* ExecutionClosure::mutable_error() {
  ::flyteidl::core::ExecutionError* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.ExecutionClosure.error)
  return _msg;
}

// string abort_cause = 10 [json_name = "abortCause", deprecated = true];
inline bool ExecutionClosure::_internal_has_abort_cause() const {
  return output_result_case() == kAbortCause;
}
inline bool ExecutionClosure::has_abort_cause() const {
  return _internal_has_abort_cause();
}
inline void ExecutionClosure::set_has_abort_cause() {
  _oneof_case_[0] = kAbortCause;
}
inline void ExecutionClosure::clear_abort_cause() {
  if (_internal_has_abort_cause()) {
    output_result_.abort_cause_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_output_result();
  }
}
inline const std::string& ExecutionClosure::abort_cause() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.ExecutionClosure.abort_cause)
  return _internal_abort_cause();
}
template <typename ArgT0, typename... ArgT>
inline void ExecutionClosure::set_abort_cause(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_abort_cause()) {
    clear_output_result();
    set_has_abort_cause();
    output_result_.abort_cause_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  output_result_.abort_cause_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.admin.ExecutionClosure.abort_cause)
}
inline std::string* ExecutionClosure::mutable_abort_cause() {
  std::string* _s = _internal_mutable_abort_cause();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.ExecutionClosure.abort_cause)
  return _s;
}
inline const std::string& ExecutionClosure::_internal_abort_cause() const {
  if (_internal_has_abort_cause()) {
    return output_result_.abort_cause_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void ExecutionClosure::_internal_set_abort_cause(const std::string& value) {
  if (!_internal_has_abort_cause()) {
    clear_output_result();
    set_has_abort_cause();
    output_result_.abort_cause_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  output_result_.abort_cause_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ExecutionClosure::_internal_mutable_abort_cause() {
  if (!_internal_has_abort_cause()) {
    clear_output_result();
    set_has_abort_cause();
    output_result_.abort_cause_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return output_result_.abort_cause_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ExecutionClosure::release_abort_cause() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.ExecutionClosure.abort_cause)
  if (_internal_has_abort_cause()) {
    clear_has_output_result();
    return output_result_.abort_cause_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void ExecutionClosure::set_allocated_abort_cause(std::string* abort_cause) {
  if (has_output_result()) {
    clear_output_result();
  }
  if (abort_cause != nullptr) {
    set_has_abort_cause();
    output_result_.abort_cause_.UnsafeSetDefault(abort_cause);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(abort_cause);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.ExecutionClosure.abort_cause)
}

// .flyteidl.admin.AbortMetadata abort_metadata = 12 [json_name = "abortMetadata"];
inline bool ExecutionClosure::_internal_has_abort_metadata() const {
  return output_result_case() == kAbortMetadata;
}
inline bool ExecutionClosure::has_abort_metadata() const {
  return _internal_has_abort_metadata();
}
inline void ExecutionClosure::set_has_abort_metadata() {
  _oneof_case_[0] = kAbortMetadata;
}
inline void ExecutionClosure::clear_abort_metadata() {
  if (_internal_has_abort_metadata()) {
    if (GetArenaForAllocation() == nullptr) {
      delete output_result_.abort_metadata_;
    }
    clear_has_output_result();
  }
}
inline ::flyteidl::admin::AbortMetadata* ExecutionClosure::release_abort_metadata() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.ExecutionClosure.abort_metadata)
  if (_internal_has_abort_metadata()) {
    clear_has_output_result();
      ::flyteidl::admin::AbortMetadata* temp = output_result_.abort_metadata_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    output_result_.abort_metadata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::admin::AbortMetadata& ExecutionClosure::_internal_abort_metadata() const {
  return _internal_has_abort_metadata()
      ? *output_result_.abort_metadata_
      : reinterpret_cast< ::flyteidl::admin::AbortMetadata&>(::flyteidl::admin::_AbortMetadata_default_instance_);
}
inline const ::flyteidl::admin::AbortMetadata& ExecutionClosure::abort_metadata() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.ExecutionClosure.abort_metadata)
  return _internal_abort_metadata();
}
inline ::flyteidl::admin::AbortMetadata* ExecutionClosure::unsafe_arena_release_abort_metadata() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flyteidl.admin.ExecutionClosure.abort_metadata)
  if (_internal_has_abort_metadata()) {
    clear_has_output_result();
    ::flyteidl::admin::AbortMetadata* temp = output_result_.abort_metadata_;
    output_result_.abort_metadata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ExecutionClosure::unsafe_arena_set_allocated_abort_metadata(::flyteidl::admin::AbortMetadata* abort_metadata) {
  clear_output_result();
  if (abort_metadata) {
    set_has_abort_metadata();
    output_result_.abort_metadata_ = abort_metadata;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.ExecutionClosure.abort_metadata)
}
inline ::flyteidl::admin::AbortMetadata* ExecutionClosure::_internal_mutable_abort_metadata() {
  if (!_internal_has_abort_metadata()) {
    clear_output_result();
    set_has_abort_metadata();
    output_result_.abort_metadata_ = CreateMaybeMessage< ::flyteidl::admin::AbortMetadata >(GetArenaForAllocation());
  }
  return output_result_.abort_metadata_;
}
inline ::flyteidl::admin::AbortMetadata* ExecutionClosure::mutable_abort_metadata() {
  ::flyteidl::admin::AbortMetadata* _msg = _internal_mutable_abort_metadata();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.ExecutionClosure.abort_metadata)
  return _msg;
}

// .flyteidl.core.LiteralMap output_data = 13 [json_name = "outputData", deprecated = true];
inline bool ExecutionClosure::_internal_has_output_data() const {
  return output_result_case() == kOutputData;
}
inline bool ExecutionClosure::has_output_data() const {
  return _internal_has_output_data();
}
inline void ExecutionClosure::set_has_output_data() {
  _oneof_case_[0] = kOutputData;
}
inline ::flyteidl::core::LiteralMap* ExecutionClosure::release_output_data() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.ExecutionClosure.output_data)
  if (_internal_has_output_data()) {
    clear_has_output_result();
      ::flyteidl::core::LiteralMap* temp = output_result_.output_data_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    output_result_.output_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::core::LiteralMap& ExecutionClosure::_internal_output_data() const {
  return _internal_has_output_data()
      ? *output_result_.output_data_
      : reinterpret_cast< ::flyteidl::core::LiteralMap&>(::flyteidl::core::_LiteralMap_default_instance_);
}
inline const ::flyteidl::core::LiteralMap& ExecutionClosure::output_data() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.ExecutionClosure.output_data)
  return _internal_output_data();
}
inline ::flyteidl::core::LiteralMap* ExecutionClosure::unsafe_arena_release_output_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flyteidl.admin.ExecutionClosure.output_data)
  if (_internal_has_output_data()) {
    clear_has_output_result();
    ::flyteidl::core::LiteralMap* temp = output_result_.output_data_;
    output_result_.output_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ExecutionClosure::unsafe_arena_set_allocated_output_data(::flyteidl::core::LiteralMap* output_data) {
  clear_output_result();
  if (output_data) {
    set_has_output_data();
    output_result_.output_data_ = output_data;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.ExecutionClosure.output_data)
}
inline ::flyteidl::core::LiteralMap* ExecutionClosure::_internal_mutable_output_data() {
  if (!_internal_has_output_data()) {
    clear_output_result();
    set_has_output_data();
    output_result_.output_data_ = CreateMaybeMessage< ::flyteidl::core::LiteralMap >(GetArenaForAllocation());
  }
  return output_result_.output_data_;
}
inline ::flyteidl::core::LiteralMap* ExecutionClosure::mutable_output_data() {
  ::flyteidl::core::LiteralMap* _msg = _internal_mutable_output_data();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.ExecutionClosure.output_data)
  return _msg;
}

// .flyteidl.core.LiteralMap computed_inputs = 3 [json_name = "computedInputs", deprecated = true];
inline bool ExecutionClosure::_internal_has_computed_inputs() const {
  return this != internal_default_instance() && computed_inputs_ != nullptr;
}
inline bool ExecutionClosure::has_computed_inputs() const {
  return _internal_has_computed_inputs();
}
inline const ::flyteidl::core::LiteralMap& ExecutionClosure::_internal_computed_inputs() const {
  const ::flyteidl::core::LiteralMap* p = computed_inputs_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::core::LiteralMap&>(
      ::flyteidl::core::_LiteralMap_default_instance_);
}
inline const ::flyteidl::core::LiteralMap& ExecutionClosure::computed_inputs() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.ExecutionClosure.computed_inputs)
  return _internal_computed_inputs();
}
inline void ExecutionClosure::unsafe_arena_set_allocated_computed_inputs(
    ::flyteidl::core::LiteralMap* computed_inputs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(computed_inputs_);
  }
  computed_inputs_ = computed_inputs;
  if (computed_inputs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.ExecutionClosure.computed_inputs)
}
inline ::flyteidl::core::LiteralMap* ExecutionClosure::release_computed_inputs() {
  
  ::flyteidl::core::LiteralMap* temp = computed_inputs_;
  computed_inputs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::core::LiteralMap* ExecutionClosure::unsafe_arena_release_computed_inputs() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.ExecutionClosure.computed_inputs)
  
  ::flyteidl::core::LiteralMap* temp = computed_inputs_;
  computed_inputs_ = nullptr;
  return temp;
}
inline ::flyteidl::core::LiteralMap* ExecutionClosure::_internal_mutable_computed_inputs() {
  
  if (computed_inputs_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::LiteralMap>(GetArenaForAllocation());
    computed_inputs_ = p;
  }
  return computed_inputs_;
}
inline ::flyteidl::core::LiteralMap* ExecutionClosure::mutable_computed_inputs() {
  ::flyteidl::core::LiteralMap* _msg = _internal_mutable_computed_inputs();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.ExecutionClosure.computed_inputs)
  return _msg;
}
inline void ExecutionClosure::set_allocated_computed_inputs(::flyteidl::core::LiteralMap* computed_inputs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(computed_inputs_);
  }
  if (computed_inputs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(computed_inputs));
    if (message_arena != submessage_arena) {
      computed_inputs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, computed_inputs, submessage_arena);
    }
    
  } else {
    
  }
  computed_inputs_ = computed_inputs;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.ExecutionClosure.computed_inputs)
}

// .flyteidl.core.WorkflowExecution.Phase phase = 4 [json_name = "phase"];
inline void ExecutionClosure::clear_phase() {
  phase_ = 0;
}
inline ::flyteidl::core::WorkflowExecution_Phase ExecutionClosure::_internal_phase() const {
  return static_cast< ::flyteidl::core::WorkflowExecution_Phase >(phase_);
}
inline ::flyteidl::core::WorkflowExecution_Phase ExecutionClosure::phase() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.ExecutionClosure.phase)
  return _internal_phase();
}
inline void ExecutionClosure::_internal_set_phase(::flyteidl::core::WorkflowExecution_Phase value) {
  
  phase_ = value;
}
inline void ExecutionClosure::set_phase(::flyteidl::core::WorkflowExecution_Phase value) {
  _internal_set_phase(value);
  // @@protoc_insertion_point(field_set:flyteidl.admin.ExecutionClosure.phase)
}

// .google.protobuf.Timestamp started_at = 5 [json_name = "startedAt"];
inline bool ExecutionClosure::_internal_has_started_at() const {
  return this != internal_default_instance() && started_at_ != nullptr;
}
inline bool ExecutionClosure::has_started_at() const {
  return _internal_has_started_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ExecutionClosure::_internal_started_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = started_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ExecutionClosure::started_at() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.ExecutionClosure.started_at)
  return _internal_started_at();
}
inline void ExecutionClosure::unsafe_arena_set_allocated_started_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* started_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(started_at_);
  }
  started_at_ = started_at;
  if (started_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.ExecutionClosure.started_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ExecutionClosure::release_started_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = started_at_;
  started_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ExecutionClosure::unsafe_arena_release_started_at() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.ExecutionClosure.started_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = started_at_;
  started_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ExecutionClosure::_internal_mutable_started_at() {
  
  if (started_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    started_at_ = p;
  }
  return started_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ExecutionClosure::mutable_started_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_started_at();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.ExecutionClosure.started_at)
  return _msg;
}
inline void ExecutionClosure::set_allocated_started_at(::PROTOBUF_NAMESPACE_ID::Timestamp* started_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(started_at_);
  }
  if (started_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(started_at));
    if (message_arena != submessage_arena) {
      started_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, started_at, submessage_arena);
    }
    
  } else {
    
  }
  started_at_ = started_at;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.ExecutionClosure.started_at)
}

// .google.protobuf.Duration duration = 6 [json_name = "duration"];
inline bool ExecutionClosure::_internal_has_duration() const {
  return this != internal_default_instance() && duration_ != nullptr;
}
inline bool ExecutionClosure::has_duration() const {
  return _internal_has_duration();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& ExecutionClosure::_internal_duration() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = duration_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& ExecutionClosure::duration() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.ExecutionClosure.duration)
  return _internal_duration();
}
inline void ExecutionClosure::unsafe_arena_set_allocated_duration(
    ::PROTOBUF_NAMESPACE_ID::Duration* duration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(duration_);
  }
  duration_ = duration;
  if (duration) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.ExecutionClosure.duration)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* ExecutionClosure::release_duration() {
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = duration_;
  duration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* ExecutionClosure::unsafe_arena_release_duration() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.ExecutionClosure.duration)
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = duration_;
  duration_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* ExecutionClosure::_internal_mutable_duration() {
  
  if (duration_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    duration_ = p;
  }
  return duration_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* ExecutionClosure::mutable_duration() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_duration();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.ExecutionClosure.duration)
  return _msg;
}
inline void ExecutionClosure::set_allocated_duration(::PROTOBUF_NAMESPACE_ID::Duration* duration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(duration_);
  }
  if (duration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(duration));
    if (message_arena != submessage_arena) {
      duration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, duration, submessage_arena);
    }
    
  } else {
    
  }
  duration_ = duration;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.ExecutionClosure.duration)
}

// .google.protobuf.Timestamp created_at = 7 [json_name = "createdAt"];
inline bool ExecutionClosure::_internal_has_created_at() const {
  return this != internal_default_instance() && created_at_ != nullptr;
}
inline bool ExecutionClosure::has_created_at() const {
  return _internal_has_created_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ExecutionClosure::_internal_created_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ExecutionClosure::created_at() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.ExecutionClosure.created_at)
  return _internal_created_at();
}
inline void ExecutionClosure::unsafe_arena_set_allocated_created_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at_);
  }
  created_at_ = created_at;
  if (created_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.ExecutionClosure.created_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ExecutionClosure::release_created_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_at_;
  created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ExecutionClosure::unsafe_arena_release_created_at() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.ExecutionClosure.created_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_at_;
  created_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ExecutionClosure::_internal_mutable_created_at() {
  
  if (created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    created_at_ = p;
  }
  return created_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ExecutionClosure::mutable_created_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.ExecutionClosure.created_at)
  return _msg;
}
inline void ExecutionClosure::set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at_);
  }
  if (created_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at));
    if (message_arena != submessage_arena) {
      created_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_at, submessage_arena);
    }
    
  } else {
    
  }
  created_at_ = created_at;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.ExecutionClosure.created_at)
}

// .google.protobuf.Timestamp updated_at = 8 [json_name = "updatedAt"];
inline bool ExecutionClosure::_internal_has_updated_at() const {
  return this != internal_default_instance() && updated_at_ != nullptr;
}
inline bool ExecutionClosure::has_updated_at() const {
  return _internal_has_updated_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ExecutionClosure::_internal_updated_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = updated_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ExecutionClosure::updated_at() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.ExecutionClosure.updated_at)
  return _internal_updated_at();
}
inline void ExecutionClosure::unsafe_arena_set_allocated_updated_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(updated_at_);
  }
  updated_at_ = updated_at;
  if (updated_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.ExecutionClosure.updated_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ExecutionClosure::release_updated_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = updated_at_;
  updated_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ExecutionClosure::unsafe_arena_release_updated_at() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.ExecutionClosure.updated_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = updated_at_;
  updated_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ExecutionClosure::_internal_mutable_updated_at() {
  
  if (updated_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    updated_at_ = p;
  }
  return updated_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ExecutionClosure::mutable_updated_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_updated_at();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.ExecutionClosure.updated_at)
  return _msg;
}
inline void ExecutionClosure::set_allocated_updated_at(::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(updated_at_);
  }
  if (updated_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(updated_at));
    if (message_arena != submessage_arena) {
      updated_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, updated_at, submessage_arena);
    }
    
  } else {
    
  }
  updated_at_ = updated_at;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.ExecutionClosure.updated_at)
}

// repeated .flyteidl.admin.Notification notifications = 9 [json_name = "notifications"];
inline int ExecutionClosure::_internal_notifications_size() const {
  return notifications_.size();
}
inline int ExecutionClosure::notifications_size() const {
  return _internal_notifications_size();
}
inline ::flyteidl::admin::Notification* ExecutionClosure::mutable_notifications(int index) {
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.ExecutionClosure.notifications)
  return notifications_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::admin::Notification >*
ExecutionClosure::mutable_notifications() {
  // @@protoc_insertion_point(field_mutable_list:flyteidl.admin.ExecutionClosure.notifications)
  return &notifications_;
}
inline const ::flyteidl::admin::Notification& ExecutionClosure::_internal_notifications(int index) const {
  return notifications_.Get(index);
}
inline const ::flyteidl::admin::Notification& ExecutionClosure::notifications(int index) const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.ExecutionClosure.notifications)
  return _internal_notifications(index);
}
inline ::flyteidl::admin::Notification* ExecutionClosure::_internal_add_notifications() {
  return notifications_.Add();
}
inline ::flyteidl::admin::Notification* ExecutionClosure::add_notifications() {
  ::flyteidl::admin::Notification* _add = _internal_add_notifications();
  // @@protoc_insertion_point(field_add:flyteidl.admin.ExecutionClosure.notifications)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::admin::Notification >&
ExecutionClosure::notifications() const {
  // @@protoc_insertion_point(field_list:flyteidl.admin.ExecutionClosure.notifications)
  return notifications_;
}

// .flyteidl.core.Identifier workflow_id = 11 [json_name = "workflowId"];
inline bool ExecutionClosure::_internal_has_workflow_id() const {
  return this != internal_default_instance() && workflow_id_ != nullptr;
}
inline bool ExecutionClosure::has_workflow_id() const {
  return _internal_has_workflow_id();
}
inline const ::flyteidl::core::Identifier& ExecutionClosure::_internal_workflow_id() const {
  const ::flyteidl::core::Identifier* p = workflow_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::core::Identifier&>(
      ::flyteidl::core::_Identifier_default_instance_);
}
inline const ::flyteidl::core::Identifier& ExecutionClosure::workflow_id() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.ExecutionClosure.workflow_id)
  return _internal_workflow_id();
}
inline void ExecutionClosure::unsafe_arena_set_allocated_workflow_id(
    ::flyteidl::core::Identifier* workflow_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(workflow_id_);
  }
  workflow_id_ = workflow_id;
  if (workflow_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.ExecutionClosure.workflow_id)
}
inline ::flyteidl::core::Identifier* ExecutionClosure::release_workflow_id() {
  
  ::flyteidl::core::Identifier* temp = workflow_id_;
  workflow_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::core::Identifier* ExecutionClosure::unsafe_arena_release_workflow_id() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.ExecutionClosure.workflow_id)
  
  ::flyteidl::core::Identifier* temp = workflow_id_;
  workflow_id_ = nullptr;
  return temp;
}
inline ::flyteidl::core::Identifier* ExecutionClosure::_internal_mutable_workflow_id() {
  
  if (workflow_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::Identifier>(GetArenaForAllocation());
    workflow_id_ = p;
  }
  return workflow_id_;
}
inline ::flyteidl::core::Identifier* ExecutionClosure::mutable_workflow_id() {
  ::flyteidl::core::Identifier* _msg = _internal_mutable_workflow_id();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.ExecutionClosure.workflow_id)
  return _msg;
}
inline void ExecutionClosure::set_allocated_workflow_id(::flyteidl::core::Identifier* workflow_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(workflow_id_);
  }
  if (workflow_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(workflow_id));
    if (message_arena != submessage_arena) {
      workflow_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, workflow_id, submessage_arena);
    }
    
  } else {
    
  }
  workflow_id_ = workflow_id;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.ExecutionClosure.workflow_id)
}

// .flyteidl.admin.ExecutionStateChangeDetails state_change_details = 14 [json_name = "stateChangeDetails"];
inline bool ExecutionClosure::_internal_has_state_change_details() const {
  return this != internal_default_instance() && state_change_details_ != nullptr;
}
inline bool ExecutionClosure::has_state_change_details() const {
  return _internal_has_state_change_details();
}
inline void ExecutionClosure::clear_state_change_details() {
  if (GetArenaForAllocation() == nullptr && state_change_details_ != nullptr) {
    delete state_change_details_;
  }
  state_change_details_ = nullptr;
}
inline const ::flyteidl::admin::ExecutionStateChangeDetails& ExecutionClosure::_internal_state_change_details() const {
  const ::flyteidl::admin::ExecutionStateChangeDetails* p = state_change_details_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::admin::ExecutionStateChangeDetails&>(
      ::flyteidl::admin::_ExecutionStateChangeDetails_default_instance_);
}
inline const ::flyteidl::admin::ExecutionStateChangeDetails& ExecutionClosure::state_change_details() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.ExecutionClosure.state_change_details)
  return _internal_state_change_details();
}
inline void ExecutionClosure::unsafe_arena_set_allocated_state_change_details(
    ::flyteidl::admin::ExecutionStateChangeDetails* state_change_details) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(state_change_details_);
  }
  state_change_details_ = state_change_details;
  if (state_change_details) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.ExecutionClosure.state_change_details)
}
inline ::flyteidl::admin::ExecutionStateChangeDetails* ExecutionClosure::release_state_change_details() {
  
  ::flyteidl::admin::ExecutionStateChangeDetails* temp = state_change_details_;
  state_change_details_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::admin::ExecutionStateChangeDetails* ExecutionClosure::unsafe_arena_release_state_change_details() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.ExecutionClosure.state_change_details)
  
  ::flyteidl::admin::ExecutionStateChangeDetails* temp = state_change_details_;
  state_change_details_ = nullptr;
  return temp;
}
inline ::flyteidl::admin::ExecutionStateChangeDetails* ExecutionClosure::_internal_mutable_state_change_details() {
  
  if (state_change_details_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::admin::ExecutionStateChangeDetails>(GetArenaForAllocation());
    state_change_details_ = p;
  }
  return state_change_details_;
}
inline ::flyteidl::admin::ExecutionStateChangeDetails* ExecutionClosure::mutable_state_change_details() {
  ::flyteidl::admin::ExecutionStateChangeDetails* _msg = _internal_mutable_state_change_details();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.ExecutionClosure.state_change_details)
  return _msg;
}
inline void ExecutionClosure::set_allocated_state_change_details(::flyteidl::admin::ExecutionStateChangeDetails* state_change_details) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete state_change_details_;
  }
  if (state_change_details) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::flyteidl::admin::ExecutionStateChangeDetails>::GetOwningArena(state_change_details);
    if (message_arena != submessage_arena) {
      state_change_details = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, state_change_details, submessage_arena);
    }
    
  } else {
    
  }
  state_change_details_ = state_change_details;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.ExecutionClosure.state_change_details)
}

inline bool ExecutionClosure::has_output_result() const {
  return output_result_case() != OUTPUT_RESULT_NOT_SET;
}
inline void ExecutionClosure::clear_has_output_result() {
  _oneof_case_[0] = OUTPUT_RESULT_NOT_SET;
}
inline ExecutionClosure::OutputResultCase ExecutionClosure::output_result_case() const {
  return ExecutionClosure::OutputResultCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SystemMetadata

// string execution_cluster = 1 [json_name = "executionCluster"];
inline void SystemMetadata::clear_execution_cluster() {
  execution_cluster_.ClearToEmpty();
}
inline const std::string& SystemMetadata::execution_cluster() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.SystemMetadata.execution_cluster)
  return _internal_execution_cluster();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SystemMetadata::set_execution_cluster(ArgT0&& arg0, ArgT... args) {
 
 execution_cluster_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.admin.SystemMetadata.execution_cluster)
}
inline std::string* SystemMetadata::mutable_execution_cluster() {
  std::string* _s = _internal_mutable_execution_cluster();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.SystemMetadata.execution_cluster)
  return _s;
}
inline const std::string& SystemMetadata::_internal_execution_cluster() const {
  return execution_cluster_.Get();
}
inline void SystemMetadata::_internal_set_execution_cluster(const std::string& value) {
  
  execution_cluster_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SystemMetadata::_internal_mutable_execution_cluster() {
  
  return execution_cluster_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SystemMetadata::release_execution_cluster() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.SystemMetadata.execution_cluster)
  return execution_cluster_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SystemMetadata::set_allocated_execution_cluster(std::string* execution_cluster) {
  if (execution_cluster != nullptr) {
    
  } else {
    
  }
  execution_cluster_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), execution_cluster,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (execution_cluster_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    execution_cluster_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.SystemMetadata.execution_cluster)
}

// -------------------------------------------------------------------

// ExecutionMetadata

// .flyteidl.admin.ExecutionMetadata.ExecutionMode mode = 1 [json_name = "mode"];
inline void ExecutionMetadata::clear_mode() {
  mode_ = 0;
}
inline ::flyteidl::admin::ExecutionMetadata_ExecutionMode ExecutionMetadata::_internal_mode() const {
  return static_cast< ::flyteidl::admin::ExecutionMetadata_ExecutionMode >(mode_);
}
inline ::flyteidl::admin::ExecutionMetadata_ExecutionMode ExecutionMetadata::mode() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.ExecutionMetadata.mode)
  return _internal_mode();
}
inline void ExecutionMetadata::_internal_set_mode(::flyteidl::admin::ExecutionMetadata_ExecutionMode value) {
  
  mode_ = value;
}
inline void ExecutionMetadata::set_mode(::flyteidl::admin::ExecutionMetadata_ExecutionMode value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:flyteidl.admin.ExecutionMetadata.mode)
}

// string principal = 2 [json_name = "principal"];
inline void ExecutionMetadata::clear_principal() {
  principal_.ClearToEmpty();
}
inline const std::string& ExecutionMetadata::principal() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.ExecutionMetadata.principal)
  return _internal_principal();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecutionMetadata::set_principal(ArgT0&& arg0, ArgT... args) {
 
 principal_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.admin.ExecutionMetadata.principal)
}
inline std::string* ExecutionMetadata::mutable_principal() {
  std::string* _s = _internal_mutable_principal();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.ExecutionMetadata.principal)
  return _s;
}
inline const std::string& ExecutionMetadata::_internal_principal() const {
  return principal_.Get();
}
inline void ExecutionMetadata::_internal_set_principal(const std::string& value) {
  
  principal_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ExecutionMetadata::_internal_mutable_principal() {
  
  return principal_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ExecutionMetadata::release_principal() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.ExecutionMetadata.principal)
  return principal_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ExecutionMetadata::set_allocated_principal(std::string* principal) {
  if (principal != nullptr) {
    
  } else {
    
  }
  principal_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), principal,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (principal_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    principal_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.ExecutionMetadata.principal)
}

// uint32 nesting = 3 [json_name = "nesting"];
inline void ExecutionMetadata::clear_nesting() {
  nesting_ = 0u;
}
inline uint32_t ExecutionMetadata::_internal_nesting() const {
  return nesting_;
}
inline uint32_t ExecutionMetadata::nesting() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.ExecutionMetadata.nesting)
  return _internal_nesting();
}
inline void ExecutionMetadata::_internal_set_nesting(uint32_t value) {
  
  nesting_ = value;
}
inline void ExecutionMetadata::set_nesting(uint32_t value) {
  _internal_set_nesting(value);
  // @@protoc_insertion_point(field_set:flyteidl.admin.ExecutionMetadata.nesting)
}

// .google.protobuf.Timestamp scheduled_at = 4 [json_name = "scheduledAt"];
inline bool ExecutionMetadata::_internal_has_scheduled_at() const {
  return this != internal_default_instance() && scheduled_at_ != nullptr;
}
inline bool ExecutionMetadata::has_scheduled_at() const {
  return _internal_has_scheduled_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ExecutionMetadata::_internal_scheduled_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = scheduled_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ExecutionMetadata::scheduled_at() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.ExecutionMetadata.scheduled_at)
  return _internal_scheduled_at();
}
inline void ExecutionMetadata::unsafe_arena_set_allocated_scheduled_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* scheduled_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(scheduled_at_);
  }
  scheduled_at_ = scheduled_at;
  if (scheduled_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.ExecutionMetadata.scheduled_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ExecutionMetadata::release_scheduled_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = scheduled_at_;
  scheduled_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ExecutionMetadata::unsafe_arena_release_scheduled_at() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.ExecutionMetadata.scheduled_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = scheduled_at_;
  scheduled_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ExecutionMetadata::_internal_mutable_scheduled_at() {
  
  if (scheduled_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    scheduled_at_ = p;
  }
  return scheduled_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ExecutionMetadata::mutable_scheduled_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_scheduled_at();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.ExecutionMetadata.scheduled_at)
  return _msg;
}
inline void ExecutionMetadata::set_allocated_scheduled_at(::PROTOBUF_NAMESPACE_ID::Timestamp* scheduled_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(scheduled_at_);
  }
  if (scheduled_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(scheduled_at));
    if (message_arena != submessage_arena) {
      scheduled_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, scheduled_at, submessage_arena);
    }
    
  } else {
    
  }
  scheduled_at_ = scheduled_at;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.ExecutionMetadata.scheduled_at)
}

// .flyteidl.core.NodeExecutionIdentifier parent_node_execution = 5 [json_name = "parentNodeExecution"];
inline bool ExecutionMetadata::_internal_has_parent_node_execution() const {
  return this != internal_default_instance() && parent_node_execution_ != nullptr;
}
inline bool ExecutionMetadata::has_parent_node_execution() const {
  return _internal_has_parent_node_execution();
}
inline const ::flyteidl::core::NodeExecutionIdentifier& ExecutionMetadata::_internal_parent_node_execution() const {
  const ::flyteidl::core::NodeExecutionIdentifier* p = parent_node_execution_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::core::NodeExecutionIdentifier&>(
      ::flyteidl::core::_NodeExecutionIdentifier_default_instance_);
}
inline const ::flyteidl::core::NodeExecutionIdentifier& ExecutionMetadata::parent_node_execution() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.ExecutionMetadata.parent_node_execution)
  return _internal_parent_node_execution();
}
inline void ExecutionMetadata::unsafe_arena_set_allocated_parent_node_execution(
    ::flyteidl::core::NodeExecutionIdentifier* parent_node_execution) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(parent_node_execution_);
  }
  parent_node_execution_ = parent_node_execution;
  if (parent_node_execution) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.ExecutionMetadata.parent_node_execution)
}
inline ::flyteidl::core::NodeExecutionIdentifier* ExecutionMetadata::release_parent_node_execution() {
  
  ::flyteidl::core::NodeExecutionIdentifier* temp = parent_node_execution_;
  parent_node_execution_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::core::NodeExecutionIdentifier* ExecutionMetadata::unsafe_arena_release_parent_node_execution() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.ExecutionMetadata.parent_node_execution)
  
  ::flyteidl::core::NodeExecutionIdentifier* temp = parent_node_execution_;
  parent_node_execution_ = nullptr;
  return temp;
}
inline ::flyteidl::core::NodeExecutionIdentifier* ExecutionMetadata::_internal_mutable_parent_node_execution() {
  
  if (parent_node_execution_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::NodeExecutionIdentifier>(GetArenaForAllocation());
    parent_node_execution_ = p;
  }
  return parent_node_execution_;
}
inline ::flyteidl::core::NodeExecutionIdentifier* ExecutionMetadata::mutable_parent_node_execution() {
  ::flyteidl::core::NodeExecutionIdentifier* _msg = _internal_mutable_parent_node_execution();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.ExecutionMetadata.parent_node_execution)
  return _msg;
}
inline void ExecutionMetadata::set_allocated_parent_node_execution(::flyteidl::core::NodeExecutionIdentifier* parent_node_execution) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(parent_node_execution_);
  }
  if (parent_node_execution) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(parent_node_execution));
    if (message_arena != submessage_arena) {
      parent_node_execution = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parent_node_execution, submessage_arena);
    }
    
  } else {
    
  }
  parent_node_execution_ = parent_node_execution;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.ExecutionMetadata.parent_node_execution)
}

// .flyteidl.core.WorkflowExecutionIdentifier reference_execution = 16 [json_name = "referenceExecution"];
inline bool ExecutionMetadata::_internal_has_reference_execution() const {
  return this != internal_default_instance() && reference_execution_ != nullptr;
}
inline bool ExecutionMetadata::has_reference_execution() const {
  return _internal_has_reference_execution();
}
inline const ::flyteidl::core::WorkflowExecutionIdentifier& ExecutionMetadata::_internal_reference_execution() const {
  const ::flyteidl::core::WorkflowExecutionIdentifier* p = reference_execution_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::core::WorkflowExecutionIdentifier&>(
      ::flyteidl::core::_WorkflowExecutionIdentifier_default_instance_);
}
inline const ::flyteidl::core::WorkflowExecutionIdentifier& ExecutionMetadata::reference_execution() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.ExecutionMetadata.reference_execution)
  return _internal_reference_execution();
}
inline void ExecutionMetadata::unsafe_arena_set_allocated_reference_execution(
    ::flyteidl::core::WorkflowExecutionIdentifier* reference_execution) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(reference_execution_);
  }
  reference_execution_ = reference_execution;
  if (reference_execution) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.ExecutionMetadata.reference_execution)
}
inline ::flyteidl::core::WorkflowExecutionIdentifier* ExecutionMetadata::release_reference_execution() {
  
  ::flyteidl::core::WorkflowExecutionIdentifier* temp = reference_execution_;
  reference_execution_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::core::WorkflowExecutionIdentifier* ExecutionMetadata::unsafe_arena_release_reference_execution() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.ExecutionMetadata.reference_execution)
  
  ::flyteidl::core::WorkflowExecutionIdentifier* temp = reference_execution_;
  reference_execution_ = nullptr;
  return temp;
}
inline ::flyteidl::core::WorkflowExecutionIdentifier* ExecutionMetadata::_internal_mutable_reference_execution() {
  
  if (reference_execution_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::WorkflowExecutionIdentifier>(GetArenaForAllocation());
    reference_execution_ = p;
  }
  return reference_execution_;
}
inline ::flyteidl::core::WorkflowExecutionIdentifier* ExecutionMetadata::mutable_reference_execution() {
  ::flyteidl::core::WorkflowExecutionIdentifier* _msg = _internal_mutable_reference_execution();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.ExecutionMetadata.reference_execution)
  return _msg;
}
inline void ExecutionMetadata::set_allocated_reference_execution(::flyteidl::core::WorkflowExecutionIdentifier* reference_execution) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(reference_execution_);
  }
  if (reference_execution) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(reference_execution));
    if (message_arena != submessage_arena) {
      reference_execution = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reference_execution, submessage_arena);
    }
    
  } else {
    
  }
  reference_execution_ = reference_execution;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.ExecutionMetadata.reference_execution)
}

// .flyteidl.admin.SystemMetadata system_metadata = 17 [json_name = "systemMetadata"];
inline bool ExecutionMetadata::_internal_has_system_metadata() const {
  return this != internal_default_instance() && system_metadata_ != nullptr;
}
inline bool ExecutionMetadata::has_system_metadata() const {
  return _internal_has_system_metadata();
}
inline void ExecutionMetadata::clear_system_metadata() {
  if (GetArenaForAllocation() == nullptr && system_metadata_ != nullptr) {
    delete system_metadata_;
  }
  system_metadata_ = nullptr;
}
inline const ::flyteidl::admin::SystemMetadata& ExecutionMetadata::_internal_system_metadata() const {
  const ::flyteidl::admin::SystemMetadata* p = system_metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::admin::SystemMetadata&>(
      ::flyteidl::admin::_SystemMetadata_default_instance_);
}
inline const ::flyteidl::admin::SystemMetadata& ExecutionMetadata::system_metadata() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.ExecutionMetadata.system_metadata)
  return _internal_system_metadata();
}
inline void ExecutionMetadata::unsafe_arena_set_allocated_system_metadata(
    ::flyteidl::admin::SystemMetadata* system_metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(system_metadata_);
  }
  system_metadata_ = system_metadata;
  if (system_metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.ExecutionMetadata.system_metadata)
}
inline ::flyteidl::admin::SystemMetadata* ExecutionMetadata::release_system_metadata() {
  
  ::flyteidl::admin::SystemMetadata* temp = system_metadata_;
  system_metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::admin::SystemMetadata* ExecutionMetadata::unsafe_arena_release_system_metadata() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.ExecutionMetadata.system_metadata)
  
  ::flyteidl::admin::SystemMetadata* temp = system_metadata_;
  system_metadata_ = nullptr;
  return temp;
}
inline ::flyteidl::admin::SystemMetadata* ExecutionMetadata::_internal_mutable_system_metadata() {
  
  if (system_metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::admin::SystemMetadata>(GetArenaForAllocation());
    system_metadata_ = p;
  }
  return system_metadata_;
}
inline ::flyteidl::admin::SystemMetadata* ExecutionMetadata::mutable_system_metadata() {
  ::flyteidl::admin::SystemMetadata* _msg = _internal_mutable_system_metadata();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.ExecutionMetadata.system_metadata)
  return _msg;
}
inline void ExecutionMetadata::set_allocated_system_metadata(::flyteidl::admin::SystemMetadata* system_metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete system_metadata_;
  }
  if (system_metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::flyteidl::admin::SystemMetadata>::GetOwningArena(system_metadata);
    if (message_arena != submessage_arena) {
      system_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, system_metadata, submessage_arena);
    }
    
  } else {
    
  }
  system_metadata_ = system_metadata;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.ExecutionMetadata.system_metadata)
}

// -------------------------------------------------------------------

// NotificationList

// repeated .flyteidl.admin.Notification notifications = 1 [json_name = "notifications"];
inline int NotificationList::_internal_notifications_size() const {
  return notifications_.size();
}
inline int NotificationList::notifications_size() const {
  return _internal_notifications_size();
}
inline ::flyteidl::admin::Notification* NotificationList::mutable_notifications(int index) {
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.NotificationList.notifications)
  return notifications_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::admin::Notification >*
NotificationList::mutable_notifications() {
  // @@protoc_insertion_point(field_mutable_list:flyteidl.admin.NotificationList.notifications)
  return &notifications_;
}
inline const ::flyteidl::admin::Notification& NotificationList::_internal_notifications(int index) const {
  return notifications_.Get(index);
}
inline const ::flyteidl::admin::Notification& NotificationList::notifications(int index) const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NotificationList.notifications)
  return _internal_notifications(index);
}
inline ::flyteidl::admin::Notification* NotificationList::_internal_add_notifications() {
  return notifications_.Add();
}
inline ::flyteidl::admin::Notification* NotificationList::add_notifications() {
  ::flyteidl::admin::Notification* _add = _internal_add_notifications();
  // @@protoc_insertion_point(field_add:flyteidl.admin.NotificationList.notifications)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::admin::Notification >&
NotificationList::notifications() const {
  // @@protoc_insertion_point(field_list:flyteidl.admin.NotificationList.notifications)
  return notifications_;
}

// -------------------------------------------------------------------

// ExecutionSpec

// .flyteidl.core.Identifier launch_plan = 1 [json_name = "launchPlan"];
inline bool ExecutionSpec::_internal_has_launch_plan() const {
  return this != internal_default_instance() && launch_plan_ != nullptr;
}
inline bool ExecutionSpec::has_launch_plan() const {
  return _internal_has_launch_plan();
}
inline const ::flyteidl::core::Identifier& ExecutionSpec::_internal_launch_plan() const {
  const ::flyteidl::core::Identifier* p = launch_plan_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::core::Identifier&>(
      ::flyteidl::core::_Identifier_default_instance_);
}
inline const ::flyteidl::core::Identifier& ExecutionSpec::launch_plan() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.ExecutionSpec.launch_plan)
  return _internal_launch_plan();
}
inline void ExecutionSpec::unsafe_arena_set_allocated_launch_plan(
    ::flyteidl::core::Identifier* launch_plan) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(launch_plan_);
  }
  launch_plan_ = launch_plan;
  if (launch_plan) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.ExecutionSpec.launch_plan)
}
inline ::flyteidl::core::Identifier* ExecutionSpec::release_launch_plan() {
  
  ::flyteidl::core::Identifier* temp = launch_plan_;
  launch_plan_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::core::Identifier* ExecutionSpec::unsafe_arena_release_launch_plan() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.ExecutionSpec.launch_plan)
  
  ::flyteidl::core::Identifier* temp = launch_plan_;
  launch_plan_ = nullptr;
  return temp;
}
inline ::flyteidl::core::Identifier* ExecutionSpec::_internal_mutable_launch_plan() {
  
  if (launch_plan_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::Identifier>(GetArenaForAllocation());
    launch_plan_ = p;
  }
  return launch_plan_;
}
inline ::flyteidl::core::Identifier* ExecutionSpec::mutable_launch_plan() {
  ::flyteidl::core::Identifier* _msg = _internal_mutable_launch_plan();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.ExecutionSpec.launch_plan)
  return _msg;
}
inline void ExecutionSpec::set_allocated_launch_plan(::flyteidl::core::Identifier* launch_plan) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(launch_plan_);
  }
  if (launch_plan) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(launch_plan));
    if (message_arena != submessage_arena) {
      launch_plan = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, launch_plan, submessage_arena);
    }
    
  } else {
    
  }
  launch_plan_ = launch_plan;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.ExecutionSpec.launch_plan)
}

// .flyteidl.core.LiteralMap inputs = 2 [json_name = "inputs", deprecated = true];
inline bool ExecutionSpec::_internal_has_inputs() const {
  return this != internal_default_instance() && inputs_ != nullptr;
}
inline bool ExecutionSpec::has_inputs() const {
  return _internal_has_inputs();
}
inline const ::flyteidl::core::LiteralMap& ExecutionSpec::_internal_inputs() const {
  const ::flyteidl::core::LiteralMap* p = inputs_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::core::LiteralMap&>(
      ::flyteidl::core::_LiteralMap_default_instance_);
}
inline const ::flyteidl::core::LiteralMap& ExecutionSpec::inputs() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.ExecutionSpec.inputs)
  return _internal_inputs();
}
inline void ExecutionSpec::unsafe_arena_set_allocated_inputs(
    ::flyteidl::core::LiteralMap* inputs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(inputs_);
  }
  inputs_ = inputs;
  if (inputs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.ExecutionSpec.inputs)
}
inline ::flyteidl::core::LiteralMap* ExecutionSpec::release_inputs() {
  
  ::flyteidl::core::LiteralMap* temp = inputs_;
  inputs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::core::LiteralMap* ExecutionSpec::unsafe_arena_release_inputs() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.ExecutionSpec.inputs)
  
  ::flyteidl::core::LiteralMap* temp = inputs_;
  inputs_ = nullptr;
  return temp;
}
inline ::flyteidl::core::LiteralMap* ExecutionSpec::_internal_mutable_inputs() {
  
  if (inputs_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::LiteralMap>(GetArenaForAllocation());
    inputs_ = p;
  }
  return inputs_;
}
inline ::flyteidl::core::LiteralMap* ExecutionSpec::mutable_inputs() {
  ::flyteidl::core::LiteralMap* _msg = _internal_mutable_inputs();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.ExecutionSpec.inputs)
  return _msg;
}
inline void ExecutionSpec::set_allocated_inputs(::flyteidl::core::LiteralMap* inputs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(inputs_);
  }
  if (inputs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(inputs));
    if (message_arena != submessage_arena) {
      inputs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, inputs, submessage_arena);
    }
    
  } else {
    
  }
  inputs_ = inputs;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.ExecutionSpec.inputs)
}

// .flyteidl.admin.ExecutionMetadata metadata = 3 [json_name = "metadata"];
inline bool ExecutionSpec::_internal_has_metadata() const {
  return this != internal_default_instance() && metadata_ != nullptr;
}
inline bool ExecutionSpec::has_metadata() const {
  return _internal_has_metadata();
}
inline void ExecutionSpec::clear_metadata() {
  if (GetArenaForAllocation() == nullptr && metadata_ != nullptr) {
    delete metadata_;
  }
  metadata_ = nullptr;
}
inline const ::flyteidl::admin::ExecutionMetadata& ExecutionSpec::_internal_metadata() const {
  const ::flyteidl::admin::ExecutionMetadata* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::admin::ExecutionMetadata&>(
      ::flyteidl::admin::_ExecutionMetadata_default_instance_);
}
inline const ::flyteidl::admin::ExecutionMetadata& ExecutionSpec::metadata() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.ExecutionSpec.metadata)
  return _internal_metadata();
}
inline void ExecutionSpec::unsafe_arena_set_allocated_metadata(
    ::flyteidl::admin::ExecutionMetadata* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.ExecutionSpec.metadata)
}
inline ::flyteidl::admin::ExecutionMetadata* ExecutionSpec::release_metadata() {
  
  ::flyteidl::admin::ExecutionMetadata* temp = metadata_;
  metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::admin::ExecutionMetadata* ExecutionSpec::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.ExecutionSpec.metadata)
  
  ::flyteidl::admin::ExecutionMetadata* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::flyteidl::admin::ExecutionMetadata* ExecutionSpec::_internal_mutable_metadata() {
  
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::admin::ExecutionMetadata>(GetArenaForAllocation());
    metadata_ = p;
  }
  return metadata_;
}
inline ::flyteidl::admin::ExecutionMetadata* ExecutionSpec::mutable_metadata() {
  ::flyteidl::admin::ExecutionMetadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.ExecutionSpec.metadata)
  return _msg;
}
inline void ExecutionSpec::set_allocated_metadata(::flyteidl::admin::ExecutionMetadata* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete metadata_;
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::flyteidl::admin::ExecutionMetadata>::GetOwningArena(metadata);
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.ExecutionSpec.metadata)
}

// .flyteidl.admin.NotificationList notifications = 5 [json_name = "notifications"];
inline bool ExecutionSpec::_internal_has_notifications() const {
  return notification_overrides_case() == kNotifications;
}
inline bool ExecutionSpec::has_notifications() const {
  return _internal_has_notifications();
}
inline void ExecutionSpec::set_has_notifications() {
  _oneof_case_[0] = kNotifications;
}
inline void ExecutionSpec::clear_notifications() {
  if (_internal_has_notifications()) {
    if (GetArenaForAllocation() == nullptr) {
      delete notification_overrides_.notifications_;
    }
    clear_has_notification_overrides();
  }
}
inline ::flyteidl::admin::NotificationList* ExecutionSpec::release_notifications() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.ExecutionSpec.notifications)
  if (_internal_has_notifications()) {
    clear_has_notification_overrides();
      ::flyteidl::admin::NotificationList* temp = notification_overrides_.notifications_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    notification_overrides_.notifications_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::admin::NotificationList& ExecutionSpec::_internal_notifications() const {
  return _internal_has_notifications()
      ? *notification_overrides_.notifications_
      : reinterpret_cast< ::flyteidl::admin::NotificationList&>(::flyteidl::admin::_NotificationList_default_instance_);
}
inline const ::flyteidl::admin::NotificationList& ExecutionSpec::notifications() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.ExecutionSpec.notifications)
  return _internal_notifications();
}
inline ::flyteidl::admin::NotificationList* ExecutionSpec::unsafe_arena_release_notifications() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flyteidl.admin.ExecutionSpec.notifications)
  if (_internal_has_notifications()) {
    clear_has_notification_overrides();
    ::flyteidl::admin::NotificationList* temp = notification_overrides_.notifications_;
    notification_overrides_.notifications_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ExecutionSpec::unsafe_arena_set_allocated_notifications(::flyteidl::admin::NotificationList* notifications) {
  clear_notification_overrides();
  if (notifications) {
    set_has_notifications();
    notification_overrides_.notifications_ = notifications;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.ExecutionSpec.notifications)
}
inline ::flyteidl::admin::NotificationList* ExecutionSpec::_internal_mutable_notifications() {
  if (!_internal_has_notifications()) {
    clear_notification_overrides();
    set_has_notifications();
    notification_overrides_.notifications_ = CreateMaybeMessage< ::flyteidl::admin::NotificationList >(GetArenaForAllocation());
  }
  return notification_overrides_.notifications_;
}
inline ::flyteidl::admin::NotificationList* ExecutionSpec::mutable_notifications() {
  ::flyteidl::admin::NotificationList* _msg = _internal_mutable_notifications();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.ExecutionSpec.notifications)
  return _msg;
}

// bool disable_all = 6 [json_name = "disableAll"];
inline bool ExecutionSpec::_internal_has_disable_all() const {
  return notification_overrides_case() == kDisableAll;
}
inline bool ExecutionSpec::has_disable_all() const {
  return _internal_has_disable_all();
}
inline void ExecutionSpec::set_has_disable_all() {
  _oneof_case_[0] = kDisableAll;
}
inline void ExecutionSpec::clear_disable_all() {
  if (_internal_has_disable_all()) {
    notification_overrides_.disable_all_ = false;
    clear_has_notification_overrides();
  }
}
inline bool ExecutionSpec::_internal_disable_all() const {
  if (_internal_has_disable_all()) {
    return notification_overrides_.disable_all_;
  }
  return false;
}
inline void ExecutionSpec::_internal_set_disable_all(bool value) {
  if (!_internal_has_disable_all()) {
    clear_notification_overrides();
    set_has_disable_all();
  }
  notification_overrides_.disable_all_ = value;
}
inline bool ExecutionSpec::disable_all() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.ExecutionSpec.disable_all)
  return _internal_disable_all();
}
inline void ExecutionSpec::set_disable_all(bool value) {
  _internal_set_disable_all(value);
  // @@protoc_insertion_point(field_set:flyteidl.admin.ExecutionSpec.disable_all)
}

// .flyteidl.admin.Labels labels = 7 [json_name = "labels"];
inline bool ExecutionSpec::_internal_has_labels() const {
  return this != internal_default_instance() && labels_ != nullptr;
}
inline bool ExecutionSpec::has_labels() const {
  return _internal_has_labels();
}
inline const ::flyteidl::admin::Labels& ExecutionSpec::_internal_labels() const {
  const ::flyteidl::admin::Labels* p = labels_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::admin::Labels&>(
      ::flyteidl::admin::_Labels_default_instance_);
}
inline const ::flyteidl::admin::Labels& ExecutionSpec::labels() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.ExecutionSpec.labels)
  return _internal_labels();
}
inline void ExecutionSpec::unsafe_arena_set_allocated_labels(
    ::flyteidl::admin::Labels* labels) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(labels_);
  }
  labels_ = labels;
  if (labels) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.ExecutionSpec.labels)
}
inline ::flyteidl::admin::Labels* ExecutionSpec::release_labels() {
  
  ::flyteidl::admin::Labels* temp = labels_;
  labels_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::admin::Labels* ExecutionSpec::unsafe_arena_release_labels() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.ExecutionSpec.labels)
  
  ::flyteidl::admin::Labels* temp = labels_;
  labels_ = nullptr;
  return temp;
}
inline ::flyteidl::admin::Labels* ExecutionSpec::_internal_mutable_labels() {
  
  if (labels_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::admin::Labels>(GetArenaForAllocation());
    labels_ = p;
  }
  return labels_;
}
inline ::flyteidl::admin::Labels* ExecutionSpec::mutable_labels() {
  ::flyteidl::admin::Labels* _msg = _internal_mutable_labels();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.ExecutionSpec.labels)
  return _msg;
}
inline void ExecutionSpec::set_allocated_labels(::flyteidl::admin::Labels* labels) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(labels_);
  }
  if (labels) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(labels));
    if (message_arena != submessage_arena) {
      labels = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, labels, submessage_arena);
    }
    
  } else {
    
  }
  labels_ = labels;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.ExecutionSpec.labels)
}

// .flyteidl.admin.Annotations annotations = 8 [json_name = "annotations"];
inline bool ExecutionSpec::_internal_has_annotations() const {
  return this != internal_default_instance() && annotations_ != nullptr;
}
inline bool ExecutionSpec::has_annotations() const {
  return _internal_has_annotations();
}
inline const ::flyteidl::admin::Annotations& ExecutionSpec::_internal_annotations() const {
  const ::flyteidl::admin::Annotations* p = annotations_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::admin::Annotations&>(
      ::flyteidl::admin::_Annotations_default_instance_);
}
inline const ::flyteidl::admin::Annotations& ExecutionSpec::annotations() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.ExecutionSpec.annotations)
  return _internal_annotations();
}
inline void ExecutionSpec::unsafe_arena_set_allocated_annotations(
    ::flyteidl::admin::Annotations* annotations) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(annotations_);
  }
  annotations_ = annotations;
  if (annotations) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.ExecutionSpec.annotations)
}
inline ::flyteidl::admin::Annotations* ExecutionSpec::release_annotations() {
  
  ::flyteidl::admin::Annotations* temp = annotations_;
  annotations_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::admin::Annotations* ExecutionSpec::unsafe_arena_release_annotations() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.ExecutionSpec.annotations)
  
  ::flyteidl::admin::Annotations* temp = annotations_;
  annotations_ = nullptr;
  return temp;
}
inline ::flyteidl::admin::Annotations* ExecutionSpec::_internal_mutable_annotations() {
  
  if (annotations_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::admin::Annotations>(GetArenaForAllocation());
    annotations_ = p;
  }
  return annotations_;
}
inline ::flyteidl::admin::Annotations* ExecutionSpec::mutable_annotations() {
  ::flyteidl::admin::Annotations* _msg = _internal_mutable_annotations();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.ExecutionSpec.annotations)
  return _msg;
}
inline void ExecutionSpec::set_allocated_annotations(::flyteidl::admin::Annotations* annotations) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(annotations_);
  }
  if (annotations) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(annotations));
    if (message_arena != submessage_arena) {
      annotations = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, annotations, submessage_arena);
    }
    
  } else {
    
  }
  annotations_ = annotations;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.ExecutionSpec.annotations)
}

// .flyteidl.core.SecurityContext security_context = 10 [json_name = "securityContext"];
inline bool ExecutionSpec::_internal_has_security_context() const {
  return this != internal_default_instance() && security_context_ != nullptr;
}
inline bool ExecutionSpec::has_security_context() const {
  return _internal_has_security_context();
}
inline const ::flyteidl::core::SecurityContext& ExecutionSpec::_internal_security_context() const {
  const ::flyteidl::core::SecurityContext* p = security_context_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::core::SecurityContext&>(
      ::flyteidl::core::_SecurityContext_default_instance_);
}
inline const ::flyteidl::core::SecurityContext& ExecutionSpec::security_context() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.ExecutionSpec.security_context)
  return _internal_security_context();
}
inline void ExecutionSpec::unsafe_arena_set_allocated_security_context(
    ::flyteidl::core::SecurityContext* security_context) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(security_context_);
  }
  security_context_ = security_context;
  if (security_context) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.ExecutionSpec.security_context)
}
inline ::flyteidl::core::SecurityContext* ExecutionSpec::release_security_context() {
  
  ::flyteidl::core::SecurityContext* temp = security_context_;
  security_context_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::core::SecurityContext* ExecutionSpec::unsafe_arena_release_security_context() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.ExecutionSpec.security_context)
  
  ::flyteidl::core::SecurityContext* temp = security_context_;
  security_context_ = nullptr;
  return temp;
}
inline ::flyteidl::core::SecurityContext* ExecutionSpec::_internal_mutable_security_context() {
  
  if (security_context_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::SecurityContext>(GetArenaForAllocation());
    security_context_ = p;
  }
  return security_context_;
}
inline ::flyteidl::core::SecurityContext* ExecutionSpec::mutable_security_context() {
  ::flyteidl::core::SecurityContext* _msg = _internal_mutable_security_context();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.ExecutionSpec.security_context)
  return _msg;
}
inline void ExecutionSpec::set_allocated_security_context(::flyteidl::core::SecurityContext* security_context) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(security_context_);
  }
  if (security_context) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(security_context));
    if (message_arena != submessage_arena) {
      security_context = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, security_context, submessage_arena);
    }
    
  } else {
    
  }
  security_context_ = security_context;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.ExecutionSpec.security_context)
}

// .flyteidl.admin.AuthRole auth_role = 16 [json_name = "authRole", deprecated = true];
inline bool ExecutionSpec::_internal_has_auth_role() const {
  return this != internal_default_instance() && auth_role_ != nullptr;
}
inline bool ExecutionSpec::has_auth_role() const {
  return _internal_has_auth_role();
}
inline const ::flyteidl::admin::AuthRole& ExecutionSpec::_internal_auth_role() const {
  const ::flyteidl::admin::AuthRole* p = auth_role_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::admin::AuthRole&>(
      ::flyteidl::admin::_AuthRole_default_instance_);
}
inline const ::flyteidl::admin::AuthRole& ExecutionSpec::auth_role() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.ExecutionSpec.auth_role)
  return _internal_auth_role();
}
inline void ExecutionSpec::unsafe_arena_set_allocated_auth_role(
    ::flyteidl::admin::AuthRole* auth_role) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(auth_role_);
  }
  auth_role_ = auth_role;
  if (auth_role) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.ExecutionSpec.auth_role)
}
inline ::flyteidl::admin::AuthRole* ExecutionSpec::release_auth_role() {
  
  ::flyteidl::admin::AuthRole* temp = auth_role_;
  auth_role_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::admin::AuthRole* ExecutionSpec::unsafe_arena_release_auth_role() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.ExecutionSpec.auth_role)
  
  ::flyteidl::admin::AuthRole* temp = auth_role_;
  auth_role_ = nullptr;
  return temp;
}
inline ::flyteidl::admin::AuthRole* ExecutionSpec::_internal_mutable_auth_role() {
  
  if (auth_role_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::admin::AuthRole>(GetArenaForAllocation());
    auth_role_ = p;
  }
  return auth_role_;
}
inline ::flyteidl::admin::AuthRole* ExecutionSpec::mutable_auth_role() {
  ::flyteidl::admin::AuthRole* _msg = _internal_mutable_auth_role();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.ExecutionSpec.auth_role)
  return _msg;
}
inline void ExecutionSpec::set_allocated_auth_role(::flyteidl::admin::AuthRole* auth_role) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(auth_role_);
  }
  if (auth_role) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(auth_role));
    if (message_arena != submessage_arena) {
      auth_role = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, auth_role, submessage_arena);
    }
    
  } else {
    
  }
  auth_role_ = auth_role;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.ExecutionSpec.auth_role)
}

// .flyteidl.core.QualityOfService quality_of_service = 17 [json_name = "qualityOfService"];
inline bool ExecutionSpec::_internal_has_quality_of_service() const {
  return this != internal_default_instance() && quality_of_service_ != nullptr;
}
inline bool ExecutionSpec::has_quality_of_service() const {
  return _internal_has_quality_of_service();
}
inline const ::flyteidl::core::QualityOfService& ExecutionSpec::_internal_quality_of_service() const {
  const ::flyteidl::core::QualityOfService* p = quality_of_service_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::core::QualityOfService&>(
      ::flyteidl::core::_QualityOfService_default_instance_);
}
inline const ::flyteidl::core::QualityOfService& ExecutionSpec::quality_of_service() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.ExecutionSpec.quality_of_service)
  return _internal_quality_of_service();
}
inline void ExecutionSpec::unsafe_arena_set_allocated_quality_of_service(
    ::flyteidl::core::QualityOfService* quality_of_service) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(quality_of_service_);
  }
  quality_of_service_ = quality_of_service;
  if (quality_of_service) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.ExecutionSpec.quality_of_service)
}
inline ::flyteidl::core::QualityOfService* ExecutionSpec::release_quality_of_service() {
  
  ::flyteidl::core::QualityOfService* temp = quality_of_service_;
  quality_of_service_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::core::QualityOfService* ExecutionSpec::unsafe_arena_release_quality_of_service() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.ExecutionSpec.quality_of_service)
  
  ::flyteidl::core::QualityOfService* temp = quality_of_service_;
  quality_of_service_ = nullptr;
  return temp;
}
inline ::flyteidl::core::QualityOfService* ExecutionSpec::_internal_mutable_quality_of_service() {
  
  if (quality_of_service_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::QualityOfService>(GetArenaForAllocation());
    quality_of_service_ = p;
  }
  return quality_of_service_;
}
inline ::flyteidl::core::QualityOfService* ExecutionSpec::mutable_quality_of_service() {
  ::flyteidl::core::QualityOfService* _msg = _internal_mutable_quality_of_service();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.ExecutionSpec.quality_of_service)
  return _msg;
}
inline void ExecutionSpec::set_allocated_quality_of_service(::flyteidl::core::QualityOfService* quality_of_service) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(quality_of_service_);
  }
  if (quality_of_service) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(quality_of_service));
    if (message_arena != submessage_arena) {
      quality_of_service = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, quality_of_service, submessage_arena);
    }
    
  } else {
    
  }
  quality_of_service_ = quality_of_service;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.ExecutionSpec.quality_of_service)
}

// int32 max_parallelism = 18 [json_name = "maxParallelism"];
inline void ExecutionSpec::clear_max_parallelism() {
  max_parallelism_ = 0;
}
inline int32_t ExecutionSpec::_internal_max_parallelism() const {
  return max_parallelism_;
}
inline int32_t ExecutionSpec::max_parallelism() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.ExecutionSpec.max_parallelism)
  return _internal_max_parallelism();
}
inline void ExecutionSpec::_internal_set_max_parallelism(int32_t value) {
  
  max_parallelism_ = value;
}
inline void ExecutionSpec::set_max_parallelism(int32_t value) {
  _internal_set_max_parallelism(value);
  // @@protoc_insertion_point(field_set:flyteidl.admin.ExecutionSpec.max_parallelism)
}

// .flyteidl.admin.RawOutputDataConfig raw_output_data_config = 19 [json_name = "rawOutputDataConfig"];
inline bool ExecutionSpec::_internal_has_raw_output_data_config() const {
  return this != internal_default_instance() && raw_output_data_config_ != nullptr;
}
inline bool ExecutionSpec::has_raw_output_data_config() const {
  return _internal_has_raw_output_data_config();
}
inline const ::flyteidl::admin::RawOutputDataConfig& ExecutionSpec::_internal_raw_output_data_config() const {
  const ::flyteidl::admin::RawOutputDataConfig* p = raw_output_data_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::admin::RawOutputDataConfig&>(
      ::flyteidl::admin::_RawOutputDataConfig_default_instance_);
}
inline const ::flyteidl::admin::RawOutputDataConfig& ExecutionSpec::raw_output_data_config() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.ExecutionSpec.raw_output_data_config)
  return _internal_raw_output_data_config();
}
inline void ExecutionSpec::unsafe_arena_set_allocated_raw_output_data_config(
    ::flyteidl::admin::RawOutputDataConfig* raw_output_data_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(raw_output_data_config_);
  }
  raw_output_data_config_ = raw_output_data_config;
  if (raw_output_data_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.ExecutionSpec.raw_output_data_config)
}
inline ::flyteidl::admin::RawOutputDataConfig* ExecutionSpec::release_raw_output_data_config() {
  
  ::flyteidl::admin::RawOutputDataConfig* temp = raw_output_data_config_;
  raw_output_data_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::admin::RawOutputDataConfig* ExecutionSpec::unsafe_arena_release_raw_output_data_config() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.ExecutionSpec.raw_output_data_config)
  
  ::flyteidl::admin::RawOutputDataConfig* temp = raw_output_data_config_;
  raw_output_data_config_ = nullptr;
  return temp;
}
inline ::flyteidl::admin::RawOutputDataConfig* ExecutionSpec::_internal_mutable_raw_output_data_config() {
  
  if (raw_output_data_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::admin::RawOutputDataConfig>(GetArenaForAllocation());
    raw_output_data_config_ = p;
  }
  return raw_output_data_config_;
}
inline ::flyteidl::admin::RawOutputDataConfig* ExecutionSpec::mutable_raw_output_data_config() {
  ::flyteidl::admin::RawOutputDataConfig* _msg = _internal_mutable_raw_output_data_config();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.ExecutionSpec.raw_output_data_config)
  return _msg;
}
inline void ExecutionSpec::set_allocated_raw_output_data_config(::flyteidl::admin::RawOutputDataConfig* raw_output_data_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(raw_output_data_config_);
  }
  if (raw_output_data_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(raw_output_data_config));
    if (message_arena != submessage_arena) {
      raw_output_data_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, raw_output_data_config, submessage_arena);
    }
    
  } else {
    
  }
  raw_output_data_config_ = raw_output_data_config;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.ExecutionSpec.raw_output_data_config)
}

// .flyteidl.admin.ClusterAssignment cluster_assignment = 20 [json_name = "clusterAssignment"];
inline bool ExecutionSpec::_internal_has_cluster_assignment() const {
  return this != internal_default_instance() && cluster_assignment_ != nullptr;
}
inline bool ExecutionSpec::has_cluster_assignment() const {
  return _internal_has_cluster_assignment();
}
inline const ::flyteidl::admin::ClusterAssignment& ExecutionSpec::_internal_cluster_assignment() const {
  const ::flyteidl::admin::ClusterAssignment* p = cluster_assignment_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::admin::ClusterAssignment&>(
      ::flyteidl::admin::_ClusterAssignment_default_instance_);
}
inline const ::flyteidl::admin::ClusterAssignment& ExecutionSpec::cluster_assignment() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.ExecutionSpec.cluster_assignment)
  return _internal_cluster_assignment();
}
inline void ExecutionSpec::unsafe_arena_set_allocated_cluster_assignment(
    ::flyteidl::admin::ClusterAssignment* cluster_assignment) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cluster_assignment_);
  }
  cluster_assignment_ = cluster_assignment;
  if (cluster_assignment) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.ExecutionSpec.cluster_assignment)
}
inline ::flyteidl::admin::ClusterAssignment* ExecutionSpec::release_cluster_assignment() {
  
  ::flyteidl::admin::ClusterAssignment* temp = cluster_assignment_;
  cluster_assignment_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::admin::ClusterAssignment* ExecutionSpec::unsafe_arena_release_cluster_assignment() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.ExecutionSpec.cluster_assignment)
  
  ::flyteidl::admin::ClusterAssignment* temp = cluster_assignment_;
  cluster_assignment_ = nullptr;
  return temp;
}
inline ::flyteidl::admin::ClusterAssignment* ExecutionSpec::_internal_mutable_cluster_assignment() {
  
  if (cluster_assignment_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::admin::ClusterAssignment>(GetArenaForAllocation());
    cluster_assignment_ = p;
  }
  return cluster_assignment_;
}
inline ::flyteidl::admin::ClusterAssignment* ExecutionSpec::mutable_cluster_assignment() {
  ::flyteidl::admin::ClusterAssignment* _msg = _internal_mutable_cluster_assignment();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.ExecutionSpec.cluster_assignment)
  return _msg;
}
inline void ExecutionSpec::set_allocated_cluster_assignment(::flyteidl::admin::ClusterAssignment* cluster_assignment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(cluster_assignment_);
  }
  if (cluster_assignment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cluster_assignment));
    if (message_arena != submessage_arena) {
      cluster_assignment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cluster_assignment, submessage_arena);
    }
    
  } else {
    
  }
  cluster_assignment_ = cluster_assignment;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.ExecutionSpec.cluster_assignment)
}

inline bool ExecutionSpec::has_notification_overrides() const {
  return notification_overrides_case() != NOTIFICATION_OVERRIDES_NOT_SET;
}
inline void ExecutionSpec::clear_has_notification_overrides() {
  _oneof_case_[0] = NOTIFICATION_OVERRIDES_NOT_SET;
}
inline ExecutionSpec::NotificationOverridesCase ExecutionSpec::notification_overrides_case() const {
  return ExecutionSpec::NotificationOverridesCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ExecutionTerminateRequest

// .flyteidl.core.WorkflowExecutionIdentifier id = 1 [json_name = "id"];
inline bool ExecutionTerminateRequest::_internal_has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline bool ExecutionTerminateRequest::has_id() const {
  return _internal_has_id();
}
inline const ::flyteidl::core::WorkflowExecutionIdentifier& ExecutionTerminateRequest::_internal_id() const {
  const ::flyteidl::core::WorkflowExecutionIdentifier* p = id_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::core::WorkflowExecutionIdentifier&>(
      ::flyteidl::core::_WorkflowExecutionIdentifier_default_instance_);
}
inline const ::flyteidl::core::WorkflowExecutionIdentifier& ExecutionTerminateRequest::id() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.ExecutionTerminateRequest.id)
  return _internal_id();
}
inline void ExecutionTerminateRequest::unsafe_arena_set_allocated_id(
    ::flyteidl::core::WorkflowExecutionIdentifier* id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.ExecutionTerminateRequest.id)
}
inline ::flyteidl::core::WorkflowExecutionIdentifier* ExecutionTerminateRequest::release_id() {
  
  ::flyteidl::core::WorkflowExecutionIdentifier* temp = id_;
  id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::core::WorkflowExecutionIdentifier* ExecutionTerminateRequest::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.ExecutionTerminateRequest.id)
  
  ::flyteidl::core::WorkflowExecutionIdentifier* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::flyteidl::core::WorkflowExecutionIdentifier* ExecutionTerminateRequest::_internal_mutable_id() {
  
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::WorkflowExecutionIdentifier>(GetArenaForAllocation());
    id_ = p;
  }
  return id_;
}
inline ::flyteidl::core::WorkflowExecutionIdentifier* ExecutionTerminateRequest::mutable_id() {
  ::flyteidl::core::WorkflowExecutionIdentifier* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.ExecutionTerminateRequest.id)
  return _msg;
}
inline void ExecutionTerminateRequest::set_allocated_id(::flyteidl::core::WorkflowExecutionIdentifier* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id));
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.ExecutionTerminateRequest.id)
}

// string cause = 2 [json_name = "cause"];
inline void ExecutionTerminateRequest::clear_cause() {
  cause_.ClearToEmpty();
}
inline const std::string& ExecutionTerminateRequest::cause() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.ExecutionTerminateRequest.cause)
  return _internal_cause();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecutionTerminateRequest::set_cause(ArgT0&& arg0, ArgT... args) {
 
 cause_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.admin.ExecutionTerminateRequest.cause)
}
inline std::string* ExecutionTerminateRequest::mutable_cause() {
  std::string* _s = _internal_mutable_cause();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.ExecutionTerminateRequest.cause)
  return _s;
}
inline const std::string& ExecutionTerminateRequest::_internal_cause() const {
  return cause_.Get();
}
inline void ExecutionTerminateRequest::_internal_set_cause(const std::string& value) {
  
  cause_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ExecutionTerminateRequest::_internal_mutable_cause() {
  
  return cause_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ExecutionTerminateRequest::release_cause() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.ExecutionTerminateRequest.cause)
  return cause_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ExecutionTerminateRequest::set_allocated_cause(std::string* cause) {
  if (cause != nullptr) {
    
  } else {
    
  }
  cause_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cause,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (cause_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    cause_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.ExecutionTerminateRequest.cause)
}

// -------------------------------------------------------------------

// ExecutionTerminateResponse

// -------------------------------------------------------------------

// WorkflowExecutionGetDataRequest

// .flyteidl.core.WorkflowExecutionIdentifier id = 1 [json_name = "id"];
inline bool WorkflowExecutionGetDataRequest::_internal_has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline bool WorkflowExecutionGetDataRequest::has_id() const {
  return _internal_has_id();
}
inline const ::flyteidl::core::WorkflowExecutionIdentifier& WorkflowExecutionGetDataRequest::_internal_id() const {
  const ::flyteidl::core::WorkflowExecutionIdentifier* p = id_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::core::WorkflowExecutionIdentifier&>(
      ::flyteidl::core::_WorkflowExecutionIdentifier_default_instance_);
}
inline const ::flyteidl::core::WorkflowExecutionIdentifier& WorkflowExecutionGetDataRequest::id() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.WorkflowExecutionGetDataRequest.id)
  return _internal_id();
}
inline void WorkflowExecutionGetDataRequest::unsafe_arena_set_allocated_id(
    ::flyteidl::core::WorkflowExecutionIdentifier* id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.WorkflowExecutionGetDataRequest.id)
}
inline ::flyteidl::core::WorkflowExecutionIdentifier* WorkflowExecutionGetDataRequest::release_id() {
  
  ::flyteidl::core::WorkflowExecutionIdentifier* temp = id_;
  id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::core::WorkflowExecutionIdentifier* WorkflowExecutionGetDataRequest::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.WorkflowExecutionGetDataRequest.id)
  
  ::flyteidl::core::WorkflowExecutionIdentifier* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::flyteidl::core::WorkflowExecutionIdentifier* WorkflowExecutionGetDataRequest::_internal_mutable_id() {
  
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::WorkflowExecutionIdentifier>(GetArenaForAllocation());
    id_ = p;
  }
  return id_;
}
inline ::flyteidl::core::WorkflowExecutionIdentifier* WorkflowExecutionGetDataRequest::mutable_id() {
  ::flyteidl::core::WorkflowExecutionIdentifier* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.WorkflowExecutionGetDataRequest.id)
  return _msg;
}
inline void WorkflowExecutionGetDataRequest::set_allocated_id(::flyteidl::core::WorkflowExecutionIdentifier* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id));
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.WorkflowExecutionGetDataRequest.id)
}

// -------------------------------------------------------------------

// WorkflowExecutionGetDataResponse

// .flyteidl.admin.UrlBlob outputs = 1 [json_name = "outputs", deprecated = true];
inline bool WorkflowExecutionGetDataResponse::_internal_has_outputs() const {
  return this != internal_default_instance() && outputs_ != nullptr;
}
inline bool WorkflowExecutionGetDataResponse::has_outputs() const {
  return _internal_has_outputs();
}
inline const ::flyteidl::admin::UrlBlob& WorkflowExecutionGetDataResponse::_internal_outputs() const {
  const ::flyteidl::admin::UrlBlob* p = outputs_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::admin::UrlBlob&>(
      ::flyteidl::admin::_UrlBlob_default_instance_);
}
inline const ::flyteidl::admin::UrlBlob& WorkflowExecutionGetDataResponse::outputs() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.WorkflowExecutionGetDataResponse.outputs)
  return _internal_outputs();
}
inline void WorkflowExecutionGetDataResponse::unsafe_arena_set_allocated_outputs(
    ::flyteidl::admin::UrlBlob* outputs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(outputs_);
  }
  outputs_ = outputs;
  if (outputs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.WorkflowExecutionGetDataResponse.outputs)
}
inline ::flyteidl::admin::UrlBlob* WorkflowExecutionGetDataResponse::release_outputs() {
  
  ::flyteidl::admin::UrlBlob* temp = outputs_;
  outputs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::admin::UrlBlob* WorkflowExecutionGetDataResponse::unsafe_arena_release_outputs() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.WorkflowExecutionGetDataResponse.outputs)
  
  ::flyteidl::admin::UrlBlob* temp = outputs_;
  outputs_ = nullptr;
  return temp;
}
inline ::flyteidl::admin::UrlBlob* WorkflowExecutionGetDataResponse::_internal_mutable_outputs() {
  
  if (outputs_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::admin::UrlBlob>(GetArenaForAllocation());
    outputs_ = p;
  }
  return outputs_;
}
inline ::flyteidl::admin::UrlBlob* WorkflowExecutionGetDataResponse::mutable_outputs() {
  ::flyteidl::admin::UrlBlob* _msg = _internal_mutable_outputs();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.WorkflowExecutionGetDataResponse.outputs)
  return _msg;
}
inline void WorkflowExecutionGetDataResponse::set_allocated_outputs(::flyteidl::admin::UrlBlob* outputs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(outputs_);
  }
  if (outputs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(outputs));
    if (message_arena != submessage_arena) {
      outputs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, outputs, submessage_arena);
    }
    
  } else {
    
  }
  outputs_ = outputs;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.WorkflowExecutionGetDataResponse.outputs)
}

// .flyteidl.admin.UrlBlob inputs = 2 [json_name = "inputs", deprecated = true];
inline bool WorkflowExecutionGetDataResponse::_internal_has_inputs() const {
  return this != internal_default_instance() && inputs_ != nullptr;
}
inline bool WorkflowExecutionGetDataResponse::has_inputs() const {
  return _internal_has_inputs();
}
inline const ::flyteidl::admin::UrlBlob& WorkflowExecutionGetDataResponse::_internal_inputs() const {
  const ::flyteidl::admin::UrlBlob* p = inputs_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::admin::UrlBlob&>(
      ::flyteidl::admin::_UrlBlob_default_instance_);
}
inline const ::flyteidl::admin::UrlBlob& WorkflowExecutionGetDataResponse::inputs() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.WorkflowExecutionGetDataResponse.inputs)
  return _internal_inputs();
}
inline void WorkflowExecutionGetDataResponse::unsafe_arena_set_allocated_inputs(
    ::flyteidl::admin::UrlBlob* inputs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(inputs_);
  }
  inputs_ = inputs;
  if (inputs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.WorkflowExecutionGetDataResponse.inputs)
}
inline ::flyteidl::admin::UrlBlob* WorkflowExecutionGetDataResponse::release_inputs() {
  
  ::flyteidl::admin::UrlBlob* temp = inputs_;
  inputs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::admin::UrlBlob* WorkflowExecutionGetDataResponse::unsafe_arena_release_inputs() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.WorkflowExecutionGetDataResponse.inputs)
  
  ::flyteidl::admin::UrlBlob* temp = inputs_;
  inputs_ = nullptr;
  return temp;
}
inline ::flyteidl::admin::UrlBlob* WorkflowExecutionGetDataResponse::_internal_mutable_inputs() {
  
  if (inputs_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::admin::UrlBlob>(GetArenaForAllocation());
    inputs_ = p;
  }
  return inputs_;
}
inline ::flyteidl::admin::UrlBlob* WorkflowExecutionGetDataResponse::mutable_inputs() {
  ::flyteidl::admin::UrlBlob* _msg = _internal_mutable_inputs();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.WorkflowExecutionGetDataResponse.inputs)
  return _msg;
}
inline void WorkflowExecutionGetDataResponse::set_allocated_inputs(::flyteidl::admin::UrlBlob* inputs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(inputs_);
  }
  if (inputs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(inputs));
    if (message_arena != submessage_arena) {
      inputs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, inputs, submessage_arena);
    }
    
  } else {
    
  }
  inputs_ = inputs;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.WorkflowExecutionGetDataResponse.inputs)
}

// .flyteidl.core.LiteralMap full_inputs = 3 [json_name = "fullInputs"];
inline bool WorkflowExecutionGetDataResponse::_internal_has_full_inputs() const {
  return this != internal_default_instance() && full_inputs_ != nullptr;
}
inline bool WorkflowExecutionGetDataResponse::has_full_inputs() const {
  return _internal_has_full_inputs();
}
inline const ::flyteidl::core::LiteralMap& WorkflowExecutionGetDataResponse::_internal_full_inputs() const {
  const ::flyteidl::core::LiteralMap* p = full_inputs_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::core::LiteralMap&>(
      ::flyteidl::core::_LiteralMap_default_instance_);
}
inline const ::flyteidl::core::LiteralMap& WorkflowExecutionGetDataResponse::full_inputs() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.WorkflowExecutionGetDataResponse.full_inputs)
  return _internal_full_inputs();
}
inline void WorkflowExecutionGetDataResponse::unsafe_arena_set_allocated_full_inputs(
    ::flyteidl::core::LiteralMap* full_inputs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(full_inputs_);
  }
  full_inputs_ = full_inputs;
  if (full_inputs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.WorkflowExecutionGetDataResponse.full_inputs)
}
inline ::flyteidl::core::LiteralMap* WorkflowExecutionGetDataResponse::release_full_inputs() {
  
  ::flyteidl::core::LiteralMap* temp = full_inputs_;
  full_inputs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::core::LiteralMap* WorkflowExecutionGetDataResponse::unsafe_arena_release_full_inputs() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.WorkflowExecutionGetDataResponse.full_inputs)
  
  ::flyteidl::core::LiteralMap* temp = full_inputs_;
  full_inputs_ = nullptr;
  return temp;
}
inline ::flyteidl::core::LiteralMap* WorkflowExecutionGetDataResponse::_internal_mutable_full_inputs() {
  
  if (full_inputs_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::LiteralMap>(GetArenaForAllocation());
    full_inputs_ = p;
  }
  return full_inputs_;
}
inline ::flyteidl::core::LiteralMap* WorkflowExecutionGetDataResponse::mutable_full_inputs() {
  ::flyteidl::core::LiteralMap* _msg = _internal_mutable_full_inputs();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.WorkflowExecutionGetDataResponse.full_inputs)
  return _msg;
}
inline void WorkflowExecutionGetDataResponse::set_allocated_full_inputs(::flyteidl::core::LiteralMap* full_inputs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(full_inputs_);
  }
  if (full_inputs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(full_inputs));
    if (message_arena != submessage_arena) {
      full_inputs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, full_inputs, submessage_arena);
    }
    
  } else {
    
  }
  full_inputs_ = full_inputs;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.WorkflowExecutionGetDataResponse.full_inputs)
}

// .flyteidl.core.LiteralMap full_outputs = 4 [json_name = "fullOutputs"];
inline bool WorkflowExecutionGetDataResponse::_internal_has_full_outputs() const {
  return this != internal_default_instance() && full_outputs_ != nullptr;
}
inline bool WorkflowExecutionGetDataResponse::has_full_outputs() const {
  return _internal_has_full_outputs();
}
inline const ::flyteidl::core::LiteralMap& WorkflowExecutionGetDataResponse::_internal_full_outputs() const {
  const ::flyteidl::core::LiteralMap* p = full_outputs_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::core::LiteralMap&>(
      ::flyteidl::core::_LiteralMap_default_instance_);
}
inline const ::flyteidl::core::LiteralMap& WorkflowExecutionGetDataResponse::full_outputs() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.WorkflowExecutionGetDataResponse.full_outputs)
  return _internal_full_outputs();
}
inline void WorkflowExecutionGetDataResponse::unsafe_arena_set_allocated_full_outputs(
    ::flyteidl::core::LiteralMap* full_outputs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(full_outputs_);
  }
  full_outputs_ = full_outputs;
  if (full_outputs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.WorkflowExecutionGetDataResponse.full_outputs)
}
inline ::flyteidl::core::LiteralMap* WorkflowExecutionGetDataResponse::release_full_outputs() {
  
  ::flyteidl::core::LiteralMap* temp = full_outputs_;
  full_outputs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::core::LiteralMap* WorkflowExecutionGetDataResponse::unsafe_arena_release_full_outputs() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.WorkflowExecutionGetDataResponse.full_outputs)
  
  ::flyteidl::core::LiteralMap* temp = full_outputs_;
  full_outputs_ = nullptr;
  return temp;
}
inline ::flyteidl::core::LiteralMap* WorkflowExecutionGetDataResponse::_internal_mutable_full_outputs() {
  
  if (full_outputs_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::LiteralMap>(GetArenaForAllocation());
    full_outputs_ = p;
  }
  return full_outputs_;
}
inline ::flyteidl::core::LiteralMap* WorkflowExecutionGetDataResponse::mutable_full_outputs() {
  ::flyteidl::core::LiteralMap* _msg = _internal_mutable_full_outputs();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.WorkflowExecutionGetDataResponse.full_outputs)
  return _msg;
}
inline void WorkflowExecutionGetDataResponse::set_allocated_full_outputs(::flyteidl::core::LiteralMap* full_outputs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(full_outputs_);
  }
  if (full_outputs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(full_outputs));
    if (message_arena != submessage_arena) {
      full_outputs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, full_outputs, submessage_arena);
    }
    
  } else {
    
  }
  full_outputs_ = full_outputs;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.WorkflowExecutionGetDataResponse.full_outputs)
}

// -------------------------------------------------------------------

// ExecutionUpdateRequest

// .flyteidl.core.WorkflowExecutionIdentifier id = 1 [json_name = "id"];
inline bool ExecutionUpdateRequest::_internal_has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline bool ExecutionUpdateRequest::has_id() const {
  return _internal_has_id();
}
inline const ::flyteidl::core::WorkflowExecutionIdentifier& ExecutionUpdateRequest::_internal_id() const {
  const ::flyteidl::core::WorkflowExecutionIdentifier* p = id_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::core::WorkflowExecutionIdentifier&>(
      ::flyteidl::core::_WorkflowExecutionIdentifier_default_instance_);
}
inline const ::flyteidl::core::WorkflowExecutionIdentifier& ExecutionUpdateRequest::id() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.ExecutionUpdateRequest.id)
  return _internal_id();
}
inline void ExecutionUpdateRequest::unsafe_arena_set_allocated_id(
    ::flyteidl::core::WorkflowExecutionIdentifier* id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.ExecutionUpdateRequest.id)
}
inline ::flyteidl::core::WorkflowExecutionIdentifier* ExecutionUpdateRequest::release_id() {
  
  ::flyteidl::core::WorkflowExecutionIdentifier* temp = id_;
  id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::core::WorkflowExecutionIdentifier* ExecutionUpdateRequest::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.ExecutionUpdateRequest.id)
  
  ::flyteidl::core::WorkflowExecutionIdentifier* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::flyteidl::core::WorkflowExecutionIdentifier* ExecutionUpdateRequest::_internal_mutable_id() {
  
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::WorkflowExecutionIdentifier>(GetArenaForAllocation());
    id_ = p;
  }
  return id_;
}
inline ::flyteidl::core::WorkflowExecutionIdentifier* ExecutionUpdateRequest::mutable_id() {
  ::flyteidl::core::WorkflowExecutionIdentifier* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.ExecutionUpdateRequest.id)
  return _msg;
}
inline void ExecutionUpdateRequest::set_allocated_id(::flyteidl::core::WorkflowExecutionIdentifier* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id));
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.ExecutionUpdateRequest.id)
}

// .flyteidl.admin.ExecutionState state = 2 [json_name = "state"];
inline void ExecutionUpdateRequest::clear_state() {
  state_ = 0;
}
inline ::flyteidl::admin::ExecutionState ExecutionUpdateRequest::_internal_state() const {
  return static_cast< ::flyteidl::admin::ExecutionState >(state_);
}
inline ::flyteidl::admin::ExecutionState ExecutionUpdateRequest::state() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.ExecutionUpdateRequest.state)
  return _internal_state();
}
inline void ExecutionUpdateRequest::_internal_set_state(::flyteidl::admin::ExecutionState value) {
  
  state_ = value;
}
inline void ExecutionUpdateRequest::set_state(::flyteidl::admin::ExecutionState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:flyteidl.admin.ExecutionUpdateRequest.state)
}

// -------------------------------------------------------------------

// ExecutionStateChangeDetails

// .flyteidl.admin.ExecutionState state = 1 [json_name = "state"];
inline void ExecutionStateChangeDetails::clear_state() {
  state_ = 0;
}
inline ::flyteidl::admin::ExecutionState ExecutionStateChangeDetails::_internal_state() const {
  return static_cast< ::flyteidl::admin::ExecutionState >(state_);
}
inline ::flyteidl::admin::ExecutionState ExecutionStateChangeDetails::state() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.ExecutionStateChangeDetails.state)
  return _internal_state();
}
inline void ExecutionStateChangeDetails::_internal_set_state(::flyteidl::admin::ExecutionState value) {
  
  state_ = value;
}
inline void ExecutionStateChangeDetails::set_state(::flyteidl::admin::ExecutionState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:flyteidl.admin.ExecutionStateChangeDetails.state)
}

// .google.protobuf.Timestamp occurred_at = 2 [json_name = "occurredAt"];
inline bool ExecutionStateChangeDetails::_internal_has_occurred_at() const {
  return this != internal_default_instance() && occurred_at_ != nullptr;
}
inline bool ExecutionStateChangeDetails::has_occurred_at() const {
  return _internal_has_occurred_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ExecutionStateChangeDetails::_internal_occurred_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = occurred_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ExecutionStateChangeDetails::occurred_at() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.ExecutionStateChangeDetails.occurred_at)
  return _internal_occurred_at();
}
inline void ExecutionStateChangeDetails::unsafe_arena_set_allocated_occurred_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* occurred_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(occurred_at_);
  }
  occurred_at_ = occurred_at;
  if (occurred_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.ExecutionStateChangeDetails.occurred_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ExecutionStateChangeDetails::release_occurred_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = occurred_at_;
  occurred_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ExecutionStateChangeDetails::unsafe_arena_release_occurred_at() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.ExecutionStateChangeDetails.occurred_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = occurred_at_;
  occurred_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ExecutionStateChangeDetails::_internal_mutable_occurred_at() {
  
  if (occurred_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    occurred_at_ = p;
  }
  return occurred_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ExecutionStateChangeDetails::mutable_occurred_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_occurred_at();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.ExecutionStateChangeDetails.occurred_at)
  return _msg;
}
inline void ExecutionStateChangeDetails::set_allocated_occurred_at(::PROTOBUF_NAMESPACE_ID::Timestamp* occurred_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(occurred_at_);
  }
  if (occurred_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(occurred_at));
    if (message_arena != submessage_arena) {
      occurred_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, occurred_at, submessage_arena);
    }
    
  } else {
    
  }
  occurred_at_ = occurred_at;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.ExecutionStateChangeDetails.occurred_at)
}

// string principal = 3 [json_name = "principal"];
inline void ExecutionStateChangeDetails::clear_principal() {
  principal_.ClearToEmpty();
}
inline const std::string& ExecutionStateChangeDetails::principal() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.ExecutionStateChangeDetails.principal)
  return _internal_principal();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecutionStateChangeDetails::set_principal(ArgT0&& arg0, ArgT... args) {
 
 principal_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.admin.ExecutionStateChangeDetails.principal)
}
inline std::string* ExecutionStateChangeDetails::mutable_principal() {
  std::string* _s = _internal_mutable_principal();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.ExecutionStateChangeDetails.principal)
  return _s;
}
inline const std::string& ExecutionStateChangeDetails::_internal_principal() const {
  return principal_.Get();
}
inline void ExecutionStateChangeDetails::_internal_set_principal(const std::string& value) {
  
  principal_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ExecutionStateChangeDetails::_internal_mutable_principal() {
  
  return principal_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ExecutionStateChangeDetails::release_principal() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.ExecutionStateChangeDetails.principal)
  return principal_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ExecutionStateChangeDetails::set_allocated_principal(std::string* principal) {
  if (principal != nullptr) {
    
  } else {
    
  }
  principal_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), principal,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (principal_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    principal_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.ExecutionStateChangeDetails.principal)
}

// -------------------------------------------------------------------

// ExecutionUpdateResponse

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace admin
}  // namespace flyteidl

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::flyteidl::admin::ExecutionMetadata_ExecutionMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::flyteidl::admin::ExecutionMetadata_ExecutionMode>() {
  return ::flyteidl::admin::ExecutionMetadata_ExecutionMode_descriptor();
}
template <> struct is_proto_enum< ::flyteidl::admin::ExecutionState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::flyteidl::admin::ExecutionState>() {
  return ::flyteidl::admin::ExecutionState_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_flyteidl_2fadmin_2fexecution_2eproto
