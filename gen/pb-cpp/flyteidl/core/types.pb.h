// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: flyteidl/core/types.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_flyteidl_2fcore_2ftypes_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_flyteidl_2fcore_2ftypes_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/struct.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_flyteidl_2fcore_2ftypes_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_flyteidl_2fcore_2ftypes_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[12]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_flyteidl_2fcore_2ftypes_2eproto;
namespace flyteidl {
namespace core {
class BlobType;
struct BlobTypeDefaultTypeInternal;
extern BlobTypeDefaultTypeInternal _BlobType_default_instance_;
class EnumType;
struct EnumTypeDefaultTypeInternal;
extern EnumTypeDefaultTypeInternal _EnumType_default_instance_;
class Error;
struct ErrorDefaultTypeInternal;
extern ErrorDefaultTypeInternal _Error_default_instance_;
class LiteralType;
struct LiteralTypeDefaultTypeInternal;
extern LiteralTypeDefaultTypeInternal _LiteralType_default_instance_;
class OutputReference;
struct OutputReferenceDefaultTypeInternal;
extern OutputReferenceDefaultTypeInternal _OutputReference_default_instance_;
class SchemaType;
struct SchemaTypeDefaultTypeInternal;
extern SchemaTypeDefaultTypeInternal _SchemaType_default_instance_;
class SchemaType_SchemaColumn;
struct SchemaType_SchemaColumnDefaultTypeInternal;
extern SchemaType_SchemaColumnDefaultTypeInternal _SchemaType_SchemaColumn_default_instance_;
class StructuredDatasetType;
struct StructuredDatasetTypeDefaultTypeInternal;
extern StructuredDatasetTypeDefaultTypeInternal _StructuredDatasetType_default_instance_;
class StructuredDatasetType_DatasetColumn;
struct StructuredDatasetType_DatasetColumnDefaultTypeInternal;
extern StructuredDatasetType_DatasetColumnDefaultTypeInternal _StructuredDatasetType_DatasetColumn_default_instance_;
class TypeAnnotation;
struct TypeAnnotationDefaultTypeInternal;
extern TypeAnnotationDefaultTypeInternal _TypeAnnotation_default_instance_;
class TypeStructure;
struct TypeStructureDefaultTypeInternal;
extern TypeStructureDefaultTypeInternal _TypeStructure_default_instance_;
class UnionType;
struct UnionTypeDefaultTypeInternal;
extern UnionTypeDefaultTypeInternal _UnionType_default_instance_;
}  // namespace core
}  // namespace flyteidl
PROTOBUF_NAMESPACE_OPEN
template<> ::flyteidl::core::BlobType* Arena::CreateMaybeMessage<::flyteidl::core::BlobType>(Arena*);
template<> ::flyteidl::core::EnumType* Arena::CreateMaybeMessage<::flyteidl::core::EnumType>(Arena*);
template<> ::flyteidl::core::Error* Arena::CreateMaybeMessage<::flyteidl::core::Error>(Arena*);
template<> ::flyteidl::core::LiteralType* Arena::CreateMaybeMessage<::flyteidl::core::LiteralType>(Arena*);
template<> ::flyteidl::core::OutputReference* Arena::CreateMaybeMessage<::flyteidl::core::OutputReference>(Arena*);
template<> ::flyteidl::core::SchemaType* Arena::CreateMaybeMessage<::flyteidl::core::SchemaType>(Arena*);
template<> ::flyteidl::core::SchemaType_SchemaColumn* Arena::CreateMaybeMessage<::flyteidl::core::SchemaType_SchemaColumn>(Arena*);
template<> ::flyteidl::core::StructuredDatasetType* Arena::CreateMaybeMessage<::flyteidl::core::StructuredDatasetType>(Arena*);
template<> ::flyteidl::core::StructuredDatasetType_DatasetColumn* Arena::CreateMaybeMessage<::flyteidl::core::StructuredDatasetType_DatasetColumn>(Arena*);
template<> ::flyteidl::core::TypeAnnotation* Arena::CreateMaybeMessage<::flyteidl::core::TypeAnnotation>(Arena*);
template<> ::flyteidl::core::TypeStructure* Arena::CreateMaybeMessage<::flyteidl::core::TypeStructure>(Arena*);
template<> ::flyteidl::core::UnionType* Arena::CreateMaybeMessage<::flyteidl::core::UnionType>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace flyteidl {
namespace core {

enum SchemaType_SchemaColumn_SchemaColumnType : int {
  SchemaType_SchemaColumn_SchemaColumnType_INTEGER = 0,
  SchemaType_SchemaColumn_SchemaColumnType_FLOAT = 1,
  SchemaType_SchemaColumn_SchemaColumnType_STRING = 2,
  SchemaType_SchemaColumn_SchemaColumnType_BOOLEAN = 3,
  SchemaType_SchemaColumn_SchemaColumnType_DATETIME = 4,
  SchemaType_SchemaColumn_SchemaColumnType_DURATION = 5,
  SchemaType_SchemaColumn_SchemaColumnType_SchemaType_SchemaColumn_SchemaColumnType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SchemaType_SchemaColumn_SchemaColumnType_SchemaType_SchemaColumn_SchemaColumnType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SchemaType_SchemaColumn_SchemaColumnType_IsValid(int value);
constexpr SchemaType_SchemaColumn_SchemaColumnType SchemaType_SchemaColumn_SchemaColumnType_SchemaColumnType_MIN = SchemaType_SchemaColumn_SchemaColumnType_INTEGER;
constexpr SchemaType_SchemaColumn_SchemaColumnType SchemaType_SchemaColumn_SchemaColumnType_SchemaColumnType_MAX = SchemaType_SchemaColumn_SchemaColumnType_DURATION;
constexpr int SchemaType_SchemaColumn_SchemaColumnType_SchemaColumnType_ARRAYSIZE = SchemaType_SchemaColumn_SchemaColumnType_SchemaColumnType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SchemaType_SchemaColumn_SchemaColumnType_descriptor();
template<typename T>
inline const std::string& SchemaType_SchemaColumn_SchemaColumnType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SchemaType_SchemaColumn_SchemaColumnType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SchemaType_SchemaColumn_SchemaColumnType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SchemaType_SchemaColumn_SchemaColumnType_descriptor(), enum_t_value);
}
inline bool SchemaType_SchemaColumn_SchemaColumnType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SchemaType_SchemaColumn_SchemaColumnType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SchemaType_SchemaColumn_SchemaColumnType>(
    SchemaType_SchemaColumn_SchemaColumnType_descriptor(), name, value);
}
enum BlobType_BlobDimensionality : int {
  BlobType_BlobDimensionality_SINGLE = 0,
  BlobType_BlobDimensionality_MULTIPART = 1,
  BlobType_BlobDimensionality_BlobType_BlobDimensionality_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  BlobType_BlobDimensionality_BlobType_BlobDimensionality_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool BlobType_BlobDimensionality_IsValid(int value);
constexpr BlobType_BlobDimensionality BlobType_BlobDimensionality_BlobDimensionality_MIN = BlobType_BlobDimensionality_SINGLE;
constexpr BlobType_BlobDimensionality BlobType_BlobDimensionality_BlobDimensionality_MAX = BlobType_BlobDimensionality_MULTIPART;
constexpr int BlobType_BlobDimensionality_BlobDimensionality_ARRAYSIZE = BlobType_BlobDimensionality_BlobDimensionality_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BlobType_BlobDimensionality_descriptor();
template<typename T>
inline const std::string& BlobType_BlobDimensionality_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BlobType_BlobDimensionality>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BlobType_BlobDimensionality_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BlobType_BlobDimensionality_descriptor(), enum_t_value);
}
inline bool BlobType_BlobDimensionality_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BlobType_BlobDimensionality* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BlobType_BlobDimensionality>(
    BlobType_BlobDimensionality_descriptor(), name, value);
}
enum SimpleType : int {
  NONE = 0,
  INTEGER = 1,
  FLOAT = 2,
  STRING = 3,
  BOOLEAN = 4,
  DATETIME = 5,
  DURATION = 6,
  BINARY = 7,
  ERROR = 8,
  STRUCT = 9,
  SimpleType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SimpleType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SimpleType_IsValid(int value);
constexpr SimpleType SimpleType_MIN = NONE;
constexpr SimpleType SimpleType_MAX = STRUCT;
constexpr int SimpleType_ARRAYSIZE = SimpleType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SimpleType_descriptor();
template<typename T>
inline const std::string& SimpleType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SimpleType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SimpleType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SimpleType_descriptor(), enum_t_value);
}
inline bool SimpleType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SimpleType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SimpleType>(
    SimpleType_descriptor(), name, value);
}
// ===================================================================

class SchemaType_SchemaColumn final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.SchemaType.SchemaColumn) */ {
 public:
  inline SchemaType_SchemaColumn() : SchemaType_SchemaColumn(nullptr) {}
  ~SchemaType_SchemaColumn() override;
  explicit constexpr SchemaType_SchemaColumn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SchemaType_SchemaColumn(const SchemaType_SchemaColumn& from);
  SchemaType_SchemaColumn(SchemaType_SchemaColumn&& from) noexcept
    : SchemaType_SchemaColumn() {
    *this = ::std::move(from);
  }

  inline SchemaType_SchemaColumn& operator=(const SchemaType_SchemaColumn& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchemaType_SchemaColumn& operator=(SchemaType_SchemaColumn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SchemaType_SchemaColumn& default_instance() {
    return *internal_default_instance();
  }
  static inline const SchemaType_SchemaColumn* internal_default_instance() {
    return reinterpret_cast<const SchemaType_SchemaColumn*>(
               &_SchemaType_SchemaColumn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SchemaType_SchemaColumn& a, SchemaType_SchemaColumn& b) {
    a.Swap(&b);
  }
  inline void Swap(SchemaType_SchemaColumn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SchemaType_SchemaColumn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SchemaType_SchemaColumn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SchemaType_SchemaColumn>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SchemaType_SchemaColumn* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.core.SchemaType.SchemaColumn";
  }
  protected:
  explicit SchemaType_SchemaColumn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SchemaType_SchemaColumn_SchemaColumnType SchemaColumnType;
  static constexpr SchemaColumnType INTEGER =
    SchemaType_SchemaColumn_SchemaColumnType_INTEGER;
  static constexpr SchemaColumnType FLOAT =
    SchemaType_SchemaColumn_SchemaColumnType_FLOAT;
  static constexpr SchemaColumnType STRING =
    SchemaType_SchemaColumn_SchemaColumnType_STRING;
  static constexpr SchemaColumnType BOOLEAN =
    SchemaType_SchemaColumn_SchemaColumnType_BOOLEAN;
  static constexpr SchemaColumnType DATETIME =
    SchemaType_SchemaColumn_SchemaColumnType_DATETIME;
  static constexpr SchemaColumnType DURATION =
    SchemaType_SchemaColumn_SchemaColumnType_DURATION;
  static inline bool SchemaColumnType_IsValid(int value) {
    return SchemaType_SchemaColumn_SchemaColumnType_IsValid(value);
  }
  static constexpr SchemaColumnType SchemaColumnType_MIN =
    SchemaType_SchemaColumn_SchemaColumnType_SchemaColumnType_MIN;
  static constexpr SchemaColumnType SchemaColumnType_MAX =
    SchemaType_SchemaColumn_SchemaColumnType_SchemaColumnType_MAX;
  static constexpr int SchemaColumnType_ARRAYSIZE =
    SchemaType_SchemaColumn_SchemaColumnType_SchemaColumnType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SchemaColumnType_descriptor() {
    return SchemaType_SchemaColumn_SchemaColumnType_descriptor();
  }
  template<typename T>
  static inline const std::string& SchemaColumnType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SchemaColumnType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SchemaColumnType_Name.");
    return SchemaType_SchemaColumn_SchemaColumnType_Name(enum_t_value);
  }
  static inline bool SchemaColumnType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SchemaColumnType* value) {
    return SchemaType_SchemaColumn_SchemaColumnType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .flyteidl.core.SchemaType.SchemaColumn.SchemaColumnType type = 2 [json_name = "type"];
  void clear_type();
  ::flyteidl::core::SchemaType_SchemaColumn_SchemaColumnType type() const;
  void set_type(::flyteidl::core::SchemaType_SchemaColumn_SchemaColumnType value);
  private:
  ::flyteidl::core::SchemaType_SchemaColumn_SchemaColumnType _internal_type() const;
  void _internal_set_type(::flyteidl::core::SchemaType_SchemaColumn_SchemaColumnType value);
  public:

  // @@protoc_insertion_point(class_scope:flyteidl.core.SchemaType.SchemaColumn)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class SchemaType final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.SchemaType) */ {
 public:
  inline SchemaType() : SchemaType(nullptr) {}
  ~SchemaType() override;
  explicit constexpr SchemaType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SchemaType(const SchemaType& from);
  SchemaType(SchemaType&& from) noexcept
    : SchemaType() {
    *this = ::std::move(from);
  }

  inline SchemaType& operator=(const SchemaType& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchemaType& operator=(SchemaType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SchemaType& default_instance() {
    return *internal_default_instance();
  }
  static inline const SchemaType* internal_default_instance() {
    return reinterpret_cast<const SchemaType*>(
               &_SchemaType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SchemaType& a, SchemaType& b) {
    a.Swap(&b);
  }
  inline void Swap(SchemaType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SchemaType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SchemaType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SchemaType>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SchemaType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.core.SchemaType";
  }
  protected:
  explicit SchemaType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SchemaType_SchemaColumn SchemaColumn;

  // accessors -------------------------------------------------------

  enum : int {
    kColumnsFieldNumber = 3,
  };
  // repeated .flyteidl.core.SchemaType.SchemaColumn columns = 3 [json_name = "columns"];
  int columns_size() const;
  private:
  int _internal_columns_size() const;
  public:
  void clear_columns();
  ::flyteidl::core::SchemaType_SchemaColumn* mutable_columns(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::core::SchemaType_SchemaColumn >*
      mutable_columns();
  private:
  const ::flyteidl::core::SchemaType_SchemaColumn& _internal_columns(int index) const;
  ::flyteidl::core::SchemaType_SchemaColumn* _internal_add_columns();
  public:
  const ::flyteidl::core::SchemaType_SchemaColumn& columns(int index) const;
  ::flyteidl::core::SchemaType_SchemaColumn* add_columns();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::core::SchemaType_SchemaColumn >&
      columns() const;

  // @@protoc_insertion_point(class_scope:flyteidl.core.SchemaType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::core::SchemaType_SchemaColumn > columns_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class StructuredDatasetType_DatasetColumn final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.StructuredDatasetType.DatasetColumn) */ {
 public:
  inline StructuredDatasetType_DatasetColumn() : StructuredDatasetType_DatasetColumn(nullptr) {}
  ~StructuredDatasetType_DatasetColumn() override;
  explicit constexpr StructuredDatasetType_DatasetColumn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StructuredDatasetType_DatasetColumn(const StructuredDatasetType_DatasetColumn& from);
  StructuredDatasetType_DatasetColumn(StructuredDatasetType_DatasetColumn&& from) noexcept
    : StructuredDatasetType_DatasetColumn() {
    *this = ::std::move(from);
  }

  inline StructuredDatasetType_DatasetColumn& operator=(const StructuredDatasetType_DatasetColumn& from) {
    CopyFrom(from);
    return *this;
  }
  inline StructuredDatasetType_DatasetColumn& operator=(StructuredDatasetType_DatasetColumn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StructuredDatasetType_DatasetColumn& default_instance() {
    return *internal_default_instance();
  }
  static inline const StructuredDatasetType_DatasetColumn* internal_default_instance() {
    return reinterpret_cast<const StructuredDatasetType_DatasetColumn*>(
               &_StructuredDatasetType_DatasetColumn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(StructuredDatasetType_DatasetColumn& a, StructuredDatasetType_DatasetColumn& b) {
    a.Swap(&b);
  }
  inline void Swap(StructuredDatasetType_DatasetColumn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StructuredDatasetType_DatasetColumn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StructuredDatasetType_DatasetColumn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StructuredDatasetType_DatasetColumn>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StructuredDatasetType_DatasetColumn* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.core.StructuredDatasetType.DatasetColumn";
  }
  protected:
  explicit StructuredDatasetType_DatasetColumn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kLiteralTypeFieldNumber = 2,
  };
  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .flyteidl.core.LiteralType literal_type = 2 [json_name = "literalType"];
  bool has_literal_type() const;
  private:
  bool _internal_has_literal_type() const;
  public:
  void clear_literal_type();
  const ::flyteidl::core::LiteralType& literal_type() const;
  PROTOBUF_NODISCARD ::flyteidl::core::LiteralType* release_literal_type();
  ::flyteidl::core::LiteralType* mutable_literal_type();
  void set_allocated_literal_type(::flyteidl::core::LiteralType* literal_type);
  private:
  const ::flyteidl::core::LiteralType& _internal_literal_type() const;
  ::flyteidl::core::LiteralType* _internal_mutable_literal_type();
  public:
  void unsafe_arena_set_allocated_literal_type(
      ::flyteidl::core::LiteralType* literal_type);
  ::flyteidl::core::LiteralType* unsafe_arena_release_literal_type();

  // @@protoc_insertion_point(class_scope:flyteidl.core.StructuredDatasetType.DatasetColumn)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::flyteidl::core::LiteralType* literal_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class StructuredDatasetType final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.StructuredDatasetType) */ {
 public:
  inline StructuredDatasetType() : StructuredDatasetType(nullptr) {}
  ~StructuredDatasetType() override;
  explicit constexpr StructuredDatasetType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StructuredDatasetType(const StructuredDatasetType& from);
  StructuredDatasetType(StructuredDatasetType&& from) noexcept
    : StructuredDatasetType() {
    *this = ::std::move(from);
  }

  inline StructuredDatasetType& operator=(const StructuredDatasetType& from) {
    CopyFrom(from);
    return *this;
  }
  inline StructuredDatasetType& operator=(StructuredDatasetType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StructuredDatasetType& default_instance() {
    return *internal_default_instance();
  }
  static inline const StructuredDatasetType* internal_default_instance() {
    return reinterpret_cast<const StructuredDatasetType*>(
               &_StructuredDatasetType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(StructuredDatasetType& a, StructuredDatasetType& b) {
    a.Swap(&b);
  }
  inline void Swap(StructuredDatasetType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StructuredDatasetType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StructuredDatasetType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StructuredDatasetType>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StructuredDatasetType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.core.StructuredDatasetType";
  }
  protected:
  explicit StructuredDatasetType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef StructuredDatasetType_DatasetColumn DatasetColumn;

  // accessors -------------------------------------------------------

  enum : int {
    kColumnsFieldNumber = 1,
    kFormatFieldNumber = 2,
    kExternalSchemaTypeFieldNumber = 3,
    kExternalSchemaBytesFieldNumber = 4,
  };
  // repeated .flyteidl.core.StructuredDatasetType.DatasetColumn columns = 1 [json_name = "columns"];
  int columns_size() const;
  private:
  int _internal_columns_size() const;
  public:
  void clear_columns();
  ::flyteidl::core::StructuredDatasetType_DatasetColumn* mutable_columns(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::core::StructuredDatasetType_DatasetColumn >*
      mutable_columns();
  private:
  const ::flyteidl::core::StructuredDatasetType_DatasetColumn& _internal_columns(int index) const;
  ::flyteidl::core::StructuredDatasetType_DatasetColumn* _internal_add_columns();
  public:
  const ::flyteidl::core::StructuredDatasetType_DatasetColumn& columns(int index) const;
  ::flyteidl::core::StructuredDatasetType_DatasetColumn* add_columns();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::core::StructuredDatasetType_DatasetColumn >&
      columns() const;

  // string format = 2 [json_name = "format"];
  void clear_format();
  const std::string& format() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_format(ArgT0&& arg0, ArgT... args);
  std::string* mutable_format();
  PROTOBUF_NODISCARD std::string* release_format();
  void set_allocated_format(std::string* format);
  private:
  const std::string& _internal_format() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_format(const std::string& value);
  std::string* _internal_mutable_format();
  public:

  // string external_schema_type = 3 [json_name = "externalSchemaType"];
  void clear_external_schema_type();
  const std::string& external_schema_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_external_schema_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_external_schema_type();
  PROTOBUF_NODISCARD std::string* release_external_schema_type();
  void set_allocated_external_schema_type(std::string* external_schema_type);
  private:
  const std::string& _internal_external_schema_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_external_schema_type(const std::string& value);
  std::string* _internal_mutable_external_schema_type();
  public:

  // bytes external_schema_bytes = 4 [json_name = "externalSchemaBytes"];
  void clear_external_schema_bytes();
  const std::string& external_schema_bytes() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_external_schema_bytes(ArgT0&& arg0, ArgT... args);
  std::string* mutable_external_schema_bytes();
  PROTOBUF_NODISCARD std::string* release_external_schema_bytes();
  void set_allocated_external_schema_bytes(std::string* external_schema_bytes);
  private:
  const std::string& _internal_external_schema_bytes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_external_schema_bytes(const std::string& value);
  std::string* _internal_mutable_external_schema_bytes();
  public:

  // @@protoc_insertion_point(class_scope:flyteidl.core.StructuredDatasetType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::core::StructuredDatasetType_DatasetColumn > columns_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr format_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr external_schema_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr external_schema_bytes_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class BlobType final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.BlobType) */ {
 public:
  inline BlobType() : BlobType(nullptr) {}
  ~BlobType() override;
  explicit constexpr BlobType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlobType(const BlobType& from);
  BlobType(BlobType&& from) noexcept
    : BlobType() {
    *this = ::std::move(from);
  }

  inline BlobType& operator=(const BlobType& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlobType& operator=(BlobType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlobType& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlobType* internal_default_instance() {
    return reinterpret_cast<const BlobType*>(
               &_BlobType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(BlobType& a, BlobType& b) {
    a.Swap(&b);
  }
  inline void Swap(BlobType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlobType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlobType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlobType>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlobType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.core.BlobType";
  }
  protected:
  explicit BlobType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef BlobType_BlobDimensionality BlobDimensionality;
  static constexpr BlobDimensionality SINGLE =
    BlobType_BlobDimensionality_SINGLE;
  static constexpr BlobDimensionality MULTIPART =
    BlobType_BlobDimensionality_MULTIPART;
  static inline bool BlobDimensionality_IsValid(int value) {
    return BlobType_BlobDimensionality_IsValid(value);
  }
  static constexpr BlobDimensionality BlobDimensionality_MIN =
    BlobType_BlobDimensionality_BlobDimensionality_MIN;
  static constexpr BlobDimensionality BlobDimensionality_MAX =
    BlobType_BlobDimensionality_BlobDimensionality_MAX;
  static constexpr int BlobDimensionality_ARRAYSIZE =
    BlobType_BlobDimensionality_BlobDimensionality_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  BlobDimensionality_descriptor() {
    return BlobType_BlobDimensionality_descriptor();
  }
  template<typename T>
  static inline const std::string& BlobDimensionality_Name(T enum_t_value) {
    static_assert(::std::is_same<T, BlobDimensionality>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function BlobDimensionality_Name.");
    return BlobType_BlobDimensionality_Name(enum_t_value);
  }
  static inline bool BlobDimensionality_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      BlobDimensionality* value) {
    return BlobType_BlobDimensionality_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kFormatFieldNumber = 1,
    kDimensionalityFieldNumber = 2,
  };
  // string format = 1 [json_name = "format"];
  void clear_format();
  const std::string& format() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_format(ArgT0&& arg0, ArgT... args);
  std::string* mutable_format();
  PROTOBUF_NODISCARD std::string* release_format();
  void set_allocated_format(std::string* format);
  private:
  const std::string& _internal_format() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_format(const std::string& value);
  std::string* _internal_mutable_format();
  public:

  // .flyteidl.core.BlobType.BlobDimensionality dimensionality = 2 [json_name = "dimensionality"];
  void clear_dimensionality();
  ::flyteidl::core::BlobType_BlobDimensionality dimensionality() const;
  void set_dimensionality(::flyteidl::core::BlobType_BlobDimensionality value);
  private:
  ::flyteidl::core::BlobType_BlobDimensionality _internal_dimensionality() const;
  void _internal_set_dimensionality(::flyteidl::core::BlobType_BlobDimensionality value);
  public:

  // @@protoc_insertion_point(class_scope:flyteidl.core.BlobType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr format_;
  int dimensionality_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class EnumType final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.EnumType) */ {
 public:
  inline EnumType() : EnumType(nullptr) {}
  ~EnumType() override;
  explicit constexpr EnumType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EnumType(const EnumType& from);
  EnumType(EnumType&& from) noexcept
    : EnumType() {
    *this = ::std::move(from);
  }

  inline EnumType& operator=(const EnumType& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnumType& operator=(EnumType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EnumType& default_instance() {
    return *internal_default_instance();
  }
  static inline const EnumType* internal_default_instance() {
    return reinterpret_cast<const EnumType*>(
               &_EnumType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(EnumType& a, EnumType& b) {
    a.Swap(&b);
  }
  inline void Swap(EnumType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EnumType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EnumType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EnumType>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EnumType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.core.EnumType";
  }
  protected:
  explicit EnumType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated string values = 1 [json_name = "values"];
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  const std::string& values(int index) const;
  std::string* mutable_values(int index);
  void set_values(int index, const std::string& value);
  void set_values(int index, std::string&& value);
  void set_values(int index, const char* value);
  void set_values(int index, const char* value, size_t size);
  std::string* add_values();
  void add_values(const std::string& value);
  void add_values(std::string&& value);
  void add_values(const char* value);
  void add_values(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_values();
  private:
  const std::string& _internal_values(int index) const;
  std::string* _internal_add_values();
  public:

  // @@protoc_insertion_point(class_scope:flyteidl.core.EnumType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> values_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class UnionType final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.UnionType) */ {
 public:
  inline UnionType() : UnionType(nullptr) {}
  ~UnionType() override;
  explicit constexpr UnionType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnionType(const UnionType& from);
  UnionType(UnionType&& from) noexcept
    : UnionType() {
    *this = ::std::move(from);
  }

  inline UnionType& operator=(const UnionType& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnionType& operator=(UnionType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnionType& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnionType* internal_default_instance() {
    return reinterpret_cast<const UnionType*>(
               &_UnionType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(UnionType& a, UnionType& b) {
    a.Swap(&b);
  }
  inline void Swap(UnionType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnionType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnionType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnionType>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnionType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.core.UnionType";
  }
  protected:
  explicit UnionType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVariantsFieldNumber = 1,
  };
  // repeated .flyteidl.core.LiteralType variants = 1 [json_name = "variants"];
  int variants_size() const;
  private:
  int _internal_variants_size() const;
  public:
  void clear_variants();
  ::flyteidl::core::LiteralType* mutable_variants(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::core::LiteralType >*
      mutable_variants();
  private:
  const ::flyteidl::core::LiteralType& _internal_variants(int index) const;
  ::flyteidl::core::LiteralType* _internal_add_variants();
  public:
  const ::flyteidl::core::LiteralType& variants(int index) const;
  ::flyteidl::core::LiteralType* add_variants();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::core::LiteralType >&
      variants() const;

  // @@protoc_insertion_point(class_scope:flyteidl.core.UnionType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::core::LiteralType > variants_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class TypeStructure final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.TypeStructure) */ {
 public:
  inline TypeStructure() : TypeStructure(nullptr) {}
  ~TypeStructure() override;
  explicit constexpr TypeStructure(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TypeStructure(const TypeStructure& from);
  TypeStructure(TypeStructure&& from) noexcept
    : TypeStructure() {
    *this = ::std::move(from);
  }

  inline TypeStructure& operator=(const TypeStructure& from) {
    CopyFrom(from);
    return *this;
  }
  inline TypeStructure& operator=(TypeStructure&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TypeStructure& default_instance() {
    return *internal_default_instance();
  }
  static inline const TypeStructure* internal_default_instance() {
    return reinterpret_cast<const TypeStructure*>(
               &_TypeStructure_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(TypeStructure& a, TypeStructure& b) {
    a.Swap(&b);
  }
  inline void Swap(TypeStructure* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TypeStructure* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TypeStructure* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TypeStructure>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TypeStructure* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.core.TypeStructure";
  }
  protected:
  explicit TypeStructure(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagFieldNumber = 1,
  };
  // string tag = 1 [json_name = "tag"];
  void clear_tag();
  const std::string& tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tag();
  PROTOBUF_NODISCARD std::string* release_tag();
  void set_allocated_tag(std::string* tag);
  private:
  const std::string& _internal_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tag(const std::string& value);
  std::string* _internal_mutable_tag();
  public:

  // @@protoc_insertion_point(class_scope:flyteidl.core.TypeStructure)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class TypeAnnotation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.TypeAnnotation) */ {
 public:
  inline TypeAnnotation() : TypeAnnotation(nullptr) {}
  ~TypeAnnotation() override;
  explicit constexpr TypeAnnotation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TypeAnnotation(const TypeAnnotation& from);
  TypeAnnotation(TypeAnnotation&& from) noexcept
    : TypeAnnotation() {
    *this = ::std::move(from);
  }

  inline TypeAnnotation& operator=(const TypeAnnotation& from) {
    CopyFrom(from);
    return *this;
  }
  inline TypeAnnotation& operator=(TypeAnnotation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TypeAnnotation& default_instance() {
    return *internal_default_instance();
  }
  static inline const TypeAnnotation* internal_default_instance() {
    return reinterpret_cast<const TypeAnnotation*>(
               &_TypeAnnotation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(TypeAnnotation& a, TypeAnnotation& b) {
    a.Swap(&b);
  }
  inline void Swap(TypeAnnotation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TypeAnnotation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TypeAnnotation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TypeAnnotation>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TypeAnnotation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.core.TypeAnnotation";
  }
  protected:
  explicit TypeAnnotation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAnnotationsFieldNumber = 1,
  };
  // .google.protobuf.Struct annotations = 1 [json_name = "annotations"];
  bool has_annotations() const;
  private:
  bool _internal_has_annotations() const;
  public:
  void clear_annotations();
  const ::PROTOBUF_NAMESPACE_ID::Struct& annotations() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_annotations();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_annotations();
  void set_allocated_annotations(::PROTOBUF_NAMESPACE_ID::Struct* annotations);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_annotations() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_annotations();
  public:
  void unsafe_arena_set_allocated_annotations(
      ::PROTOBUF_NAMESPACE_ID::Struct* annotations);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_annotations();

  // @@protoc_insertion_point(class_scope:flyteidl.core.TypeAnnotation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::Struct* annotations_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class LiteralType final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.LiteralType) */ {
 public:
  inline LiteralType() : LiteralType(nullptr) {}
  ~LiteralType() override;
  explicit constexpr LiteralType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LiteralType(const LiteralType& from);
  LiteralType(LiteralType&& from) noexcept
    : LiteralType() {
    *this = ::std::move(from);
  }

  inline LiteralType& operator=(const LiteralType& from) {
    CopyFrom(from);
    return *this;
  }
  inline LiteralType& operator=(LiteralType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LiteralType& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kSimple = 1,
    kSchema = 2,
    kCollectionType = 3,
    kMapValueType = 4,
    kBlob = 5,
    kEnumType = 7,
    kStructuredDatasetType = 8,
    kUnionType = 10,
    TYPE_NOT_SET = 0,
  };

  static inline const LiteralType* internal_default_instance() {
    return reinterpret_cast<const LiteralType*>(
               &_LiteralType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(LiteralType& a, LiteralType& b) {
    a.Swap(&b);
  }
  inline void Swap(LiteralType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LiteralType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LiteralType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LiteralType>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LiteralType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.core.LiteralType";
  }
  protected:
  explicit LiteralType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 6,
    kAnnotationFieldNumber = 9,
    kStructureFieldNumber = 11,
    kSimpleFieldNumber = 1,
    kSchemaFieldNumber = 2,
    kCollectionTypeFieldNumber = 3,
    kMapValueTypeFieldNumber = 4,
    kBlobFieldNumber = 5,
    kEnumTypeFieldNumber = 7,
    kStructuredDatasetTypeFieldNumber = 8,
    kUnionTypeFieldNumber = 10,
  };
  // .google.protobuf.Struct metadata = 6 [json_name = "metadata"];
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::PROTOBUF_NAMESPACE_ID::Struct& metadata() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_metadata();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_metadata();
  void set_allocated_metadata(::PROTOBUF_NAMESPACE_ID::Struct* metadata);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::PROTOBUF_NAMESPACE_ID::Struct* metadata);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_metadata();

  // .flyteidl.core.TypeAnnotation annotation = 9 [json_name = "annotation"];
  bool has_annotation() const;
  private:
  bool _internal_has_annotation() const;
  public:
  void clear_annotation();
  const ::flyteidl::core::TypeAnnotation& annotation() const;
  PROTOBUF_NODISCARD ::flyteidl::core::TypeAnnotation* release_annotation();
  ::flyteidl::core::TypeAnnotation* mutable_annotation();
  void set_allocated_annotation(::flyteidl::core::TypeAnnotation* annotation);
  private:
  const ::flyteidl::core::TypeAnnotation& _internal_annotation() const;
  ::flyteidl::core::TypeAnnotation* _internal_mutable_annotation();
  public:
  void unsafe_arena_set_allocated_annotation(
      ::flyteidl::core::TypeAnnotation* annotation);
  ::flyteidl::core::TypeAnnotation* unsafe_arena_release_annotation();

  // .flyteidl.core.TypeStructure structure = 11 [json_name = "structure"];
  bool has_structure() const;
  private:
  bool _internal_has_structure() const;
  public:
  void clear_structure();
  const ::flyteidl::core::TypeStructure& structure() const;
  PROTOBUF_NODISCARD ::flyteidl::core::TypeStructure* release_structure();
  ::flyteidl::core::TypeStructure* mutable_structure();
  void set_allocated_structure(::flyteidl::core::TypeStructure* structure);
  private:
  const ::flyteidl::core::TypeStructure& _internal_structure() const;
  ::flyteidl::core::TypeStructure* _internal_mutable_structure();
  public:
  void unsafe_arena_set_allocated_structure(
      ::flyteidl::core::TypeStructure* structure);
  ::flyteidl::core::TypeStructure* unsafe_arena_release_structure();

  // .flyteidl.core.SimpleType simple = 1 [json_name = "simple"];
  bool has_simple() const;
  private:
  bool _internal_has_simple() const;
  public:
  void clear_simple();
  ::flyteidl::core::SimpleType simple() const;
  void set_simple(::flyteidl::core::SimpleType value);
  private:
  ::flyteidl::core::SimpleType _internal_simple() const;
  void _internal_set_simple(::flyteidl::core::SimpleType value);
  public:

  // .flyteidl.core.SchemaType schema = 2 [json_name = "schema"];
  bool has_schema() const;
  private:
  bool _internal_has_schema() const;
  public:
  void clear_schema();
  const ::flyteidl::core::SchemaType& schema() const;
  PROTOBUF_NODISCARD ::flyteidl::core::SchemaType* release_schema();
  ::flyteidl::core::SchemaType* mutable_schema();
  void set_allocated_schema(::flyteidl::core::SchemaType* schema);
  private:
  const ::flyteidl::core::SchemaType& _internal_schema() const;
  ::flyteidl::core::SchemaType* _internal_mutable_schema();
  public:
  void unsafe_arena_set_allocated_schema(
      ::flyteidl::core::SchemaType* schema);
  ::flyteidl::core::SchemaType* unsafe_arena_release_schema();

  // .flyteidl.core.LiteralType collection_type = 3 [json_name = "collectionType"];
  bool has_collection_type() const;
  private:
  bool _internal_has_collection_type() const;
  public:
  void clear_collection_type();
  const ::flyteidl::core::LiteralType& collection_type() const;
  PROTOBUF_NODISCARD ::flyteidl::core::LiteralType* release_collection_type();
  ::flyteidl::core::LiteralType* mutable_collection_type();
  void set_allocated_collection_type(::flyteidl::core::LiteralType* collection_type);
  private:
  const ::flyteidl::core::LiteralType& _internal_collection_type() const;
  ::flyteidl::core::LiteralType* _internal_mutable_collection_type();
  public:
  void unsafe_arena_set_allocated_collection_type(
      ::flyteidl::core::LiteralType* collection_type);
  ::flyteidl::core::LiteralType* unsafe_arena_release_collection_type();

  // .flyteidl.core.LiteralType map_value_type = 4 [json_name = "mapValueType"];
  bool has_map_value_type() const;
  private:
  bool _internal_has_map_value_type() const;
  public:
  void clear_map_value_type();
  const ::flyteidl::core::LiteralType& map_value_type() const;
  PROTOBUF_NODISCARD ::flyteidl::core::LiteralType* release_map_value_type();
  ::flyteidl::core::LiteralType* mutable_map_value_type();
  void set_allocated_map_value_type(::flyteidl::core::LiteralType* map_value_type);
  private:
  const ::flyteidl::core::LiteralType& _internal_map_value_type() const;
  ::flyteidl::core::LiteralType* _internal_mutable_map_value_type();
  public:
  void unsafe_arena_set_allocated_map_value_type(
      ::flyteidl::core::LiteralType* map_value_type);
  ::flyteidl::core::LiteralType* unsafe_arena_release_map_value_type();

  // .flyteidl.core.BlobType blob = 5 [json_name = "blob"];
  bool has_blob() const;
  private:
  bool _internal_has_blob() const;
  public:
  void clear_blob();
  const ::flyteidl::core::BlobType& blob() const;
  PROTOBUF_NODISCARD ::flyteidl::core::BlobType* release_blob();
  ::flyteidl::core::BlobType* mutable_blob();
  void set_allocated_blob(::flyteidl::core::BlobType* blob);
  private:
  const ::flyteidl::core::BlobType& _internal_blob() const;
  ::flyteidl::core::BlobType* _internal_mutable_blob();
  public:
  void unsafe_arena_set_allocated_blob(
      ::flyteidl::core::BlobType* blob);
  ::flyteidl::core::BlobType* unsafe_arena_release_blob();

  // .flyteidl.core.EnumType enum_type = 7 [json_name = "enumType"];
  bool has_enum_type() const;
  private:
  bool _internal_has_enum_type() const;
  public:
  void clear_enum_type();
  const ::flyteidl::core::EnumType& enum_type() const;
  PROTOBUF_NODISCARD ::flyteidl::core::EnumType* release_enum_type();
  ::flyteidl::core::EnumType* mutable_enum_type();
  void set_allocated_enum_type(::flyteidl::core::EnumType* enum_type);
  private:
  const ::flyteidl::core::EnumType& _internal_enum_type() const;
  ::flyteidl::core::EnumType* _internal_mutable_enum_type();
  public:
  void unsafe_arena_set_allocated_enum_type(
      ::flyteidl::core::EnumType* enum_type);
  ::flyteidl::core::EnumType* unsafe_arena_release_enum_type();

  // .flyteidl.core.StructuredDatasetType structured_dataset_type = 8 [json_name = "structuredDatasetType"];
  bool has_structured_dataset_type() const;
  private:
  bool _internal_has_structured_dataset_type() const;
  public:
  void clear_structured_dataset_type();
  const ::flyteidl::core::StructuredDatasetType& structured_dataset_type() const;
  PROTOBUF_NODISCARD ::flyteidl::core::StructuredDatasetType* release_structured_dataset_type();
  ::flyteidl::core::StructuredDatasetType* mutable_structured_dataset_type();
  void set_allocated_structured_dataset_type(::flyteidl::core::StructuredDatasetType* structured_dataset_type);
  private:
  const ::flyteidl::core::StructuredDatasetType& _internal_structured_dataset_type() const;
  ::flyteidl::core::StructuredDatasetType* _internal_mutable_structured_dataset_type();
  public:
  void unsafe_arena_set_allocated_structured_dataset_type(
      ::flyteidl::core::StructuredDatasetType* structured_dataset_type);
  ::flyteidl::core::StructuredDatasetType* unsafe_arena_release_structured_dataset_type();

  // .flyteidl.core.UnionType union_type = 10 [json_name = "unionType"];
  bool has_union_type() const;
  private:
  bool _internal_has_union_type() const;
  public:
  void clear_union_type();
  const ::flyteidl::core::UnionType& union_type() const;
  PROTOBUF_NODISCARD ::flyteidl::core::UnionType* release_union_type();
  ::flyteidl::core::UnionType* mutable_union_type();
  void set_allocated_union_type(::flyteidl::core::UnionType* union_type);
  private:
  const ::flyteidl::core::UnionType& _internal_union_type() const;
  ::flyteidl::core::UnionType* _internal_mutable_union_type();
  public:
  void unsafe_arena_set_allocated_union_type(
      ::flyteidl::core::UnionType* union_type);
  ::flyteidl::core::UnionType* unsafe_arena_release_union_type();

  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:flyteidl.core.LiteralType)
 private:
  class _Internal;
  void set_has_simple();
  void set_has_schema();
  void set_has_collection_type();
  void set_has_map_value_type();
  void set_has_blob();
  void set_has_enum_type();
  void set_has_structured_dataset_type();
  void set_has_union_type();

  inline bool has_type() const;
  inline void clear_has_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::Struct* metadata_;
  ::flyteidl::core::TypeAnnotation* annotation_;
  ::flyteidl::core::TypeStructure* structure_;
  union TypeUnion {
    constexpr TypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    int simple_;
    ::flyteidl::core::SchemaType* schema_;
    ::flyteidl::core::LiteralType* collection_type_;
    ::flyteidl::core::LiteralType* map_value_type_;
    ::flyteidl::core::BlobType* blob_;
    ::flyteidl::core::EnumType* enum_type_;
    ::flyteidl::core::StructuredDatasetType* structured_dataset_type_;
    ::flyteidl::core::UnionType* union_type_;
  } type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_flyteidl_2fcore_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class OutputReference final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.OutputReference) */ {
 public:
  inline OutputReference() : OutputReference(nullptr) {}
  ~OutputReference() override;
  explicit constexpr OutputReference(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OutputReference(const OutputReference& from);
  OutputReference(OutputReference&& from) noexcept
    : OutputReference() {
    *this = ::std::move(from);
  }

  inline OutputReference& operator=(const OutputReference& from) {
    CopyFrom(from);
    return *this;
  }
  inline OutputReference& operator=(OutputReference&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OutputReference& default_instance() {
    return *internal_default_instance();
  }
  static inline const OutputReference* internal_default_instance() {
    return reinterpret_cast<const OutputReference*>(
               &_OutputReference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(OutputReference& a, OutputReference& b) {
    a.Swap(&b);
  }
  inline void Swap(OutputReference* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OutputReference* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OutputReference* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OutputReference>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OutputReference* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.core.OutputReference";
  }
  protected:
  explicit OutputReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeIdFieldNumber = 1,
    kVarFieldNumber = 2,
  };
  // string node_id = 1 [json_name = "nodeId"];
  void clear_node_id();
  const std::string& node_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_node_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_node_id();
  PROTOBUF_NODISCARD std::string* release_node_id();
  void set_allocated_node_id(std::string* node_id);
  private:
  const std::string& _internal_node_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_id(const std::string& value);
  std::string* _internal_mutable_node_id();
  public:

  // string var = 2 [json_name = "var"];
  void clear_var();
  const std::string& var() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_var(ArgT0&& arg0, ArgT... args);
  std::string* mutable_var();
  PROTOBUF_NODISCARD std::string* release_var();
  void set_allocated_var(std::string* var);
  private:
  const std::string& _internal_var() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_var(const std::string& value);
  std::string* _internal_mutable_var();
  public:

  // @@protoc_insertion_point(class_scope:flyteidl.core.OutputReference)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr var_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class Error final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.Error) */ {
 public:
  inline Error() : Error(nullptr) {}
  ~Error() override;
  explicit constexpr Error(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Error(const Error& from);
  Error(Error&& from) noexcept
    : Error() {
    *this = ::std::move(from);
  }

  inline Error& operator=(const Error& from) {
    CopyFrom(from);
    return *this;
  }
  inline Error& operator=(Error&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Error& default_instance() {
    return *internal_default_instance();
  }
  static inline const Error* internal_default_instance() {
    return reinterpret_cast<const Error*>(
               &_Error_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Error& a, Error& b) {
    a.Swap(&b);
  }
  inline void Swap(Error* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Error* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Error* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Error>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Error* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.core.Error";
  }
  protected:
  explicit Error(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFailedNodeIdFieldNumber = 1,
    kMessageFieldNumber = 2,
  };
  // string failed_node_id = 1 [json_name = "failedNodeId"];
  void clear_failed_node_id();
  const std::string& failed_node_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_failed_node_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_failed_node_id();
  PROTOBUF_NODISCARD std::string* release_failed_node_id();
  void set_allocated_failed_node_id(std::string* failed_node_id);
  private:
  const std::string& _internal_failed_node_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_failed_node_id(const std::string& value);
  std::string* _internal_mutable_failed_node_id();
  public:

  // string message = 2 [json_name = "message"];
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:flyteidl.core.Error)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr failed_node_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2ftypes_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SchemaType_SchemaColumn

// string name = 1 [json_name = "name"];
inline void SchemaType_SchemaColumn::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& SchemaType_SchemaColumn::name() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.SchemaType.SchemaColumn.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SchemaType_SchemaColumn::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.core.SchemaType.SchemaColumn.name)
}
inline std::string* SchemaType_SchemaColumn::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.SchemaType.SchemaColumn.name)
  return _s;
}
inline const std::string& SchemaType_SchemaColumn::_internal_name() const {
  return name_.Get();
}
inline void SchemaType_SchemaColumn::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SchemaType_SchemaColumn::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SchemaType_SchemaColumn::release_name() {
  // @@protoc_insertion_point(field_release:flyteidl.core.SchemaType.SchemaColumn.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SchemaType_SchemaColumn::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.SchemaType.SchemaColumn.name)
}

// .flyteidl.core.SchemaType.SchemaColumn.SchemaColumnType type = 2 [json_name = "type"];
inline void SchemaType_SchemaColumn::clear_type() {
  type_ = 0;
}
inline ::flyteidl::core::SchemaType_SchemaColumn_SchemaColumnType SchemaType_SchemaColumn::_internal_type() const {
  return static_cast< ::flyteidl::core::SchemaType_SchemaColumn_SchemaColumnType >(type_);
}
inline ::flyteidl::core::SchemaType_SchemaColumn_SchemaColumnType SchemaType_SchemaColumn::type() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.SchemaType.SchemaColumn.type)
  return _internal_type();
}
inline void SchemaType_SchemaColumn::_internal_set_type(::flyteidl::core::SchemaType_SchemaColumn_SchemaColumnType value) {
  
  type_ = value;
}
inline void SchemaType_SchemaColumn::set_type(::flyteidl::core::SchemaType_SchemaColumn_SchemaColumnType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:flyteidl.core.SchemaType.SchemaColumn.type)
}

// -------------------------------------------------------------------

// SchemaType

// repeated .flyteidl.core.SchemaType.SchemaColumn columns = 3 [json_name = "columns"];
inline int SchemaType::_internal_columns_size() const {
  return columns_.size();
}
inline int SchemaType::columns_size() const {
  return _internal_columns_size();
}
inline void SchemaType::clear_columns() {
  columns_.Clear();
}
inline ::flyteidl::core::SchemaType_SchemaColumn* SchemaType::mutable_columns(int index) {
  // @@protoc_insertion_point(field_mutable:flyteidl.core.SchemaType.columns)
  return columns_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::core::SchemaType_SchemaColumn >*
SchemaType::mutable_columns() {
  // @@protoc_insertion_point(field_mutable_list:flyteidl.core.SchemaType.columns)
  return &columns_;
}
inline const ::flyteidl::core::SchemaType_SchemaColumn& SchemaType::_internal_columns(int index) const {
  return columns_.Get(index);
}
inline const ::flyteidl::core::SchemaType_SchemaColumn& SchemaType::columns(int index) const {
  // @@protoc_insertion_point(field_get:flyteidl.core.SchemaType.columns)
  return _internal_columns(index);
}
inline ::flyteidl::core::SchemaType_SchemaColumn* SchemaType::_internal_add_columns() {
  return columns_.Add();
}
inline ::flyteidl::core::SchemaType_SchemaColumn* SchemaType::add_columns() {
  ::flyteidl::core::SchemaType_SchemaColumn* _add = _internal_add_columns();
  // @@protoc_insertion_point(field_add:flyteidl.core.SchemaType.columns)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::core::SchemaType_SchemaColumn >&
SchemaType::columns() const {
  // @@protoc_insertion_point(field_list:flyteidl.core.SchemaType.columns)
  return columns_;
}

// -------------------------------------------------------------------

// StructuredDatasetType_DatasetColumn

// string name = 1 [json_name = "name"];
inline void StructuredDatasetType_DatasetColumn::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& StructuredDatasetType_DatasetColumn::name() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.StructuredDatasetType.DatasetColumn.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StructuredDatasetType_DatasetColumn::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.core.StructuredDatasetType.DatasetColumn.name)
}
inline std::string* StructuredDatasetType_DatasetColumn::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.StructuredDatasetType.DatasetColumn.name)
  return _s;
}
inline const std::string& StructuredDatasetType_DatasetColumn::_internal_name() const {
  return name_.Get();
}
inline void StructuredDatasetType_DatasetColumn::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StructuredDatasetType_DatasetColumn::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StructuredDatasetType_DatasetColumn::release_name() {
  // @@protoc_insertion_point(field_release:flyteidl.core.StructuredDatasetType.DatasetColumn.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void StructuredDatasetType_DatasetColumn::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.StructuredDatasetType.DatasetColumn.name)
}

// .flyteidl.core.LiteralType literal_type = 2 [json_name = "literalType"];
inline bool StructuredDatasetType_DatasetColumn::_internal_has_literal_type() const {
  return this != internal_default_instance() && literal_type_ != nullptr;
}
inline bool StructuredDatasetType_DatasetColumn::has_literal_type() const {
  return _internal_has_literal_type();
}
inline void StructuredDatasetType_DatasetColumn::clear_literal_type() {
  if (GetArenaForAllocation() == nullptr && literal_type_ != nullptr) {
    delete literal_type_;
  }
  literal_type_ = nullptr;
}
inline const ::flyteidl::core::LiteralType& StructuredDatasetType_DatasetColumn::_internal_literal_type() const {
  const ::flyteidl::core::LiteralType* p = literal_type_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::core::LiteralType&>(
      ::flyteidl::core::_LiteralType_default_instance_);
}
inline const ::flyteidl::core::LiteralType& StructuredDatasetType_DatasetColumn::literal_type() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.StructuredDatasetType.DatasetColumn.literal_type)
  return _internal_literal_type();
}
inline void StructuredDatasetType_DatasetColumn::unsafe_arena_set_allocated_literal_type(
    ::flyteidl::core::LiteralType* literal_type) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(literal_type_);
  }
  literal_type_ = literal_type;
  if (literal_type) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.core.StructuredDatasetType.DatasetColumn.literal_type)
}
inline ::flyteidl::core::LiteralType* StructuredDatasetType_DatasetColumn::release_literal_type() {
  
  ::flyteidl::core::LiteralType* temp = literal_type_;
  literal_type_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::core::LiteralType* StructuredDatasetType_DatasetColumn::unsafe_arena_release_literal_type() {
  // @@protoc_insertion_point(field_release:flyteidl.core.StructuredDatasetType.DatasetColumn.literal_type)
  
  ::flyteidl::core::LiteralType* temp = literal_type_;
  literal_type_ = nullptr;
  return temp;
}
inline ::flyteidl::core::LiteralType* StructuredDatasetType_DatasetColumn::_internal_mutable_literal_type() {
  
  if (literal_type_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::LiteralType>(GetArenaForAllocation());
    literal_type_ = p;
  }
  return literal_type_;
}
inline ::flyteidl::core::LiteralType* StructuredDatasetType_DatasetColumn::mutable_literal_type() {
  ::flyteidl::core::LiteralType* _msg = _internal_mutable_literal_type();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.StructuredDatasetType.DatasetColumn.literal_type)
  return _msg;
}
inline void StructuredDatasetType_DatasetColumn::set_allocated_literal_type(::flyteidl::core::LiteralType* literal_type) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete literal_type_;
  }
  if (literal_type) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::flyteidl::core::LiteralType>::GetOwningArena(literal_type);
    if (message_arena != submessage_arena) {
      literal_type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, literal_type, submessage_arena);
    }
    
  } else {
    
  }
  literal_type_ = literal_type;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.StructuredDatasetType.DatasetColumn.literal_type)
}

// -------------------------------------------------------------------

// StructuredDatasetType

// repeated .flyteidl.core.StructuredDatasetType.DatasetColumn columns = 1 [json_name = "columns"];
inline int StructuredDatasetType::_internal_columns_size() const {
  return columns_.size();
}
inline int StructuredDatasetType::columns_size() const {
  return _internal_columns_size();
}
inline void StructuredDatasetType::clear_columns() {
  columns_.Clear();
}
inline ::flyteidl::core::StructuredDatasetType_DatasetColumn* StructuredDatasetType::mutable_columns(int index) {
  // @@protoc_insertion_point(field_mutable:flyteidl.core.StructuredDatasetType.columns)
  return columns_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::core::StructuredDatasetType_DatasetColumn >*
StructuredDatasetType::mutable_columns() {
  // @@protoc_insertion_point(field_mutable_list:flyteidl.core.StructuredDatasetType.columns)
  return &columns_;
}
inline const ::flyteidl::core::StructuredDatasetType_DatasetColumn& StructuredDatasetType::_internal_columns(int index) const {
  return columns_.Get(index);
}
inline const ::flyteidl::core::StructuredDatasetType_DatasetColumn& StructuredDatasetType::columns(int index) const {
  // @@protoc_insertion_point(field_get:flyteidl.core.StructuredDatasetType.columns)
  return _internal_columns(index);
}
inline ::flyteidl::core::StructuredDatasetType_DatasetColumn* StructuredDatasetType::_internal_add_columns() {
  return columns_.Add();
}
inline ::flyteidl::core::StructuredDatasetType_DatasetColumn* StructuredDatasetType::add_columns() {
  ::flyteidl::core::StructuredDatasetType_DatasetColumn* _add = _internal_add_columns();
  // @@protoc_insertion_point(field_add:flyteidl.core.StructuredDatasetType.columns)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::core::StructuredDatasetType_DatasetColumn >&
StructuredDatasetType::columns() const {
  // @@protoc_insertion_point(field_list:flyteidl.core.StructuredDatasetType.columns)
  return columns_;
}

// string format = 2 [json_name = "format"];
inline void StructuredDatasetType::clear_format() {
  format_.ClearToEmpty();
}
inline const std::string& StructuredDatasetType::format() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.StructuredDatasetType.format)
  return _internal_format();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StructuredDatasetType::set_format(ArgT0&& arg0, ArgT... args) {
 
 format_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.core.StructuredDatasetType.format)
}
inline std::string* StructuredDatasetType::mutable_format() {
  std::string* _s = _internal_mutable_format();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.StructuredDatasetType.format)
  return _s;
}
inline const std::string& StructuredDatasetType::_internal_format() const {
  return format_.Get();
}
inline void StructuredDatasetType::_internal_set_format(const std::string& value) {
  
  format_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StructuredDatasetType::_internal_mutable_format() {
  
  return format_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StructuredDatasetType::release_format() {
  // @@protoc_insertion_point(field_release:flyteidl.core.StructuredDatasetType.format)
  return format_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void StructuredDatasetType::set_allocated_format(std::string* format) {
  if (format != nullptr) {
    
  } else {
    
  }
  format_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), format,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (format_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    format_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.StructuredDatasetType.format)
}

// string external_schema_type = 3 [json_name = "externalSchemaType"];
inline void StructuredDatasetType::clear_external_schema_type() {
  external_schema_type_.ClearToEmpty();
}
inline const std::string& StructuredDatasetType::external_schema_type() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.StructuredDatasetType.external_schema_type)
  return _internal_external_schema_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StructuredDatasetType::set_external_schema_type(ArgT0&& arg0, ArgT... args) {
 
 external_schema_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.core.StructuredDatasetType.external_schema_type)
}
inline std::string* StructuredDatasetType::mutable_external_schema_type() {
  std::string* _s = _internal_mutable_external_schema_type();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.StructuredDatasetType.external_schema_type)
  return _s;
}
inline const std::string& StructuredDatasetType::_internal_external_schema_type() const {
  return external_schema_type_.Get();
}
inline void StructuredDatasetType::_internal_set_external_schema_type(const std::string& value) {
  
  external_schema_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StructuredDatasetType::_internal_mutable_external_schema_type() {
  
  return external_schema_type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StructuredDatasetType::release_external_schema_type() {
  // @@protoc_insertion_point(field_release:flyteidl.core.StructuredDatasetType.external_schema_type)
  return external_schema_type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void StructuredDatasetType::set_allocated_external_schema_type(std::string* external_schema_type) {
  if (external_schema_type != nullptr) {
    
  } else {
    
  }
  external_schema_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), external_schema_type,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (external_schema_type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    external_schema_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.StructuredDatasetType.external_schema_type)
}

// bytes external_schema_bytes = 4 [json_name = "externalSchemaBytes"];
inline void StructuredDatasetType::clear_external_schema_bytes() {
  external_schema_bytes_.ClearToEmpty();
}
inline const std::string& StructuredDatasetType::external_schema_bytes() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.StructuredDatasetType.external_schema_bytes)
  return _internal_external_schema_bytes();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StructuredDatasetType::set_external_schema_bytes(ArgT0&& arg0, ArgT... args) {
 
 external_schema_bytes_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.core.StructuredDatasetType.external_schema_bytes)
}
inline std::string* StructuredDatasetType::mutable_external_schema_bytes() {
  std::string* _s = _internal_mutable_external_schema_bytes();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.StructuredDatasetType.external_schema_bytes)
  return _s;
}
inline const std::string& StructuredDatasetType::_internal_external_schema_bytes() const {
  return external_schema_bytes_.Get();
}
inline void StructuredDatasetType::_internal_set_external_schema_bytes(const std::string& value) {
  
  external_schema_bytes_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StructuredDatasetType::_internal_mutable_external_schema_bytes() {
  
  return external_schema_bytes_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StructuredDatasetType::release_external_schema_bytes() {
  // @@protoc_insertion_point(field_release:flyteidl.core.StructuredDatasetType.external_schema_bytes)
  return external_schema_bytes_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void StructuredDatasetType::set_allocated_external_schema_bytes(std::string* external_schema_bytes) {
  if (external_schema_bytes != nullptr) {
    
  } else {
    
  }
  external_schema_bytes_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), external_schema_bytes,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (external_schema_bytes_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    external_schema_bytes_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.StructuredDatasetType.external_schema_bytes)
}

// -------------------------------------------------------------------

// BlobType

// string format = 1 [json_name = "format"];
inline void BlobType::clear_format() {
  format_.ClearToEmpty();
}
inline const std::string& BlobType::format() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.BlobType.format)
  return _internal_format();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BlobType::set_format(ArgT0&& arg0, ArgT... args) {
 
 format_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.core.BlobType.format)
}
inline std::string* BlobType::mutable_format() {
  std::string* _s = _internal_mutable_format();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.BlobType.format)
  return _s;
}
inline const std::string& BlobType::_internal_format() const {
  return format_.Get();
}
inline void BlobType::_internal_set_format(const std::string& value) {
  
  format_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BlobType::_internal_mutable_format() {
  
  return format_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BlobType::release_format() {
  // @@protoc_insertion_point(field_release:flyteidl.core.BlobType.format)
  return format_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BlobType::set_allocated_format(std::string* format) {
  if (format != nullptr) {
    
  } else {
    
  }
  format_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), format,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (format_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    format_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.BlobType.format)
}

// .flyteidl.core.BlobType.BlobDimensionality dimensionality = 2 [json_name = "dimensionality"];
inline void BlobType::clear_dimensionality() {
  dimensionality_ = 0;
}
inline ::flyteidl::core::BlobType_BlobDimensionality BlobType::_internal_dimensionality() const {
  return static_cast< ::flyteidl::core::BlobType_BlobDimensionality >(dimensionality_);
}
inline ::flyteidl::core::BlobType_BlobDimensionality BlobType::dimensionality() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.BlobType.dimensionality)
  return _internal_dimensionality();
}
inline void BlobType::_internal_set_dimensionality(::flyteidl::core::BlobType_BlobDimensionality value) {
  
  dimensionality_ = value;
}
inline void BlobType::set_dimensionality(::flyteidl::core::BlobType_BlobDimensionality value) {
  _internal_set_dimensionality(value);
  // @@protoc_insertion_point(field_set:flyteidl.core.BlobType.dimensionality)
}

// -------------------------------------------------------------------

// EnumType

// repeated string values = 1 [json_name = "values"];
inline int EnumType::_internal_values_size() const {
  return values_.size();
}
inline int EnumType::values_size() const {
  return _internal_values_size();
}
inline void EnumType::clear_values() {
  values_.Clear();
}
inline std::string* EnumType::add_values() {
  std::string* _s = _internal_add_values();
  // @@protoc_insertion_point(field_add_mutable:flyteidl.core.EnumType.values)
  return _s;
}
inline const std::string& EnumType::_internal_values(int index) const {
  return values_.Get(index);
}
inline const std::string& EnumType::values(int index) const {
  // @@protoc_insertion_point(field_get:flyteidl.core.EnumType.values)
  return _internal_values(index);
}
inline std::string* EnumType::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:flyteidl.core.EnumType.values)
  return values_.Mutable(index);
}
inline void EnumType::set_values(int index, const std::string& value) {
  values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:flyteidl.core.EnumType.values)
}
inline void EnumType::set_values(int index, std::string&& value) {
  values_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:flyteidl.core.EnumType.values)
}
inline void EnumType::set_values(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:flyteidl.core.EnumType.values)
}
inline void EnumType::set_values(int index, const char* value, size_t size) {
  values_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.EnumType.values)
}
inline std::string* EnumType::_internal_add_values() {
  return values_.Add();
}
inline void EnumType::add_values(const std::string& value) {
  values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:flyteidl.core.EnumType.values)
}
inline void EnumType::add_values(std::string&& value) {
  values_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:flyteidl.core.EnumType.values)
}
inline void EnumType::add_values(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:flyteidl.core.EnumType.values)
}
inline void EnumType::add_values(const char* value, size_t size) {
  values_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:flyteidl.core.EnumType.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
EnumType::values() const {
  // @@protoc_insertion_point(field_list:flyteidl.core.EnumType.values)
  return values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
EnumType::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:flyteidl.core.EnumType.values)
  return &values_;
}

// -------------------------------------------------------------------

// UnionType

// repeated .flyteidl.core.LiteralType variants = 1 [json_name = "variants"];
inline int UnionType::_internal_variants_size() const {
  return variants_.size();
}
inline int UnionType::variants_size() const {
  return _internal_variants_size();
}
inline void UnionType::clear_variants() {
  variants_.Clear();
}
inline ::flyteidl::core::LiteralType* UnionType::mutable_variants(int index) {
  // @@protoc_insertion_point(field_mutable:flyteidl.core.UnionType.variants)
  return variants_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::core::LiteralType >*
UnionType::mutable_variants() {
  // @@protoc_insertion_point(field_mutable_list:flyteidl.core.UnionType.variants)
  return &variants_;
}
inline const ::flyteidl::core::LiteralType& UnionType::_internal_variants(int index) const {
  return variants_.Get(index);
}
inline const ::flyteidl::core::LiteralType& UnionType::variants(int index) const {
  // @@protoc_insertion_point(field_get:flyteidl.core.UnionType.variants)
  return _internal_variants(index);
}
inline ::flyteidl::core::LiteralType* UnionType::_internal_add_variants() {
  return variants_.Add();
}
inline ::flyteidl::core::LiteralType* UnionType::add_variants() {
  ::flyteidl::core::LiteralType* _add = _internal_add_variants();
  // @@protoc_insertion_point(field_add:flyteidl.core.UnionType.variants)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::core::LiteralType >&
UnionType::variants() const {
  // @@protoc_insertion_point(field_list:flyteidl.core.UnionType.variants)
  return variants_;
}

// -------------------------------------------------------------------

// TypeStructure

// string tag = 1 [json_name = "tag"];
inline void TypeStructure::clear_tag() {
  tag_.ClearToEmpty();
}
inline const std::string& TypeStructure::tag() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.TypeStructure.tag)
  return _internal_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TypeStructure::set_tag(ArgT0&& arg0, ArgT... args) {
 
 tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.core.TypeStructure.tag)
}
inline std::string* TypeStructure::mutable_tag() {
  std::string* _s = _internal_mutable_tag();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.TypeStructure.tag)
  return _s;
}
inline const std::string& TypeStructure::_internal_tag() const {
  return tag_.Get();
}
inline void TypeStructure::_internal_set_tag(const std::string& value) {
  
  tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TypeStructure::_internal_mutable_tag() {
  
  return tag_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TypeStructure::release_tag() {
  // @@protoc_insertion_point(field_release:flyteidl.core.TypeStructure.tag)
  return tag_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TypeStructure::set_allocated_tag(std::string* tag) {
  if (tag != nullptr) {
    
  } else {
    
  }
  tag_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tag,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tag_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.TypeStructure.tag)
}

// -------------------------------------------------------------------

// TypeAnnotation

// .google.protobuf.Struct annotations = 1 [json_name = "annotations"];
inline bool TypeAnnotation::_internal_has_annotations() const {
  return this != internal_default_instance() && annotations_ != nullptr;
}
inline bool TypeAnnotation::has_annotations() const {
  return _internal_has_annotations();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& TypeAnnotation::_internal_annotations() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = annotations_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& TypeAnnotation::annotations() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.TypeAnnotation.annotations)
  return _internal_annotations();
}
inline void TypeAnnotation::unsafe_arena_set_allocated_annotations(
    ::PROTOBUF_NAMESPACE_ID::Struct* annotations) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(annotations_);
  }
  annotations_ = annotations;
  if (annotations) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.core.TypeAnnotation.annotations)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* TypeAnnotation::release_annotations() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = annotations_;
  annotations_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* TypeAnnotation::unsafe_arena_release_annotations() {
  // @@protoc_insertion_point(field_release:flyteidl.core.TypeAnnotation.annotations)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = annotations_;
  annotations_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* TypeAnnotation::_internal_mutable_annotations() {
  
  if (annotations_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    annotations_ = p;
  }
  return annotations_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* TypeAnnotation::mutable_annotations() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_annotations();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.TypeAnnotation.annotations)
  return _msg;
}
inline void TypeAnnotation::set_allocated_annotations(::PROTOBUF_NAMESPACE_ID::Struct* annotations) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(annotations_);
  }
  if (annotations) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(annotations));
    if (message_arena != submessage_arena) {
      annotations = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, annotations, submessage_arena);
    }
    
  } else {
    
  }
  annotations_ = annotations;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.TypeAnnotation.annotations)
}

// -------------------------------------------------------------------

// LiteralType

// .flyteidl.core.SimpleType simple = 1 [json_name = "simple"];
inline bool LiteralType::_internal_has_simple() const {
  return type_case() == kSimple;
}
inline bool LiteralType::has_simple() const {
  return _internal_has_simple();
}
inline void LiteralType::set_has_simple() {
  _oneof_case_[0] = kSimple;
}
inline void LiteralType::clear_simple() {
  if (_internal_has_simple()) {
    type_.simple_ = 0;
    clear_has_type();
  }
}
inline ::flyteidl::core::SimpleType LiteralType::_internal_simple() const {
  if (_internal_has_simple()) {
    return static_cast< ::flyteidl::core::SimpleType >(type_.simple_);
  }
  return static_cast< ::flyteidl::core::SimpleType >(0);
}
inline ::flyteidl::core::SimpleType LiteralType::simple() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.LiteralType.simple)
  return _internal_simple();
}
inline void LiteralType::_internal_set_simple(::flyteidl::core::SimpleType value) {
  if (!_internal_has_simple()) {
    clear_type();
    set_has_simple();
  }
  type_.simple_ = value;
}
inline void LiteralType::set_simple(::flyteidl::core::SimpleType value) {
  _internal_set_simple(value);
  // @@protoc_insertion_point(field_set:flyteidl.core.LiteralType.simple)
}

// .flyteidl.core.SchemaType schema = 2 [json_name = "schema"];
inline bool LiteralType::_internal_has_schema() const {
  return type_case() == kSchema;
}
inline bool LiteralType::has_schema() const {
  return _internal_has_schema();
}
inline void LiteralType::set_has_schema() {
  _oneof_case_[0] = kSchema;
}
inline void LiteralType::clear_schema() {
  if (_internal_has_schema()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.schema_;
    }
    clear_has_type();
  }
}
inline ::flyteidl::core::SchemaType* LiteralType::release_schema() {
  // @@protoc_insertion_point(field_release:flyteidl.core.LiteralType.schema)
  if (_internal_has_schema()) {
    clear_has_type();
      ::flyteidl::core::SchemaType* temp = type_.schema_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.schema_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::core::SchemaType& LiteralType::_internal_schema() const {
  return _internal_has_schema()
      ? *type_.schema_
      : reinterpret_cast< ::flyteidl::core::SchemaType&>(::flyteidl::core::_SchemaType_default_instance_);
}
inline const ::flyteidl::core::SchemaType& LiteralType::schema() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.LiteralType.schema)
  return _internal_schema();
}
inline ::flyteidl::core::SchemaType* LiteralType::unsafe_arena_release_schema() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flyteidl.core.LiteralType.schema)
  if (_internal_has_schema()) {
    clear_has_type();
    ::flyteidl::core::SchemaType* temp = type_.schema_;
    type_.schema_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LiteralType::unsafe_arena_set_allocated_schema(::flyteidl::core::SchemaType* schema) {
  clear_type();
  if (schema) {
    set_has_schema();
    type_.schema_ = schema;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.core.LiteralType.schema)
}
inline ::flyteidl::core::SchemaType* LiteralType::_internal_mutable_schema() {
  if (!_internal_has_schema()) {
    clear_type();
    set_has_schema();
    type_.schema_ = CreateMaybeMessage< ::flyteidl::core::SchemaType >(GetArenaForAllocation());
  }
  return type_.schema_;
}
inline ::flyteidl::core::SchemaType* LiteralType::mutable_schema() {
  ::flyteidl::core::SchemaType* _msg = _internal_mutable_schema();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.LiteralType.schema)
  return _msg;
}

// .flyteidl.core.LiteralType collection_type = 3 [json_name = "collectionType"];
inline bool LiteralType::_internal_has_collection_type() const {
  return type_case() == kCollectionType;
}
inline bool LiteralType::has_collection_type() const {
  return _internal_has_collection_type();
}
inline void LiteralType::set_has_collection_type() {
  _oneof_case_[0] = kCollectionType;
}
inline void LiteralType::clear_collection_type() {
  if (_internal_has_collection_type()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.collection_type_;
    }
    clear_has_type();
  }
}
inline ::flyteidl::core::LiteralType* LiteralType::release_collection_type() {
  // @@protoc_insertion_point(field_release:flyteidl.core.LiteralType.collection_type)
  if (_internal_has_collection_type()) {
    clear_has_type();
      ::flyteidl::core::LiteralType* temp = type_.collection_type_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.collection_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::core::LiteralType& LiteralType::_internal_collection_type() const {
  return _internal_has_collection_type()
      ? *type_.collection_type_
      : reinterpret_cast< ::flyteidl::core::LiteralType&>(::flyteidl::core::_LiteralType_default_instance_);
}
inline const ::flyteidl::core::LiteralType& LiteralType::collection_type() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.LiteralType.collection_type)
  return _internal_collection_type();
}
inline ::flyteidl::core::LiteralType* LiteralType::unsafe_arena_release_collection_type() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flyteidl.core.LiteralType.collection_type)
  if (_internal_has_collection_type()) {
    clear_has_type();
    ::flyteidl::core::LiteralType* temp = type_.collection_type_;
    type_.collection_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LiteralType::unsafe_arena_set_allocated_collection_type(::flyteidl::core::LiteralType* collection_type) {
  clear_type();
  if (collection_type) {
    set_has_collection_type();
    type_.collection_type_ = collection_type;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.core.LiteralType.collection_type)
}
inline ::flyteidl::core::LiteralType* LiteralType::_internal_mutable_collection_type() {
  if (!_internal_has_collection_type()) {
    clear_type();
    set_has_collection_type();
    type_.collection_type_ = CreateMaybeMessage< ::flyteidl::core::LiteralType >(GetArenaForAllocation());
  }
  return type_.collection_type_;
}
inline ::flyteidl::core::LiteralType* LiteralType::mutable_collection_type() {
  ::flyteidl::core::LiteralType* _msg = _internal_mutable_collection_type();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.LiteralType.collection_type)
  return _msg;
}

// .flyteidl.core.LiteralType map_value_type = 4 [json_name = "mapValueType"];
inline bool LiteralType::_internal_has_map_value_type() const {
  return type_case() == kMapValueType;
}
inline bool LiteralType::has_map_value_type() const {
  return _internal_has_map_value_type();
}
inline void LiteralType::set_has_map_value_type() {
  _oneof_case_[0] = kMapValueType;
}
inline void LiteralType::clear_map_value_type() {
  if (_internal_has_map_value_type()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.map_value_type_;
    }
    clear_has_type();
  }
}
inline ::flyteidl::core::LiteralType* LiteralType::release_map_value_type() {
  // @@protoc_insertion_point(field_release:flyteidl.core.LiteralType.map_value_type)
  if (_internal_has_map_value_type()) {
    clear_has_type();
      ::flyteidl::core::LiteralType* temp = type_.map_value_type_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.map_value_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::core::LiteralType& LiteralType::_internal_map_value_type() const {
  return _internal_has_map_value_type()
      ? *type_.map_value_type_
      : reinterpret_cast< ::flyteidl::core::LiteralType&>(::flyteidl::core::_LiteralType_default_instance_);
}
inline const ::flyteidl::core::LiteralType& LiteralType::map_value_type() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.LiteralType.map_value_type)
  return _internal_map_value_type();
}
inline ::flyteidl::core::LiteralType* LiteralType::unsafe_arena_release_map_value_type() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flyteidl.core.LiteralType.map_value_type)
  if (_internal_has_map_value_type()) {
    clear_has_type();
    ::flyteidl::core::LiteralType* temp = type_.map_value_type_;
    type_.map_value_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LiteralType::unsafe_arena_set_allocated_map_value_type(::flyteidl::core::LiteralType* map_value_type) {
  clear_type();
  if (map_value_type) {
    set_has_map_value_type();
    type_.map_value_type_ = map_value_type;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.core.LiteralType.map_value_type)
}
inline ::flyteidl::core::LiteralType* LiteralType::_internal_mutable_map_value_type() {
  if (!_internal_has_map_value_type()) {
    clear_type();
    set_has_map_value_type();
    type_.map_value_type_ = CreateMaybeMessage< ::flyteidl::core::LiteralType >(GetArenaForAllocation());
  }
  return type_.map_value_type_;
}
inline ::flyteidl::core::LiteralType* LiteralType::mutable_map_value_type() {
  ::flyteidl::core::LiteralType* _msg = _internal_mutable_map_value_type();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.LiteralType.map_value_type)
  return _msg;
}

// .flyteidl.core.BlobType blob = 5 [json_name = "blob"];
inline bool LiteralType::_internal_has_blob() const {
  return type_case() == kBlob;
}
inline bool LiteralType::has_blob() const {
  return _internal_has_blob();
}
inline void LiteralType::set_has_blob() {
  _oneof_case_[0] = kBlob;
}
inline void LiteralType::clear_blob() {
  if (_internal_has_blob()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.blob_;
    }
    clear_has_type();
  }
}
inline ::flyteidl::core::BlobType* LiteralType::release_blob() {
  // @@protoc_insertion_point(field_release:flyteidl.core.LiteralType.blob)
  if (_internal_has_blob()) {
    clear_has_type();
      ::flyteidl::core::BlobType* temp = type_.blob_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.blob_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::core::BlobType& LiteralType::_internal_blob() const {
  return _internal_has_blob()
      ? *type_.blob_
      : reinterpret_cast< ::flyteidl::core::BlobType&>(::flyteidl::core::_BlobType_default_instance_);
}
inline const ::flyteidl::core::BlobType& LiteralType::blob() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.LiteralType.blob)
  return _internal_blob();
}
inline ::flyteidl::core::BlobType* LiteralType::unsafe_arena_release_blob() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flyteidl.core.LiteralType.blob)
  if (_internal_has_blob()) {
    clear_has_type();
    ::flyteidl::core::BlobType* temp = type_.blob_;
    type_.blob_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LiteralType::unsafe_arena_set_allocated_blob(::flyteidl::core::BlobType* blob) {
  clear_type();
  if (blob) {
    set_has_blob();
    type_.blob_ = blob;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.core.LiteralType.blob)
}
inline ::flyteidl::core::BlobType* LiteralType::_internal_mutable_blob() {
  if (!_internal_has_blob()) {
    clear_type();
    set_has_blob();
    type_.blob_ = CreateMaybeMessage< ::flyteidl::core::BlobType >(GetArenaForAllocation());
  }
  return type_.blob_;
}
inline ::flyteidl::core::BlobType* LiteralType::mutable_blob() {
  ::flyteidl::core::BlobType* _msg = _internal_mutable_blob();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.LiteralType.blob)
  return _msg;
}

// .flyteidl.core.EnumType enum_type = 7 [json_name = "enumType"];
inline bool LiteralType::_internal_has_enum_type() const {
  return type_case() == kEnumType;
}
inline bool LiteralType::has_enum_type() const {
  return _internal_has_enum_type();
}
inline void LiteralType::set_has_enum_type() {
  _oneof_case_[0] = kEnumType;
}
inline void LiteralType::clear_enum_type() {
  if (_internal_has_enum_type()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.enum_type_;
    }
    clear_has_type();
  }
}
inline ::flyteidl::core::EnumType* LiteralType::release_enum_type() {
  // @@protoc_insertion_point(field_release:flyteidl.core.LiteralType.enum_type)
  if (_internal_has_enum_type()) {
    clear_has_type();
      ::flyteidl::core::EnumType* temp = type_.enum_type_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.enum_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::core::EnumType& LiteralType::_internal_enum_type() const {
  return _internal_has_enum_type()
      ? *type_.enum_type_
      : reinterpret_cast< ::flyteidl::core::EnumType&>(::flyteidl::core::_EnumType_default_instance_);
}
inline const ::flyteidl::core::EnumType& LiteralType::enum_type() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.LiteralType.enum_type)
  return _internal_enum_type();
}
inline ::flyteidl::core::EnumType* LiteralType::unsafe_arena_release_enum_type() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flyteidl.core.LiteralType.enum_type)
  if (_internal_has_enum_type()) {
    clear_has_type();
    ::flyteidl::core::EnumType* temp = type_.enum_type_;
    type_.enum_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LiteralType::unsafe_arena_set_allocated_enum_type(::flyteidl::core::EnumType* enum_type) {
  clear_type();
  if (enum_type) {
    set_has_enum_type();
    type_.enum_type_ = enum_type;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.core.LiteralType.enum_type)
}
inline ::flyteidl::core::EnumType* LiteralType::_internal_mutable_enum_type() {
  if (!_internal_has_enum_type()) {
    clear_type();
    set_has_enum_type();
    type_.enum_type_ = CreateMaybeMessage< ::flyteidl::core::EnumType >(GetArenaForAllocation());
  }
  return type_.enum_type_;
}
inline ::flyteidl::core::EnumType* LiteralType::mutable_enum_type() {
  ::flyteidl::core::EnumType* _msg = _internal_mutable_enum_type();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.LiteralType.enum_type)
  return _msg;
}

// .flyteidl.core.StructuredDatasetType structured_dataset_type = 8 [json_name = "structuredDatasetType"];
inline bool LiteralType::_internal_has_structured_dataset_type() const {
  return type_case() == kStructuredDatasetType;
}
inline bool LiteralType::has_structured_dataset_type() const {
  return _internal_has_structured_dataset_type();
}
inline void LiteralType::set_has_structured_dataset_type() {
  _oneof_case_[0] = kStructuredDatasetType;
}
inline void LiteralType::clear_structured_dataset_type() {
  if (_internal_has_structured_dataset_type()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.structured_dataset_type_;
    }
    clear_has_type();
  }
}
inline ::flyteidl::core::StructuredDatasetType* LiteralType::release_structured_dataset_type() {
  // @@protoc_insertion_point(field_release:flyteidl.core.LiteralType.structured_dataset_type)
  if (_internal_has_structured_dataset_type()) {
    clear_has_type();
      ::flyteidl::core::StructuredDatasetType* temp = type_.structured_dataset_type_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.structured_dataset_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::core::StructuredDatasetType& LiteralType::_internal_structured_dataset_type() const {
  return _internal_has_structured_dataset_type()
      ? *type_.structured_dataset_type_
      : reinterpret_cast< ::flyteidl::core::StructuredDatasetType&>(::flyteidl::core::_StructuredDatasetType_default_instance_);
}
inline const ::flyteidl::core::StructuredDatasetType& LiteralType::structured_dataset_type() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.LiteralType.structured_dataset_type)
  return _internal_structured_dataset_type();
}
inline ::flyteidl::core::StructuredDatasetType* LiteralType::unsafe_arena_release_structured_dataset_type() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flyteidl.core.LiteralType.structured_dataset_type)
  if (_internal_has_structured_dataset_type()) {
    clear_has_type();
    ::flyteidl::core::StructuredDatasetType* temp = type_.structured_dataset_type_;
    type_.structured_dataset_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LiteralType::unsafe_arena_set_allocated_structured_dataset_type(::flyteidl::core::StructuredDatasetType* structured_dataset_type) {
  clear_type();
  if (structured_dataset_type) {
    set_has_structured_dataset_type();
    type_.structured_dataset_type_ = structured_dataset_type;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.core.LiteralType.structured_dataset_type)
}
inline ::flyteidl::core::StructuredDatasetType* LiteralType::_internal_mutable_structured_dataset_type() {
  if (!_internal_has_structured_dataset_type()) {
    clear_type();
    set_has_structured_dataset_type();
    type_.structured_dataset_type_ = CreateMaybeMessage< ::flyteidl::core::StructuredDatasetType >(GetArenaForAllocation());
  }
  return type_.structured_dataset_type_;
}
inline ::flyteidl::core::StructuredDatasetType* LiteralType::mutable_structured_dataset_type() {
  ::flyteidl::core::StructuredDatasetType* _msg = _internal_mutable_structured_dataset_type();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.LiteralType.structured_dataset_type)
  return _msg;
}

// .flyteidl.core.UnionType union_type = 10 [json_name = "unionType"];
inline bool LiteralType::_internal_has_union_type() const {
  return type_case() == kUnionType;
}
inline bool LiteralType::has_union_type() const {
  return _internal_has_union_type();
}
inline void LiteralType::set_has_union_type() {
  _oneof_case_[0] = kUnionType;
}
inline void LiteralType::clear_union_type() {
  if (_internal_has_union_type()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.union_type_;
    }
    clear_has_type();
  }
}
inline ::flyteidl::core::UnionType* LiteralType::release_union_type() {
  // @@protoc_insertion_point(field_release:flyteidl.core.LiteralType.union_type)
  if (_internal_has_union_type()) {
    clear_has_type();
      ::flyteidl::core::UnionType* temp = type_.union_type_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.union_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::core::UnionType& LiteralType::_internal_union_type() const {
  return _internal_has_union_type()
      ? *type_.union_type_
      : reinterpret_cast< ::flyteidl::core::UnionType&>(::flyteidl::core::_UnionType_default_instance_);
}
inline const ::flyteidl::core::UnionType& LiteralType::union_type() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.LiteralType.union_type)
  return _internal_union_type();
}
inline ::flyteidl::core::UnionType* LiteralType::unsafe_arena_release_union_type() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flyteidl.core.LiteralType.union_type)
  if (_internal_has_union_type()) {
    clear_has_type();
    ::flyteidl::core::UnionType* temp = type_.union_type_;
    type_.union_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LiteralType::unsafe_arena_set_allocated_union_type(::flyteidl::core::UnionType* union_type) {
  clear_type();
  if (union_type) {
    set_has_union_type();
    type_.union_type_ = union_type;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.core.LiteralType.union_type)
}
inline ::flyteidl::core::UnionType* LiteralType::_internal_mutable_union_type() {
  if (!_internal_has_union_type()) {
    clear_type();
    set_has_union_type();
    type_.union_type_ = CreateMaybeMessage< ::flyteidl::core::UnionType >(GetArenaForAllocation());
  }
  return type_.union_type_;
}
inline ::flyteidl::core::UnionType* LiteralType::mutable_union_type() {
  ::flyteidl::core::UnionType* _msg = _internal_mutable_union_type();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.LiteralType.union_type)
  return _msg;
}

// .google.protobuf.Struct metadata = 6 [json_name = "metadata"];
inline bool LiteralType::_internal_has_metadata() const {
  return this != internal_default_instance() && metadata_ != nullptr;
}
inline bool LiteralType::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& LiteralType::_internal_metadata() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& LiteralType::metadata() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.LiteralType.metadata)
  return _internal_metadata();
}
inline void LiteralType::unsafe_arena_set_allocated_metadata(
    ::PROTOBUF_NAMESPACE_ID::Struct* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.core.LiteralType.metadata)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* LiteralType::release_metadata() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = metadata_;
  metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* LiteralType::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:flyteidl.core.LiteralType.metadata)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* LiteralType::_internal_mutable_metadata() {
  
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    metadata_ = p;
  }
  return metadata_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* LiteralType::mutable_metadata() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.LiteralType.metadata)
  return _msg;
}
inline void LiteralType::set_allocated_metadata(::PROTOBUF_NAMESPACE_ID::Struct* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.LiteralType.metadata)
}

// .flyteidl.core.TypeAnnotation annotation = 9 [json_name = "annotation"];
inline bool LiteralType::_internal_has_annotation() const {
  return this != internal_default_instance() && annotation_ != nullptr;
}
inline bool LiteralType::has_annotation() const {
  return _internal_has_annotation();
}
inline void LiteralType::clear_annotation() {
  if (GetArenaForAllocation() == nullptr && annotation_ != nullptr) {
    delete annotation_;
  }
  annotation_ = nullptr;
}
inline const ::flyteidl::core::TypeAnnotation& LiteralType::_internal_annotation() const {
  const ::flyteidl::core::TypeAnnotation* p = annotation_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::core::TypeAnnotation&>(
      ::flyteidl::core::_TypeAnnotation_default_instance_);
}
inline const ::flyteidl::core::TypeAnnotation& LiteralType::annotation() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.LiteralType.annotation)
  return _internal_annotation();
}
inline void LiteralType::unsafe_arena_set_allocated_annotation(
    ::flyteidl::core::TypeAnnotation* annotation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(annotation_);
  }
  annotation_ = annotation;
  if (annotation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.core.LiteralType.annotation)
}
inline ::flyteidl::core::TypeAnnotation* LiteralType::release_annotation() {
  
  ::flyteidl::core::TypeAnnotation* temp = annotation_;
  annotation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::core::TypeAnnotation* LiteralType::unsafe_arena_release_annotation() {
  // @@protoc_insertion_point(field_release:flyteidl.core.LiteralType.annotation)
  
  ::flyteidl::core::TypeAnnotation* temp = annotation_;
  annotation_ = nullptr;
  return temp;
}
inline ::flyteidl::core::TypeAnnotation* LiteralType::_internal_mutable_annotation() {
  
  if (annotation_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::TypeAnnotation>(GetArenaForAllocation());
    annotation_ = p;
  }
  return annotation_;
}
inline ::flyteidl::core::TypeAnnotation* LiteralType::mutable_annotation() {
  ::flyteidl::core::TypeAnnotation* _msg = _internal_mutable_annotation();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.LiteralType.annotation)
  return _msg;
}
inline void LiteralType::set_allocated_annotation(::flyteidl::core::TypeAnnotation* annotation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete annotation_;
  }
  if (annotation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::flyteidl::core::TypeAnnotation>::GetOwningArena(annotation);
    if (message_arena != submessage_arena) {
      annotation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, annotation, submessage_arena);
    }
    
  } else {
    
  }
  annotation_ = annotation;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.LiteralType.annotation)
}

// .flyteidl.core.TypeStructure structure = 11 [json_name = "structure"];
inline bool LiteralType::_internal_has_structure() const {
  return this != internal_default_instance() && structure_ != nullptr;
}
inline bool LiteralType::has_structure() const {
  return _internal_has_structure();
}
inline void LiteralType::clear_structure() {
  if (GetArenaForAllocation() == nullptr && structure_ != nullptr) {
    delete structure_;
  }
  structure_ = nullptr;
}
inline const ::flyteidl::core::TypeStructure& LiteralType::_internal_structure() const {
  const ::flyteidl::core::TypeStructure* p = structure_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::core::TypeStructure&>(
      ::flyteidl::core::_TypeStructure_default_instance_);
}
inline const ::flyteidl::core::TypeStructure& LiteralType::structure() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.LiteralType.structure)
  return _internal_structure();
}
inline void LiteralType::unsafe_arena_set_allocated_structure(
    ::flyteidl::core::TypeStructure* structure) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(structure_);
  }
  structure_ = structure;
  if (structure) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.core.LiteralType.structure)
}
inline ::flyteidl::core::TypeStructure* LiteralType::release_structure() {
  
  ::flyteidl::core::TypeStructure* temp = structure_;
  structure_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::core::TypeStructure* LiteralType::unsafe_arena_release_structure() {
  // @@protoc_insertion_point(field_release:flyteidl.core.LiteralType.structure)
  
  ::flyteidl::core::TypeStructure* temp = structure_;
  structure_ = nullptr;
  return temp;
}
inline ::flyteidl::core::TypeStructure* LiteralType::_internal_mutable_structure() {
  
  if (structure_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::TypeStructure>(GetArenaForAllocation());
    structure_ = p;
  }
  return structure_;
}
inline ::flyteidl::core::TypeStructure* LiteralType::mutable_structure() {
  ::flyteidl::core::TypeStructure* _msg = _internal_mutable_structure();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.LiteralType.structure)
  return _msg;
}
inline void LiteralType::set_allocated_structure(::flyteidl::core::TypeStructure* structure) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete structure_;
  }
  if (structure) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::flyteidl::core::TypeStructure>::GetOwningArena(structure);
    if (message_arena != submessage_arena) {
      structure = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, structure, submessage_arena);
    }
    
  } else {
    
  }
  structure_ = structure;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.LiteralType.structure)
}

inline bool LiteralType::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void LiteralType::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline LiteralType::TypeCase LiteralType::type_case() const {
  return LiteralType::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// OutputReference

// string node_id = 1 [json_name = "nodeId"];
inline void OutputReference::clear_node_id() {
  node_id_.ClearToEmpty();
}
inline const std::string& OutputReference::node_id() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.OutputReference.node_id)
  return _internal_node_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OutputReference::set_node_id(ArgT0&& arg0, ArgT... args) {
 
 node_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.core.OutputReference.node_id)
}
inline std::string* OutputReference::mutable_node_id() {
  std::string* _s = _internal_mutable_node_id();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.OutputReference.node_id)
  return _s;
}
inline const std::string& OutputReference::_internal_node_id() const {
  return node_id_.Get();
}
inline void OutputReference::_internal_set_node_id(const std::string& value) {
  
  node_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* OutputReference::_internal_mutable_node_id() {
  
  return node_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* OutputReference::release_node_id() {
  // @@protoc_insertion_point(field_release:flyteidl.core.OutputReference.node_id)
  return node_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void OutputReference::set_allocated_node_id(std::string* node_id) {
  if (node_id != nullptr) {
    
  } else {
    
  }
  node_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), node_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (node_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    node_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.OutputReference.node_id)
}

// string var = 2 [json_name = "var"];
inline void OutputReference::clear_var() {
  var_.ClearToEmpty();
}
inline const std::string& OutputReference::var() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.OutputReference.var)
  return _internal_var();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OutputReference::set_var(ArgT0&& arg0, ArgT... args) {
 
 var_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.core.OutputReference.var)
}
inline std::string* OutputReference::mutable_var() {
  std::string* _s = _internal_mutable_var();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.OutputReference.var)
  return _s;
}
inline const std::string& OutputReference::_internal_var() const {
  return var_.Get();
}
inline void OutputReference::_internal_set_var(const std::string& value) {
  
  var_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* OutputReference::_internal_mutable_var() {
  
  return var_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* OutputReference::release_var() {
  // @@protoc_insertion_point(field_release:flyteidl.core.OutputReference.var)
  return var_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void OutputReference::set_allocated_var(std::string* var) {
  if (var != nullptr) {
    
  } else {
    
  }
  var_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), var,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (var_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    var_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.OutputReference.var)
}

// -------------------------------------------------------------------

// Error

// string failed_node_id = 1 [json_name = "failedNodeId"];
inline void Error::clear_failed_node_id() {
  failed_node_id_.ClearToEmpty();
}
inline const std::string& Error::failed_node_id() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Error.failed_node_id)
  return _internal_failed_node_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Error::set_failed_node_id(ArgT0&& arg0, ArgT... args) {
 
 failed_node_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.core.Error.failed_node_id)
}
inline std::string* Error::mutable_failed_node_id() {
  std::string* _s = _internal_mutable_failed_node_id();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Error.failed_node_id)
  return _s;
}
inline const std::string& Error::_internal_failed_node_id() const {
  return failed_node_id_.Get();
}
inline void Error::_internal_set_failed_node_id(const std::string& value) {
  
  failed_node_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Error::_internal_mutable_failed_node_id() {
  
  return failed_node_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Error::release_failed_node_id() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Error.failed_node_id)
  return failed_node_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Error::set_allocated_failed_node_id(std::string* failed_node_id) {
  if (failed_node_id != nullptr) {
    
  } else {
    
  }
  failed_node_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), failed_node_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (failed_node_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    failed_node_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.Error.failed_node_id)
}

// string message = 2 [json_name = "message"];
inline void Error::clear_message() {
  message_.ClearToEmpty();
}
inline const std::string& Error::message() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Error.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Error::set_message(ArgT0&& arg0, ArgT... args) {
 
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.core.Error.message)
}
inline std::string* Error::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Error.message)
  return _s;
}
inline const std::string& Error::_internal_message() const {
  return message_.Get();
}
inline void Error::_internal_set_message(const std::string& value) {
  
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Error::_internal_mutable_message() {
  
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Error::release_message() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Error.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Error::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.Error.message)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace core
}  // namespace flyteidl

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::flyteidl::core::SchemaType_SchemaColumn_SchemaColumnType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::flyteidl::core::SchemaType_SchemaColumn_SchemaColumnType>() {
  return ::flyteidl::core::SchemaType_SchemaColumn_SchemaColumnType_descriptor();
}
template <> struct is_proto_enum< ::flyteidl::core::BlobType_BlobDimensionality> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::flyteidl::core::BlobType_BlobDimensionality>() {
  return ::flyteidl::core::BlobType_BlobDimensionality_descriptor();
}
template <> struct is_proto_enum< ::flyteidl::core::SimpleType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::flyteidl::core::SimpleType>() {
  return ::flyteidl::core::SimpleType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_flyteidl_2fcore_2ftypes_2eproto
