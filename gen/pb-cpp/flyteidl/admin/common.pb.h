// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: flyteidl/admin/common.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_flyteidl_2fadmin_2fcommon_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_flyteidl_2fadmin_2fcommon_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "flyteidl/core/execution.pb.h"
#include "flyteidl/core/identifier.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_flyteidl_2fadmin_2fcommon_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_flyteidl_2fadmin_2fcommon_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[24]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_flyteidl_2fadmin_2fcommon_2eproto;
namespace flyteidl {
namespace admin {
class Annotations;
struct AnnotationsDefaultTypeInternal;
extern AnnotationsDefaultTypeInternal _Annotations_default_instance_;
class Annotations_ValuesEntry_DoNotUse;
struct Annotations_ValuesEntry_DoNotUseDefaultTypeInternal;
extern Annotations_ValuesEntry_DoNotUseDefaultTypeInternal _Annotations_ValuesEntry_DoNotUse_default_instance_;
class AuthRole;
struct AuthRoleDefaultTypeInternal;
extern AuthRoleDefaultTypeInternal _AuthRole_default_instance_;
class EmailNotification;
struct EmailNotificationDefaultTypeInternal;
extern EmailNotificationDefaultTypeInternal _EmailNotification_default_instance_;
class Labels;
struct LabelsDefaultTypeInternal;
extern LabelsDefaultTypeInternal _Labels_default_instance_;
class Labels_ValuesEntry_DoNotUse;
struct Labels_ValuesEntry_DoNotUseDefaultTypeInternal;
extern Labels_ValuesEntry_DoNotUseDefaultTypeInternal _Labels_ValuesEntry_DoNotUse_default_instance_;
class NamedEntity;
struct NamedEntityDefaultTypeInternal;
extern NamedEntityDefaultTypeInternal _NamedEntity_default_instance_;
class NamedEntityGetRequest;
struct NamedEntityGetRequestDefaultTypeInternal;
extern NamedEntityGetRequestDefaultTypeInternal _NamedEntityGetRequest_default_instance_;
class NamedEntityIdentifier;
struct NamedEntityIdentifierDefaultTypeInternal;
extern NamedEntityIdentifierDefaultTypeInternal _NamedEntityIdentifier_default_instance_;
class NamedEntityIdentifierList;
struct NamedEntityIdentifierListDefaultTypeInternal;
extern NamedEntityIdentifierListDefaultTypeInternal _NamedEntityIdentifierList_default_instance_;
class NamedEntityIdentifierListRequest;
struct NamedEntityIdentifierListRequestDefaultTypeInternal;
extern NamedEntityIdentifierListRequestDefaultTypeInternal _NamedEntityIdentifierListRequest_default_instance_;
class NamedEntityList;
struct NamedEntityListDefaultTypeInternal;
extern NamedEntityListDefaultTypeInternal _NamedEntityList_default_instance_;
class NamedEntityListRequest;
struct NamedEntityListRequestDefaultTypeInternal;
extern NamedEntityListRequestDefaultTypeInternal _NamedEntityListRequest_default_instance_;
class NamedEntityMetadata;
struct NamedEntityMetadataDefaultTypeInternal;
extern NamedEntityMetadataDefaultTypeInternal _NamedEntityMetadata_default_instance_;
class NamedEntityUpdateRequest;
struct NamedEntityUpdateRequestDefaultTypeInternal;
extern NamedEntityUpdateRequestDefaultTypeInternal _NamedEntityUpdateRequest_default_instance_;
class NamedEntityUpdateResponse;
struct NamedEntityUpdateResponseDefaultTypeInternal;
extern NamedEntityUpdateResponseDefaultTypeInternal _NamedEntityUpdateResponse_default_instance_;
class Notification;
struct NotificationDefaultTypeInternal;
extern NotificationDefaultTypeInternal _Notification_default_instance_;
class ObjectGetRequest;
struct ObjectGetRequestDefaultTypeInternal;
extern ObjectGetRequestDefaultTypeInternal _ObjectGetRequest_default_instance_;
class PagerDutyNotification;
struct PagerDutyNotificationDefaultTypeInternal;
extern PagerDutyNotificationDefaultTypeInternal _PagerDutyNotification_default_instance_;
class RawOutputDataConfig;
struct RawOutputDataConfigDefaultTypeInternal;
extern RawOutputDataConfigDefaultTypeInternal _RawOutputDataConfig_default_instance_;
class ResourceListRequest;
struct ResourceListRequestDefaultTypeInternal;
extern ResourceListRequestDefaultTypeInternal _ResourceListRequest_default_instance_;
class SlackNotification;
struct SlackNotificationDefaultTypeInternal;
extern SlackNotificationDefaultTypeInternal _SlackNotification_default_instance_;
class Sort;
struct SortDefaultTypeInternal;
extern SortDefaultTypeInternal _Sort_default_instance_;
class UrlBlob;
struct UrlBlobDefaultTypeInternal;
extern UrlBlobDefaultTypeInternal _UrlBlob_default_instance_;
}  // namespace admin
}  // namespace flyteidl
PROTOBUF_NAMESPACE_OPEN
template<> ::flyteidl::admin::Annotations* Arena::CreateMaybeMessage<::flyteidl::admin::Annotations>(Arena*);
template<> ::flyteidl::admin::Annotations_ValuesEntry_DoNotUse* Arena::CreateMaybeMessage<::flyteidl::admin::Annotations_ValuesEntry_DoNotUse>(Arena*);
template<> ::flyteidl::admin::AuthRole* Arena::CreateMaybeMessage<::flyteidl::admin::AuthRole>(Arena*);
template<> ::flyteidl::admin::EmailNotification* Arena::CreateMaybeMessage<::flyteidl::admin::EmailNotification>(Arena*);
template<> ::flyteidl::admin::Labels* Arena::CreateMaybeMessage<::flyteidl::admin::Labels>(Arena*);
template<> ::flyteidl::admin::Labels_ValuesEntry_DoNotUse* Arena::CreateMaybeMessage<::flyteidl::admin::Labels_ValuesEntry_DoNotUse>(Arena*);
template<> ::flyteidl::admin::NamedEntity* Arena::CreateMaybeMessage<::flyteidl::admin::NamedEntity>(Arena*);
template<> ::flyteidl::admin::NamedEntityGetRequest* Arena::CreateMaybeMessage<::flyteidl::admin::NamedEntityGetRequest>(Arena*);
template<> ::flyteidl::admin::NamedEntityIdentifier* Arena::CreateMaybeMessage<::flyteidl::admin::NamedEntityIdentifier>(Arena*);
template<> ::flyteidl::admin::NamedEntityIdentifierList* Arena::CreateMaybeMessage<::flyteidl::admin::NamedEntityIdentifierList>(Arena*);
template<> ::flyteidl::admin::NamedEntityIdentifierListRequest* Arena::CreateMaybeMessage<::flyteidl::admin::NamedEntityIdentifierListRequest>(Arena*);
template<> ::flyteidl::admin::NamedEntityList* Arena::CreateMaybeMessage<::flyteidl::admin::NamedEntityList>(Arena*);
template<> ::flyteidl::admin::NamedEntityListRequest* Arena::CreateMaybeMessage<::flyteidl::admin::NamedEntityListRequest>(Arena*);
template<> ::flyteidl::admin::NamedEntityMetadata* Arena::CreateMaybeMessage<::flyteidl::admin::NamedEntityMetadata>(Arena*);
template<> ::flyteidl::admin::NamedEntityUpdateRequest* Arena::CreateMaybeMessage<::flyteidl::admin::NamedEntityUpdateRequest>(Arena*);
template<> ::flyteidl::admin::NamedEntityUpdateResponse* Arena::CreateMaybeMessage<::flyteidl::admin::NamedEntityUpdateResponse>(Arena*);
template<> ::flyteidl::admin::Notification* Arena::CreateMaybeMessage<::flyteidl::admin::Notification>(Arena*);
template<> ::flyteidl::admin::ObjectGetRequest* Arena::CreateMaybeMessage<::flyteidl::admin::ObjectGetRequest>(Arena*);
template<> ::flyteidl::admin::PagerDutyNotification* Arena::CreateMaybeMessage<::flyteidl::admin::PagerDutyNotification>(Arena*);
template<> ::flyteidl::admin::RawOutputDataConfig* Arena::CreateMaybeMessage<::flyteidl::admin::RawOutputDataConfig>(Arena*);
template<> ::flyteidl::admin::ResourceListRequest* Arena::CreateMaybeMessage<::flyteidl::admin::ResourceListRequest>(Arena*);
template<> ::flyteidl::admin::SlackNotification* Arena::CreateMaybeMessage<::flyteidl::admin::SlackNotification>(Arena*);
template<> ::flyteidl::admin::Sort* Arena::CreateMaybeMessage<::flyteidl::admin::Sort>(Arena*);
template<> ::flyteidl::admin::UrlBlob* Arena::CreateMaybeMessage<::flyteidl::admin::UrlBlob>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace flyteidl {
namespace admin {

enum Sort_Direction : int {
  Sort_Direction_DESCENDING = 0,
  Sort_Direction_ASCENDING = 1,
  Sort_Direction_Sort_Direction_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Sort_Direction_Sort_Direction_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Sort_Direction_IsValid(int value);
constexpr Sort_Direction Sort_Direction_Direction_MIN = Sort_Direction_DESCENDING;
constexpr Sort_Direction Sort_Direction_Direction_MAX = Sort_Direction_ASCENDING;
constexpr int Sort_Direction_Direction_ARRAYSIZE = Sort_Direction_Direction_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Sort_Direction_descriptor();
template<typename T>
inline const std::string& Sort_Direction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Sort_Direction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Sort_Direction_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Sort_Direction_descriptor(), enum_t_value);
}
inline bool Sort_Direction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Sort_Direction* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Sort_Direction>(
    Sort_Direction_descriptor(), name, value);
}
enum NamedEntityState : int {
  NAMED_ENTITY_ACTIVE = 0,
  NAMED_ENTITY_ARCHIVED = 1,
  SYSTEM_GENERATED = 2,
  NamedEntityState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  NamedEntityState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool NamedEntityState_IsValid(int value);
constexpr NamedEntityState NamedEntityState_MIN = NAMED_ENTITY_ACTIVE;
constexpr NamedEntityState NamedEntityState_MAX = SYSTEM_GENERATED;
constexpr int NamedEntityState_ARRAYSIZE = NamedEntityState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NamedEntityState_descriptor();
template<typename T>
inline const std::string& NamedEntityState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NamedEntityState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NamedEntityState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    NamedEntityState_descriptor(), enum_t_value);
}
inline bool NamedEntityState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NamedEntityState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NamedEntityState>(
    NamedEntityState_descriptor(), name, value);
}
// ===================================================================

class NamedEntityIdentifier final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.admin.NamedEntityIdentifier) */ {
 public:
  inline NamedEntityIdentifier() : NamedEntityIdentifier(nullptr) {}
  ~NamedEntityIdentifier() override;
  explicit constexpr NamedEntityIdentifier(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NamedEntityIdentifier(const NamedEntityIdentifier& from);
  NamedEntityIdentifier(NamedEntityIdentifier&& from) noexcept
    : NamedEntityIdentifier() {
    *this = ::std::move(from);
  }

  inline NamedEntityIdentifier& operator=(const NamedEntityIdentifier& from) {
    CopyFrom(from);
    return *this;
  }
  inline NamedEntityIdentifier& operator=(NamedEntityIdentifier&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NamedEntityIdentifier& default_instance() {
    return *internal_default_instance();
  }
  static inline const NamedEntityIdentifier* internal_default_instance() {
    return reinterpret_cast<const NamedEntityIdentifier*>(
               &_NamedEntityIdentifier_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(NamedEntityIdentifier& a, NamedEntityIdentifier& b) {
    a.Swap(&b);
  }
  inline void Swap(NamedEntityIdentifier* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NamedEntityIdentifier* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NamedEntityIdentifier* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NamedEntityIdentifier>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NamedEntityIdentifier* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.admin.NamedEntityIdentifier";
  }
  protected:
  explicit NamedEntityIdentifier(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProjectFieldNumber = 1,
    kDomainFieldNumber = 2,
    kNameFieldNumber = 3,
  };
  // string project = 1 [json_name = "project"];
  void clear_project();
  const std::string& project() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_project(ArgT0&& arg0, ArgT... args);
  std::string* mutable_project();
  PROTOBUF_NODISCARD std::string* release_project();
  void set_allocated_project(std::string* project);
  private:
  const std::string& _internal_project() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_project(const std::string& value);
  std::string* _internal_mutable_project();
  public:

  // string domain = 2 [json_name = "domain"];
  void clear_domain();
  const std::string& domain() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_domain(ArgT0&& arg0, ArgT... args);
  std::string* mutable_domain();
  PROTOBUF_NODISCARD std::string* release_domain();
  void set_allocated_domain(std::string* domain);
  private:
  const std::string& _internal_domain() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_domain(const std::string& value);
  std::string* _internal_mutable_domain();
  public:

  // string name = 3 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:flyteidl.admin.NamedEntityIdentifier)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr project_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr domain_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fadmin_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class NamedEntityMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.admin.NamedEntityMetadata) */ {
 public:
  inline NamedEntityMetadata() : NamedEntityMetadata(nullptr) {}
  ~NamedEntityMetadata() override;
  explicit constexpr NamedEntityMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NamedEntityMetadata(const NamedEntityMetadata& from);
  NamedEntityMetadata(NamedEntityMetadata&& from) noexcept
    : NamedEntityMetadata() {
    *this = ::std::move(from);
  }

  inline NamedEntityMetadata& operator=(const NamedEntityMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline NamedEntityMetadata& operator=(NamedEntityMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NamedEntityMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const NamedEntityMetadata* internal_default_instance() {
    return reinterpret_cast<const NamedEntityMetadata*>(
               &_NamedEntityMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(NamedEntityMetadata& a, NamedEntityMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(NamedEntityMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NamedEntityMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NamedEntityMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NamedEntityMetadata>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NamedEntityMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.admin.NamedEntityMetadata";
  }
  protected:
  explicit NamedEntityMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDescriptionFieldNumber = 1,
    kStateFieldNumber = 2,
  };
  // string description = 1 [json_name = "description"];
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // .flyteidl.admin.NamedEntityState state = 2 [json_name = "state"];
  void clear_state();
  ::flyteidl::admin::NamedEntityState state() const;
  void set_state(::flyteidl::admin::NamedEntityState value);
  private:
  ::flyteidl::admin::NamedEntityState _internal_state() const;
  void _internal_set_state(::flyteidl::admin::NamedEntityState value);
  public:

  // @@protoc_insertion_point(class_scope:flyteidl.admin.NamedEntityMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  int state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fadmin_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class NamedEntity final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.admin.NamedEntity) */ {
 public:
  inline NamedEntity() : NamedEntity(nullptr) {}
  ~NamedEntity() override;
  explicit constexpr NamedEntity(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NamedEntity(const NamedEntity& from);
  NamedEntity(NamedEntity&& from) noexcept
    : NamedEntity() {
    *this = ::std::move(from);
  }

  inline NamedEntity& operator=(const NamedEntity& from) {
    CopyFrom(from);
    return *this;
  }
  inline NamedEntity& operator=(NamedEntity&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NamedEntity& default_instance() {
    return *internal_default_instance();
  }
  static inline const NamedEntity* internal_default_instance() {
    return reinterpret_cast<const NamedEntity*>(
               &_NamedEntity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(NamedEntity& a, NamedEntity& b) {
    a.Swap(&b);
  }
  inline void Swap(NamedEntity* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NamedEntity* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NamedEntity* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NamedEntity>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NamedEntity* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.admin.NamedEntity";
  }
  protected:
  explicit NamedEntity(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 2,
    kMetadataFieldNumber = 3,
    kResourceTypeFieldNumber = 1,
  };
  // .flyteidl.admin.NamedEntityIdentifier id = 2 [json_name = "id"];
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::flyteidl::admin::NamedEntityIdentifier& id() const;
  PROTOBUF_NODISCARD ::flyteidl::admin::NamedEntityIdentifier* release_id();
  ::flyteidl::admin::NamedEntityIdentifier* mutable_id();
  void set_allocated_id(::flyteidl::admin::NamedEntityIdentifier* id);
  private:
  const ::flyteidl::admin::NamedEntityIdentifier& _internal_id() const;
  ::flyteidl::admin::NamedEntityIdentifier* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::flyteidl::admin::NamedEntityIdentifier* id);
  ::flyteidl::admin::NamedEntityIdentifier* unsafe_arena_release_id();

  // .flyteidl.admin.NamedEntityMetadata metadata = 3 [json_name = "metadata"];
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::flyteidl::admin::NamedEntityMetadata& metadata() const;
  PROTOBUF_NODISCARD ::flyteidl::admin::NamedEntityMetadata* release_metadata();
  ::flyteidl::admin::NamedEntityMetadata* mutable_metadata();
  void set_allocated_metadata(::flyteidl::admin::NamedEntityMetadata* metadata);
  private:
  const ::flyteidl::admin::NamedEntityMetadata& _internal_metadata() const;
  ::flyteidl::admin::NamedEntityMetadata* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::flyteidl::admin::NamedEntityMetadata* metadata);
  ::flyteidl::admin::NamedEntityMetadata* unsafe_arena_release_metadata();

  // .flyteidl.core.ResourceType resource_type = 1 [json_name = "resourceType"];
  void clear_resource_type();
  ::flyteidl::core::ResourceType resource_type() const;
  void set_resource_type(::flyteidl::core::ResourceType value);
  private:
  ::flyteidl::core::ResourceType _internal_resource_type() const;
  void _internal_set_resource_type(::flyteidl::core::ResourceType value);
  public:

  // @@protoc_insertion_point(class_scope:flyteidl.admin.NamedEntity)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::flyteidl::admin::NamedEntityIdentifier* id_;
  ::flyteidl::admin::NamedEntityMetadata* metadata_;
  int resource_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fadmin_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class Sort final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.admin.Sort) */ {
 public:
  inline Sort() : Sort(nullptr) {}
  ~Sort() override;
  explicit constexpr Sort(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Sort(const Sort& from);
  Sort(Sort&& from) noexcept
    : Sort() {
    *this = ::std::move(from);
  }

  inline Sort& operator=(const Sort& from) {
    CopyFrom(from);
    return *this;
  }
  inline Sort& operator=(Sort&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Sort& default_instance() {
    return *internal_default_instance();
  }
  static inline const Sort* internal_default_instance() {
    return reinterpret_cast<const Sort*>(
               &_Sort_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Sort& a, Sort& b) {
    a.Swap(&b);
  }
  inline void Swap(Sort* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Sort* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Sort* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Sort>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Sort* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.admin.Sort";
  }
  protected:
  explicit Sort(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Sort_Direction Direction;
  static constexpr Direction DESCENDING =
    Sort_Direction_DESCENDING;
  static constexpr Direction ASCENDING =
    Sort_Direction_ASCENDING;
  static inline bool Direction_IsValid(int value) {
    return Sort_Direction_IsValid(value);
  }
  static constexpr Direction Direction_MIN =
    Sort_Direction_Direction_MIN;
  static constexpr Direction Direction_MAX =
    Sort_Direction_Direction_MAX;
  static constexpr int Direction_ARRAYSIZE =
    Sort_Direction_Direction_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Direction_descriptor() {
    return Sort_Direction_descriptor();
  }
  template<typename T>
  static inline const std::string& Direction_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Direction>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Direction_Name.");
    return Sort_Direction_Name(enum_t_value);
  }
  static inline bool Direction_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Direction* value) {
    return Sort_Direction_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kDirectionFieldNumber = 2,
  };
  // string key = 1 [json_name = "key"];
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // .flyteidl.admin.Sort.Direction direction = 2 [json_name = "direction"];
  void clear_direction();
  ::flyteidl::admin::Sort_Direction direction() const;
  void set_direction(::flyteidl::admin::Sort_Direction value);
  private:
  ::flyteidl::admin::Sort_Direction _internal_direction() const;
  void _internal_set_direction(::flyteidl::admin::Sort_Direction value);
  public:

  // @@protoc_insertion_point(class_scope:flyteidl.admin.Sort)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  int direction_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fadmin_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class NamedEntityIdentifierListRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.admin.NamedEntityIdentifierListRequest) */ {
 public:
  inline NamedEntityIdentifierListRequest() : NamedEntityIdentifierListRequest(nullptr) {}
  ~NamedEntityIdentifierListRequest() override;
  explicit constexpr NamedEntityIdentifierListRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NamedEntityIdentifierListRequest(const NamedEntityIdentifierListRequest& from);
  NamedEntityIdentifierListRequest(NamedEntityIdentifierListRequest&& from) noexcept
    : NamedEntityIdentifierListRequest() {
    *this = ::std::move(from);
  }

  inline NamedEntityIdentifierListRequest& operator=(const NamedEntityIdentifierListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NamedEntityIdentifierListRequest& operator=(NamedEntityIdentifierListRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NamedEntityIdentifierListRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NamedEntityIdentifierListRequest* internal_default_instance() {
    return reinterpret_cast<const NamedEntityIdentifierListRequest*>(
               &_NamedEntityIdentifierListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(NamedEntityIdentifierListRequest& a, NamedEntityIdentifierListRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NamedEntityIdentifierListRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NamedEntityIdentifierListRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NamedEntityIdentifierListRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NamedEntityIdentifierListRequest>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NamedEntityIdentifierListRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.admin.NamedEntityIdentifierListRequest";
  }
  protected:
  explicit NamedEntityIdentifierListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProjectFieldNumber = 1,
    kDomainFieldNumber = 2,
    kTokenFieldNumber = 4,
    kFiltersFieldNumber = 6,
    kSortByFieldNumber = 5,
    kLimitFieldNumber = 3,
  };
  // string project = 1 [json_name = "project"];
  void clear_project();
  const std::string& project() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_project(ArgT0&& arg0, ArgT... args);
  std::string* mutable_project();
  PROTOBUF_NODISCARD std::string* release_project();
  void set_allocated_project(std::string* project);
  private:
  const std::string& _internal_project() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_project(const std::string& value);
  std::string* _internal_mutable_project();
  public:

  // string domain = 2 [json_name = "domain"];
  void clear_domain();
  const std::string& domain() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_domain(ArgT0&& arg0, ArgT... args);
  std::string* mutable_domain();
  PROTOBUF_NODISCARD std::string* release_domain();
  void set_allocated_domain(std::string* domain);
  private:
  const std::string& _internal_domain() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_domain(const std::string& value);
  std::string* _internal_mutable_domain();
  public:

  // string token = 4 [json_name = "token"];
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // string filters = 6 [json_name = "filters"];
  void clear_filters();
  const std::string& filters() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filters(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filters();
  PROTOBUF_NODISCARD std::string* release_filters();
  void set_allocated_filters(std::string* filters);
  private:
  const std::string& _internal_filters() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filters(const std::string& value);
  std::string* _internal_mutable_filters();
  public:

  // .flyteidl.admin.Sort sort_by = 5 [json_name = "sortBy"];
  bool has_sort_by() const;
  private:
  bool _internal_has_sort_by() const;
  public:
  void clear_sort_by();
  const ::flyteidl::admin::Sort& sort_by() const;
  PROTOBUF_NODISCARD ::flyteidl::admin::Sort* release_sort_by();
  ::flyteidl::admin::Sort* mutable_sort_by();
  void set_allocated_sort_by(::flyteidl::admin::Sort* sort_by);
  private:
  const ::flyteidl::admin::Sort& _internal_sort_by() const;
  ::flyteidl::admin::Sort* _internal_mutable_sort_by();
  public:
  void unsafe_arena_set_allocated_sort_by(
      ::flyteidl::admin::Sort* sort_by);
  ::flyteidl::admin::Sort* unsafe_arena_release_sort_by();

  // uint32 limit = 3 [json_name = "limit"];
  void clear_limit();
  uint32_t limit() const;
  void set_limit(uint32_t value);
  private:
  uint32_t _internal_limit() const;
  void _internal_set_limit(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:flyteidl.admin.NamedEntityIdentifierListRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr project_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr domain_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filters_;
  ::flyteidl::admin::Sort* sort_by_;
  uint32_t limit_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fadmin_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class NamedEntityListRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.admin.NamedEntityListRequest) */ {
 public:
  inline NamedEntityListRequest() : NamedEntityListRequest(nullptr) {}
  ~NamedEntityListRequest() override;
  explicit constexpr NamedEntityListRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NamedEntityListRequest(const NamedEntityListRequest& from);
  NamedEntityListRequest(NamedEntityListRequest&& from) noexcept
    : NamedEntityListRequest() {
    *this = ::std::move(from);
  }

  inline NamedEntityListRequest& operator=(const NamedEntityListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NamedEntityListRequest& operator=(NamedEntityListRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NamedEntityListRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NamedEntityListRequest* internal_default_instance() {
    return reinterpret_cast<const NamedEntityListRequest*>(
               &_NamedEntityListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(NamedEntityListRequest& a, NamedEntityListRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NamedEntityListRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NamedEntityListRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NamedEntityListRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NamedEntityListRequest>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NamedEntityListRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.admin.NamedEntityListRequest";
  }
  protected:
  explicit NamedEntityListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProjectFieldNumber = 2,
    kDomainFieldNumber = 3,
    kTokenFieldNumber = 5,
    kFiltersFieldNumber = 7,
    kSortByFieldNumber = 6,
    kResourceTypeFieldNumber = 1,
    kLimitFieldNumber = 4,
  };
  // string project = 2 [json_name = "project"];
  void clear_project();
  const std::string& project() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_project(ArgT0&& arg0, ArgT... args);
  std::string* mutable_project();
  PROTOBUF_NODISCARD std::string* release_project();
  void set_allocated_project(std::string* project);
  private:
  const std::string& _internal_project() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_project(const std::string& value);
  std::string* _internal_mutable_project();
  public:

  // string domain = 3 [json_name = "domain"];
  void clear_domain();
  const std::string& domain() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_domain(ArgT0&& arg0, ArgT... args);
  std::string* mutable_domain();
  PROTOBUF_NODISCARD std::string* release_domain();
  void set_allocated_domain(std::string* domain);
  private:
  const std::string& _internal_domain() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_domain(const std::string& value);
  std::string* _internal_mutable_domain();
  public:

  // string token = 5 [json_name = "token"];
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // string filters = 7 [json_name = "filters"];
  void clear_filters();
  const std::string& filters() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filters(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filters();
  PROTOBUF_NODISCARD std::string* release_filters();
  void set_allocated_filters(std::string* filters);
  private:
  const std::string& _internal_filters() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filters(const std::string& value);
  std::string* _internal_mutable_filters();
  public:

  // .flyteidl.admin.Sort sort_by = 6 [json_name = "sortBy"];
  bool has_sort_by() const;
  private:
  bool _internal_has_sort_by() const;
  public:
  void clear_sort_by();
  const ::flyteidl::admin::Sort& sort_by() const;
  PROTOBUF_NODISCARD ::flyteidl::admin::Sort* release_sort_by();
  ::flyteidl::admin::Sort* mutable_sort_by();
  void set_allocated_sort_by(::flyteidl::admin::Sort* sort_by);
  private:
  const ::flyteidl::admin::Sort& _internal_sort_by() const;
  ::flyteidl::admin::Sort* _internal_mutable_sort_by();
  public:
  void unsafe_arena_set_allocated_sort_by(
      ::flyteidl::admin::Sort* sort_by);
  ::flyteidl::admin::Sort* unsafe_arena_release_sort_by();

  // .flyteidl.core.ResourceType resource_type = 1 [json_name = "resourceType"];
  void clear_resource_type();
  ::flyteidl::core::ResourceType resource_type() const;
  void set_resource_type(::flyteidl::core::ResourceType value);
  private:
  ::flyteidl::core::ResourceType _internal_resource_type() const;
  void _internal_set_resource_type(::flyteidl::core::ResourceType value);
  public:

  // uint32 limit = 4 [json_name = "limit"];
  void clear_limit();
  uint32_t limit() const;
  void set_limit(uint32_t value);
  private:
  uint32_t _internal_limit() const;
  void _internal_set_limit(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:flyteidl.admin.NamedEntityListRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr project_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr domain_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filters_;
  ::flyteidl::admin::Sort* sort_by_;
  int resource_type_;
  uint32_t limit_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fadmin_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class NamedEntityIdentifierList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.admin.NamedEntityIdentifierList) */ {
 public:
  inline NamedEntityIdentifierList() : NamedEntityIdentifierList(nullptr) {}
  ~NamedEntityIdentifierList() override;
  explicit constexpr NamedEntityIdentifierList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NamedEntityIdentifierList(const NamedEntityIdentifierList& from);
  NamedEntityIdentifierList(NamedEntityIdentifierList&& from) noexcept
    : NamedEntityIdentifierList() {
    *this = ::std::move(from);
  }

  inline NamedEntityIdentifierList& operator=(const NamedEntityIdentifierList& from) {
    CopyFrom(from);
    return *this;
  }
  inline NamedEntityIdentifierList& operator=(NamedEntityIdentifierList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NamedEntityIdentifierList& default_instance() {
    return *internal_default_instance();
  }
  static inline const NamedEntityIdentifierList* internal_default_instance() {
    return reinterpret_cast<const NamedEntityIdentifierList*>(
               &_NamedEntityIdentifierList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(NamedEntityIdentifierList& a, NamedEntityIdentifierList& b) {
    a.Swap(&b);
  }
  inline void Swap(NamedEntityIdentifierList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NamedEntityIdentifierList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NamedEntityIdentifierList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NamedEntityIdentifierList>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NamedEntityIdentifierList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.admin.NamedEntityIdentifierList";
  }
  protected:
  explicit NamedEntityIdentifierList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntitiesFieldNumber = 1,
    kTokenFieldNumber = 2,
  };
  // repeated .flyteidl.admin.NamedEntityIdentifier entities = 1 [json_name = "entities"];
  int entities_size() const;
  private:
  int _internal_entities_size() const;
  public:
  void clear_entities();
  ::flyteidl::admin::NamedEntityIdentifier* mutable_entities(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::admin::NamedEntityIdentifier >*
      mutable_entities();
  private:
  const ::flyteidl::admin::NamedEntityIdentifier& _internal_entities(int index) const;
  ::flyteidl::admin::NamedEntityIdentifier* _internal_add_entities();
  public:
  const ::flyteidl::admin::NamedEntityIdentifier& entities(int index) const;
  ::flyteidl::admin::NamedEntityIdentifier* add_entities();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::admin::NamedEntityIdentifier >&
      entities() const;

  // string token = 2 [json_name = "token"];
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // @@protoc_insertion_point(class_scope:flyteidl.admin.NamedEntityIdentifierList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::admin::NamedEntityIdentifier > entities_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fadmin_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class NamedEntityList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.admin.NamedEntityList) */ {
 public:
  inline NamedEntityList() : NamedEntityList(nullptr) {}
  ~NamedEntityList() override;
  explicit constexpr NamedEntityList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NamedEntityList(const NamedEntityList& from);
  NamedEntityList(NamedEntityList&& from) noexcept
    : NamedEntityList() {
    *this = ::std::move(from);
  }

  inline NamedEntityList& operator=(const NamedEntityList& from) {
    CopyFrom(from);
    return *this;
  }
  inline NamedEntityList& operator=(NamedEntityList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NamedEntityList& default_instance() {
    return *internal_default_instance();
  }
  static inline const NamedEntityList* internal_default_instance() {
    return reinterpret_cast<const NamedEntityList*>(
               &_NamedEntityList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(NamedEntityList& a, NamedEntityList& b) {
    a.Swap(&b);
  }
  inline void Swap(NamedEntityList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NamedEntityList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NamedEntityList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NamedEntityList>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NamedEntityList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.admin.NamedEntityList";
  }
  protected:
  explicit NamedEntityList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntitiesFieldNumber = 1,
    kTokenFieldNumber = 2,
  };
  // repeated .flyteidl.admin.NamedEntity entities = 1 [json_name = "entities"];
  int entities_size() const;
  private:
  int _internal_entities_size() const;
  public:
  void clear_entities();
  ::flyteidl::admin::NamedEntity* mutable_entities(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::admin::NamedEntity >*
      mutable_entities();
  private:
  const ::flyteidl::admin::NamedEntity& _internal_entities(int index) const;
  ::flyteidl::admin::NamedEntity* _internal_add_entities();
  public:
  const ::flyteidl::admin::NamedEntity& entities(int index) const;
  ::flyteidl::admin::NamedEntity* add_entities();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::admin::NamedEntity >&
      entities() const;

  // string token = 2 [json_name = "token"];
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // @@protoc_insertion_point(class_scope:flyteidl.admin.NamedEntityList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::admin::NamedEntity > entities_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fadmin_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class NamedEntityGetRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.admin.NamedEntityGetRequest) */ {
 public:
  inline NamedEntityGetRequest() : NamedEntityGetRequest(nullptr) {}
  ~NamedEntityGetRequest() override;
  explicit constexpr NamedEntityGetRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NamedEntityGetRequest(const NamedEntityGetRequest& from);
  NamedEntityGetRequest(NamedEntityGetRequest&& from) noexcept
    : NamedEntityGetRequest() {
    *this = ::std::move(from);
  }

  inline NamedEntityGetRequest& operator=(const NamedEntityGetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NamedEntityGetRequest& operator=(NamedEntityGetRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NamedEntityGetRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NamedEntityGetRequest* internal_default_instance() {
    return reinterpret_cast<const NamedEntityGetRequest*>(
               &_NamedEntityGetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(NamedEntityGetRequest& a, NamedEntityGetRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NamedEntityGetRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NamedEntityGetRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NamedEntityGetRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NamedEntityGetRequest>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NamedEntityGetRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.admin.NamedEntityGetRequest";
  }
  protected:
  explicit NamedEntityGetRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 2,
    kResourceTypeFieldNumber = 1,
  };
  // .flyteidl.admin.NamedEntityIdentifier id = 2 [json_name = "id"];
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::flyteidl::admin::NamedEntityIdentifier& id() const;
  PROTOBUF_NODISCARD ::flyteidl::admin::NamedEntityIdentifier* release_id();
  ::flyteidl::admin::NamedEntityIdentifier* mutable_id();
  void set_allocated_id(::flyteidl::admin::NamedEntityIdentifier* id);
  private:
  const ::flyteidl::admin::NamedEntityIdentifier& _internal_id() const;
  ::flyteidl::admin::NamedEntityIdentifier* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::flyteidl::admin::NamedEntityIdentifier* id);
  ::flyteidl::admin::NamedEntityIdentifier* unsafe_arena_release_id();

  // .flyteidl.core.ResourceType resource_type = 1 [json_name = "resourceType"];
  void clear_resource_type();
  ::flyteidl::core::ResourceType resource_type() const;
  void set_resource_type(::flyteidl::core::ResourceType value);
  private:
  ::flyteidl::core::ResourceType _internal_resource_type() const;
  void _internal_set_resource_type(::flyteidl::core::ResourceType value);
  public:

  // @@protoc_insertion_point(class_scope:flyteidl.admin.NamedEntityGetRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::flyteidl::admin::NamedEntityIdentifier* id_;
  int resource_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fadmin_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class NamedEntityUpdateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.admin.NamedEntityUpdateRequest) */ {
 public:
  inline NamedEntityUpdateRequest() : NamedEntityUpdateRequest(nullptr) {}
  ~NamedEntityUpdateRequest() override;
  explicit constexpr NamedEntityUpdateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NamedEntityUpdateRequest(const NamedEntityUpdateRequest& from);
  NamedEntityUpdateRequest(NamedEntityUpdateRequest&& from) noexcept
    : NamedEntityUpdateRequest() {
    *this = ::std::move(from);
  }

  inline NamedEntityUpdateRequest& operator=(const NamedEntityUpdateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NamedEntityUpdateRequest& operator=(NamedEntityUpdateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NamedEntityUpdateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NamedEntityUpdateRequest* internal_default_instance() {
    return reinterpret_cast<const NamedEntityUpdateRequest*>(
               &_NamedEntityUpdateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(NamedEntityUpdateRequest& a, NamedEntityUpdateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NamedEntityUpdateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NamedEntityUpdateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NamedEntityUpdateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NamedEntityUpdateRequest>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NamedEntityUpdateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.admin.NamedEntityUpdateRequest";
  }
  protected:
  explicit NamedEntityUpdateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 2,
    kMetadataFieldNumber = 3,
    kResourceTypeFieldNumber = 1,
  };
  // .flyteidl.admin.NamedEntityIdentifier id = 2 [json_name = "id"];
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::flyteidl::admin::NamedEntityIdentifier& id() const;
  PROTOBUF_NODISCARD ::flyteidl::admin::NamedEntityIdentifier* release_id();
  ::flyteidl::admin::NamedEntityIdentifier* mutable_id();
  void set_allocated_id(::flyteidl::admin::NamedEntityIdentifier* id);
  private:
  const ::flyteidl::admin::NamedEntityIdentifier& _internal_id() const;
  ::flyteidl::admin::NamedEntityIdentifier* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::flyteidl::admin::NamedEntityIdentifier* id);
  ::flyteidl::admin::NamedEntityIdentifier* unsafe_arena_release_id();

  // .flyteidl.admin.NamedEntityMetadata metadata = 3 [json_name = "metadata"];
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::flyteidl::admin::NamedEntityMetadata& metadata() const;
  PROTOBUF_NODISCARD ::flyteidl::admin::NamedEntityMetadata* release_metadata();
  ::flyteidl::admin::NamedEntityMetadata* mutable_metadata();
  void set_allocated_metadata(::flyteidl::admin::NamedEntityMetadata* metadata);
  private:
  const ::flyteidl::admin::NamedEntityMetadata& _internal_metadata() const;
  ::flyteidl::admin::NamedEntityMetadata* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::flyteidl::admin::NamedEntityMetadata* metadata);
  ::flyteidl::admin::NamedEntityMetadata* unsafe_arena_release_metadata();

  // .flyteidl.core.ResourceType resource_type = 1 [json_name = "resourceType"];
  void clear_resource_type();
  ::flyteidl::core::ResourceType resource_type() const;
  void set_resource_type(::flyteidl::core::ResourceType value);
  private:
  ::flyteidl::core::ResourceType _internal_resource_type() const;
  void _internal_set_resource_type(::flyteidl::core::ResourceType value);
  public:

  // @@protoc_insertion_point(class_scope:flyteidl.admin.NamedEntityUpdateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::flyteidl::admin::NamedEntityIdentifier* id_;
  ::flyteidl::admin::NamedEntityMetadata* metadata_;
  int resource_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fadmin_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class NamedEntityUpdateResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:flyteidl.admin.NamedEntityUpdateResponse) */ {
 public:
  inline NamedEntityUpdateResponse() : NamedEntityUpdateResponse(nullptr) {}
  explicit constexpr NamedEntityUpdateResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NamedEntityUpdateResponse(const NamedEntityUpdateResponse& from);
  NamedEntityUpdateResponse(NamedEntityUpdateResponse&& from) noexcept
    : NamedEntityUpdateResponse() {
    *this = ::std::move(from);
  }

  inline NamedEntityUpdateResponse& operator=(const NamedEntityUpdateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NamedEntityUpdateResponse& operator=(NamedEntityUpdateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NamedEntityUpdateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const NamedEntityUpdateResponse* internal_default_instance() {
    return reinterpret_cast<const NamedEntityUpdateResponse*>(
               &_NamedEntityUpdateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(NamedEntityUpdateResponse& a, NamedEntityUpdateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NamedEntityUpdateResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NamedEntityUpdateResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NamedEntityUpdateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NamedEntityUpdateResponse>(arena);
  }

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.admin.NamedEntityUpdateResponse";
  }
  protected:
  explicit NamedEntityUpdateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:flyteidl.admin.NamedEntityUpdateResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fadmin_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class ObjectGetRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.admin.ObjectGetRequest) */ {
 public:
  inline ObjectGetRequest() : ObjectGetRequest(nullptr) {}
  ~ObjectGetRequest() override;
  explicit constexpr ObjectGetRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObjectGetRequest(const ObjectGetRequest& from);
  ObjectGetRequest(ObjectGetRequest&& from) noexcept
    : ObjectGetRequest() {
    *this = ::std::move(from);
  }

  inline ObjectGetRequest& operator=(const ObjectGetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectGetRequest& operator=(ObjectGetRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectGetRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObjectGetRequest* internal_default_instance() {
    return reinterpret_cast<const ObjectGetRequest*>(
               &_ObjectGetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ObjectGetRequest& a, ObjectGetRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectGetRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectGetRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjectGetRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObjectGetRequest>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectGetRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.admin.ObjectGetRequest";
  }
  protected:
  explicit ObjectGetRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // .flyteidl.core.Identifier id = 1 [json_name = "id"];
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::flyteidl::core::Identifier& id() const;
  PROTOBUF_NODISCARD ::flyteidl::core::Identifier* release_id();
  ::flyteidl::core::Identifier* mutable_id();
  void set_allocated_id(::flyteidl::core::Identifier* id);
  private:
  const ::flyteidl::core::Identifier& _internal_id() const;
  ::flyteidl::core::Identifier* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::flyteidl::core::Identifier* id);
  ::flyteidl::core::Identifier* unsafe_arena_release_id();

  // @@protoc_insertion_point(class_scope:flyteidl.admin.ObjectGetRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::flyteidl::core::Identifier* id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fadmin_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class ResourceListRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.admin.ResourceListRequest) */ {
 public:
  inline ResourceListRequest() : ResourceListRequest(nullptr) {}
  ~ResourceListRequest() override;
  explicit constexpr ResourceListRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResourceListRequest(const ResourceListRequest& from);
  ResourceListRequest(ResourceListRequest&& from) noexcept
    : ResourceListRequest() {
    *this = ::std::move(from);
  }

  inline ResourceListRequest& operator=(const ResourceListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResourceListRequest& operator=(ResourceListRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResourceListRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResourceListRequest* internal_default_instance() {
    return reinterpret_cast<const ResourceListRequest*>(
               &_ResourceListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ResourceListRequest& a, ResourceListRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ResourceListRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResourceListRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResourceListRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResourceListRequest>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResourceListRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.admin.ResourceListRequest";
  }
  protected:
  explicit ResourceListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 3,
    kFiltersFieldNumber = 4,
    kIdFieldNumber = 1,
    kSortByFieldNumber = 5,
    kLimitFieldNumber = 2,
  };
  // string token = 3 [json_name = "token"];
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // string filters = 4 [json_name = "filters"];
  void clear_filters();
  const std::string& filters() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filters(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filters();
  PROTOBUF_NODISCARD std::string* release_filters();
  void set_allocated_filters(std::string* filters);
  private:
  const std::string& _internal_filters() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filters(const std::string& value);
  std::string* _internal_mutable_filters();
  public:

  // .flyteidl.admin.NamedEntityIdentifier id = 1 [json_name = "id"];
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::flyteidl::admin::NamedEntityIdentifier& id() const;
  PROTOBUF_NODISCARD ::flyteidl::admin::NamedEntityIdentifier* release_id();
  ::flyteidl::admin::NamedEntityIdentifier* mutable_id();
  void set_allocated_id(::flyteidl::admin::NamedEntityIdentifier* id);
  private:
  const ::flyteidl::admin::NamedEntityIdentifier& _internal_id() const;
  ::flyteidl::admin::NamedEntityIdentifier* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::flyteidl::admin::NamedEntityIdentifier* id);
  ::flyteidl::admin::NamedEntityIdentifier* unsafe_arena_release_id();

  // .flyteidl.admin.Sort sort_by = 5 [json_name = "sortBy"];
  bool has_sort_by() const;
  private:
  bool _internal_has_sort_by() const;
  public:
  void clear_sort_by();
  const ::flyteidl::admin::Sort& sort_by() const;
  PROTOBUF_NODISCARD ::flyteidl::admin::Sort* release_sort_by();
  ::flyteidl::admin::Sort* mutable_sort_by();
  void set_allocated_sort_by(::flyteidl::admin::Sort* sort_by);
  private:
  const ::flyteidl::admin::Sort& _internal_sort_by() const;
  ::flyteidl::admin::Sort* _internal_mutable_sort_by();
  public:
  void unsafe_arena_set_allocated_sort_by(
      ::flyteidl::admin::Sort* sort_by);
  ::flyteidl::admin::Sort* unsafe_arena_release_sort_by();

  // uint32 limit = 2 [json_name = "limit"];
  void clear_limit();
  uint32_t limit() const;
  void set_limit(uint32_t value);
  private:
  uint32_t _internal_limit() const;
  void _internal_set_limit(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:flyteidl.admin.ResourceListRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filters_;
  ::flyteidl::admin::NamedEntityIdentifier* id_;
  ::flyteidl::admin::Sort* sort_by_;
  uint32_t limit_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fadmin_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class EmailNotification final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.admin.EmailNotification) */ {
 public:
  inline EmailNotification() : EmailNotification(nullptr) {}
  ~EmailNotification() override;
  explicit constexpr EmailNotification(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EmailNotification(const EmailNotification& from);
  EmailNotification(EmailNotification&& from) noexcept
    : EmailNotification() {
    *this = ::std::move(from);
  }

  inline EmailNotification& operator=(const EmailNotification& from) {
    CopyFrom(from);
    return *this;
  }
  inline EmailNotification& operator=(EmailNotification&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EmailNotification& default_instance() {
    return *internal_default_instance();
  }
  static inline const EmailNotification* internal_default_instance() {
    return reinterpret_cast<const EmailNotification*>(
               &_EmailNotification_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(EmailNotification& a, EmailNotification& b) {
    a.Swap(&b);
  }
  inline void Swap(EmailNotification* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EmailNotification* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EmailNotification* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EmailNotification>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EmailNotification* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.admin.EmailNotification";
  }
  protected:
  explicit EmailNotification(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRecipientsEmailFieldNumber = 1,
  };
  // repeated string recipients_email = 1 [json_name = "recipientsEmail"];
  int recipients_email_size() const;
  private:
  int _internal_recipients_email_size() const;
  public:
  void clear_recipients_email();
  const std::string& recipients_email(int index) const;
  std::string* mutable_recipients_email(int index);
  void set_recipients_email(int index, const std::string& value);
  void set_recipients_email(int index, std::string&& value);
  void set_recipients_email(int index, const char* value);
  void set_recipients_email(int index, const char* value, size_t size);
  std::string* add_recipients_email();
  void add_recipients_email(const std::string& value);
  void add_recipients_email(std::string&& value);
  void add_recipients_email(const char* value);
  void add_recipients_email(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& recipients_email() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_recipients_email();
  private:
  const std::string& _internal_recipients_email(int index) const;
  std::string* _internal_add_recipients_email();
  public:

  // @@protoc_insertion_point(class_scope:flyteidl.admin.EmailNotification)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> recipients_email_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fadmin_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class PagerDutyNotification final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.admin.PagerDutyNotification) */ {
 public:
  inline PagerDutyNotification() : PagerDutyNotification(nullptr) {}
  ~PagerDutyNotification() override;
  explicit constexpr PagerDutyNotification(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PagerDutyNotification(const PagerDutyNotification& from);
  PagerDutyNotification(PagerDutyNotification&& from) noexcept
    : PagerDutyNotification() {
    *this = ::std::move(from);
  }

  inline PagerDutyNotification& operator=(const PagerDutyNotification& from) {
    CopyFrom(from);
    return *this;
  }
  inline PagerDutyNotification& operator=(PagerDutyNotification&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PagerDutyNotification& default_instance() {
    return *internal_default_instance();
  }
  static inline const PagerDutyNotification* internal_default_instance() {
    return reinterpret_cast<const PagerDutyNotification*>(
               &_PagerDutyNotification_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(PagerDutyNotification& a, PagerDutyNotification& b) {
    a.Swap(&b);
  }
  inline void Swap(PagerDutyNotification* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PagerDutyNotification* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PagerDutyNotification* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PagerDutyNotification>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PagerDutyNotification* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.admin.PagerDutyNotification";
  }
  protected:
  explicit PagerDutyNotification(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRecipientsEmailFieldNumber = 1,
  };
  // repeated string recipients_email = 1 [json_name = "recipientsEmail"];
  int recipients_email_size() const;
  private:
  int _internal_recipients_email_size() const;
  public:
  void clear_recipients_email();
  const std::string& recipients_email(int index) const;
  std::string* mutable_recipients_email(int index);
  void set_recipients_email(int index, const std::string& value);
  void set_recipients_email(int index, std::string&& value);
  void set_recipients_email(int index, const char* value);
  void set_recipients_email(int index, const char* value, size_t size);
  std::string* add_recipients_email();
  void add_recipients_email(const std::string& value);
  void add_recipients_email(std::string&& value);
  void add_recipients_email(const char* value);
  void add_recipients_email(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& recipients_email() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_recipients_email();
  private:
  const std::string& _internal_recipients_email(int index) const;
  std::string* _internal_add_recipients_email();
  public:

  // @@protoc_insertion_point(class_scope:flyteidl.admin.PagerDutyNotification)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> recipients_email_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fadmin_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class SlackNotification final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.admin.SlackNotification) */ {
 public:
  inline SlackNotification() : SlackNotification(nullptr) {}
  ~SlackNotification() override;
  explicit constexpr SlackNotification(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SlackNotification(const SlackNotification& from);
  SlackNotification(SlackNotification&& from) noexcept
    : SlackNotification() {
    *this = ::std::move(from);
  }

  inline SlackNotification& operator=(const SlackNotification& from) {
    CopyFrom(from);
    return *this;
  }
  inline SlackNotification& operator=(SlackNotification&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SlackNotification& default_instance() {
    return *internal_default_instance();
  }
  static inline const SlackNotification* internal_default_instance() {
    return reinterpret_cast<const SlackNotification*>(
               &_SlackNotification_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(SlackNotification& a, SlackNotification& b) {
    a.Swap(&b);
  }
  inline void Swap(SlackNotification* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SlackNotification* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SlackNotification* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SlackNotification>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SlackNotification* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.admin.SlackNotification";
  }
  protected:
  explicit SlackNotification(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRecipientsEmailFieldNumber = 1,
  };
  // repeated string recipients_email = 1 [json_name = "recipientsEmail"];
  int recipients_email_size() const;
  private:
  int _internal_recipients_email_size() const;
  public:
  void clear_recipients_email();
  const std::string& recipients_email(int index) const;
  std::string* mutable_recipients_email(int index);
  void set_recipients_email(int index, const std::string& value);
  void set_recipients_email(int index, std::string&& value);
  void set_recipients_email(int index, const char* value);
  void set_recipients_email(int index, const char* value, size_t size);
  std::string* add_recipients_email();
  void add_recipients_email(const std::string& value);
  void add_recipients_email(std::string&& value);
  void add_recipients_email(const char* value);
  void add_recipients_email(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& recipients_email() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_recipients_email();
  private:
  const std::string& _internal_recipients_email(int index) const;
  std::string* _internal_add_recipients_email();
  public:

  // @@protoc_insertion_point(class_scope:flyteidl.admin.SlackNotification)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> recipients_email_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fadmin_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class Notification final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.admin.Notification) */ {
 public:
  inline Notification() : Notification(nullptr) {}
  ~Notification() override;
  explicit constexpr Notification(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Notification(const Notification& from);
  Notification(Notification&& from) noexcept
    : Notification() {
    *this = ::std::move(from);
  }

  inline Notification& operator=(const Notification& from) {
    CopyFrom(from);
    return *this;
  }
  inline Notification& operator=(Notification&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Notification& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kEmail = 2,
    kPagerDuty = 3,
    kSlack = 4,
    TYPE_NOT_SET = 0,
  };

  static inline const Notification* internal_default_instance() {
    return reinterpret_cast<const Notification*>(
               &_Notification_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(Notification& a, Notification& b) {
    a.Swap(&b);
  }
  inline void Swap(Notification* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Notification* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Notification* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Notification>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Notification* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.admin.Notification";
  }
  protected:
  explicit Notification(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPhasesFieldNumber = 1,
    kEmailFieldNumber = 2,
    kPagerDutyFieldNumber = 3,
    kSlackFieldNumber = 4,
  };
  // repeated .flyteidl.core.WorkflowExecution.Phase phases = 1 [json_name = "phases"];
  int phases_size() const;
  private:
  int _internal_phases_size() const;
  public:
  void clear_phases();
  private:
  ::flyteidl::core::WorkflowExecution_Phase _internal_phases(int index) const;
  void _internal_add_phases(::flyteidl::core::WorkflowExecution_Phase value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_phases();
  public:
  ::flyteidl::core::WorkflowExecution_Phase phases(int index) const;
  void set_phases(int index, ::flyteidl::core::WorkflowExecution_Phase value);
  void add_phases(::flyteidl::core::WorkflowExecution_Phase value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& phases() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_phases();

  // .flyteidl.admin.EmailNotification email = 2 [json_name = "email"];
  bool has_email() const;
  private:
  bool _internal_has_email() const;
  public:
  void clear_email();
  const ::flyteidl::admin::EmailNotification& email() const;
  PROTOBUF_NODISCARD ::flyteidl::admin::EmailNotification* release_email();
  ::flyteidl::admin::EmailNotification* mutable_email();
  void set_allocated_email(::flyteidl::admin::EmailNotification* email);
  private:
  const ::flyteidl::admin::EmailNotification& _internal_email() const;
  ::flyteidl::admin::EmailNotification* _internal_mutable_email();
  public:
  void unsafe_arena_set_allocated_email(
      ::flyteidl::admin::EmailNotification* email);
  ::flyteidl::admin::EmailNotification* unsafe_arena_release_email();

  // .flyteidl.admin.PagerDutyNotification pager_duty = 3 [json_name = "pagerDuty"];
  bool has_pager_duty() const;
  private:
  bool _internal_has_pager_duty() const;
  public:
  void clear_pager_duty();
  const ::flyteidl::admin::PagerDutyNotification& pager_duty() const;
  PROTOBUF_NODISCARD ::flyteidl::admin::PagerDutyNotification* release_pager_duty();
  ::flyteidl::admin::PagerDutyNotification* mutable_pager_duty();
  void set_allocated_pager_duty(::flyteidl::admin::PagerDutyNotification* pager_duty);
  private:
  const ::flyteidl::admin::PagerDutyNotification& _internal_pager_duty() const;
  ::flyteidl::admin::PagerDutyNotification* _internal_mutable_pager_duty();
  public:
  void unsafe_arena_set_allocated_pager_duty(
      ::flyteidl::admin::PagerDutyNotification* pager_duty);
  ::flyteidl::admin::PagerDutyNotification* unsafe_arena_release_pager_duty();

  // .flyteidl.admin.SlackNotification slack = 4 [json_name = "slack"];
  bool has_slack() const;
  private:
  bool _internal_has_slack() const;
  public:
  void clear_slack();
  const ::flyteidl::admin::SlackNotification& slack() const;
  PROTOBUF_NODISCARD ::flyteidl::admin::SlackNotification* release_slack();
  ::flyteidl::admin::SlackNotification* mutable_slack();
  void set_allocated_slack(::flyteidl::admin::SlackNotification* slack);
  private:
  const ::flyteidl::admin::SlackNotification& _internal_slack() const;
  ::flyteidl::admin::SlackNotification* _internal_mutable_slack();
  public:
  void unsafe_arena_set_allocated_slack(
      ::flyteidl::admin::SlackNotification* slack);
  ::flyteidl::admin::SlackNotification* unsafe_arena_release_slack();

  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:flyteidl.admin.Notification)
 private:
  class _Internal;
  void set_has_email();
  void set_has_pager_duty();
  void set_has_slack();

  inline bool has_type() const;
  inline void clear_has_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> phases_;
  union TypeUnion {
    constexpr TypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::flyteidl::admin::EmailNotification* email_;
    ::flyteidl::admin::PagerDutyNotification* pager_duty_;
    ::flyteidl::admin::SlackNotification* slack_;
  } type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_flyteidl_2fadmin_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class UrlBlob final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.admin.UrlBlob) */ {
 public:
  inline UrlBlob() : UrlBlob(nullptr) {}
  ~UrlBlob() override;
  explicit constexpr UrlBlob(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UrlBlob(const UrlBlob& from);
  UrlBlob(UrlBlob&& from) noexcept
    : UrlBlob() {
    *this = ::std::move(from);
  }

  inline UrlBlob& operator=(const UrlBlob& from) {
    CopyFrom(from);
    return *this;
  }
  inline UrlBlob& operator=(UrlBlob&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UrlBlob& default_instance() {
    return *internal_default_instance();
  }
  static inline const UrlBlob* internal_default_instance() {
    return reinterpret_cast<const UrlBlob*>(
               &_UrlBlob_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(UrlBlob& a, UrlBlob& b) {
    a.Swap(&b);
  }
  inline void Swap(UrlBlob* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UrlBlob* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UrlBlob* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UrlBlob>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UrlBlob* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.admin.UrlBlob";
  }
  protected:
  explicit UrlBlob(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlFieldNumber = 1,
    kBytesFieldNumber = 2,
  };
  // string url = 1 [json_name = "url"];
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // int64 bytes = 2 [json_name = "bytes"];
  void clear_bytes();
  int64_t bytes() const;
  void set_bytes(int64_t value);
  private:
  int64_t _internal_bytes() const;
  void _internal_set_bytes(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:flyteidl.admin.UrlBlob)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  int64_t bytes_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fadmin_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class Labels_ValuesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Labels_ValuesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Labels_ValuesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  Labels_ValuesEntry_DoNotUse();
  explicit constexpr Labels_ValuesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Labels_ValuesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Labels_ValuesEntry_DoNotUse& other);
  static const Labels_ValuesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Labels_ValuesEntry_DoNotUse*>(&_Labels_ValuesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "flyteidl.admin.Labels.ValuesEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "flyteidl.admin.Labels.ValuesEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class Labels final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.admin.Labels) */ {
 public:
  inline Labels() : Labels(nullptr) {}
  ~Labels() override;
  explicit constexpr Labels(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Labels(const Labels& from);
  Labels(Labels&& from) noexcept
    : Labels() {
    *this = ::std::move(from);
  }

  inline Labels& operator=(const Labels& from) {
    CopyFrom(from);
    return *this;
  }
  inline Labels& operator=(Labels&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Labels& default_instance() {
    return *internal_default_instance();
  }
  static inline const Labels* internal_default_instance() {
    return reinterpret_cast<const Labels*>(
               &_Labels_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(Labels& a, Labels& b) {
    a.Swap(&b);
  }
  inline void Swap(Labels* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Labels* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Labels* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Labels>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Labels* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.admin.Labels";
  }
  protected:
  explicit Labels(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // map<string, string> values = 1 [json_name = "values"];
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_values() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_values();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      values() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:flyteidl.admin.Labels)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Labels_ValuesEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> values_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fadmin_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class Annotations_ValuesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Annotations_ValuesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Annotations_ValuesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  Annotations_ValuesEntry_DoNotUse();
  explicit constexpr Annotations_ValuesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Annotations_ValuesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Annotations_ValuesEntry_DoNotUse& other);
  static const Annotations_ValuesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Annotations_ValuesEntry_DoNotUse*>(&_Annotations_ValuesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "flyteidl.admin.Annotations.ValuesEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "flyteidl.admin.Annotations.ValuesEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class Annotations final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.admin.Annotations) */ {
 public:
  inline Annotations() : Annotations(nullptr) {}
  ~Annotations() override;
  explicit constexpr Annotations(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Annotations(const Annotations& from);
  Annotations(Annotations&& from) noexcept
    : Annotations() {
    *this = ::std::move(from);
  }

  inline Annotations& operator=(const Annotations& from) {
    CopyFrom(from);
    return *this;
  }
  inline Annotations& operator=(Annotations&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Annotations& default_instance() {
    return *internal_default_instance();
  }
  static inline const Annotations* internal_default_instance() {
    return reinterpret_cast<const Annotations*>(
               &_Annotations_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(Annotations& a, Annotations& b) {
    a.Swap(&b);
  }
  inline void Swap(Annotations* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Annotations* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Annotations* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Annotations>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Annotations* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.admin.Annotations";
  }
  protected:
  explicit Annotations(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // map<string, string> values = 1 [json_name = "values"];
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_values() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_values();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      values() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:flyteidl.admin.Annotations)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Annotations_ValuesEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> values_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fadmin_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class AuthRole final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.admin.AuthRole) */ {
 public:
  inline AuthRole() : AuthRole(nullptr) {}
  ~AuthRole() override;
  explicit constexpr AuthRole(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthRole(const AuthRole& from);
  AuthRole(AuthRole&& from) noexcept
    : AuthRole() {
    *this = ::std::move(from);
  }

  inline AuthRole& operator=(const AuthRole& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthRole& operator=(AuthRole&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthRole& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthRole* internal_default_instance() {
    return reinterpret_cast<const AuthRole*>(
               &_AuthRole_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(AuthRole& a, AuthRole& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthRole* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthRole* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthRole* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthRole>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthRole* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.admin.AuthRole";
  }
  protected:
  explicit AuthRole(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAssumableIamRoleFieldNumber = 1,
    kKubernetesServiceAccountFieldNumber = 2,
  };
  // string assumable_iam_role = 1 [json_name = "assumableIamRole"];
  void clear_assumable_iam_role();
  const std::string& assumable_iam_role() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_assumable_iam_role(ArgT0&& arg0, ArgT... args);
  std::string* mutable_assumable_iam_role();
  PROTOBUF_NODISCARD std::string* release_assumable_iam_role();
  void set_allocated_assumable_iam_role(std::string* assumable_iam_role);
  private:
  const std::string& _internal_assumable_iam_role() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_assumable_iam_role(const std::string& value);
  std::string* _internal_mutable_assumable_iam_role();
  public:

  // string kubernetes_service_account = 2 [json_name = "kubernetesServiceAccount"];
  void clear_kubernetes_service_account();
  const std::string& kubernetes_service_account() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_kubernetes_service_account(ArgT0&& arg0, ArgT... args);
  std::string* mutable_kubernetes_service_account();
  PROTOBUF_NODISCARD std::string* release_kubernetes_service_account();
  void set_allocated_kubernetes_service_account(std::string* kubernetes_service_account);
  private:
  const std::string& _internal_kubernetes_service_account() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_kubernetes_service_account(const std::string& value);
  std::string* _internal_mutable_kubernetes_service_account();
  public:

  // @@protoc_insertion_point(class_scope:flyteidl.admin.AuthRole)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr assumable_iam_role_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr kubernetes_service_account_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fadmin_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class RawOutputDataConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.admin.RawOutputDataConfig) */ {
 public:
  inline RawOutputDataConfig() : RawOutputDataConfig(nullptr) {}
  ~RawOutputDataConfig() override;
  explicit constexpr RawOutputDataConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RawOutputDataConfig(const RawOutputDataConfig& from);
  RawOutputDataConfig(RawOutputDataConfig&& from) noexcept
    : RawOutputDataConfig() {
    *this = ::std::move(from);
  }

  inline RawOutputDataConfig& operator=(const RawOutputDataConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline RawOutputDataConfig& operator=(RawOutputDataConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RawOutputDataConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const RawOutputDataConfig* internal_default_instance() {
    return reinterpret_cast<const RawOutputDataConfig*>(
               &_RawOutputDataConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(RawOutputDataConfig& a, RawOutputDataConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(RawOutputDataConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RawOutputDataConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RawOutputDataConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RawOutputDataConfig>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RawOutputDataConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.admin.RawOutputDataConfig";
  }
  protected:
  explicit RawOutputDataConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOutputLocationPrefixFieldNumber = 1,
  };
  // string output_location_prefix = 1 [json_name = "outputLocationPrefix"];
  void clear_output_location_prefix();
  const std::string& output_location_prefix() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_output_location_prefix(ArgT0&& arg0, ArgT... args);
  std::string* mutable_output_location_prefix();
  PROTOBUF_NODISCARD std::string* release_output_location_prefix();
  void set_allocated_output_location_prefix(std::string* output_location_prefix);
  private:
  const std::string& _internal_output_location_prefix() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_output_location_prefix(const std::string& value);
  std::string* _internal_mutable_output_location_prefix();
  public:

  // @@protoc_insertion_point(class_scope:flyteidl.admin.RawOutputDataConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr output_location_prefix_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fadmin_2fcommon_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// NamedEntityIdentifier

// string project = 1 [json_name = "project"];
inline void NamedEntityIdentifier::clear_project() {
  project_.ClearToEmpty();
}
inline const std::string& NamedEntityIdentifier::project() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NamedEntityIdentifier.project)
  return _internal_project();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NamedEntityIdentifier::set_project(ArgT0&& arg0, ArgT... args) {
 
 project_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.admin.NamedEntityIdentifier.project)
}
inline std::string* NamedEntityIdentifier::mutable_project() {
  std::string* _s = _internal_mutable_project();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.NamedEntityIdentifier.project)
  return _s;
}
inline const std::string& NamedEntityIdentifier::_internal_project() const {
  return project_.Get();
}
inline void NamedEntityIdentifier::_internal_set_project(const std::string& value) {
  
  project_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NamedEntityIdentifier::_internal_mutable_project() {
  
  return project_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NamedEntityIdentifier::release_project() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.NamedEntityIdentifier.project)
  return project_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NamedEntityIdentifier::set_allocated_project(std::string* project) {
  if (project != nullptr) {
    
  } else {
    
  }
  project_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), project,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (project_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    project_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.NamedEntityIdentifier.project)
}

// string domain = 2 [json_name = "domain"];
inline void NamedEntityIdentifier::clear_domain() {
  domain_.ClearToEmpty();
}
inline const std::string& NamedEntityIdentifier::domain() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NamedEntityIdentifier.domain)
  return _internal_domain();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NamedEntityIdentifier::set_domain(ArgT0&& arg0, ArgT... args) {
 
 domain_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.admin.NamedEntityIdentifier.domain)
}
inline std::string* NamedEntityIdentifier::mutable_domain() {
  std::string* _s = _internal_mutable_domain();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.NamedEntityIdentifier.domain)
  return _s;
}
inline const std::string& NamedEntityIdentifier::_internal_domain() const {
  return domain_.Get();
}
inline void NamedEntityIdentifier::_internal_set_domain(const std::string& value) {
  
  domain_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NamedEntityIdentifier::_internal_mutable_domain() {
  
  return domain_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NamedEntityIdentifier::release_domain() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.NamedEntityIdentifier.domain)
  return domain_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NamedEntityIdentifier::set_allocated_domain(std::string* domain) {
  if (domain != nullptr) {
    
  } else {
    
  }
  domain_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), domain,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (domain_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    domain_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.NamedEntityIdentifier.domain)
}

// string name = 3 [json_name = "name"];
inline void NamedEntityIdentifier::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& NamedEntityIdentifier::name() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NamedEntityIdentifier.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NamedEntityIdentifier::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.admin.NamedEntityIdentifier.name)
}
inline std::string* NamedEntityIdentifier::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.NamedEntityIdentifier.name)
  return _s;
}
inline const std::string& NamedEntityIdentifier::_internal_name() const {
  return name_.Get();
}
inline void NamedEntityIdentifier::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NamedEntityIdentifier::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NamedEntityIdentifier::release_name() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.NamedEntityIdentifier.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NamedEntityIdentifier::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.NamedEntityIdentifier.name)
}

// -------------------------------------------------------------------

// NamedEntityMetadata

// string description = 1 [json_name = "description"];
inline void NamedEntityMetadata::clear_description() {
  description_.ClearToEmpty();
}
inline const std::string& NamedEntityMetadata::description() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NamedEntityMetadata.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NamedEntityMetadata::set_description(ArgT0&& arg0, ArgT... args) {
 
 description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.admin.NamedEntityMetadata.description)
}
inline std::string* NamedEntityMetadata::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.NamedEntityMetadata.description)
  return _s;
}
inline const std::string& NamedEntityMetadata::_internal_description() const {
  return description_.Get();
}
inline void NamedEntityMetadata::_internal_set_description(const std::string& value) {
  
  description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NamedEntityMetadata::_internal_mutable_description() {
  
  return description_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NamedEntityMetadata::release_description() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.NamedEntityMetadata.description)
  return description_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NamedEntityMetadata::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (description_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.NamedEntityMetadata.description)
}

// .flyteidl.admin.NamedEntityState state = 2 [json_name = "state"];
inline void NamedEntityMetadata::clear_state() {
  state_ = 0;
}
inline ::flyteidl::admin::NamedEntityState NamedEntityMetadata::_internal_state() const {
  return static_cast< ::flyteidl::admin::NamedEntityState >(state_);
}
inline ::flyteidl::admin::NamedEntityState NamedEntityMetadata::state() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NamedEntityMetadata.state)
  return _internal_state();
}
inline void NamedEntityMetadata::_internal_set_state(::flyteidl::admin::NamedEntityState value) {
  
  state_ = value;
}
inline void NamedEntityMetadata::set_state(::flyteidl::admin::NamedEntityState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:flyteidl.admin.NamedEntityMetadata.state)
}

// -------------------------------------------------------------------

// NamedEntity

// .flyteidl.core.ResourceType resource_type = 1 [json_name = "resourceType"];
inline void NamedEntity::clear_resource_type() {
  resource_type_ = 0;
}
inline ::flyteidl::core::ResourceType NamedEntity::_internal_resource_type() const {
  return static_cast< ::flyteidl::core::ResourceType >(resource_type_);
}
inline ::flyteidl::core::ResourceType NamedEntity::resource_type() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NamedEntity.resource_type)
  return _internal_resource_type();
}
inline void NamedEntity::_internal_set_resource_type(::flyteidl::core::ResourceType value) {
  
  resource_type_ = value;
}
inline void NamedEntity::set_resource_type(::flyteidl::core::ResourceType value) {
  _internal_set_resource_type(value);
  // @@protoc_insertion_point(field_set:flyteidl.admin.NamedEntity.resource_type)
}

// .flyteidl.admin.NamedEntityIdentifier id = 2 [json_name = "id"];
inline bool NamedEntity::_internal_has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline bool NamedEntity::has_id() const {
  return _internal_has_id();
}
inline void NamedEntity::clear_id() {
  if (GetArenaForAllocation() == nullptr && id_ != nullptr) {
    delete id_;
  }
  id_ = nullptr;
}
inline const ::flyteidl::admin::NamedEntityIdentifier& NamedEntity::_internal_id() const {
  const ::flyteidl::admin::NamedEntityIdentifier* p = id_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::admin::NamedEntityIdentifier&>(
      ::flyteidl::admin::_NamedEntityIdentifier_default_instance_);
}
inline const ::flyteidl::admin::NamedEntityIdentifier& NamedEntity::id() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NamedEntity.id)
  return _internal_id();
}
inline void NamedEntity::unsafe_arena_set_allocated_id(
    ::flyteidl::admin::NamedEntityIdentifier* id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.NamedEntity.id)
}
inline ::flyteidl::admin::NamedEntityIdentifier* NamedEntity::release_id() {
  
  ::flyteidl::admin::NamedEntityIdentifier* temp = id_;
  id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::admin::NamedEntityIdentifier* NamedEntity::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.NamedEntity.id)
  
  ::flyteidl::admin::NamedEntityIdentifier* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::flyteidl::admin::NamedEntityIdentifier* NamedEntity::_internal_mutable_id() {
  
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::admin::NamedEntityIdentifier>(GetArenaForAllocation());
    id_ = p;
  }
  return id_;
}
inline ::flyteidl::admin::NamedEntityIdentifier* NamedEntity::mutable_id() {
  ::flyteidl::admin::NamedEntityIdentifier* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.NamedEntity.id)
  return _msg;
}
inline void NamedEntity::set_allocated_id(::flyteidl::admin::NamedEntityIdentifier* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete id_;
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::flyteidl::admin::NamedEntityIdentifier>::GetOwningArena(id);
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.NamedEntity.id)
}

// .flyteidl.admin.NamedEntityMetadata metadata = 3 [json_name = "metadata"];
inline bool NamedEntity::_internal_has_metadata() const {
  return this != internal_default_instance() && metadata_ != nullptr;
}
inline bool NamedEntity::has_metadata() const {
  return _internal_has_metadata();
}
inline void NamedEntity::clear_metadata() {
  if (GetArenaForAllocation() == nullptr && metadata_ != nullptr) {
    delete metadata_;
  }
  metadata_ = nullptr;
}
inline const ::flyteidl::admin::NamedEntityMetadata& NamedEntity::_internal_metadata() const {
  const ::flyteidl::admin::NamedEntityMetadata* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::admin::NamedEntityMetadata&>(
      ::flyteidl::admin::_NamedEntityMetadata_default_instance_);
}
inline const ::flyteidl::admin::NamedEntityMetadata& NamedEntity::metadata() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NamedEntity.metadata)
  return _internal_metadata();
}
inline void NamedEntity::unsafe_arena_set_allocated_metadata(
    ::flyteidl::admin::NamedEntityMetadata* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.NamedEntity.metadata)
}
inline ::flyteidl::admin::NamedEntityMetadata* NamedEntity::release_metadata() {
  
  ::flyteidl::admin::NamedEntityMetadata* temp = metadata_;
  metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::admin::NamedEntityMetadata* NamedEntity::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.NamedEntity.metadata)
  
  ::flyteidl::admin::NamedEntityMetadata* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::flyteidl::admin::NamedEntityMetadata* NamedEntity::_internal_mutable_metadata() {
  
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::admin::NamedEntityMetadata>(GetArenaForAllocation());
    metadata_ = p;
  }
  return metadata_;
}
inline ::flyteidl::admin::NamedEntityMetadata* NamedEntity::mutable_metadata() {
  ::flyteidl::admin::NamedEntityMetadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.NamedEntity.metadata)
  return _msg;
}
inline void NamedEntity::set_allocated_metadata(::flyteidl::admin::NamedEntityMetadata* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete metadata_;
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::flyteidl::admin::NamedEntityMetadata>::GetOwningArena(metadata);
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.NamedEntity.metadata)
}

// -------------------------------------------------------------------

// Sort

// string key = 1 [json_name = "key"];
inline void Sort::clear_key() {
  key_.ClearToEmpty();
}
inline const std::string& Sort::key() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.Sort.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Sort::set_key(ArgT0&& arg0, ArgT... args) {
 
 key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.admin.Sort.key)
}
inline std::string* Sort::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.Sort.key)
  return _s;
}
inline const std::string& Sort::_internal_key() const {
  return key_.Get();
}
inline void Sort::_internal_set_key(const std::string& value) {
  
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Sort::_internal_mutable_key() {
  
  return key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Sort::release_key() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.Sort.key)
  return key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Sort::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.Sort.key)
}

// .flyteidl.admin.Sort.Direction direction = 2 [json_name = "direction"];
inline void Sort::clear_direction() {
  direction_ = 0;
}
inline ::flyteidl::admin::Sort_Direction Sort::_internal_direction() const {
  return static_cast< ::flyteidl::admin::Sort_Direction >(direction_);
}
inline ::flyteidl::admin::Sort_Direction Sort::direction() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.Sort.direction)
  return _internal_direction();
}
inline void Sort::_internal_set_direction(::flyteidl::admin::Sort_Direction value) {
  
  direction_ = value;
}
inline void Sort::set_direction(::flyteidl::admin::Sort_Direction value) {
  _internal_set_direction(value);
  // @@protoc_insertion_point(field_set:flyteidl.admin.Sort.direction)
}

// -------------------------------------------------------------------

// NamedEntityIdentifierListRequest

// string project = 1 [json_name = "project"];
inline void NamedEntityIdentifierListRequest::clear_project() {
  project_.ClearToEmpty();
}
inline const std::string& NamedEntityIdentifierListRequest::project() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NamedEntityIdentifierListRequest.project)
  return _internal_project();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NamedEntityIdentifierListRequest::set_project(ArgT0&& arg0, ArgT... args) {
 
 project_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.admin.NamedEntityIdentifierListRequest.project)
}
inline std::string* NamedEntityIdentifierListRequest::mutable_project() {
  std::string* _s = _internal_mutable_project();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.NamedEntityIdentifierListRequest.project)
  return _s;
}
inline const std::string& NamedEntityIdentifierListRequest::_internal_project() const {
  return project_.Get();
}
inline void NamedEntityIdentifierListRequest::_internal_set_project(const std::string& value) {
  
  project_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NamedEntityIdentifierListRequest::_internal_mutable_project() {
  
  return project_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NamedEntityIdentifierListRequest::release_project() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.NamedEntityIdentifierListRequest.project)
  return project_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NamedEntityIdentifierListRequest::set_allocated_project(std::string* project) {
  if (project != nullptr) {
    
  } else {
    
  }
  project_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), project,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (project_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    project_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.NamedEntityIdentifierListRequest.project)
}

// string domain = 2 [json_name = "domain"];
inline void NamedEntityIdentifierListRequest::clear_domain() {
  domain_.ClearToEmpty();
}
inline const std::string& NamedEntityIdentifierListRequest::domain() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NamedEntityIdentifierListRequest.domain)
  return _internal_domain();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NamedEntityIdentifierListRequest::set_domain(ArgT0&& arg0, ArgT... args) {
 
 domain_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.admin.NamedEntityIdentifierListRequest.domain)
}
inline std::string* NamedEntityIdentifierListRequest::mutable_domain() {
  std::string* _s = _internal_mutable_domain();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.NamedEntityIdentifierListRequest.domain)
  return _s;
}
inline const std::string& NamedEntityIdentifierListRequest::_internal_domain() const {
  return domain_.Get();
}
inline void NamedEntityIdentifierListRequest::_internal_set_domain(const std::string& value) {
  
  domain_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NamedEntityIdentifierListRequest::_internal_mutable_domain() {
  
  return domain_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NamedEntityIdentifierListRequest::release_domain() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.NamedEntityIdentifierListRequest.domain)
  return domain_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NamedEntityIdentifierListRequest::set_allocated_domain(std::string* domain) {
  if (domain != nullptr) {
    
  } else {
    
  }
  domain_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), domain,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (domain_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    domain_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.NamedEntityIdentifierListRequest.domain)
}

// uint32 limit = 3 [json_name = "limit"];
inline void NamedEntityIdentifierListRequest::clear_limit() {
  limit_ = 0u;
}
inline uint32_t NamedEntityIdentifierListRequest::_internal_limit() const {
  return limit_;
}
inline uint32_t NamedEntityIdentifierListRequest::limit() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NamedEntityIdentifierListRequest.limit)
  return _internal_limit();
}
inline void NamedEntityIdentifierListRequest::_internal_set_limit(uint32_t value) {
  
  limit_ = value;
}
inline void NamedEntityIdentifierListRequest::set_limit(uint32_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:flyteidl.admin.NamedEntityIdentifierListRequest.limit)
}

// string token = 4 [json_name = "token"];
inline void NamedEntityIdentifierListRequest::clear_token() {
  token_.ClearToEmpty();
}
inline const std::string& NamedEntityIdentifierListRequest::token() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NamedEntityIdentifierListRequest.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NamedEntityIdentifierListRequest::set_token(ArgT0&& arg0, ArgT... args) {
 
 token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.admin.NamedEntityIdentifierListRequest.token)
}
inline std::string* NamedEntityIdentifierListRequest::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.NamedEntityIdentifierListRequest.token)
  return _s;
}
inline const std::string& NamedEntityIdentifierListRequest::_internal_token() const {
  return token_.Get();
}
inline void NamedEntityIdentifierListRequest::_internal_set_token(const std::string& value) {
  
  token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NamedEntityIdentifierListRequest::_internal_mutable_token() {
  
  return token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NamedEntityIdentifierListRequest::release_token() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.NamedEntityIdentifierListRequest.token)
  return token_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NamedEntityIdentifierListRequest::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.NamedEntityIdentifierListRequest.token)
}

// .flyteidl.admin.Sort sort_by = 5 [json_name = "sortBy"];
inline bool NamedEntityIdentifierListRequest::_internal_has_sort_by() const {
  return this != internal_default_instance() && sort_by_ != nullptr;
}
inline bool NamedEntityIdentifierListRequest::has_sort_by() const {
  return _internal_has_sort_by();
}
inline void NamedEntityIdentifierListRequest::clear_sort_by() {
  if (GetArenaForAllocation() == nullptr && sort_by_ != nullptr) {
    delete sort_by_;
  }
  sort_by_ = nullptr;
}
inline const ::flyteidl::admin::Sort& NamedEntityIdentifierListRequest::_internal_sort_by() const {
  const ::flyteidl::admin::Sort* p = sort_by_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::admin::Sort&>(
      ::flyteidl::admin::_Sort_default_instance_);
}
inline const ::flyteidl::admin::Sort& NamedEntityIdentifierListRequest::sort_by() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NamedEntityIdentifierListRequest.sort_by)
  return _internal_sort_by();
}
inline void NamedEntityIdentifierListRequest::unsafe_arena_set_allocated_sort_by(
    ::flyteidl::admin::Sort* sort_by) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sort_by_);
  }
  sort_by_ = sort_by;
  if (sort_by) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.NamedEntityIdentifierListRequest.sort_by)
}
inline ::flyteidl::admin::Sort* NamedEntityIdentifierListRequest::release_sort_by() {
  
  ::flyteidl::admin::Sort* temp = sort_by_;
  sort_by_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::admin::Sort* NamedEntityIdentifierListRequest::unsafe_arena_release_sort_by() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.NamedEntityIdentifierListRequest.sort_by)
  
  ::flyteidl::admin::Sort* temp = sort_by_;
  sort_by_ = nullptr;
  return temp;
}
inline ::flyteidl::admin::Sort* NamedEntityIdentifierListRequest::_internal_mutable_sort_by() {
  
  if (sort_by_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::admin::Sort>(GetArenaForAllocation());
    sort_by_ = p;
  }
  return sort_by_;
}
inline ::flyteidl::admin::Sort* NamedEntityIdentifierListRequest::mutable_sort_by() {
  ::flyteidl::admin::Sort* _msg = _internal_mutable_sort_by();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.NamedEntityIdentifierListRequest.sort_by)
  return _msg;
}
inline void NamedEntityIdentifierListRequest::set_allocated_sort_by(::flyteidl::admin::Sort* sort_by) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete sort_by_;
  }
  if (sort_by) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::flyteidl::admin::Sort>::GetOwningArena(sort_by);
    if (message_arena != submessage_arena) {
      sort_by = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sort_by, submessage_arena);
    }
    
  } else {
    
  }
  sort_by_ = sort_by;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.NamedEntityIdentifierListRequest.sort_by)
}

// string filters = 6 [json_name = "filters"];
inline void NamedEntityIdentifierListRequest::clear_filters() {
  filters_.ClearToEmpty();
}
inline const std::string& NamedEntityIdentifierListRequest::filters() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NamedEntityIdentifierListRequest.filters)
  return _internal_filters();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NamedEntityIdentifierListRequest::set_filters(ArgT0&& arg0, ArgT... args) {
 
 filters_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.admin.NamedEntityIdentifierListRequest.filters)
}
inline std::string* NamedEntityIdentifierListRequest::mutable_filters() {
  std::string* _s = _internal_mutable_filters();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.NamedEntityIdentifierListRequest.filters)
  return _s;
}
inline const std::string& NamedEntityIdentifierListRequest::_internal_filters() const {
  return filters_.Get();
}
inline void NamedEntityIdentifierListRequest::_internal_set_filters(const std::string& value) {
  
  filters_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NamedEntityIdentifierListRequest::_internal_mutable_filters() {
  
  return filters_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NamedEntityIdentifierListRequest::release_filters() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.NamedEntityIdentifierListRequest.filters)
  return filters_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NamedEntityIdentifierListRequest::set_allocated_filters(std::string* filters) {
  if (filters != nullptr) {
    
  } else {
    
  }
  filters_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), filters,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (filters_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    filters_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.NamedEntityIdentifierListRequest.filters)
}

// -------------------------------------------------------------------

// NamedEntityListRequest

// .flyteidl.core.ResourceType resource_type = 1 [json_name = "resourceType"];
inline void NamedEntityListRequest::clear_resource_type() {
  resource_type_ = 0;
}
inline ::flyteidl::core::ResourceType NamedEntityListRequest::_internal_resource_type() const {
  return static_cast< ::flyteidl::core::ResourceType >(resource_type_);
}
inline ::flyteidl::core::ResourceType NamedEntityListRequest::resource_type() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NamedEntityListRequest.resource_type)
  return _internal_resource_type();
}
inline void NamedEntityListRequest::_internal_set_resource_type(::flyteidl::core::ResourceType value) {
  
  resource_type_ = value;
}
inline void NamedEntityListRequest::set_resource_type(::flyteidl::core::ResourceType value) {
  _internal_set_resource_type(value);
  // @@protoc_insertion_point(field_set:flyteidl.admin.NamedEntityListRequest.resource_type)
}

// string project = 2 [json_name = "project"];
inline void NamedEntityListRequest::clear_project() {
  project_.ClearToEmpty();
}
inline const std::string& NamedEntityListRequest::project() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NamedEntityListRequest.project)
  return _internal_project();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NamedEntityListRequest::set_project(ArgT0&& arg0, ArgT... args) {
 
 project_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.admin.NamedEntityListRequest.project)
}
inline std::string* NamedEntityListRequest::mutable_project() {
  std::string* _s = _internal_mutable_project();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.NamedEntityListRequest.project)
  return _s;
}
inline const std::string& NamedEntityListRequest::_internal_project() const {
  return project_.Get();
}
inline void NamedEntityListRequest::_internal_set_project(const std::string& value) {
  
  project_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NamedEntityListRequest::_internal_mutable_project() {
  
  return project_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NamedEntityListRequest::release_project() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.NamedEntityListRequest.project)
  return project_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NamedEntityListRequest::set_allocated_project(std::string* project) {
  if (project != nullptr) {
    
  } else {
    
  }
  project_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), project,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (project_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    project_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.NamedEntityListRequest.project)
}

// string domain = 3 [json_name = "domain"];
inline void NamedEntityListRequest::clear_domain() {
  domain_.ClearToEmpty();
}
inline const std::string& NamedEntityListRequest::domain() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NamedEntityListRequest.domain)
  return _internal_domain();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NamedEntityListRequest::set_domain(ArgT0&& arg0, ArgT... args) {
 
 domain_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.admin.NamedEntityListRequest.domain)
}
inline std::string* NamedEntityListRequest::mutable_domain() {
  std::string* _s = _internal_mutable_domain();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.NamedEntityListRequest.domain)
  return _s;
}
inline const std::string& NamedEntityListRequest::_internal_domain() const {
  return domain_.Get();
}
inline void NamedEntityListRequest::_internal_set_domain(const std::string& value) {
  
  domain_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NamedEntityListRequest::_internal_mutable_domain() {
  
  return domain_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NamedEntityListRequest::release_domain() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.NamedEntityListRequest.domain)
  return domain_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NamedEntityListRequest::set_allocated_domain(std::string* domain) {
  if (domain != nullptr) {
    
  } else {
    
  }
  domain_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), domain,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (domain_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    domain_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.NamedEntityListRequest.domain)
}

// uint32 limit = 4 [json_name = "limit"];
inline void NamedEntityListRequest::clear_limit() {
  limit_ = 0u;
}
inline uint32_t NamedEntityListRequest::_internal_limit() const {
  return limit_;
}
inline uint32_t NamedEntityListRequest::limit() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NamedEntityListRequest.limit)
  return _internal_limit();
}
inline void NamedEntityListRequest::_internal_set_limit(uint32_t value) {
  
  limit_ = value;
}
inline void NamedEntityListRequest::set_limit(uint32_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:flyteidl.admin.NamedEntityListRequest.limit)
}

// string token = 5 [json_name = "token"];
inline void NamedEntityListRequest::clear_token() {
  token_.ClearToEmpty();
}
inline const std::string& NamedEntityListRequest::token() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NamedEntityListRequest.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NamedEntityListRequest::set_token(ArgT0&& arg0, ArgT... args) {
 
 token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.admin.NamedEntityListRequest.token)
}
inline std::string* NamedEntityListRequest::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.NamedEntityListRequest.token)
  return _s;
}
inline const std::string& NamedEntityListRequest::_internal_token() const {
  return token_.Get();
}
inline void NamedEntityListRequest::_internal_set_token(const std::string& value) {
  
  token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NamedEntityListRequest::_internal_mutable_token() {
  
  return token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NamedEntityListRequest::release_token() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.NamedEntityListRequest.token)
  return token_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NamedEntityListRequest::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.NamedEntityListRequest.token)
}

// .flyteidl.admin.Sort sort_by = 6 [json_name = "sortBy"];
inline bool NamedEntityListRequest::_internal_has_sort_by() const {
  return this != internal_default_instance() && sort_by_ != nullptr;
}
inline bool NamedEntityListRequest::has_sort_by() const {
  return _internal_has_sort_by();
}
inline void NamedEntityListRequest::clear_sort_by() {
  if (GetArenaForAllocation() == nullptr && sort_by_ != nullptr) {
    delete sort_by_;
  }
  sort_by_ = nullptr;
}
inline const ::flyteidl::admin::Sort& NamedEntityListRequest::_internal_sort_by() const {
  const ::flyteidl::admin::Sort* p = sort_by_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::admin::Sort&>(
      ::flyteidl::admin::_Sort_default_instance_);
}
inline const ::flyteidl::admin::Sort& NamedEntityListRequest::sort_by() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NamedEntityListRequest.sort_by)
  return _internal_sort_by();
}
inline void NamedEntityListRequest::unsafe_arena_set_allocated_sort_by(
    ::flyteidl::admin::Sort* sort_by) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sort_by_);
  }
  sort_by_ = sort_by;
  if (sort_by) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.NamedEntityListRequest.sort_by)
}
inline ::flyteidl::admin::Sort* NamedEntityListRequest::release_sort_by() {
  
  ::flyteidl::admin::Sort* temp = sort_by_;
  sort_by_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::admin::Sort* NamedEntityListRequest::unsafe_arena_release_sort_by() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.NamedEntityListRequest.sort_by)
  
  ::flyteidl::admin::Sort* temp = sort_by_;
  sort_by_ = nullptr;
  return temp;
}
inline ::flyteidl::admin::Sort* NamedEntityListRequest::_internal_mutable_sort_by() {
  
  if (sort_by_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::admin::Sort>(GetArenaForAllocation());
    sort_by_ = p;
  }
  return sort_by_;
}
inline ::flyteidl::admin::Sort* NamedEntityListRequest::mutable_sort_by() {
  ::flyteidl::admin::Sort* _msg = _internal_mutable_sort_by();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.NamedEntityListRequest.sort_by)
  return _msg;
}
inline void NamedEntityListRequest::set_allocated_sort_by(::flyteidl::admin::Sort* sort_by) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete sort_by_;
  }
  if (sort_by) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::flyteidl::admin::Sort>::GetOwningArena(sort_by);
    if (message_arena != submessage_arena) {
      sort_by = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sort_by, submessage_arena);
    }
    
  } else {
    
  }
  sort_by_ = sort_by;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.NamedEntityListRequest.sort_by)
}

// string filters = 7 [json_name = "filters"];
inline void NamedEntityListRequest::clear_filters() {
  filters_.ClearToEmpty();
}
inline const std::string& NamedEntityListRequest::filters() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NamedEntityListRequest.filters)
  return _internal_filters();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NamedEntityListRequest::set_filters(ArgT0&& arg0, ArgT... args) {
 
 filters_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.admin.NamedEntityListRequest.filters)
}
inline std::string* NamedEntityListRequest::mutable_filters() {
  std::string* _s = _internal_mutable_filters();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.NamedEntityListRequest.filters)
  return _s;
}
inline const std::string& NamedEntityListRequest::_internal_filters() const {
  return filters_.Get();
}
inline void NamedEntityListRequest::_internal_set_filters(const std::string& value) {
  
  filters_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NamedEntityListRequest::_internal_mutable_filters() {
  
  return filters_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NamedEntityListRequest::release_filters() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.NamedEntityListRequest.filters)
  return filters_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NamedEntityListRequest::set_allocated_filters(std::string* filters) {
  if (filters != nullptr) {
    
  } else {
    
  }
  filters_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), filters,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (filters_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    filters_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.NamedEntityListRequest.filters)
}

// -------------------------------------------------------------------

// NamedEntityIdentifierList

// repeated .flyteidl.admin.NamedEntityIdentifier entities = 1 [json_name = "entities"];
inline int NamedEntityIdentifierList::_internal_entities_size() const {
  return entities_.size();
}
inline int NamedEntityIdentifierList::entities_size() const {
  return _internal_entities_size();
}
inline void NamedEntityIdentifierList::clear_entities() {
  entities_.Clear();
}
inline ::flyteidl::admin::NamedEntityIdentifier* NamedEntityIdentifierList::mutable_entities(int index) {
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.NamedEntityIdentifierList.entities)
  return entities_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::admin::NamedEntityIdentifier >*
NamedEntityIdentifierList::mutable_entities() {
  // @@protoc_insertion_point(field_mutable_list:flyteidl.admin.NamedEntityIdentifierList.entities)
  return &entities_;
}
inline const ::flyteidl::admin::NamedEntityIdentifier& NamedEntityIdentifierList::_internal_entities(int index) const {
  return entities_.Get(index);
}
inline const ::flyteidl::admin::NamedEntityIdentifier& NamedEntityIdentifierList::entities(int index) const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NamedEntityIdentifierList.entities)
  return _internal_entities(index);
}
inline ::flyteidl::admin::NamedEntityIdentifier* NamedEntityIdentifierList::_internal_add_entities() {
  return entities_.Add();
}
inline ::flyteidl::admin::NamedEntityIdentifier* NamedEntityIdentifierList::add_entities() {
  ::flyteidl::admin::NamedEntityIdentifier* _add = _internal_add_entities();
  // @@protoc_insertion_point(field_add:flyteidl.admin.NamedEntityIdentifierList.entities)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::admin::NamedEntityIdentifier >&
NamedEntityIdentifierList::entities() const {
  // @@protoc_insertion_point(field_list:flyteidl.admin.NamedEntityIdentifierList.entities)
  return entities_;
}

// string token = 2 [json_name = "token"];
inline void NamedEntityIdentifierList::clear_token() {
  token_.ClearToEmpty();
}
inline const std::string& NamedEntityIdentifierList::token() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NamedEntityIdentifierList.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NamedEntityIdentifierList::set_token(ArgT0&& arg0, ArgT... args) {
 
 token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.admin.NamedEntityIdentifierList.token)
}
inline std::string* NamedEntityIdentifierList::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.NamedEntityIdentifierList.token)
  return _s;
}
inline const std::string& NamedEntityIdentifierList::_internal_token() const {
  return token_.Get();
}
inline void NamedEntityIdentifierList::_internal_set_token(const std::string& value) {
  
  token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NamedEntityIdentifierList::_internal_mutable_token() {
  
  return token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NamedEntityIdentifierList::release_token() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.NamedEntityIdentifierList.token)
  return token_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NamedEntityIdentifierList::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.NamedEntityIdentifierList.token)
}

// -------------------------------------------------------------------

// NamedEntityList

// repeated .flyteidl.admin.NamedEntity entities = 1 [json_name = "entities"];
inline int NamedEntityList::_internal_entities_size() const {
  return entities_.size();
}
inline int NamedEntityList::entities_size() const {
  return _internal_entities_size();
}
inline void NamedEntityList::clear_entities() {
  entities_.Clear();
}
inline ::flyteidl::admin::NamedEntity* NamedEntityList::mutable_entities(int index) {
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.NamedEntityList.entities)
  return entities_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::admin::NamedEntity >*
NamedEntityList::mutable_entities() {
  // @@protoc_insertion_point(field_mutable_list:flyteidl.admin.NamedEntityList.entities)
  return &entities_;
}
inline const ::flyteidl::admin::NamedEntity& NamedEntityList::_internal_entities(int index) const {
  return entities_.Get(index);
}
inline const ::flyteidl::admin::NamedEntity& NamedEntityList::entities(int index) const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NamedEntityList.entities)
  return _internal_entities(index);
}
inline ::flyteidl::admin::NamedEntity* NamedEntityList::_internal_add_entities() {
  return entities_.Add();
}
inline ::flyteidl::admin::NamedEntity* NamedEntityList::add_entities() {
  ::flyteidl::admin::NamedEntity* _add = _internal_add_entities();
  // @@protoc_insertion_point(field_add:flyteidl.admin.NamedEntityList.entities)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::admin::NamedEntity >&
NamedEntityList::entities() const {
  // @@protoc_insertion_point(field_list:flyteidl.admin.NamedEntityList.entities)
  return entities_;
}

// string token = 2 [json_name = "token"];
inline void NamedEntityList::clear_token() {
  token_.ClearToEmpty();
}
inline const std::string& NamedEntityList::token() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NamedEntityList.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NamedEntityList::set_token(ArgT0&& arg0, ArgT... args) {
 
 token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.admin.NamedEntityList.token)
}
inline std::string* NamedEntityList::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.NamedEntityList.token)
  return _s;
}
inline const std::string& NamedEntityList::_internal_token() const {
  return token_.Get();
}
inline void NamedEntityList::_internal_set_token(const std::string& value) {
  
  token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NamedEntityList::_internal_mutable_token() {
  
  return token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NamedEntityList::release_token() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.NamedEntityList.token)
  return token_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NamedEntityList::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.NamedEntityList.token)
}

// -------------------------------------------------------------------

// NamedEntityGetRequest

// .flyteidl.core.ResourceType resource_type = 1 [json_name = "resourceType"];
inline void NamedEntityGetRequest::clear_resource_type() {
  resource_type_ = 0;
}
inline ::flyteidl::core::ResourceType NamedEntityGetRequest::_internal_resource_type() const {
  return static_cast< ::flyteidl::core::ResourceType >(resource_type_);
}
inline ::flyteidl::core::ResourceType NamedEntityGetRequest::resource_type() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NamedEntityGetRequest.resource_type)
  return _internal_resource_type();
}
inline void NamedEntityGetRequest::_internal_set_resource_type(::flyteidl::core::ResourceType value) {
  
  resource_type_ = value;
}
inline void NamedEntityGetRequest::set_resource_type(::flyteidl::core::ResourceType value) {
  _internal_set_resource_type(value);
  // @@protoc_insertion_point(field_set:flyteidl.admin.NamedEntityGetRequest.resource_type)
}

// .flyteidl.admin.NamedEntityIdentifier id = 2 [json_name = "id"];
inline bool NamedEntityGetRequest::_internal_has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline bool NamedEntityGetRequest::has_id() const {
  return _internal_has_id();
}
inline void NamedEntityGetRequest::clear_id() {
  if (GetArenaForAllocation() == nullptr && id_ != nullptr) {
    delete id_;
  }
  id_ = nullptr;
}
inline const ::flyteidl::admin::NamedEntityIdentifier& NamedEntityGetRequest::_internal_id() const {
  const ::flyteidl::admin::NamedEntityIdentifier* p = id_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::admin::NamedEntityIdentifier&>(
      ::flyteidl::admin::_NamedEntityIdentifier_default_instance_);
}
inline const ::flyteidl::admin::NamedEntityIdentifier& NamedEntityGetRequest::id() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NamedEntityGetRequest.id)
  return _internal_id();
}
inline void NamedEntityGetRequest::unsafe_arena_set_allocated_id(
    ::flyteidl::admin::NamedEntityIdentifier* id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.NamedEntityGetRequest.id)
}
inline ::flyteidl::admin::NamedEntityIdentifier* NamedEntityGetRequest::release_id() {
  
  ::flyteidl::admin::NamedEntityIdentifier* temp = id_;
  id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::admin::NamedEntityIdentifier* NamedEntityGetRequest::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.NamedEntityGetRequest.id)
  
  ::flyteidl::admin::NamedEntityIdentifier* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::flyteidl::admin::NamedEntityIdentifier* NamedEntityGetRequest::_internal_mutable_id() {
  
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::admin::NamedEntityIdentifier>(GetArenaForAllocation());
    id_ = p;
  }
  return id_;
}
inline ::flyteidl::admin::NamedEntityIdentifier* NamedEntityGetRequest::mutable_id() {
  ::flyteidl::admin::NamedEntityIdentifier* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.NamedEntityGetRequest.id)
  return _msg;
}
inline void NamedEntityGetRequest::set_allocated_id(::flyteidl::admin::NamedEntityIdentifier* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete id_;
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::flyteidl::admin::NamedEntityIdentifier>::GetOwningArena(id);
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.NamedEntityGetRequest.id)
}

// -------------------------------------------------------------------

// NamedEntityUpdateRequest

// .flyteidl.core.ResourceType resource_type = 1 [json_name = "resourceType"];
inline void NamedEntityUpdateRequest::clear_resource_type() {
  resource_type_ = 0;
}
inline ::flyteidl::core::ResourceType NamedEntityUpdateRequest::_internal_resource_type() const {
  return static_cast< ::flyteidl::core::ResourceType >(resource_type_);
}
inline ::flyteidl::core::ResourceType NamedEntityUpdateRequest::resource_type() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NamedEntityUpdateRequest.resource_type)
  return _internal_resource_type();
}
inline void NamedEntityUpdateRequest::_internal_set_resource_type(::flyteidl::core::ResourceType value) {
  
  resource_type_ = value;
}
inline void NamedEntityUpdateRequest::set_resource_type(::flyteidl::core::ResourceType value) {
  _internal_set_resource_type(value);
  // @@protoc_insertion_point(field_set:flyteidl.admin.NamedEntityUpdateRequest.resource_type)
}

// .flyteidl.admin.NamedEntityIdentifier id = 2 [json_name = "id"];
inline bool NamedEntityUpdateRequest::_internal_has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline bool NamedEntityUpdateRequest::has_id() const {
  return _internal_has_id();
}
inline void NamedEntityUpdateRequest::clear_id() {
  if (GetArenaForAllocation() == nullptr && id_ != nullptr) {
    delete id_;
  }
  id_ = nullptr;
}
inline const ::flyteidl::admin::NamedEntityIdentifier& NamedEntityUpdateRequest::_internal_id() const {
  const ::flyteidl::admin::NamedEntityIdentifier* p = id_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::admin::NamedEntityIdentifier&>(
      ::flyteidl::admin::_NamedEntityIdentifier_default_instance_);
}
inline const ::flyteidl::admin::NamedEntityIdentifier& NamedEntityUpdateRequest::id() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NamedEntityUpdateRequest.id)
  return _internal_id();
}
inline void NamedEntityUpdateRequest::unsafe_arena_set_allocated_id(
    ::flyteidl::admin::NamedEntityIdentifier* id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.NamedEntityUpdateRequest.id)
}
inline ::flyteidl::admin::NamedEntityIdentifier* NamedEntityUpdateRequest::release_id() {
  
  ::flyteidl::admin::NamedEntityIdentifier* temp = id_;
  id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::admin::NamedEntityIdentifier* NamedEntityUpdateRequest::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.NamedEntityUpdateRequest.id)
  
  ::flyteidl::admin::NamedEntityIdentifier* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::flyteidl::admin::NamedEntityIdentifier* NamedEntityUpdateRequest::_internal_mutable_id() {
  
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::admin::NamedEntityIdentifier>(GetArenaForAllocation());
    id_ = p;
  }
  return id_;
}
inline ::flyteidl::admin::NamedEntityIdentifier* NamedEntityUpdateRequest::mutable_id() {
  ::flyteidl::admin::NamedEntityIdentifier* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.NamedEntityUpdateRequest.id)
  return _msg;
}
inline void NamedEntityUpdateRequest::set_allocated_id(::flyteidl::admin::NamedEntityIdentifier* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete id_;
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::flyteidl::admin::NamedEntityIdentifier>::GetOwningArena(id);
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.NamedEntityUpdateRequest.id)
}

// .flyteidl.admin.NamedEntityMetadata metadata = 3 [json_name = "metadata"];
inline bool NamedEntityUpdateRequest::_internal_has_metadata() const {
  return this != internal_default_instance() && metadata_ != nullptr;
}
inline bool NamedEntityUpdateRequest::has_metadata() const {
  return _internal_has_metadata();
}
inline void NamedEntityUpdateRequest::clear_metadata() {
  if (GetArenaForAllocation() == nullptr && metadata_ != nullptr) {
    delete metadata_;
  }
  metadata_ = nullptr;
}
inline const ::flyteidl::admin::NamedEntityMetadata& NamedEntityUpdateRequest::_internal_metadata() const {
  const ::flyteidl::admin::NamedEntityMetadata* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::admin::NamedEntityMetadata&>(
      ::flyteidl::admin::_NamedEntityMetadata_default_instance_);
}
inline const ::flyteidl::admin::NamedEntityMetadata& NamedEntityUpdateRequest::metadata() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NamedEntityUpdateRequest.metadata)
  return _internal_metadata();
}
inline void NamedEntityUpdateRequest::unsafe_arena_set_allocated_metadata(
    ::flyteidl::admin::NamedEntityMetadata* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.NamedEntityUpdateRequest.metadata)
}
inline ::flyteidl::admin::NamedEntityMetadata* NamedEntityUpdateRequest::release_metadata() {
  
  ::flyteidl::admin::NamedEntityMetadata* temp = metadata_;
  metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::admin::NamedEntityMetadata* NamedEntityUpdateRequest::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.NamedEntityUpdateRequest.metadata)
  
  ::flyteidl::admin::NamedEntityMetadata* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::flyteidl::admin::NamedEntityMetadata* NamedEntityUpdateRequest::_internal_mutable_metadata() {
  
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::admin::NamedEntityMetadata>(GetArenaForAllocation());
    metadata_ = p;
  }
  return metadata_;
}
inline ::flyteidl::admin::NamedEntityMetadata* NamedEntityUpdateRequest::mutable_metadata() {
  ::flyteidl::admin::NamedEntityMetadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.NamedEntityUpdateRequest.metadata)
  return _msg;
}
inline void NamedEntityUpdateRequest::set_allocated_metadata(::flyteidl::admin::NamedEntityMetadata* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete metadata_;
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::flyteidl::admin::NamedEntityMetadata>::GetOwningArena(metadata);
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.NamedEntityUpdateRequest.metadata)
}

// -------------------------------------------------------------------

// NamedEntityUpdateResponse

// -------------------------------------------------------------------

// ObjectGetRequest

// .flyteidl.core.Identifier id = 1 [json_name = "id"];
inline bool ObjectGetRequest::_internal_has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline bool ObjectGetRequest::has_id() const {
  return _internal_has_id();
}
inline const ::flyteidl::core::Identifier& ObjectGetRequest::_internal_id() const {
  const ::flyteidl::core::Identifier* p = id_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::core::Identifier&>(
      ::flyteidl::core::_Identifier_default_instance_);
}
inline const ::flyteidl::core::Identifier& ObjectGetRequest::id() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.ObjectGetRequest.id)
  return _internal_id();
}
inline void ObjectGetRequest::unsafe_arena_set_allocated_id(
    ::flyteidl::core::Identifier* id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.ObjectGetRequest.id)
}
inline ::flyteidl::core::Identifier* ObjectGetRequest::release_id() {
  
  ::flyteidl::core::Identifier* temp = id_;
  id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::core::Identifier* ObjectGetRequest::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.ObjectGetRequest.id)
  
  ::flyteidl::core::Identifier* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::flyteidl::core::Identifier* ObjectGetRequest::_internal_mutable_id() {
  
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::Identifier>(GetArenaForAllocation());
    id_ = p;
  }
  return id_;
}
inline ::flyteidl::core::Identifier* ObjectGetRequest::mutable_id() {
  ::flyteidl::core::Identifier* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.ObjectGetRequest.id)
  return _msg;
}
inline void ObjectGetRequest::set_allocated_id(::flyteidl::core::Identifier* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id));
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.ObjectGetRequest.id)
}

// -------------------------------------------------------------------

// ResourceListRequest

// .flyteidl.admin.NamedEntityIdentifier id = 1 [json_name = "id"];
inline bool ResourceListRequest::_internal_has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline bool ResourceListRequest::has_id() const {
  return _internal_has_id();
}
inline void ResourceListRequest::clear_id() {
  if (GetArenaForAllocation() == nullptr && id_ != nullptr) {
    delete id_;
  }
  id_ = nullptr;
}
inline const ::flyteidl::admin::NamedEntityIdentifier& ResourceListRequest::_internal_id() const {
  const ::flyteidl::admin::NamedEntityIdentifier* p = id_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::admin::NamedEntityIdentifier&>(
      ::flyteidl::admin::_NamedEntityIdentifier_default_instance_);
}
inline const ::flyteidl::admin::NamedEntityIdentifier& ResourceListRequest::id() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.ResourceListRequest.id)
  return _internal_id();
}
inline void ResourceListRequest::unsafe_arena_set_allocated_id(
    ::flyteidl::admin::NamedEntityIdentifier* id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.ResourceListRequest.id)
}
inline ::flyteidl::admin::NamedEntityIdentifier* ResourceListRequest::release_id() {
  
  ::flyteidl::admin::NamedEntityIdentifier* temp = id_;
  id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::admin::NamedEntityIdentifier* ResourceListRequest::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.ResourceListRequest.id)
  
  ::flyteidl::admin::NamedEntityIdentifier* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::flyteidl::admin::NamedEntityIdentifier* ResourceListRequest::_internal_mutable_id() {
  
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::admin::NamedEntityIdentifier>(GetArenaForAllocation());
    id_ = p;
  }
  return id_;
}
inline ::flyteidl::admin::NamedEntityIdentifier* ResourceListRequest::mutable_id() {
  ::flyteidl::admin::NamedEntityIdentifier* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.ResourceListRequest.id)
  return _msg;
}
inline void ResourceListRequest::set_allocated_id(::flyteidl::admin::NamedEntityIdentifier* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete id_;
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::flyteidl::admin::NamedEntityIdentifier>::GetOwningArena(id);
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.ResourceListRequest.id)
}

// uint32 limit = 2 [json_name = "limit"];
inline void ResourceListRequest::clear_limit() {
  limit_ = 0u;
}
inline uint32_t ResourceListRequest::_internal_limit() const {
  return limit_;
}
inline uint32_t ResourceListRequest::limit() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.ResourceListRequest.limit)
  return _internal_limit();
}
inline void ResourceListRequest::_internal_set_limit(uint32_t value) {
  
  limit_ = value;
}
inline void ResourceListRequest::set_limit(uint32_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:flyteidl.admin.ResourceListRequest.limit)
}

// string token = 3 [json_name = "token"];
inline void ResourceListRequest::clear_token() {
  token_.ClearToEmpty();
}
inline const std::string& ResourceListRequest::token() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.ResourceListRequest.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResourceListRequest::set_token(ArgT0&& arg0, ArgT... args) {
 
 token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.admin.ResourceListRequest.token)
}
inline std::string* ResourceListRequest::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.ResourceListRequest.token)
  return _s;
}
inline const std::string& ResourceListRequest::_internal_token() const {
  return token_.Get();
}
inline void ResourceListRequest::_internal_set_token(const std::string& value) {
  
  token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ResourceListRequest::_internal_mutable_token() {
  
  return token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ResourceListRequest::release_token() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.ResourceListRequest.token)
  return token_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ResourceListRequest::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.ResourceListRequest.token)
}

// string filters = 4 [json_name = "filters"];
inline void ResourceListRequest::clear_filters() {
  filters_.ClearToEmpty();
}
inline const std::string& ResourceListRequest::filters() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.ResourceListRequest.filters)
  return _internal_filters();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResourceListRequest::set_filters(ArgT0&& arg0, ArgT... args) {
 
 filters_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.admin.ResourceListRequest.filters)
}
inline std::string* ResourceListRequest::mutable_filters() {
  std::string* _s = _internal_mutable_filters();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.ResourceListRequest.filters)
  return _s;
}
inline const std::string& ResourceListRequest::_internal_filters() const {
  return filters_.Get();
}
inline void ResourceListRequest::_internal_set_filters(const std::string& value) {
  
  filters_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ResourceListRequest::_internal_mutable_filters() {
  
  return filters_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ResourceListRequest::release_filters() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.ResourceListRequest.filters)
  return filters_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ResourceListRequest::set_allocated_filters(std::string* filters) {
  if (filters != nullptr) {
    
  } else {
    
  }
  filters_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), filters,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (filters_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    filters_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.ResourceListRequest.filters)
}

// .flyteidl.admin.Sort sort_by = 5 [json_name = "sortBy"];
inline bool ResourceListRequest::_internal_has_sort_by() const {
  return this != internal_default_instance() && sort_by_ != nullptr;
}
inline bool ResourceListRequest::has_sort_by() const {
  return _internal_has_sort_by();
}
inline void ResourceListRequest::clear_sort_by() {
  if (GetArenaForAllocation() == nullptr && sort_by_ != nullptr) {
    delete sort_by_;
  }
  sort_by_ = nullptr;
}
inline const ::flyteidl::admin::Sort& ResourceListRequest::_internal_sort_by() const {
  const ::flyteidl::admin::Sort* p = sort_by_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::admin::Sort&>(
      ::flyteidl::admin::_Sort_default_instance_);
}
inline const ::flyteidl::admin::Sort& ResourceListRequest::sort_by() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.ResourceListRequest.sort_by)
  return _internal_sort_by();
}
inline void ResourceListRequest::unsafe_arena_set_allocated_sort_by(
    ::flyteidl::admin::Sort* sort_by) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sort_by_);
  }
  sort_by_ = sort_by;
  if (sort_by) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.ResourceListRequest.sort_by)
}
inline ::flyteidl::admin::Sort* ResourceListRequest::release_sort_by() {
  
  ::flyteidl::admin::Sort* temp = sort_by_;
  sort_by_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::admin::Sort* ResourceListRequest::unsafe_arena_release_sort_by() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.ResourceListRequest.sort_by)
  
  ::flyteidl::admin::Sort* temp = sort_by_;
  sort_by_ = nullptr;
  return temp;
}
inline ::flyteidl::admin::Sort* ResourceListRequest::_internal_mutable_sort_by() {
  
  if (sort_by_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::admin::Sort>(GetArenaForAllocation());
    sort_by_ = p;
  }
  return sort_by_;
}
inline ::flyteidl::admin::Sort* ResourceListRequest::mutable_sort_by() {
  ::flyteidl::admin::Sort* _msg = _internal_mutable_sort_by();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.ResourceListRequest.sort_by)
  return _msg;
}
inline void ResourceListRequest::set_allocated_sort_by(::flyteidl::admin::Sort* sort_by) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete sort_by_;
  }
  if (sort_by) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::flyteidl::admin::Sort>::GetOwningArena(sort_by);
    if (message_arena != submessage_arena) {
      sort_by = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sort_by, submessage_arena);
    }
    
  } else {
    
  }
  sort_by_ = sort_by;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.ResourceListRequest.sort_by)
}

// -------------------------------------------------------------------

// EmailNotification

// repeated string recipients_email = 1 [json_name = "recipientsEmail"];
inline int EmailNotification::_internal_recipients_email_size() const {
  return recipients_email_.size();
}
inline int EmailNotification::recipients_email_size() const {
  return _internal_recipients_email_size();
}
inline void EmailNotification::clear_recipients_email() {
  recipients_email_.Clear();
}
inline std::string* EmailNotification::add_recipients_email() {
  std::string* _s = _internal_add_recipients_email();
  // @@protoc_insertion_point(field_add_mutable:flyteidl.admin.EmailNotification.recipients_email)
  return _s;
}
inline const std::string& EmailNotification::_internal_recipients_email(int index) const {
  return recipients_email_.Get(index);
}
inline const std::string& EmailNotification::recipients_email(int index) const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.EmailNotification.recipients_email)
  return _internal_recipients_email(index);
}
inline std::string* EmailNotification::mutable_recipients_email(int index) {
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.EmailNotification.recipients_email)
  return recipients_email_.Mutable(index);
}
inline void EmailNotification::set_recipients_email(int index, const std::string& value) {
  recipients_email_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:flyteidl.admin.EmailNotification.recipients_email)
}
inline void EmailNotification::set_recipients_email(int index, std::string&& value) {
  recipients_email_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:flyteidl.admin.EmailNotification.recipients_email)
}
inline void EmailNotification::set_recipients_email(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  recipients_email_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:flyteidl.admin.EmailNotification.recipients_email)
}
inline void EmailNotification::set_recipients_email(int index, const char* value, size_t size) {
  recipients_email_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:flyteidl.admin.EmailNotification.recipients_email)
}
inline std::string* EmailNotification::_internal_add_recipients_email() {
  return recipients_email_.Add();
}
inline void EmailNotification::add_recipients_email(const std::string& value) {
  recipients_email_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:flyteidl.admin.EmailNotification.recipients_email)
}
inline void EmailNotification::add_recipients_email(std::string&& value) {
  recipients_email_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:flyteidl.admin.EmailNotification.recipients_email)
}
inline void EmailNotification::add_recipients_email(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  recipients_email_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:flyteidl.admin.EmailNotification.recipients_email)
}
inline void EmailNotification::add_recipients_email(const char* value, size_t size) {
  recipients_email_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:flyteidl.admin.EmailNotification.recipients_email)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
EmailNotification::recipients_email() const {
  // @@protoc_insertion_point(field_list:flyteidl.admin.EmailNotification.recipients_email)
  return recipients_email_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
EmailNotification::mutable_recipients_email() {
  // @@protoc_insertion_point(field_mutable_list:flyteidl.admin.EmailNotification.recipients_email)
  return &recipients_email_;
}

// -------------------------------------------------------------------

// PagerDutyNotification

// repeated string recipients_email = 1 [json_name = "recipientsEmail"];
inline int PagerDutyNotification::_internal_recipients_email_size() const {
  return recipients_email_.size();
}
inline int PagerDutyNotification::recipients_email_size() const {
  return _internal_recipients_email_size();
}
inline void PagerDutyNotification::clear_recipients_email() {
  recipients_email_.Clear();
}
inline std::string* PagerDutyNotification::add_recipients_email() {
  std::string* _s = _internal_add_recipients_email();
  // @@protoc_insertion_point(field_add_mutable:flyteidl.admin.PagerDutyNotification.recipients_email)
  return _s;
}
inline const std::string& PagerDutyNotification::_internal_recipients_email(int index) const {
  return recipients_email_.Get(index);
}
inline const std::string& PagerDutyNotification::recipients_email(int index) const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.PagerDutyNotification.recipients_email)
  return _internal_recipients_email(index);
}
inline std::string* PagerDutyNotification::mutable_recipients_email(int index) {
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.PagerDutyNotification.recipients_email)
  return recipients_email_.Mutable(index);
}
inline void PagerDutyNotification::set_recipients_email(int index, const std::string& value) {
  recipients_email_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:flyteidl.admin.PagerDutyNotification.recipients_email)
}
inline void PagerDutyNotification::set_recipients_email(int index, std::string&& value) {
  recipients_email_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:flyteidl.admin.PagerDutyNotification.recipients_email)
}
inline void PagerDutyNotification::set_recipients_email(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  recipients_email_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:flyteidl.admin.PagerDutyNotification.recipients_email)
}
inline void PagerDutyNotification::set_recipients_email(int index, const char* value, size_t size) {
  recipients_email_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:flyteidl.admin.PagerDutyNotification.recipients_email)
}
inline std::string* PagerDutyNotification::_internal_add_recipients_email() {
  return recipients_email_.Add();
}
inline void PagerDutyNotification::add_recipients_email(const std::string& value) {
  recipients_email_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:flyteidl.admin.PagerDutyNotification.recipients_email)
}
inline void PagerDutyNotification::add_recipients_email(std::string&& value) {
  recipients_email_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:flyteidl.admin.PagerDutyNotification.recipients_email)
}
inline void PagerDutyNotification::add_recipients_email(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  recipients_email_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:flyteidl.admin.PagerDutyNotification.recipients_email)
}
inline void PagerDutyNotification::add_recipients_email(const char* value, size_t size) {
  recipients_email_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:flyteidl.admin.PagerDutyNotification.recipients_email)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PagerDutyNotification::recipients_email() const {
  // @@protoc_insertion_point(field_list:flyteidl.admin.PagerDutyNotification.recipients_email)
  return recipients_email_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PagerDutyNotification::mutable_recipients_email() {
  // @@protoc_insertion_point(field_mutable_list:flyteidl.admin.PagerDutyNotification.recipients_email)
  return &recipients_email_;
}

// -------------------------------------------------------------------

// SlackNotification

// repeated string recipients_email = 1 [json_name = "recipientsEmail"];
inline int SlackNotification::_internal_recipients_email_size() const {
  return recipients_email_.size();
}
inline int SlackNotification::recipients_email_size() const {
  return _internal_recipients_email_size();
}
inline void SlackNotification::clear_recipients_email() {
  recipients_email_.Clear();
}
inline std::string* SlackNotification::add_recipients_email() {
  std::string* _s = _internal_add_recipients_email();
  // @@protoc_insertion_point(field_add_mutable:flyteidl.admin.SlackNotification.recipients_email)
  return _s;
}
inline const std::string& SlackNotification::_internal_recipients_email(int index) const {
  return recipients_email_.Get(index);
}
inline const std::string& SlackNotification::recipients_email(int index) const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.SlackNotification.recipients_email)
  return _internal_recipients_email(index);
}
inline std::string* SlackNotification::mutable_recipients_email(int index) {
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.SlackNotification.recipients_email)
  return recipients_email_.Mutable(index);
}
inline void SlackNotification::set_recipients_email(int index, const std::string& value) {
  recipients_email_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:flyteidl.admin.SlackNotification.recipients_email)
}
inline void SlackNotification::set_recipients_email(int index, std::string&& value) {
  recipients_email_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:flyteidl.admin.SlackNotification.recipients_email)
}
inline void SlackNotification::set_recipients_email(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  recipients_email_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:flyteidl.admin.SlackNotification.recipients_email)
}
inline void SlackNotification::set_recipients_email(int index, const char* value, size_t size) {
  recipients_email_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:flyteidl.admin.SlackNotification.recipients_email)
}
inline std::string* SlackNotification::_internal_add_recipients_email() {
  return recipients_email_.Add();
}
inline void SlackNotification::add_recipients_email(const std::string& value) {
  recipients_email_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:flyteidl.admin.SlackNotification.recipients_email)
}
inline void SlackNotification::add_recipients_email(std::string&& value) {
  recipients_email_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:flyteidl.admin.SlackNotification.recipients_email)
}
inline void SlackNotification::add_recipients_email(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  recipients_email_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:flyteidl.admin.SlackNotification.recipients_email)
}
inline void SlackNotification::add_recipients_email(const char* value, size_t size) {
  recipients_email_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:flyteidl.admin.SlackNotification.recipients_email)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SlackNotification::recipients_email() const {
  // @@protoc_insertion_point(field_list:flyteidl.admin.SlackNotification.recipients_email)
  return recipients_email_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SlackNotification::mutable_recipients_email() {
  // @@protoc_insertion_point(field_mutable_list:flyteidl.admin.SlackNotification.recipients_email)
  return &recipients_email_;
}

// -------------------------------------------------------------------

// Notification

// repeated .flyteidl.core.WorkflowExecution.Phase phases = 1 [json_name = "phases"];
inline int Notification::_internal_phases_size() const {
  return phases_.size();
}
inline int Notification::phases_size() const {
  return _internal_phases_size();
}
inline void Notification::clear_phases() {
  phases_.Clear();
}
inline ::flyteidl::core::WorkflowExecution_Phase Notification::_internal_phases(int index) const {
  return static_cast< ::flyteidl::core::WorkflowExecution_Phase >(phases_.Get(index));
}
inline ::flyteidl::core::WorkflowExecution_Phase Notification::phases(int index) const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.Notification.phases)
  return _internal_phases(index);
}
inline void Notification::set_phases(int index, ::flyteidl::core::WorkflowExecution_Phase value) {
  phases_.Set(index, value);
  // @@protoc_insertion_point(field_set:flyteidl.admin.Notification.phases)
}
inline void Notification::_internal_add_phases(::flyteidl::core::WorkflowExecution_Phase value) {
  phases_.Add(value);
}
inline void Notification::add_phases(::flyteidl::core::WorkflowExecution_Phase value) {
  _internal_add_phases(value);
  // @@protoc_insertion_point(field_add:flyteidl.admin.Notification.phases)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
Notification::phases() const {
  // @@protoc_insertion_point(field_list:flyteidl.admin.Notification.phases)
  return phases_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
Notification::_internal_mutable_phases() {
  return &phases_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
Notification::mutable_phases() {
  // @@protoc_insertion_point(field_mutable_list:flyteidl.admin.Notification.phases)
  return _internal_mutable_phases();
}

// .flyteidl.admin.EmailNotification email = 2 [json_name = "email"];
inline bool Notification::_internal_has_email() const {
  return type_case() == kEmail;
}
inline bool Notification::has_email() const {
  return _internal_has_email();
}
inline void Notification::set_has_email() {
  _oneof_case_[0] = kEmail;
}
inline void Notification::clear_email() {
  if (_internal_has_email()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.email_;
    }
    clear_has_type();
  }
}
inline ::flyteidl::admin::EmailNotification* Notification::release_email() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.Notification.email)
  if (_internal_has_email()) {
    clear_has_type();
      ::flyteidl::admin::EmailNotification* temp = type_.email_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.email_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::admin::EmailNotification& Notification::_internal_email() const {
  return _internal_has_email()
      ? *type_.email_
      : reinterpret_cast< ::flyteidl::admin::EmailNotification&>(::flyteidl::admin::_EmailNotification_default_instance_);
}
inline const ::flyteidl::admin::EmailNotification& Notification::email() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.Notification.email)
  return _internal_email();
}
inline ::flyteidl::admin::EmailNotification* Notification::unsafe_arena_release_email() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flyteidl.admin.Notification.email)
  if (_internal_has_email()) {
    clear_has_type();
    ::flyteidl::admin::EmailNotification* temp = type_.email_;
    type_.email_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Notification::unsafe_arena_set_allocated_email(::flyteidl::admin::EmailNotification* email) {
  clear_type();
  if (email) {
    set_has_email();
    type_.email_ = email;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.Notification.email)
}
inline ::flyteidl::admin::EmailNotification* Notification::_internal_mutable_email() {
  if (!_internal_has_email()) {
    clear_type();
    set_has_email();
    type_.email_ = CreateMaybeMessage< ::flyteidl::admin::EmailNotification >(GetArenaForAllocation());
  }
  return type_.email_;
}
inline ::flyteidl::admin::EmailNotification* Notification::mutable_email() {
  ::flyteidl::admin::EmailNotification* _msg = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.Notification.email)
  return _msg;
}

// .flyteidl.admin.PagerDutyNotification pager_duty = 3 [json_name = "pagerDuty"];
inline bool Notification::_internal_has_pager_duty() const {
  return type_case() == kPagerDuty;
}
inline bool Notification::has_pager_duty() const {
  return _internal_has_pager_duty();
}
inline void Notification::set_has_pager_duty() {
  _oneof_case_[0] = kPagerDuty;
}
inline void Notification::clear_pager_duty() {
  if (_internal_has_pager_duty()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.pager_duty_;
    }
    clear_has_type();
  }
}
inline ::flyteidl::admin::PagerDutyNotification* Notification::release_pager_duty() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.Notification.pager_duty)
  if (_internal_has_pager_duty()) {
    clear_has_type();
      ::flyteidl::admin::PagerDutyNotification* temp = type_.pager_duty_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.pager_duty_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::admin::PagerDutyNotification& Notification::_internal_pager_duty() const {
  return _internal_has_pager_duty()
      ? *type_.pager_duty_
      : reinterpret_cast< ::flyteidl::admin::PagerDutyNotification&>(::flyteidl::admin::_PagerDutyNotification_default_instance_);
}
inline const ::flyteidl::admin::PagerDutyNotification& Notification::pager_duty() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.Notification.pager_duty)
  return _internal_pager_duty();
}
inline ::flyteidl::admin::PagerDutyNotification* Notification::unsafe_arena_release_pager_duty() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flyteidl.admin.Notification.pager_duty)
  if (_internal_has_pager_duty()) {
    clear_has_type();
    ::flyteidl::admin::PagerDutyNotification* temp = type_.pager_duty_;
    type_.pager_duty_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Notification::unsafe_arena_set_allocated_pager_duty(::flyteidl::admin::PagerDutyNotification* pager_duty) {
  clear_type();
  if (pager_duty) {
    set_has_pager_duty();
    type_.pager_duty_ = pager_duty;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.Notification.pager_duty)
}
inline ::flyteidl::admin::PagerDutyNotification* Notification::_internal_mutable_pager_duty() {
  if (!_internal_has_pager_duty()) {
    clear_type();
    set_has_pager_duty();
    type_.pager_duty_ = CreateMaybeMessage< ::flyteidl::admin::PagerDutyNotification >(GetArenaForAllocation());
  }
  return type_.pager_duty_;
}
inline ::flyteidl::admin::PagerDutyNotification* Notification::mutable_pager_duty() {
  ::flyteidl::admin::PagerDutyNotification* _msg = _internal_mutable_pager_duty();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.Notification.pager_duty)
  return _msg;
}

// .flyteidl.admin.SlackNotification slack = 4 [json_name = "slack"];
inline bool Notification::_internal_has_slack() const {
  return type_case() == kSlack;
}
inline bool Notification::has_slack() const {
  return _internal_has_slack();
}
inline void Notification::set_has_slack() {
  _oneof_case_[0] = kSlack;
}
inline void Notification::clear_slack() {
  if (_internal_has_slack()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.slack_;
    }
    clear_has_type();
  }
}
inline ::flyteidl::admin::SlackNotification* Notification::release_slack() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.Notification.slack)
  if (_internal_has_slack()) {
    clear_has_type();
      ::flyteidl::admin::SlackNotification* temp = type_.slack_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.slack_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::admin::SlackNotification& Notification::_internal_slack() const {
  return _internal_has_slack()
      ? *type_.slack_
      : reinterpret_cast< ::flyteidl::admin::SlackNotification&>(::flyteidl::admin::_SlackNotification_default_instance_);
}
inline const ::flyteidl::admin::SlackNotification& Notification::slack() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.Notification.slack)
  return _internal_slack();
}
inline ::flyteidl::admin::SlackNotification* Notification::unsafe_arena_release_slack() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flyteidl.admin.Notification.slack)
  if (_internal_has_slack()) {
    clear_has_type();
    ::flyteidl::admin::SlackNotification* temp = type_.slack_;
    type_.slack_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Notification::unsafe_arena_set_allocated_slack(::flyteidl::admin::SlackNotification* slack) {
  clear_type();
  if (slack) {
    set_has_slack();
    type_.slack_ = slack;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.admin.Notification.slack)
}
inline ::flyteidl::admin::SlackNotification* Notification::_internal_mutable_slack() {
  if (!_internal_has_slack()) {
    clear_type();
    set_has_slack();
    type_.slack_ = CreateMaybeMessage< ::flyteidl::admin::SlackNotification >(GetArenaForAllocation());
  }
  return type_.slack_;
}
inline ::flyteidl::admin::SlackNotification* Notification::mutable_slack() {
  ::flyteidl::admin::SlackNotification* _msg = _internal_mutable_slack();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.Notification.slack)
  return _msg;
}

inline bool Notification::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void Notification::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline Notification::TypeCase Notification::type_case() const {
  return Notification::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// UrlBlob

// string url = 1 [json_name = "url"];
inline void UrlBlob::clear_url() {
  url_.ClearToEmpty();
}
inline const std::string& UrlBlob::url() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.UrlBlob.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UrlBlob::set_url(ArgT0&& arg0, ArgT... args) {
 
 url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.admin.UrlBlob.url)
}
inline std::string* UrlBlob::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.UrlBlob.url)
  return _s;
}
inline const std::string& UrlBlob::_internal_url() const {
  return url_.Get();
}
inline void UrlBlob::_internal_set_url(const std::string& value) {
  
  url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UrlBlob::_internal_mutable_url() {
  
  return url_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UrlBlob::release_url() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.UrlBlob.url)
  return url_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UrlBlob::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  url_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), url,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.UrlBlob.url)
}

// int64 bytes = 2 [json_name = "bytes"];
inline void UrlBlob::clear_bytes() {
  bytes_ = int64_t{0};
}
inline int64_t UrlBlob::_internal_bytes() const {
  return bytes_;
}
inline int64_t UrlBlob::bytes() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.UrlBlob.bytes)
  return _internal_bytes();
}
inline void UrlBlob::_internal_set_bytes(int64_t value) {
  
  bytes_ = value;
}
inline void UrlBlob::set_bytes(int64_t value) {
  _internal_set_bytes(value);
  // @@protoc_insertion_point(field_set:flyteidl.admin.UrlBlob.bytes)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Labels

// map<string, string> values = 1 [json_name = "values"];
inline int Labels::_internal_values_size() const {
  return values_.size();
}
inline int Labels::values_size() const {
  return _internal_values_size();
}
inline void Labels::clear_values() {
  values_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Labels::_internal_values() const {
  return values_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Labels::values() const {
  // @@protoc_insertion_point(field_map:flyteidl.admin.Labels.values)
  return _internal_values();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Labels::_internal_mutable_values() {
  return values_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Labels::mutable_values() {
  // @@protoc_insertion_point(field_mutable_map:flyteidl.admin.Labels.values)
  return _internal_mutable_values();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Annotations

// map<string, string> values = 1 [json_name = "values"];
inline int Annotations::_internal_values_size() const {
  return values_.size();
}
inline int Annotations::values_size() const {
  return _internal_values_size();
}
inline void Annotations::clear_values() {
  values_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Annotations::_internal_values() const {
  return values_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Annotations::values() const {
  // @@protoc_insertion_point(field_map:flyteidl.admin.Annotations.values)
  return _internal_values();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Annotations::_internal_mutable_values() {
  return values_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Annotations::mutable_values() {
  // @@protoc_insertion_point(field_mutable_map:flyteidl.admin.Annotations.values)
  return _internal_mutable_values();
}

// -------------------------------------------------------------------

// AuthRole

// string assumable_iam_role = 1 [json_name = "assumableIamRole"];
inline void AuthRole::clear_assumable_iam_role() {
  assumable_iam_role_.ClearToEmpty();
}
inline const std::string& AuthRole::assumable_iam_role() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.AuthRole.assumable_iam_role)
  return _internal_assumable_iam_role();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthRole::set_assumable_iam_role(ArgT0&& arg0, ArgT... args) {
 
 assumable_iam_role_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.admin.AuthRole.assumable_iam_role)
}
inline std::string* AuthRole::mutable_assumable_iam_role() {
  std::string* _s = _internal_mutable_assumable_iam_role();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.AuthRole.assumable_iam_role)
  return _s;
}
inline const std::string& AuthRole::_internal_assumable_iam_role() const {
  return assumable_iam_role_.Get();
}
inline void AuthRole::_internal_set_assumable_iam_role(const std::string& value) {
  
  assumable_iam_role_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AuthRole::_internal_mutable_assumable_iam_role() {
  
  return assumable_iam_role_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AuthRole::release_assumable_iam_role() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.AuthRole.assumable_iam_role)
  return assumable_iam_role_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AuthRole::set_allocated_assumable_iam_role(std::string* assumable_iam_role) {
  if (assumable_iam_role != nullptr) {
    
  } else {
    
  }
  assumable_iam_role_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), assumable_iam_role,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (assumable_iam_role_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    assumable_iam_role_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.AuthRole.assumable_iam_role)
}

// string kubernetes_service_account = 2 [json_name = "kubernetesServiceAccount"];
inline void AuthRole::clear_kubernetes_service_account() {
  kubernetes_service_account_.ClearToEmpty();
}
inline const std::string& AuthRole::kubernetes_service_account() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.AuthRole.kubernetes_service_account)
  return _internal_kubernetes_service_account();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthRole::set_kubernetes_service_account(ArgT0&& arg0, ArgT... args) {
 
 kubernetes_service_account_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.admin.AuthRole.kubernetes_service_account)
}
inline std::string* AuthRole::mutable_kubernetes_service_account() {
  std::string* _s = _internal_mutable_kubernetes_service_account();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.AuthRole.kubernetes_service_account)
  return _s;
}
inline const std::string& AuthRole::_internal_kubernetes_service_account() const {
  return kubernetes_service_account_.Get();
}
inline void AuthRole::_internal_set_kubernetes_service_account(const std::string& value) {
  
  kubernetes_service_account_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AuthRole::_internal_mutable_kubernetes_service_account() {
  
  return kubernetes_service_account_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AuthRole::release_kubernetes_service_account() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.AuthRole.kubernetes_service_account)
  return kubernetes_service_account_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AuthRole::set_allocated_kubernetes_service_account(std::string* kubernetes_service_account) {
  if (kubernetes_service_account != nullptr) {
    
  } else {
    
  }
  kubernetes_service_account_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), kubernetes_service_account,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (kubernetes_service_account_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    kubernetes_service_account_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.AuthRole.kubernetes_service_account)
}

// -------------------------------------------------------------------

// RawOutputDataConfig

// string output_location_prefix = 1 [json_name = "outputLocationPrefix"];
inline void RawOutputDataConfig::clear_output_location_prefix() {
  output_location_prefix_.ClearToEmpty();
}
inline const std::string& RawOutputDataConfig::output_location_prefix() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.RawOutputDataConfig.output_location_prefix)
  return _internal_output_location_prefix();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RawOutputDataConfig::set_output_location_prefix(ArgT0&& arg0, ArgT... args) {
 
 output_location_prefix_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.admin.RawOutputDataConfig.output_location_prefix)
}
inline std::string* RawOutputDataConfig::mutable_output_location_prefix() {
  std::string* _s = _internal_mutable_output_location_prefix();
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.RawOutputDataConfig.output_location_prefix)
  return _s;
}
inline const std::string& RawOutputDataConfig::_internal_output_location_prefix() const {
  return output_location_prefix_.Get();
}
inline void RawOutputDataConfig::_internal_set_output_location_prefix(const std::string& value) {
  
  output_location_prefix_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RawOutputDataConfig::_internal_mutable_output_location_prefix() {
  
  return output_location_prefix_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RawOutputDataConfig::release_output_location_prefix() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.RawOutputDataConfig.output_location_prefix)
  return output_location_prefix_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RawOutputDataConfig::set_allocated_output_location_prefix(std::string* output_location_prefix) {
  if (output_location_prefix != nullptr) {
    
  } else {
    
  }
  output_location_prefix_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), output_location_prefix,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (output_location_prefix_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    output_location_prefix_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.RawOutputDataConfig.output_location_prefix)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace admin
}  // namespace flyteidl

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::flyteidl::admin::Sort_Direction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::flyteidl::admin::Sort_Direction>() {
  return ::flyteidl::admin::Sort_Direction_descriptor();
}
template <> struct is_proto_enum< ::flyteidl::admin::NamedEntityState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::flyteidl::admin::NamedEntityState>() {
  return ::flyteidl::admin::NamedEntityState_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_flyteidl_2fadmin_2fcommon_2eproto
