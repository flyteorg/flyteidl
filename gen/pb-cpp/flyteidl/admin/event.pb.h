// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: flyteidl/admin/event.proto

#ifndef PROTOBUF_INCLUDED_flyteidl_2fadmin_2fevent_2eproto
#define PROTOBUF_INCLUDED_flyteidl_2fadmin_2fevent_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "flyteidl/event/event.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_flyteidl_2fadmin_2fevent_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_flyteidl_2fadmin_2fevent_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[9]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_flyteidl_2fadmin_2fevent_2eproto();
namespace flyteidl {
namespace admin {
class EventErrorAlreadyInTerminalState;
class EventErrorAlreadyInTerminalStateDefaultTypeInternal;
extern EventErrorAlreadyInTerminalStateDefaultTypeInternal _EventErrorAlreadyInTerminalState_default_instance_;
class EventErrorIncompatibleCluster;
class EventErrorIncompatibleClusterDefaultTypeInternal;
extern EventErrorIncompatibleClusterDefaultTypeInternal _EventErrorIncompatibleCluster_default_instance_;
class EventFailureReason;
class EventFailureReasonDefaultTypeInternal;
extern EventFailureReasonDefaultTypeInternal _EventFailureReason_default_instance_;
class NodeExecutionEventRequest;
class NodeExecutionEventRequestDefaultTypeInternal;
extern NodeExecutionEventRequestDefaultTypeInternal _NodeExecutionEventRequest_default_instance_;
class NodeExecutionEventResponse;
class NodeExecutionEventResponseDefaultTypeInternal;
extern NodeExecutionEventResponseDefaultTypeInternal _NodeExecutionEventResponse_default_instance_;
class TaskExecutionEventRequest;
class TaskExecutionEventRequestDefaultTypeInternal;
extern TaskExecutionEventRequestDefaultTypeInternal _TaskExecutionEventRequest_default_instance_;
class TaskExecutionEventResponse;
class TaskExecutionEventResponseDefaultTypeInternal;
extern TaskExecutionEventResponseDefaultTypeInternal _TaskExecutionEventResponse_default_instance_;
class WorkflowExecutionEventRequest;
class WorkflowExecutionEventRequestDefaultTypeInternal;
extern WorkflowExecutionEventRequestDefaultTypeInternal _WorkflowExecutionEventRequest_default_instance_;
class WorkflowExecutionEventResponse;
class WorkflowExecutionEventResponseDefaultTypeInternal;
extern WorkflowExecutionEventResponseDefaultTypeInternal _WorkflowExecutionEventResponse_default_instance_;
}  // namespace admin
}  // namespace flyteidl
namespace google {
namespace protobuf {
template<> ::flyteidl::admin::EventErrorAlreadyInTerminalState* Arena::CreateMaybeMessage<::flyteidl::admin::EventErrorAlreadyInTerminalState>(Arena*);
template<> ::flyteidl::admin::EventErrorIncompatibleCluster* Arena::CreateMaybeMessage<::flyteidl::admin::EventErrorIncompatibleCluster>(Arena*);
template<> ::flyteidl::admin::EventFailureReason* Arena::CreateMaybeMessage<::flyteidl::admin::EventFailureReason>(Arena*);
template<> ::flyteidl::admin::NodeExecutionEventRequest* Arena::CreateMaybeMessage<::flyteidl::admin::NodeExecutionEventRequest>(Arena*);
template<> ::flyteidl::admin::NodeExecutionEventResponse* Arena::CreateMaybeMessage<::flyteidl::admin::NodeExecutionEventResponse>(Arena*);
template<> ::flyteidl::admin::TaskExecutionEventRequest* Arena::CreateMaybeMessage<::flyteidl::admin::TaskExecutionEventRequest>(Arena*);
template<> ::flyteidl::admin::TaskExecutionEventResponse* Arena::CreateMaybeMessage<::flyteidl::admin::TaskExecutionEventResponse>(Arena*);
template<> ::flyteidl::admin::WorkflowExecutionEventRequest* Arena::CreateMaybeMessage<::flyteidl::admin::WorkflowExecutionEventRequest>(Arena*);
template<> ::flyteidl::admin::WorkflowExecutionEventResponse* Arena::CreateMaybeMessage<::flyteidl::admin::WorkflowExecutionEventResponse>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace flyteidl {
namespace admin {

// ===================================================================

class EventErrorAlreadyInTerminalState final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.admin.EventErrorAlreadyInTerminalState) */ {
 public:
  EventErrorAlreadyInTerminalState();
  virtual ~EventErrorAlreadyInTerminalState();

  EventErrorAlreadyInTerminalState(const EventErrorAlreadyInTerminalState& from);

  inline EventErrorAlreadyInTerminalState& operator=(const EventErrorAlreadyInTerminalState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EventErrorAlreadyInTerminalState(EventErrorAlreadyInTerminalState&& from) noexcept
    : EventErrorAlreadyInTerminalState() {
    *this = ::std::move(from);
  }

  inline EventErrorAlreadyInTerminalState& operator=(EventErrorAlreadyInTerminalState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const EventErrorAlreadyInTerminalState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EventErrorAlreadyInTerminalState* internal_default_instance() {
    return reinterpret_cast<const EventErrorAlreadyInTerminalState*>(
               &_EventErrorAlreadyInTerminalState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(EventErrorAlreadyInTerminalState* other);
  friend void swap(EventErrorAlreadyInTerminalState& a, EventErrorAlreadyInTerminalState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EventErrorAlreadyInTerminalState* New() const final {
    return CreateMaybeMessage<EventErrorAlreadyInTerminalState>(nullptr);
  }

  EventErrorAlreadyInTerminalState* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EventErrorAlreadyInTerminalState>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EventErrorAlreadyInTerminalState& from);
  void MergeFrom(const EventErrorAlreadyInTerminalState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventErrorAlreadyInTerminalState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string current_phase = 1;
  void clear_current_phase();
  static const int kCurrentPhaseFieldNumber = 1;
  const ::std::string& current_phase() const;
  void set_current_phase(const ::std::string& value);
  #if LANG_CXX11
  void set_current_phase(::std::string&& value);
  #endif
  void set_current_phase(const char* value);
  void set_current_phase(const char* value, size_t size);
  ::std::string* mutable_current_phase();
  ::std::string* release_current_phase();
  void set_allocated_current_phase(::std::string* current_phase);

  // @@protoc_insertion_point(class_scope:flyteidl.admin.EventErrorAlreadyInTerminalState)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr current_phase_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fadmin_2fevent_2eproto;
};
// -------------------------------------------------------------------

class EventErrorIncompatibleCluster final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.admin.EventErrorIncompatibleCluster) */ {
 public:
  EventErrorIncompatibleCluster();
  virtual ~EventErrorIncompatibleCluster();

  EventErrorIncompatibleCluster(const EventErrorIncompatibleCluster& from);

  inline EventErrorIncompatibleCluster& operator=(const EventErrorIncompatibleCluster& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EventErrorIncompatibleCluster(EventErrorIncompatibleCluster&& from) noexcept
    : EventErrorIncompatibleCluster() {
    *this = ::std::move(from);
  }

  inline EventErrorIncompatibleCluster& operator=(EventErrorIncompatibleCluster&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const EventErrorIncompatibleCluster& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EventErrorIncompatibleCluster* internal_default_instance() {
    return reinterpret_cast<const EventErrorIncompatibleCluster*>(
               &_EventErrorIncompatibleCluster_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(EventErrorIncompatibleCluster* other);
  friend void swap(EventErrorIncompatibleCluster& a, EventErrorIncompatibleCluster& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EventErrorIncompatibleCluster* New() const final {
    return CreateMaybeMessage<EventErrorIncompatibleCluster>(nullptr);
  }

  EventErrorIncompatibleCluster* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EventErrorIncompatibleCluster>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EventErrorIncompatibleCluster& from);
  void MergeFrom(const EventErrorIncompatibleCluster& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventErrorIncompatibleCluster* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string cluster = 1;
  void clear_cluster();
  static const int kClusterFieldNumber = 1;
  const ::std::string& cluster() const;
  void set_cluster(const ::std::string& value);
  #if LANG_CXX11
  void set_cluster(::std::string&& value);
  #endif
  void set_cluster(const char* value);
  void set_cluster(const char* value, size_t size);
  ::std::string* mutable_cluster();
  ::std::string* release_cluster();
  void set_allocated_cluster(::std::string* cluster);

  // @@protoc_insertion_point(class_scope:flyteidl.admin.EventErrorIncompatibleCluster)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr cluster_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fadmin_2fevent_2eproto;
};
// -------------------------------------------------------------------

class EventFailureReason final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.admin.EventFailureReason) */ {
 public:
  EventFailureReason();
  virtual ~EventFailureReason();

  EventFailureReason(const EventFailureReason& from);

  inline EventFailureReason& operator=(const EventFailureReason& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EventFailureReason(EventFailureReason&& from) noexcept
    : EventFailureReason() {
    *this = ::std::move(from);
  }

  inline EventFailureReason& operator=(EventFailureReason&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const EventFailureReason& default_instance();

  enum ReasonCase {
    kAlreadyInTerminalState = 1,
    kIncompatibleCluster = 2,
    REASON_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EventFailureReason* internal_default_instance() {
    return reinterpret_cast<const EventFailureReason*>(
               &_EventFailureReason_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(EventFailureReason* other);
  friend void swap(EventFailureReason& a, EventFailureReason& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EventFailureReason* New() const final {
    return CreateMaybeMessage<EventFailureReason>(nullptr);
  }

  EventFailureReason* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EventFailureReason>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EventFailureReason& from);
  void MergeFrom(const EventFailureReason& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventFailureReason* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .flyteidl.admin.EventErrorAlreadyInTerminalState already_in_terminal_state = 1;
  bool has_already_in_terminal_state() const;
  void clear_already_in_terminal_state();
  static const int kAlreadyInTerminalStateFieldNumber = 1;
  const ::flyteidl::admin::EventErrorAlreadyInTerminalState& already_in_terminal_state() const;
  ::flyteidl::admin::EventErrorAlreadyInTerminalState* release_already_in_terminal_state();
  ::flyteidl::admin::EventErrorAlreadyInTerminalState* mutable_already_in_terminal_state();
  void set_allocated_already_in_terminal_state(::flyteidl::admin::EventErrorAlreadyInTerminalState* already_in_terminal_state);

  // .flyteidl.admin.EventErrorIncompatibleCluster incompatible_cluster = 2;
  bool has_incompatible_cluster() const;
  void clear_incompatible_cluster();
  static const int kIncompatibleClusterFieldNumber = 2;
  const ::flyteidl::admin::EventErrorIncompatibleCluster& incompatible_cluster() const;
  ::flyteidl::admin::EventErrorIncompatibleCluster* release_incompatible_cluster();
  ::flyteidl::admin::EventErrorIncompatibleCluster* mutable_incompatible_cluster();
  void set_allocated_incompatible_cluster(::flyteidl::admin::EventErrorIncompatibleCluster* incompatible_cluster);

  void clear_reason();
  ReasonCase reason_case() const;
  // @@protoc_insertion_point(class_scope:flyteidl.admin.EventFailureReason)
 private:
  class HasBitSetters;
  void set_has_already_in_terminal_state();
  void set_has_incompatible_cluster();

  inline bool has_reason() const;
  inline void clear_has_reason();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union ReasonUnion {
    ReasonUnion() {}
    ::flyteidl::admin::EventErrorAlreadyInTerminalState* already_in_terminal_state_;
    ::flyteidl::admin::EventErrorIncompatibleCluster* incompatible_cluster_;
  } reason_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_flyteidl_2fadmin_2fevent_2eproto;
};
// -------------------------------------------------------------------

class WorkflowExecutionEventRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.admin.WorkflowExecutionEventRequest) */ {
 public:
  WorkflowExecutionEventRequest();
  virtual ~WorkflowExecutionEventRequest();

  WorkflowExecutionEventRequest(const WorkflowExecutionEventRequest& from);

  inline WorkflowExecutionEventRequest& operator=(const WorkflowExecutionEventRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WorkflowExecutionEventRequest(WorkflowExecutionEventRequest&& from) noexcept
    : WorkflowExecutionEventRequest() {
    *this = ::std::move(from);
  }

  inline WorkflowExecutionEventRequest& operator=(WorkflowExecutionEventRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const WorkflowExecutionEventRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WorkflowExecutionEventRequest* internal_default_instance() {
    return reinterpret_cast<const WorkflowExecutionEventRequest*>(
               &_WorkflowExecutionEventRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(WorkflowExecutionEventRequest* other);
  friend void swap(WorkflowExecutionEventRequest& a, WorkflowExecutionEventRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WorkflowExecutionEventRequest* New() const final {
    return CreateMaybeMessage<WorkflowExecutionEventRequest>(nullptr);
  }

  WorkflowExecutionEventRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WorkflowExecutionEventRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WorkflowExecutionEventRequest& from);
  void MergeFrom(const WorkflowExecutionEventRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkflowExecutionEventRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string request_id = 1;
  void clear_request_id();
  static const int kRequestIdFieldNumber = 1;
  const ::std::string& request_id() const;
  void set_request_id(const ::std::string& value);
  #if LANG_CXX11
  void set_request_id(::std::string&& value);
  #endif
  void set_request_id(const char* value);
  void set_request_id(const char* value, size_t size);
  ::std::string* mutable_request_id();
  ::std::string* release_request_id();
  void set_allocated_request_id(::std::string* request_id);

  // .flyteidl.event.WorkflowExecutionEvent event = 2;
  bool has_event() const;
  void clear_event();
  static const int kEventFieldNumber = 2;
  const ::flyteidl::event::WorkflowExecutionEvent& event() const;
  ::flyteidl::event::WorkflowExecutionEvent* release_event();
  ::flyteidl::event::WorkflowExecutionEvent* mutable_event();
  void set_allocated_event(::flyteidl::event::WorkflowExecutionEvent* event);

  // @@protoc_insertion_point(class_scope:flyteidl.admin.WorkflowExecutionEventRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr request_id_;
  ::flyteidl::event::WorkflowExecutionEvent* event_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fadmin_2fevent_2eproto;
};
// -------------------------------------------------------------------

class WorkflowExecutionEventResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.admin.WorkflowExecutionEventResponse) */ {
 public:
  WorkflowExecutionEventResponse();
  virtual ~WorkflowExecutionEventResponse();

  WorkflowExecutionEventResponse(const WorkflowExecutionEventResponse& from);

  inline WorkflowExecutionEventResponse& operator=(const WorkflowExecutionEventResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WorkflowExecutionEventResponse(WorkflowExecutionEventResponse&& from) noexcept
    : WorkflowExecutionEventResponse() {
    *this = ::std::move(from);
  }

  inline WorkflowExecutionEventResponse& operator=(WorkflowExecutionEventResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const WorkflowExecutionEventResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WorkflowExecutionEventResponse* internal_default_instance() {
    return reinterpret_cast<const WorkflowExecutionEventResponse*>(
               &_WorkflowExecutionEventResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(WorkflowExecutionEventResponse* other);
  friend void swap(WorkflowExecutionEventResponse& a, WorkflowExecutionEventResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WorkflowExecutionEventResponse* New() const final {
    return CreateMaybeMessage<WorkflowExecutionEventResponse>(nullptr);
  }

  WorkflowExecutionEventResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WorkflowExecutionEventResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WorkflowExecutionEventResponse& from);
  void MergeFrom(const WorkflowExecutionEventResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkflowExecutionEventResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:flyteidl.admin.WorkflowExecutionEventResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fadmin_2fevent_2eproto;
};
// -------------------------------------------------------------------

class NodeExecutionEventRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.admin.NodeExecutionEventRequest) */ {
 public:
  NodeExecutionEventRequest();
  virtual ~NodeExecutionEventRequest();

  NodeExecutionEventRequest(const NodeExecutionEventRequest& from);

  inline NodeExecutionEventRequest& operator=(const NodeExecutionEventRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NodeExecutionEventRequest(NodeExecutionEventRequest&& from) noexcept
    : NodeExecutionEventRequest() {
    *this = ::std::move(from);
  }

  inline NodeExecutionEventRequest& operator=(NodeExecutionEventRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const NodeExecutionEventRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NodeExecutionEventRequest* internal_default_instance() {
    return reinterpret_cast<const NodeExecutionEventRequest*>(
               &_NodeExecutionEventRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(NodeExecutionEventRequest* other);
  friend void swap(NodeExecutionEventRequest& a, NodeExecutionEventRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NodeExecutionEventRequest* New() const final {
    return CreateMaybeMessage<NodeExecutionEventRequest>(nullptr);
  }

  NodeExecutionEventRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NodeExecutionEventRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NodeExecutionEventRequest& from);
  void MergeFrom(const NodeExecutionEventRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeExecutionEventRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string request_id = 1;
  void clear_request_id();
  static const int kRequestIdFieldNumber = 1;
  const ::std::string& request_id() const;
  void set_request_id(const ::std::string& value);
  #if LANG_CXX11
  void set_request_id(::std::string&& value);
  #endif
  void set_request_id(const char* value);
  void set_request_id(const char* value, size_t size);
  ::std::string* mutable_request_id();
  ::std::string* release_request_id();
  void set_allocated_request_id(::std::string* request_id);

  // .flyteidl.event.NodeExecutionEvent event = 2;
  bool has_event() const;
  void clear_event();
  static const int kEventFieldNumber = 2;
  const ::flyteidl::event::NodeExecutionEvent& event() const;
  ::flyteidl::event::NodeExecutionEvent* release_event();
  ::flyteidl::event::NodeExecutionEvent* mutable_event();
  void set_allocated_event(::flyteidl::event::NodeExecutionEvent* event);

  // @@protoc_insertion_point(class_scope:flyteidl.admin.NodeExecutionEventRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr request_id_;
  ::flyteidl::event::NodeExecutionEvent* event_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fadmin_2fevent_2eproto;
};
// -------------------------------------------------------------------

class NodeExecutionEventResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.admin.NodeExecutionEventResponse) */ {
 public:
  NodeExecutionEventResponse();
  virtual ~NodeExecutionEventResponse();

  NodeExecutionEventResponse(const NodeExecutionEventResponse& from);

  inline NodeExecutionEventResponse& operator=(const NodeExecutionEventResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NodeExecutionEventResponse(NodeExecutionEventResponse&& from) noexcept
    : NodeExecutionEventResponse() {
    *this = ::std::move(from);
  }

  inline NodeExecutionEventResponse& operator=(NodeExecutionEventResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const NodeExecutionEventResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NodeExecutionEventResponse* internal_default_instance() {
    return reinterpret_cast<const NodeExecutionEventResponse*>(
               &_NodeExecutionEventResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(NodeExecutionEventResponse* other);
  friend void swap(NodeExecutionEventResponse& a, NodeExecutionEventResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NodeExecutionEventResponse* New() const final {
    return CreateMaybeMessage<NodeExecutionEventResponse>(nullptr);
  }

  NodeExecutionEventResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NodeExecutionEventResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NodeExecutionEventResponse& from);
  void MergeFrom(const NodeExecutionEventResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeExecutionEventResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:flyteidl.admin.NodeExecutionEventResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fadmin_2fevent_2eproto;
};
// -------------------------------------------------------------------

class TaskExecutionEventRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.admin.TaskExecutionEventRequest) */ {
 public:
  TaskExecutionEventRequest();
  virtual ~TaskExecutionEventRequest();

  TaskExecutionEventRequest(const TaskExecutionEventRequest& from);

  inline TaskExecutionEventRequest& operator=(const TaskExecutionEventRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TaskExecutionEventRequest(TaskExecutionEventRequest&& from) noexcept
    : TaskExecutionEventRequest() {
    *this = ::std::move(from);
  }

  inline TaskExecutionEventRequest& operator=(TaskExecutionEventRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TaskExecutionEventRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TaskExecutionEventRequest* internal_default_instance() {
    return reinterpret_cast<const TaskExecutionEventRequest*>(
               &_TaskExecutionEventRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(TaskExecutionEventRequest* other);
  friend void swap(TaskExecutionEventRequest& a, TaskExecutionEventRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TaskExecutionEventRequest* New() const final {
    return CreateMaybeMessage<TaskExecutionEventRequest>(nullptr);
  }

  TaskExecutionEventRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TaskExecutionEventRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TaskExecutionEventRequest& from);
  void MergeFrom(const TaskExecutionEventRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskExecutionEventRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string request_id = 1;
  void clear_request_id();
  static const int kRequestIdFieldNumber = 1;
  const ::std::string& request_id() const;
  void set_request_id(const ::std::string& value);
  #if LANG_CXX11
  void set_request_id(::std::string&& value);
  #endif
  void set_request_id(const char* value);
  void set_request_id(const char* value, size_t size);
  ::std::string* mutable_request_id();
  ::std::string* release_request_id();
  void set_allocated_request_id(::std::string* request_id);

  // .flyteidl.event.TaskExecutionEvent event = 2;
  bool has_event() const;
  void clear_event();
  static const int kEventFieldNumber = 2;
  const ::flyteidl::event::TaskExecutionEvent& event() const;
  ::flyteidl::event::TaskExecutionEvent* release_event();
  ::flyteidl::event::TaskExecutionEvent* mutable_event();
  void set_allocated_event(::flyteidl::event::TaskExecutionEvent* event);

  // @@protoc_insertion_point(class_scope:flyteidl.admin.TaskExecutionEventRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr request_id_;
  ::flyteidl::event::TaskExecutionEvent* event_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fadmin_2fevent_2eproto;
};
// -------------------------------------------------------------------

class TaskExecutionEventResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.admin.TaskExecutionEventResponse) */ {
 public:
  TaskExecutionEventResponse();
  virtual ~TaskExecutionEventResponse();

  TaskExecutionEventResponse(const TaskExecutionEventResponse& from);

  inline TaskExecutionEventResponse& operator=(const TaskExecutionEventResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TaskExecutionEventResponse(TaskExecutionEventResponse&& from) noexcept
    : TaskExecutionEventResponse() {
    *this = ::std::move(from);
  }

  inline TaskExecutionEventResponse& operator=(TaskExecutionEventResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TaskExecutionEventResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TaskExecutionEventResponse* internal_default_instance() {
    return reinterpret_cast<const TaskExecutionEventResponse*>(
               &_TaskExecutionEventResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(TaskExecutionEventResponse* other);
  friend void swap(TaskExecutionEventResponse& a, TaskExecutionEventResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TaskExecutionEventResponse* New() const final {
    return CreateMaybeMessage<TaskExecutionEventResponse>(nullptr);
  }

  TaskExecutionEventResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TaskExecutionEventResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TaskExecutionEventResponse& from);
  void MergeFrom(const TaskExecutionEventResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskExecutionEventResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:flyteidl.admin.TaskExecutionEventResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fadmin_2fevent_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// EventErrorAlreadyInTerminalState

// string current_phase = 1;
inline void EventErrorAlreadyInTerminalState::clear_current_phase() {
  current_phase_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EventErrorAlreadyInTerminalState::current_phase() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.EventErrorAlreadyInTerminalState.current_phase)
  return current_phase_.GetNoArena();
}
inline void EventErrorAlreadyInTerminalState::set_current_phase(const ::std::string& value) {
  
  current_phase_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.admin.EventErrorAlreadyInTerminalState.current_phase)
}
#if LANG_CXX11
inline void EventErrorAlreadyInTerminalState::set_current_phase(::std::string&& value) {
  
  current_phase_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.admin.EventErrorAlreadyInTerminalState.current_phase)
}
#endif
inline void EventErrorAlreadyInTerminalState::set_current_phase(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  current_phase_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.admin.EventErrorAlreadyInTerminalState.current_phase)
}
inline void EventErrorAlreadyInTerminalState::set_current_phase(const char* value, size_t size) {
  
  current_phase_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.admin.EventErrorAlreadyInTerminalState.current_phase)
}
inline ::std::string* EventErrorAlreadyInTerminalState::mutable_current_phase() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.EventErrorAlreadyInTerminalState.current_phase)
  return current_phase_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EventErrorAlreadyInTerminalState::release_current_phase() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.EventErrorAlreadyInTerminalState.current_phase)
  
  return current_phase_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EventErrorAlreadyInTerminalState::set_allocated_current_phase(::std::string* current_phase) {
  if (current_phase != nullptr) {
    
  } else {
    
  }
  current_phase_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), current_phase);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.EventErrorAlreadyInTerminalState.current_phase)
}

// -------------------------------------------------------------------

// EventErrorIncompatibleCluster

// string cluster = 1;
inline void EventErrorIncompatibleCluster::clear_cluster() {
  cluster_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EventErrorIncompatibleCluster::cluster() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.EventErrorIncompatibleCluster.cluster)
  return cluster_.GetNoArena();
}
inline void EventErrorIncompatibleCluster::set_cluster(const ::std::string& value) {
  
  cluster_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.admin.EventErrorIncompatibleCluster.cluster)
}
#if LANG_CXX11
inline void EventErrorIncompatibleCluster::set_cluster(::std::string&& value) {
  
  cluster_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.admin.EventErrorIncompatibleCluster.cluster)
}
#endif
inline void EventErrorIncompatibleCluster::set_cluster(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  cluster_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.admin.EventErrorIncompatibleCluster.cluster)
}
inline void EventErrorIncompatibleCluster::set_cluster(const char* value, size_t size) {
  
  cluster_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.admin.EventErrorIncompatibleCluster.cluster)
}
inline ::std::string* EventErrorIncompatibleCluster::mutable_cluster() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.EventErrorIncompatibleCluster.cluster)
  return cluster_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EventErrorIncompatibleCluster::release_cluster() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.EventErrorIncompatibleCluster.cluster)
  
  return cluster_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EventErrorIncompatibleCluster::set_allocated_cluster(::std::string* cluster) {
  if (cluster != nullptr) {
    
  } else {
    
  }
  cluster_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cluster);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.EventErrorIncompatibleCluster.cluster)
}

// -------------------------------------------------------------------

// EventFailureReason

// .flyteidl.admin.EventErrorAlreadyInTerminalState already_in_terminal_state = 1;
inline bool EventFailureReason::has_already_in_terminal_state() const {
  return reason_case() == kAlreadyInTerminalState;
}
inline void EventFailureReason::set_has_already_in_terminal_state() {
  _oneof_case_[0] = kAlreadyInTerminalState;
}
inline void EventFailureReason::clear_already_in_terminal_state() {
  if (has_already_in_terminal_state()) {
    delete reason_.already_in_terminal_state_;
    clear_has_reason();
  }
}
inline ::flyteidl::admin::EventErrorAlreadyInTerminalState* EventFailureReason::release_already_in_terminal_state() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.EventFailureReason.already_in_terminal_state)
  if (has_already_in_terminal_state()) {
    clear_has_reason();
      ::flyteidl::admin::EventErrorAlreadyInTerminalState* temp = reason_.already_in_terminal_state_;
    reason_.already_in_terminal_state_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::admin::EventErrorAlreadyInTerminalState& EventFailureReason::already_in_terminal_state() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.EventFailureReason.already_in_terminal_state)
  return has_already_in_terminal_state()
      ? *reason_.already_in_terminal_state_
      : *reinterpret_cast< ::flyteidl::admin::EventErrorAlreadyInTerminalState*>(&::flyteidl::admin::_EventErrorAlreadyInTerminalState_default_instance_);
}
inline ::flyteidl::admin::EventErrorAlreadyInTerminalState* EventFailureReason::mutable_already_in_terminal_state() {
  if (!has_already_in_terminal_state()) {
    clear_reason();
    set_has_already_in_terminal_state();
    reason_.already_in_terminal_state_ = CreateMaybeMessage< ::flyteidl::admin::EventErrorAlreadyInTerminalState >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.EventFailureReason.already_in_terminal_state)
  return reason_.already_in_terminal_state_;
}

// .flyteidl.admin.EventErrorIncompatibleCluster incompatible_cluster = 2;
inline bool EventFailureReason::has_incompatible_cluster() const {
  return reason_case() == kIncompatibleCluster;
}
inline void EventFailureReason::set_has_incompatible_cluster() {
  _oneof_case_[0] = kIncompatibleCluster;
}
inline void EventFailureReason::clear_incompatible_cluster() {
  if (has_incompatible_cluster()) {
    delete reason_.incompatible_cluster_;
    clear_has_reason();
  }
}
inline ::flyteidl::admin::EventErrorIncompatibleCluster* EventFailureReason::release_incompatible_cluster() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.EventFailureReason.incompatible_cluster)
  if (has_incompatible_cluster()) {
    clear_has_reason();
      ::flyteidl::admin::EventErrorIncompatibleCluster* temp = reason_.incompatible_cluster_;
    reason_.incompatible_cluster_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::admin::EventErrorIncompatibleCluster& EventFailureReason::incompatible_cluster() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.EventFailureReason.incompatible_cluster)
  return has_incompatible_cluster()
      ? *reason_.incompatible_cluster_
      : *reinterpret_cast< ::flyteidl::admin::EventErrorIncompatibleCluster*>(&::flyteidl::admin::_EventErrorIncompatibleCluster_default_instance_);
}
inline ::flyteidl::admin::EventErrorIncompatibleCluster* EventFailureReason::mutable_incompatible_cluster() {
  if (!has_incompatible_cluster()) {
    clear_reason();
    set_has_incompatible_cluster();
    reason_.incompatible_cluster_ = CreateMaybeMessage< ::flyteidl::admin::EventErrorIncompatibleCluster >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.EventFailureReason.incompatible_cluster)
  return reason_.incompatible_cluster_;
}

inline bool EventFailureReason::has_reason() const {
  return reason_case() != REASON_NOT_SET;
}
inline void EventFailureReason::clear_has_reason() {
  _oneof_case_[0] = REASON_NOT_SET;
}
inline EventFailureReason::ReasonCase EventFailureReason::reason_case() const {
  return EventFailureReason::ReasonCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// WorkflowExecutionEventRequest

// string request_id = 1;
inline void WorkflowExecutionEventRequest::clear_request_id() {
  request_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WorkflowExecutionEventRequest::request_id() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.WorkflowExecutionEventRequest.request_id)
  return request_id_.GetNoArena();
}
inline void WorkflowExecutionEventRequest::set_request_id(const ::std::string& value) {
  
  request_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.admin.WorkflowExecutionEventRequest.request_id)
}
#if LANG_CXX11
inline void WorkflowExecutionEventRequest::set_request_id(::std::string&& value) {
  
  request_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.admin.WorkflowExecutionEventRequest.request_id)
}
#endif
inline void WorkflowExecutionEventRequest::set_request_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  request_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.admin.WorkflowExecutionEventRequest.request_id)
}
inline void WorkflowExecutionEventRequest::set_request_id(const char* value, size_t size) {
  
  request_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.admin.WorkflowExecutionEventRequest.request_id)
}
inline ::std::string* WorkflowExecutionEventRequest::mutable_request_id() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.WorkflowExecutionEventRequest.request_id)
  return request_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WorkflowExecutionEventRequest::release_request_id() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.WorkflowExecutionEventRequest.request_id)
  
  return request_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WorkflowExecutionEventRequest::set_allocated_request_id(::std::string* request_id) {
  if (request_id != nullptr) {
    
  } else {
    
  }
  request_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), request_id);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.WorkflowExecutionEventRequest.request_id)
}

// .flyteidl.event.WorkflowExecutionEvent event = 2;
inline bool WorkflowExecutionEventRequest::has_event() const {
  return this != internal_default_instance() && event_ != nullptr;
}
inline const ::flyteidl::event::WorkflowExecutionEvent& WorkflowExecutionEventRequest::event() const {
  const ::flyteidl::event::WorkflowExecutionEvent* p = event_;
  // @@protoc_insertion_point(field_get:flyteidl.admin.WorkflowExecutionEventRequest.event)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::event::WorkflowExecutionEvent*>(
      &::flyteidl::event::_WorkflowExecutionEvent_default_instance_);
}
inline ::flyteidl::event::WorkflowExecutionEvent* WorkflowExecutionEventRequest::release_event() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.WorkflowExecutionEventRequest.event)
  
  ::flyteidl::event::WorkflowExecutionEvent* temp = event_;
  event_ = nullptr;
  return temp;
}
inline ::flyteidl::event::WorkflowExecutionEvent* WorkflowExecutionEventRequest::mutable_event() {
  
  if (event_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::event::WorkflowExecutionEvent>(GetArenaNoVirtual());
    event_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.WorkflowExecutionEventRequest.event)
  return event_;
}
inline void WorkflowExecutionEventRequest::set_allocated_event(::flyteidl::event::WorkflowExecutionEvent* event) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(event_);
  }
  if (event) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      event = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, event, submessage_arena);
    }
    
  } else {
    
  }
  event_ = event;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.WorkflowExecutionEventRequest.event)
}

// -------------------------------------------------------------------

// WorkflowExecutionEventResponse

// -------------------------------------------------------------------

// NodeExecutionEventRequest

// string request_id = 1;
inline void NodeExecutionEventRequest::clear_request_id() {
  request_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NodeExecutionEventRequest::request_id() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.NodeExecutionEventRequest.request_id)
  return request_id_.GetNoArena();
}
inline void NodeExecutionEventRequest::set_request_id(const ::std::string& value) {
  
  request_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.admin.NodeExecutionEventRequest.request_id)
}
#if LANG_CXX11
inline void NodeExecutionEventRequest::set_request_id(::std::string&& value) {
  
  request_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.admin.NodeExecutionEventRequest.request_id)
}
#endif
inline void NodeExecutionEventRequest::set_request_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  request_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.admin.NodeExecutionEventRequest.request_id)
}
inline void NodeExecutionEventRequest::set_request_id(const char* value, size_t size) {
  
  request_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.admin.NodeExecutionEventRequest.request_id)
}
inline ::std::string* NodeExecutionEventRequest::mutable_request_id() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.NodeExecutionEventRequest.request_id)
  return request_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NodeExecutionEventRequest::release_request_id() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.NodeExecutionEventRequest.request_id)
  
  return request_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NodeExecutionEventRequest::set_allocated_request_id(::std::string* request_id) {
  if (request_id != nullptr) {
    
  } else {
    
  }
  request_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), request_id);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.NodeExecutionEventRequest.request_id)
}

// .flyteidl.event.NodeExecutionEvent event = 2;
inline bool NodeExecutionEventRequest::has_event() const {
  return this != internal_default_instance() && event_ != nullptr;
}
inline const ::flyteidl::event::NodeExecutionEvent& NodeExecutionEventRequest::event() const {
  const ::flyteidl::event::NodeExecutionEvent* p = event_;
  // @@protoc_insertion_point(field_get:flyteidl.admin.NodeExecutionEventRequest.event)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::event::NodeExecutionEvent*>(
      &::flyteidl::event::_NodeExecutionEvent_default_instance_);
}
inline ::flyteidl::event::NodeExecutionEvent* NodeExecutionEventRequest::release_event() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.NodeExecutionEventRequest.event)
  
  ::flyteidl::event::NodeExecutionEvent* temp = event_;
  event_ = nullptr;
  return temp;
}
inline ::flyteidl::event::NodeExecutionEvent* NodeExecutionEventRequest::mutable_event() {
  
  if (event_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::event::NodeExecutionEvent>(GetArenaNoVirtual());
    event_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.NodeExecutionEventRequest.event)
  return event_;
}
inline void NodeExecutionEventRequest::set_allocated_event(::flyteidl::event::NodeExecutionEvent* event) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(event_);
  }
  if (event) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      event = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, event, submessage_arena);
    }
    
  } else {
    
  }
  event_ = event;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.NodeExecutionEventRequest.event)
}

// -------------------------------------------------------------------

// NodeExecutionEventResponse

// -------------------------------------------------------------------

// TaskExecutionEventRequest

// string request_id = 1;
inline void TaskExecutionEventRequest::clear_request_id() {
  request_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TaskExecutionEventRequest::request_id() const {
  // @@protoc_insertion_point(field_get:flyteidl.admin.TaskExecutionEventRequest.request_id)
  return request_id_.GetNoArena();
}
inline void TaskExecutionEventRequest::set_request_id(const ::std::string& value) {
  
  request_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.admin.TaskExecutionEventRequest.request_id)
}
#if LANG_CXX11
inline void TaskExecutionEventRequest::set_request_id(::std::string&& value) {
  
  request_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.admin.TaskExecutionEventRequest.request_id)
}
#endif
inline void TaskExecutionEventRequest::set_request_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  request_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.admin.TaskExecutionEventRequest.request_id)
}
inline void TaskExecutionEventRequest::set_request_id(const char* value, size_t size) {
  
  request_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.admin.TaskExecutionEventRequest.request_id)
}
inline ::std::string* TaskExecutionEventRequest::mutable_request_id() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.TaskExecutionEventRequest.request_id)
  return request_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TaskExecutionEventRequest::release_request_id() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.TaskExecutionEventRequest.request_id)
  
  return request_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TaskExecutionEventRequest::set_allocated_request_id(::std::string* request_id) {
  if (request_id != nullptr) {
    
  } else {
    
  }
  request_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), request_id);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.TaskExecutionEventRequest.request_id)
}

// .flyteidl.event.TaskExecutionEvent event = 2;
inline bool TaskExecutionEventRequest::has_event() const {
  return this != internal_default_instance() && event_ != nullptr;
}
inline const ::flyteidl::event::TaskExecutionEvent& TaskExecutionEventRequest::event() const {
  const ::flyteidl::event::TaskExecutionEvent* p = event_;
  // @@protoc_insertion_point(field_get:flyteidl.admin.TaskExecutionEventRequest.event)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::event::TaskExecutionEvent*>(
      &::flyteidl::event::_TaskExecutionEvent_default_instance_);
}
inline ::flyteidl::event::TaskExecutionEvent* TaskExecutionEventRequest::release_event() {
  // @@protoc_insertion_point(field_release:flyteidl.admin.TaskExecutionEventRequest.event)
  
  ::flyteidl::event::TaskExecutionEvent* temp = event_;
  event_ = nullptr;
  return temp;
}
inline ::flyteidl::event::TaskExecutionEvent* TaskExecutionEventRequest::mutable_event() {
  
  if (event_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::event::TaskExecutionEvent>(GetArenaNoVirtual());
    event_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.admin.TaskExecutionEventRequest.event)
  return event_;
}
inline void TaskExecutionEventRequest::set_allocated_event(::flyteidl::event::TaskExecutionEvent* event) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(event_);
  }
  if (event) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      event = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, event, submessage_arena);
    }
    
  } else {
    
  }
  event_ = event;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.admin.TaskExecutionEventRequest.event)
}

// -------------------------------------------------------------------

// TaskExecutionEventResponse

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace admin
}  // namespace flyteidl

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_flyteidl_2fadmin_2fevent_2eproto
