// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: flyteidl/core/tasks.proto

#ifndef PROTOBUF_INCLUDED_flyteidl_2fcore_2ftasks_2eproto
#define PROTOBUF_INCLUDED_flyteidl_2fcore_2ftasks_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "flyteidl/core/identifier.pb.h"
#include "flyteidl/core/interface.pb.h"
#include "flyteidl/core/literals.pb.h"
#include "flyteidl/core/security.pb.h"
#include <google/protobuf/duration.pb.h>
#include <google/protobuf/struct.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_flyteidl_2fcore_2ftasks_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_flyteidl_2fcore_2ftasks_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[16]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_flyteidl_2fcore_2ftasks_2eproto();
namespace flyteidl {
namespace core {
class Container;
class ContainerDefaultTypeInternal;
extern ContainerDefaultTypeInternal _Container_default_instance_;
class ContainerPort;
class ContainerPortDefaultTypeInternal;
extern ContainerPortDefaultTypeInternal _ContainerPort_default_instance_;
class DataLoadingConfig;
class DataLoadingConfigDefaultTypeInternal;
extern DataLoadingConfigDefaultTypeInternal _DataLoadingConfig_default_instance_;
class IOStrategy;
class IOStrategyDefaultTypeInternal;
extern IOStrategyDefaultTypeInternal _IOStrategy_default_instance_;
class K8sObjectMetadata;
class K8sObjectMetadataDefaultTypeInternal;
extern K8sObjectMetadataDefaultTypeInternal _K8sObjectMetadata_default_instance_;
class K8sObjectMetadata_AnnotationsEntry_DoNotUse;
class K8sObjectMetadata_AnnotationsEntry_DoNotUseDefaultTypeInternal;
extern K8sObjectMetadata_AnnotationsEntry_DoNotUseDefaultTypeInternal _K8sObjectMetadata_AnnotationsEntry_DoNotUse_default_instance_;
class K8sObjectMetadata_LabelsEntry_DoNotUse;
class K8sObjectMetadata_LabelsEntry_DoNotUseDefaultTypeInternal;
extern K8sObjectMetadata_LabelsEntry_DoNotUseDefaultTypeInternal _K8sObjectMetadata_LabelsEntry_DoNotUse_default_instance_;
class K8sPod;
class K8sPodDefaultTypeInternal;
extern K8sPodDefaultTypeInternal _K8sPod_default_instance_;
class Resources;
class ResourcesDefaultTypeInternal;
extern ResourcesDefaultTypeInternal _Resources_default_instance_;
class Resources_ResourceEntry;
class Resources_ResourceEntryDefaultTypeInternal;
extern Resources_ResourceEntryDefaultTypeInternal _Resources_ResourceEntry_default_instance_;
class RuntimeMetadata;
class RuntimeMetadataDefaultTypeInternal;
extern RuntimeMetadataDefaultTypeInternal _RuntimeMetadata_default_instance_;
class Sql;
class SqlDefaultTypeInternal;
extern SqlDefaultTypeInternal _Sql_default_instance_;
class TaskMetadata;
class TaskMetadataDefaultTypeInternal;
extern TaskMetadataDefaultTypeInternal _TaskMetadata_default_instance_;
class TaskMetadata_TagsEntry_DoNotUse;
class TaskMetadata_TagsEntry_DoNotUseDefaultTypeInternal;
extern TaskMetadata_TagsEntry_DoNotUseDefaultTypeInternal _TaskMetadata_TagsEntry_DoNotUse_default_instance_;
class TaskTemplate;
class TaskTemplateDefaultTypeInternal;
extern TaskTemplateDefaultTypeInternal _TaskTemplate_default_instance_;
class TaskTemplate_ConfigEntry_DoNotUse;
class TaskTemplate_ConfigEntry_DoNotUseDefaultTypeInternal;
extern TaskTemplate_ConfigEntry_DoNotUseDefaultTypeInternal _TaskTemplate_ConfigEntry_DoNotUse_default_instance_;
}  // namespace core
}  // namespace flyteidl
namespace google {
namespace protobuf {
template<> ::flyteidl::core::Container* Arena::CreateMaybeMessage<::flyteidl::core::Container>(Arena*);
template<> ::flyteidl::core::ContainerPort* Arena::CreateMaybeMessage<::flyteidl::core::ContainerPort>(Arena*);
template<> ::flyteidl::core::DataLoadingConfig* Arena::CreateMaybeMessage<::flyteidl::core::DataLoadingConfig>(Arena*);
template<> ::flyteidl::core::IOStrategy* Arena::CreateMaybeMessage<::flyteidl::core::IOStrategy>(Arena*);
template<> ::flyteidl::core::K8sObjectMetadata* Arena::CreateMaybeMessage<::flyteidl::core::K8sObjectMetadata>(Arena*);
template<> ::flyteidl::core::K8sObjectMetadata_AnnotationsEntry_DoNotUse* Arena::CreateMaybeMessage<::flyteidl::core::K8sObjectMetadata_AnnotationsEntry_DoNotUse>(Arena*);
template<> ::flyteidl::core::K8sObjectMetadata_LabelsEntry_DoNotUse* Arena::CreateMaybeMessage<::flyteidl::core::K8sObjectMetadata_LabelsEntry_DoNotUse>(Arena*);
template<> ::flyteidl::core::K8sPod* Arena::CreateMaybeMessage<::flyteidl::core::K8sPod>(Arena*);
template<> ::flyteidl::core::Resources* Arena::CreateMaybeMessage<::flyteidl::core::Resources>(Arena*);
template<> ::flyteidl::core::Resources_ResourceEntry* Arena::CreateMaybeMessage<::flyteidl::core::Resources_ResourceEntry>(Arena*);
template<> ::flyteidl::core::RuntimeMetadata* Arena::CreateMaybeMessage<::flyteidl::core::RuntimeMetadata>(Arena*);
template<> ::flyteidl::core::Sql* Arena::CreateMaybeMessage<::flyteidl::core::Sql>(Arena*);
template<> ::flyteidl::core::TaskMetadata* Arena::CreateMaybeMessage<::flyteidl::core::TaskMetadata>(Arena*);
template<> ::flyteidl::core::TaskMetadata_TagsEntry_DoNotUse* Arena::CreateMaybeMessage<::flyteidl::core::TaskMetadata_TagsEntry_DoNotUse>(Arena*);
template<> ::flyteidl::core::TaskTemplate* Arena::CreateMaybeMessage<::flyteidl::core::TaskTemplate>(Arena*);
template<> ::flyteidl::core::TaskTemplate_ConfigEntry_DoNotUse* Arena::CreateMaybeMessage<::flyteidl::core::TaskTemplate_ConfigEntry_DoNotUse>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace flyteidl {
namespace core {

enum Resources_ResourceName {
  Resources_ResourceName_UNKNOWN = 0,
  Resources_ResourceName_CPU = 1,
  Resources_ResourceName_GPU = 2,
  Resources_ResourceName_MEMORY = 3,
  Resources_ResourceName_STORAGE = 4,
  Resources_ResourceName_EPHEMERAL_STORAGE = 5,
  Resources_ResourceName_Resources_ResourceName_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  Resources_ResourceName_Resources_ResourceName_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool Resources_ResourceName_IsValid(int value);
const Resources_ResourceName Resources_ResourceName_ResourceName_MIN = Resources_ResourceName_UNKNOWN;
const Resources_ResourceName Resources_ResourceName_ResourceName_MAX = Resources_ResourceName_EPHEMERAL_STORAGE;
const int Resources_ResourceName_ResourceName_ARRAYSIZE = Resources_ResourceName_ResourceName_MAX + 1;

const ::google::protobuf::EnumDescriptor* Resources_ResourceName_descriptor();
inline const ::std::string& Resources_ResourceName_Name(Resources_ResourceName value) {
  return ::google::protobuf::internal::NameOfEnum(
    Resources_ResourceName_descriptor(), value);
}
inline bool Resources_ResourceName_Parse(
    const ::std::string& name, Resources_ResourceName* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Resources_ResourceName>(
    Resources_ResourceName_descriptor(), name, value);
}
enum RuntimeMetadata_RuntimeType {
  RuntimeMetadata_RuntimeType_OTHER = 0,
  RuntimeMetadata_RuntimeType_FLYTE_SDK = 1,
  RuntimeMetadata_RuntimeType_RuntimeMetadata_RuntimeType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  RuntimeMetadata_RuntimeType_RuntimeMetadata_RuntimeType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool RuntimeMetadata_RuntimeType_IsValid(int value);
const RuntimeMetadata_RuntimeType RuntimeMetadata_RuntimeType_RuntimeType_MIN = RuntimeMetadata_RuntimeType_OTHER;
const RuntimeMetadata_RuntimeType RuntimeMetadata_RuntimeType_RuntimeType_MAX = RuntimeMetadata_RuntimeType_FLYTE_SDK;
const int RuntimeMetadata_RuntimeType_RuntimeType_ARRAYSIZE = RuntimeMetadata_RuntimeType_RuntimeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RuntimeMetadata_RuntimeType_descriptor();
inline const ::std::string& RuntimeMetadata_RuntimeType_Name(RuntimeMetadata_RuntimeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RuntimeMetadata_RuntimeType_descriptor(), value);
}
inline bool RuntimeMetadata_RuntimeType_Parse(
    const ::std::string& name, RuntimeMetadata_RuntimeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RuntimeMetadata_RuntimeType>(
    RuntimeMetadata_RuntimeType_descriptor(), name, value);
}
enum Container_Architecture {
  Container_Architecture_UNKNOWN = 0,
  Container_Architecture_AMD64 = 1,
  Container_Architecture_ARM64 = 2,
  Container_Architecture_ARM_V6 = 3,
  Container_Architecture_ARM_V7 = 4,
  Container_Architecture_Container_Architecture_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  Container_Architecture_Container_Architecture_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool Container_Architecture_IsValid(int value);
const Container_Architecture Container_Architecture_Architecture_MIN = Container_Architecture_UNKNOWN;
const Container_Architecture Container_Architecture_Architecture_MAX = Container_Architecture_ARM_V7;
const int Container_Architecture_Architecture_ARRAYSIZE = Container_Architecture_Architecture_MAX + 1;

const ::google::protobuf::EnumDescriptor* Container_Architecture_descriptor();
inline const ::std::string& Container_Architecture_Name(Container_Architecture value) {
  return ::google::protobuf::internal::NameOfEnum(
    Container_Architecture_descriptor(), value);
}
inline bool Container_Architecture_Parse(
    const ::std::string& name, Container_Architecture* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Container_Architecture>(
    Container_Architecture_descriptor(), name, value);
}
enum IOStrategy_DownloadMode {
  IOStrategy_DownloadMode_DOWNLOAD_EAGER = 0,
  IOStrategy_DownloadMode_DOWNLOAD_STREAM = 1,
  IOStrategy_DownloadMode_DO_NOT_DOWNLOAD = 2,
  IOStrategy_DownloadMode_IOStrategy_DownloadMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  IOStrategy_DownloadMode_IOStrategy_DownloadMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool IOStrategy_DownloadMode_IsValid(int value);
const IOStrategy_DownloadMode IOStrategy_DownloadMode_DownloadMode_MIN = IOStrategy_DownloadMode_DOWNLOAD_EAGER;
const IOStrategy_DownloadMode IOStrategy_DownloadMode_DownloadMode_MAX = IOStrategy_DownloadMode_DO_NOT_DOWNLOAD;
const int IOStrategy_DownloadMode_DownloadMode_ARRAYSIZE = IOStrategy_DownloadMode_DownloadMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* IOStrategy_DownloadMode_descriptor();
inline const ::std::string& IOStrategy_DownloadMode_Name(IOStrategy_DownloadMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    IOStrategy_DownloadMode_descriptor(), value);
}
inline bool IOStrategy_DownloadMode_Parse(
    const ::std::string& name, IOStrategy_DownloadMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<IOStrategy_DownloadMode>(
    IOStrategy_DownloadMode_descriptor(), name, value);
}
enum IOStrategy_UploadMode {
  IOStrategy_UploadMode_UPLOAD_ON_EXIT = 0,
  IOStrategy_UploadMode_UPLOAD_EAGER = 1,
  IOStrategy_UploadMode_DO_NOT_UPLOAD = 2,
  IOStrategy_UploadMode_IOStrategy_UploadMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  IOStrategy_UploadMode_IOStrategy_UploadMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool IOStrategy_UploadMode_IsValid(int value);
const IOStrategy_UploadMode IOStrategy_UploadMode_UploadMode_MIN = IOStrategy_UploadMode_UPLOAD_ON_EXIT;
const IOStrategy_UploadMode IOStrategy_UploadMode_UploadMode_MAX = IOStrategy_UploadMode_DO_NOT_UPLOAD;
const int IOStrategy_UploadMode_UploadMode_ARRAYSIZE = IOStrategy_UploadMode_UploadMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* IOStrategy_UploadMode_descriptor();
inline const ::std::string& IOStrategy_UploadMode_Name(IOStrategy_UploadMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    IOStrategy_UploadMode_descriptor(), value);
}
inline bool IOStrategy_UploadMode_Parse(
    const ::std::string& name, IOStrategy_UploadMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<IOStrategy_UploadMode>(
    IOStrategy_UploadMode_descriptor(), name, value);
}
enum DataLoadingConfig_LiteralMapFormat {
  DataLoadingConfig_LiteralMapFormat_JSON = 0,
  DataLoadingConfig_LiteralMapFormat_YAML = 1,
  DataLoadingConfig_LiteralMapFormat_PROTO = 2,
  DataLoadingConfig_LiteralMapFormat_DataLoadingConfig_LiteralMapFormat_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  DataLoadingConfig_LiteralMapFormat_DataLoadingConfig_LiteralMapFormat_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool DataLoadingConfig_LiteralMapFormat_IsValid(int value);
const DataLoadingConfig_LiteralMapFormat DataLoadingConfig_LiteralMapFormat_LiteralMapFormat_MIN = DataLoadingConfig_LiteralMapFormat_JSON;
const DataLoadingConfig_LiteralMapFormat DataLoadingConfig_LiteralMapFormat_LiteralMapFormat_MAX = DataLoadingConfig_LiteralMapFormat_PROTO;
const int DataLoadingConfig_LiteralMapFormat_LiteralMapFormat_ARRAYSIZE = DataLoadingConfig_LiteralMapFormat_LiteralMapFormat_MAX + 1;

const ::google::protobuf::EnumDescriptor* DataLoadingConfig_LiteralMapFormat_descriptor();
inline const ::std::string& DataLoadingConfig_LiteralMapFormat_Name(DataLoadingConfig_LiteralMapFormat value) {
  return ::google::protobuf::internal::NameOfEnum(
    DataLoadingConfig_LiteralMapFormat_descriptor(), value);
}
inline bool DataLoadingConfig_LiteralMapFormat_Parse(
    const ::std::string& name, DataLoadingConfig_LiteralMapFormat* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DataLoadingConfig_LiteralMapFormat>(
    DataLoadingConfig_LiteralMapFormat_descriptor(), name, value);
}
enum Sql_Dialect {
  Sql_Dialect_UNDEFINED = 0,
  Sql_Dialect_ANSI = 1,
  Sql_Dialect_HIVE = 2,
  Sql_Dialect_OTHER = 3,
  Sql_Dialect_Sql_Dialect_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  Sql_Dialect_Sql_Dialect_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool Sql_Dialect_IsValid(int value);
const Sql_Dialect Sql_Dialect_Dialect_MIN = Sql_Dialect_UNDEFINED;
const Sql_Dialect Sql_Dialect_Dialect_MAX = Sql_Dialect_OTHER;
const int Sql_Dialect_Dialect_ARRAYSIZE = Sql_Dialect_Dialect_MAX + 1;

const ::google::protobuf::EnumDescriptor* Sql_Dialect_descriptor();
inline const ::std::string& Sql_Dialect_Name(Sql_Dialect value) {
  return ::google::protobuf::internal::NameOfEnum(
    Sql_Dialect_descriptor(), value);
}
inline bool Sql_Dialect_Parse(
    const ::std::string& name, Sql_Dialect* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Sql_Dialect>(
    Sql_Dialect_descriptor(), name, value);
}
// ===================================================================

class Resources_ResourceEntry final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.Resources.ResourceEntry) */ {
 public:
  Resources_ResourceEntry();
  virtual ~Resources_ResourceEntry();

  Resources_ResourceEntry(const Resources_ResourceEntry& from);

  inline Resources_ResourceEntry& operator=(const Resources_ResourceEntry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Resources_ResourceEntry(Resources_ResourceEntry&& from) noexcept
    : Resources_ResourceEntry() {
    *this = ::std::move(from);
  }

  inline Resources_ResourceEntry& operator=(Resources_ResourceEntry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Resources_ResourceEntry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Resources_ResourceEntry* internal_default_instance() {
    return reinterpret_cast<const Resources_ResourceEntry*>(
               &_Resources_ResourceEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Resources_ResourceEntry* other);
  friend void swap(Resources_ResourceEntry& a, Resources_ResourceEntry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Resources_ResourceEntry* New() const final {
    return CreateMaybeMessage<Resources_ResourceEntry>(nullptr);
  }

  Resources_ResourceEntry* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Resources_ResourceEntry>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Resources_ResourceEntry& from);
  void MergeFrom(const Resources_ResourceEntry& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Resources_ResourceEntry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // .flyteidl.core.Resources.ResourceName name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  ::flyteidl::core::Resources_ResourceName name() const;
  void set_name(::flyteidl::core::Resources_ResourceName value);

  // @@protoc_insertion_point(class_scope:flyteidl.core.Resources.ResourceEntry)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  int name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2ftasks_2eproto;
};
// -------------------------------------------------------------------

class Resources final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.Resources) */ {
 public:
  Resources();
  virtual ~Resources();

  Resources(const Resources& from);

  inline Resources& operator=(const Resources& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Resources(Resources&& from) noexcept
    : Resources() {
    *this = ::std::move(from);
  }

  inline Resources& operator=(Resources&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Resources& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Resources* internal_default_instance() {
    return reinterpret_cast<const Resources*>(
               &_Resources_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Resources* other);
  friend void swap(Resources& a, Resources& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Resources* New() const final {
    return CreateMaybeMessage<Resources>(nullptr);
  }

  Resources* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Resources>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Resources& from);
  void MergeFrom(const Resources& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Resources* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Resources_ResourceEntry ResourceEntry;

  typedef Resources_ResourceName ResourceName;
  static const ResourceName UNKNOWN =
    Resources_ResourceName_UNKNOWN;
  static const ResourceName CPU =
    Resources_ResourceName_CPU;
  static const ResourceName GPU =
    Resources_ResourceName_GPU;
  static const ResourceName MEMORY =
    Resources_ResourceName_MEMORY;
  static const ResourceName STORAGE =
    Resources_ResourceName_STORAGE;
  static const ResourceName EPHEMERAL_STORAGE =
    Resources_ResourceName_EPHEMERAL_STORAGE;
  static inline bool ResourceName_IsValid(int value) {
    return Resources_ResourceName_IsValid(value);
  }
  static const ResourceName ResourceName_MIN =
    Resources_ResourceName_ResourceName_MIN;
  static const ResourceName ResourceName_MAX =
    Resources_ResourceName_ResourceName_MAX;
  static const int ResourceName_ARRAYSIZE =
    Resources_ResourceName_ResourceName_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ResourceName_descriptor() {
    return Resources_ResourceName_descriptor();
  }
  static inline const ::std::string& ResourceName_Name(ResourceName value) {
    return Resources_ResourceName_Name(value);
  }
  static inline bool ResourceName_Parse(const ::std::string& name,
      ResourceName* value) {
    return Resources_ResourceName_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .flyteidl.core.Resources.ResourceEntry requests = 1;
  int requests_size() const;
  void clear_requests();
  static const int kRequestsFieldNumber = 1;
  ::flyteidl::core::Resources_ResourceEntry* mutable_requests(int index);
  ::google::protobuf::RepeatedPtrField< ::flyteidl::core::Resources_ResourceEntry >*
      mutable_requests();
  const ::flyteidl::core::Resources_ResourceEntry& requests(int index) const;
  ::flyteidl::core::Resources_ResourceEntry* add_requests();
  const ::google::protobuf::RepeatedPtrField< ::flyteidl::core::Resources_ResourceEntry >&
      requests() const;

  // repeated .flyteidl.core.Resources.ResourceEntry limits = 2;
  int limits_size() const;
  void clear_limits();
  static const int kLimitsFieldNumber = 2;
  ::flyteidl::core::Resources_ResourceEntry* mutable_limits(int index);
  ::google::protobuf::RepeatedPtrField< ::flyteidl::core::Resources_ResourceEntry >*
      mutable_limits();
  const ::flyteidl::core::Resources_ResourceEntry& limits(int index) const;
  ::flyteidl::core::Resources_ResourceEntry* add_limits();
  const ::google::protobuf::RepeatedPtrField< ::flyteidl::core::Resources_ResourceEntry >&
      limits() const;

  // @@protoc_insertion_point(class_scope:flyteidl.core.Resources)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::flyteidl::core::Resources_ResourceEntry > requests_;
  ::google::protobuf::RepeatedPtrField< ::flyteidl::core::Resources_ResourceEntry > limits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2ftasks_2eproto;
};
// -------------------------------------------------------------------

class RuntimeMetadata final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.RuntimeMetadata) */ {
 public:
  RuntimeMetadata();
  virtual ~RuntimeMetadata();

  RuntimeMetadata(const RuntimeMetadata& from);

  inline RuntimeMetadata& operator=(const RuntimeMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RuntimeMetadata(RuntimeMetadata&& from) noexcept
    : RuntimeMetadata() {
    *this = ::std::move(from);
  }

  inline RuntimeMetadata& operator=(RuntimeMetadata&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RuntimeMetadata& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RuntimeMetadata* internal_default_instance() {
    return reinterpret_cast<const RuntimeMetadata*>(
               &_RuntimeMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(RuntimeMetadata* other);
  friend void swap(RuntimeMetadata& a, RuntimeMetadata& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RuntimeMetadata* New() const final {
    return CreateMaybeMessage<RuntimeMetadata>(nullptr);
  }

  RuntimeMetadata* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RuntimeMetadata>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RuntimeMetadata& from);
  void MergeFrom(const RuntimeMetadata& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RuntimeMetadata* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RuntimeMetadata_RuntimeType RuntimeType;
  static const RuntimeType OTHER =
    RuntimeMetadata_RuntimeType_OTHER;
  static const RuntimeType FLYTE_SDK =
    RuntimeMetadata_RuntimeType_FLYTE_SDK;
  static inline bool RuntimeType_IsValid(int value) {
    return RuntimeMetadata_RuntimeType_IsValid(value);
  }
  static const RuntimeType RuntimeType_MIN =
    RuntimeMetadata_RuntimeType_RuntimeType_MIN;
  static const RuntimeType RuntimeType_MAX =
    RuntimeMetadata_RuntimeType_RuntimeType_MAX;
  static const int RuntimeType_ARRAYSIZE =
    RuntimeMetadata_RuntimeType_RuntimeType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RuntimeType_descriptor() {
    return RuntimeMetadata_RuntimeType_descriptor();
  }
  static inline const ::std::string& RuntimeType_Name(RuntimeType value) {
    return RuntimeMetadata_RuntimeType_Name(value);
  }
  static inline bool RuntimeType_Parse(const ::std::string& name,
      RuntimeType* value) {
    return RuntimeMetadata_RuntimeType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string version = 2;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // string flavor = 3;
  void clear_flavor();
  static const int kFlavorFieldNumber = 3;
  const ::std::string& flavor() const;
  void set_flavor(const ::std::string& value);
  #if LANG_CXX11
  void set_flavor(::std::string&& value);
  #endif
  void set_flavor(const char* value);
  void set_flavor(const char* value, size_t size);
  ::std::string* mutable_flavor();
  ::std::string* release_flavor();
  void set_allocated_flavor(::std::string* flavor);

  // .flyteidl.core.RuntimeMetadata.RuntimeType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::flyteidl::core::RuntimeMetadata_RuntimeType type() const;
  void set_type(::flyteidl::core::RuntimeMetadata_RuntimeType value);

  // @@protoc_insertion_point(class_scope:flyteidl.core.RuntimeMetadata)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr flavor_;
  int type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2ftasks_2eproto;
};
// -------------------------------------------------------------------

class TaskMetadata_TagsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<TaskMetadata_TagsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
static bool _ParseMap(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  typedef ::google::protobuf::internal::MapEntry<TaskMetadata_TagsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  TaskMetadata_TagsEntry_DoNotUse();
  TaskMetadata_TagsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const TaskMetadata_TagsEntry_DoNotUse& other);
  static const TaskMetadata_TagsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TaskMetadata_TagsEntry_DoNotUse*>(&_TaskMetadata_TagsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class TaskMetadata final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.TaskMetadata) */ {
 public:
  TaskMetadata();
  virtual ~TaskMetadata();

  TaskMetadata(const TaskMetadata& from);

  inline TaskMetadata& operator=(const TaskMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TaskMetadata(TaskMetadata&& from) noexcept
    : TaskMetadata() {
    *this = ::std::move(from);
  }

  inline TaskMetadata& operator=(TaskMetadata&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TaskMetadata& default_instance();

  enum InterruptibleValueCase {
    kInterruptible = 8,
    INTERRUPTIBLE_VALUE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TaskMetadata* internal_default_instance() {
    return reinterpret_cast<const TaskMetadata*>(
               &_TaskMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(TaskMetadata* other);
  friend void swap(TaskMetadata& a, TaskMetadata& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TaskMetadata* New() const final {
    return CreateMaybeMessage<TaskMetadata>(nullptr);
  }

  TaskMetadata* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TaskMetadata>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TaskMetadata& from);
  void MergeFrom(const TaskMetadata& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskMetadata* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, string> tags = 11;
  int tags_size() const;
  void clear_tags();
  static const int kTagsFieldNumber = 11;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      tags() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_tags();

  // string discovery_version = 6;
  void clear_discovery_version();
  static const int kDiscoveryVersionFieldNumber = 6;
  const ::std::string& discovery_version() const;
  void set_discovery_version(const ::std::string& value);
  #if LANG_CXX11
  void set_discovery_version(::std::string&& value);
  #endif
  void set_discovery_version(const char* value);
  void set_discovery_version(const char* value, size_t size);
  ::std::string* mutable_discovery_version();
  ::std::string* release_discovery_version();
  void set_allocated_discovery_version(::std::string* discovery_version);

  // string deprecated_error_message = 7;
  void clear_deprecated_error_message();
  static const int kDeprecatedErrorMessageFieldNumber = 7;
  const ::std::string& deprecated_error_message() const;
  void set_deprecated_error_message(const ::std::string& value);
  #if LANG_CXX11
  void set_deprecated_error_message(::std::string&& value);
  #endif
  void set_deprecated_error_message(const char* value);
  void set_deprecated_error_message(const char* value, size_t size);
  ::std::string* mutable_deprecated_error_message();
  ::std::string* release_deprecated_error_message();
  void set_allocated_deprecated_error_message(::std::string* deprecated_error_message);

  // string pod_template_name = 12;
  void clear_pod_template_name();
  static const int kPodTemplateNameFieldNumber = 12;
  const ::std::string& pod_template_name() const;
  void set_pod_template_name(const ::std::string& value);
  #if LANG_CXX11
  void set_pod_template_name(::std::string&& value);
  #endif
  void set_pod_template_name(const char* value);
  void set_pod_template_name(const char* value, size_t size);
  ::std::string* mutable_pod_template_name();
  ::std::string* release_pod_template_name();
  void set_allocated_pod_template_name(::std::string* pod_template_name);

  // .flyteidl.core.RuntimeMetadata runtime = 2;
  bool has_runtime() const;
  void clear_runtime();
  static const int kRuntimeFieldNumber = 2;
  const ::flyteidl::core::RuntimeMetadata& runtime() const;
  ::flyteidl::core::RuntimeMetadata* release_runtime();
  ::flyteidl::core::RuntimeMetadata* mutable_runtime();
  void set_allocated_runtime(::flyteidl::core::RuntimeMetadata* runtime);

  // .google.protobuf.Duration timeout = 4;
  bool has_timeout() const;
  void clear_timeout();
  static const int kTimeoutFieldNumber = 4;
  const ::google::protobuf::Duration& timeout() const;
  ::google::protobuf::Duration* release_timeout();
  ::google::protobuf::Duration* mutable_timeout();
  void set_allocated_timeout(::google::protobuf::Duration* timeout);

  // .flyteidl.core.RetryStrategy retries = 5;
  bool has_retries() const;
  void clear_retries();
  static const int kRetriesFieldNumber = 5;
  const ::flyteidl::core::RetryStrategy& retries() const;
  ::flyteidl::core::RetryStrategy* release_retries();
  ::flyteidl::core::RetryStrategy* mutable_retries();
  void set_allocated_retries(::flyteidl::core::RetryStrategy* retries);

  // bool discoverable = 1;
  void clear_discoverable();
  static const int kDiscoverableFieldNumber = 1;
  bool discoverable() const;
  void set_discoverable(bool value);

  // bool cache_serializable = 9;
  void clear_cache_serializable();
  static const int kCacheSerializableFieldNumber = 9;
  bool cache_serializable() const;
  void set_cache_serializable(bool value);

  // bool generates_deck = 10;
  void clear_generates_deck();
  static const int kGeneratesDeckFieldNumber = 10;
  bool generates_deck() const;
  void set_generates_deck(bool value);

  // bool interruptible = 8;
  private:
  bool has_interruptible() const;
  public:
  void clear_interruptible();
  static const int kInterruptibleFieldNumber = 8;
  bool interruptible() const;
  void set_interruptible(bool value);

  void clear_interruptible_value();
  InterruptibleValueCase interruptible_value_case() const;
  // @@protoc_insertion_point(class_scope:flyteidl.core.TaskMetadata)
 private:
  class HasBitSetters;
  void set_has_interruptible();

  inline bool has_interruptible_value() const;
  inline void clear_has_interruptible_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      TaskMetadata_TagsEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > tags_;
  ::google::protobuf::internal::ArenaStringPtr discovery_version_;
  ::google::protobuf::internal::ArenaStringPtr deprecated_error_message_;
  ::google::protobuf::internal::ArenaStringPtr pod_template_name_;
  ::flyteidl::core::RuntimeMetadata* runtime_;
  ::google::protobuf::Duration* timeout_;
  ::flyteidl::core::RetryStrategy* retries_;
  bool discoverable_;
  bool cache_serializable_;
  bool generates_deck_;
  union InterruptibleValueUnion {
    InterruptibleValueUnion() {}
    bool interruptible_;
  } interruptible_value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_flyteidl_2fcore_2ftasks_2eproto;
};
// -------------------------------------------------------------------

class TaskTemplate_ConfigEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<TaskTemplate_ConfigEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
static bool _ParseMap(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  typedef ::google::protobuf::internal::MapEntry<TaskTemplate_ConfigEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  TaskTemplate_ConfigEntry_DoNotUse();
  TaskTemplate_ConfigEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const TaskTemplate_ConfigEntry_DoNotUse& other);
  static const TaskTemplate_ConfigEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TaskTemplate_ConfigEntry_DoNotUse*>(&_TaskTemplate_ConfigEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class TaskTemplate final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.TaskTemplate) */ {
 public:
  TaskTemplate();
  virtual ~TaskTemplate();

  TaskTemplate(const TaskTemplate& from);

  inline TaskTemplate& operator=(const TaskTemplate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TaskTemplate(TaskTemplate&& from) noexcept
    : TaskTemplate() {
    *this = ::std::move(from);
  }

  inline TaskTemplate& operator=(TaskTemplate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TaskTemplate& default_instance();

  enum TargetCase {
    kContainer = 6,
    kK8SPod = 17,
    kSql = 18,
    TARGET_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TaskTemplate* internal_default_instance() {
    return reinterpret_cast<const TaskTemplate*>(
               &_TaskTemplate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(TaskTemplate* other);
  friend void swap(TaskTemplate& a, TaskTemplate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TaskTemplate* New() const final {
    return CreateMaybeMessage<TaskTemplate>(nullptr);
  }

  TaskTemplate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TaskTemplate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TaskTemplate& from);
  void MergeFrom(const TaskTemplate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskTemplate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, string> config = 16;
  int config_size() const;
  void clear_config();
  static const int kConfigFieldNumber = 16;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      config() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_config();

  // string type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // .flyteidl.core.Identifier id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::flyteidl::core::Identifier& id() const;
  ::flyteidl::core::Identifier* release_id();
  ::flyteidl::core::Identifier* mutable_id();
  void set_allocated_id(::flyteidl::core::Identifier* id);

  // .flyteidl.core.TaskMetadata metadata = 3;
  bool has_metadata() const;
  void clear_metadata();
  static const int kMetadataFieldNumber = 3;
  const ::flyteidl::core::TaskMetadata& metadata() const;
  ::flyteidl::core::TaskMetadata* release_metadata();
  ::flyteidl::core::TaskMetadata* mutable_metadata();
  void set_allocated_metadata(::flyteidl::core::TaskMetadata* metadata);

  // .flyteidl.core.TypedInterface interface = 4;
  bool has_interface() const;
  void clear_interface();
  static const int kInterfaceFieldNumber = 4;
  const ::flyteidl::core::TypedInterface& interface() const;
  ::flyteidl::core::TypedInterface* release_interface();
  ::flyteidl::core::TypedInterface* mutable_interface();
  void set_allocated_interface(::flyteidl::core::TypedInterface* interface);

  // .google.protobuf.Struct custom = 5;
  bool has_custom() const;
  void clear_custom();
  static const int kCustomFieldNumber = 5;
  const ::google::protobuf::Struct& custom() const;
  ::google::protobuf::Struct* release_custom();
  ::google::protobuf::Struct* mutable_custom();
  void set_allocated_custom(::google::protobuf::Struct* custom);

  // .flyteidl.core.SecurityContext security_context = 8;
  bool has_security_context() const;
  void clear_security_context();
  static const int kSecurityContextFieldNumber = 8;
  const ::flyteidl::core::SecurityContext& security_context() const;
  ::flyteidl::core::SecurityContext* release_security_context();
  ::flyteidl::core::SecurityContext* mutable_security_context();
  void set_allocated_security_context(::flyteidl::core::SecurityContext* security_context);

  // int32 task_type_version = 7;
  void clear_task_type_version();
  static const int kTaskTypeVersionFieldNumber = 7;
  ::google::protobuf::int32 task_type_version() const;
  void set_task_type_version(::google::protobuf::int32 value);

  // .flyteidl.core.Container container = 6;
  bool has_container() const;
  void clear_container();
  static const int kContainerFieldNumber = 6;
  const ::flyteidl::core::Container& container() const;
  ::flyteidl::core::Container* release_container();
  ::flyteidl::core::Container* mutable_container();
  void set_allocated_container(::flyteidl::core::Container* container);

  // .flyteidl.core.K8sPod k8s_pod = 17;
  bool has_k8s_pod() const;
  void clear_k8s_pod();
  static const int kK8SPodFieldNumber = 17;
  const ::flyteidl::core::K8sPod& k8s_pod() const;
  ::flyteidl::core::K8sPod* release_k8s_pod();
  ::flyteidl::core::K8sPod* mutable_k8s_pod();
  void set_allocated_k8s_pod(::flyteidl::core::K8sPod* k8s_pod);

  // .flyteidl.core.Sql sql = 18;
  bool has_sql() const;
  void clear_sql();
  static const int kSqlFieldNumber = 18;
  const ::flyteidl::core::Sql& sql() const;
  ::flyteidl::core::Sql* release_sql();
  ::flyteidl::core::Sql* mutable_sql();
  void set_allocated_sql(::flyteidl::core::Sql* sql);

  void clear_target();
  TargetCase target_case() const;
  // @@protoc_insertion_point(class_scope:flyteidl.core.TaskTemplate)
 private:
  class HasBitSetters;
  void set_has_container();
  void set_has_k8s_pod();
  void set_has_sql();

  inline bool has_target() const;
  inline void clear_has_target();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      TaskTemplate_ConfigEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > config_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::flyteidl::core::Identifier* id_;
  ::flyteidl::core::TaskMetadata* metadata_;
  ::flyteidl::core::TypedInterface* interface_;
  ::google::protobuf::Struct* custom_;
  ::flyteidl::core::SecurityContext* security_context_;
  ::google::protobuf::int32 task_type_version_;
  union TargetUnion {
    TargetUnion() {}
    ::flyteidl::core::Container* container_;
    ::flyteidl::core::K8sPod* k8s_pod_;
    ::flyteidl::core::Sql* sql_;
  } target_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_flyteidl_2fcore_2ftasks_2eproto;
};
// -------------------------------------------------------------------

class ContainerPort final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.ContainerPort) */ {
 public:
  ContainerPort();
  virtual ~ContainerPort();

  ContainerPort(const ContainerPort& from);

  inline ContainerPort& operator=(const ContainerPort& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ContainerPort(ContainerPort&& from) noexcept
    : ContainerPort() {
    *this = ::std::move(from);
  }

  inline ContainerPort& operator=(ContainerPort&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ContainerPort& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ContainerPort* internal_default_instance() {
    return reinterpret_cast<const ContainerPort*>(
               &_ContainerPort_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(ContainerPort* other);
  friend void swap(ContainerPort& a, ContainerPort& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ContainerPort* New() const final {
    return CreateMaybeMessage<ContainerPort>(nullptr);
  }

  ContainerPort* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ContainerPort>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ContainerPort& from);
  void MergeFrom(const ContainerPort& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContainerPort* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 container_port = 1;
  void clear_container_port();
  static const int kContainerPortFieldNumber = 1;
  ::google::protobuf::uint32 container_port() const;
  void set_container_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:flyteidl.core.ContainerPort)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 container_port_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2ftasks_2eproto;
};
// -------------------------------------------------------------------

class Container final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.Container) */ {
 public:
  Container();
  virtual ~Container();

  Container(const Container& from);

  inline Container& operator=(const Container& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Container(Container&& from) noexcept
    : Container() {
    *this = ::std::move(from);
  }

  inline Container& operator=(Container&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Container& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Container* internal_default_instance() {
    return reinterpret_cast<const Container*>(
               &_Container_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(Container* other);
  friend void swap(Container& a, Container& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Container* New() const final {
    return CreateMaybeMessage<Container>(nullptr);
  }

  Container* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Container>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Container& from);
  void MergeFrom(const Container& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Container* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Container_Architecture Architecture;
  static const Architecture UNKNOWN =
    Container_Architecture_UNKNOWN;
  static const Architecture AMD64 =
    Container_Architecture_AMD64;
  static const Architecture ARM64 =
    Container_Architecture_ARM64;
  static const Architecture ARM_V6 =
    Container_Architecture_ARM_V6;
  static const Architecture ARM_V7 =
    Container_Architecture_ARM_V7;
  static inline bool Architecture_IsValid(int value) {
    return Container_Architecture_IsValid(value);
  }
  static const Architecture Architecture_MIN =
    Container_Architecture_Architecture_MIN;
  static const Architecture Architecture_MAX =
    Container_Architecture_Architecture_MAX;
  static const int Architecture_ARRAYSIZE =
    Container_Architecture_Architecture_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Architecture_descriptor() {
    return Container_Architecture_descriptor();
  }
  static inline const ::std::string& Architecture_Name(Architecture value) {
    return Container_Architecture_Name(value);
  }
  static inline bool Architecture_Parse(const ::std::string& name,
      Architecture* value) {
    return Container_Architecture_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated string command = 2;
  int command_size() const;
  void clear_command();
  static const int kCommandFieldNumber = 2;
  const ::std::string& command(int index) const;
  ::std::string* mutable_command(int index);
  void set_command(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_command(int index, ::std::string&& value);
  #endif
  void set_command(int index, const char* value);
  void set_command(int index, const char* value, size_t size);
  ::std::string* add_command();
  void add_command(const ::std::string& value);
  #if LANG_CXX11
  void add_command(::std::string&& value);
  #endif
  void add_command(const char* value);
  void add_command(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& command() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_command();

  // repeated string args = 3;
  int args_size() const;
  void clear_args();
  static const int kArgsFieldNumber = 3;
  const ::std::string& args(int index) const;
  ::std::string* mutable_args(int index);
  void set_args(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_args(int index, ::std::string&& value);
  #endif
  void set_args(int index, const char* value);
  void set_args(int index, const char* value, size_t size);
  ::std::string* add_args();
  void add_args(const ::std::string& value);
  #if LANG_CXX11
  void add_args(::std::string&& value);
  #endif
  void add_args(const char* value);
  void add_args(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& args() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_args();

  // repeated .flyteidl.core.KeyValuePair env = 5;
  int env_size() const;
  void clear_env();
  static const int kEnvFieldNumber = 5;
  ::flyteidl::core::KeyValuePair* mutable_env(int index);
  ::google::protobuf::RepeatedPtrField< ::flyteidl::core::KeyValuePair >*
      mutable_env();
  const ::flyteidl::core::KeyValuePair& env(int index) const;
  ::flyteidl::core::KeyValuePair* add_env();
  const ::google::protobuf::RepeatedPtrField< ::flyteidl::core::KeyValuePair >&
      env() const;

  // repeated .flyteidl.core.KeyValuePair config = 6 [deprecated = true];
  PROTOBUF_DEPRECATED int config_size() const;
  PROTOBUF_DEPRECATED void clear_config();
  PROTOBUF_DEPRECATED static const int kConfigFieldNumber = 6;
  PROTOBUF_DEPRECATED ::flyteidl::core::KeyValuePair* mutable_config(int index);
  PROTOBUF_DEPRECATED ::google::protobuf::RepeatedPtrField< ::flyteidl::core::KeyValuePair >*
      mutable_config();
  PROTOBUF_DEPRECATED const ::flyteidl::core::KeyValuePair& config(int index) const;
  PROTOBUF_DEPRECATED ::flyteidl::core::KeyValuePair* add_config();
  PROTOBUF_DEPRECATED const ::google::protobuf::RepeatedPtrField< ::flyteidl::core::KeyValuePair >&
      config() const;

  // repeated .flyteidl.core.ContainerPort ports = 7;
  int ports_size() const;
  void clear_ports();
  static const int kPortsFieldNumber = 7;
  ::flyteidl::core::ContainerPort* mutable_ports(int index);
  ::google::protobuf::RepeatedPtrField< ::flyteidl::core::ContainerPort >*
      mutable_ports();
  const ::flyteidl::core::ContainerPort& ports(int index) const;
  ::flyteidl::core::ContainerPort* add_ports();
  const ::google::protobuf::RepeatedPtrField< ::flyteidl::core::ContainerPort >&
      ports() const;

  // string image = 1;
  void clear_image();
  static const int kImageFieldNumber = 1;
  const ::std::string& image() const;
  void set_image(const ::std::string& value);
  #if LANG_CXX11
  void set_image(::std::string&& value);
  #endif
  void set_image(const char* value);
  void set_image(const char* value, size_t size);
  ::std::string* mutable_image();
  ::std::string* release_image();
  void set_allocated_image(::std::string* image);

  // .flyteidl.core.Resources resources = 4;
  bool has_resources() const;
  void clear_resources();
  static const int kResourcesFieldNumber = 4;
  const ::flyteidl::core::Resources& resources() const;
  ::flyteidl::core::Resources* release_resources();
  ::flyteidl::core::Resources* mutable_resources();
  void set_allocated_resources(::flyteidl::core::Resources* resources);

  // .flyteidl.core.DataLoadingConfig data_config = 9;
  bool has_data_config() const;
  void clear_data_config();
  static const int kDataConfigFieldNumber = 9;
  const ::flyteidl::core::DataLoadingConfig& data_config() const;
  ::flyteidl::core::DataLoadingConfig* release_data_config();
  ::flyteidl::core::DataLoadingConfig* mutable_data_config();
  void set_allocated_data_config(::flyteidl::core::DataLoadingConfig* data_config);

  // .flyteidl.core.Container.Architecture architecture = 10;
  void clear_architecture();
  static const int kArchitectureFieldNumber = 10;
  ::flyteidl::core::Container_Architecture architecture() const;
  void set_architecture(::flyteidl::core::Container_Architecture value);

  // @@protoc_insertion_point(class_scope:flyteidl.core.Container)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField<::std::string> command_;
  ::google::protobuf::RepeatedPtrField<::std::string> args_;
  ::google::protobuf::RepeatedPtrField< ::flyteidl::core::KeyValuePair > env_;
  ::google::protobuf::RepeatedPtrField< ::flyteidl::core::KeyValuePair > config_;
  ::google::protobuf::RepeatedPtrField< ::flyteidl::core::ContainerPort > ports_;
  ::google::protobuf::internal::ArenaStringPtr image_;
  ::flyteidl::core::Resources* resources_;
  ::flyteidl::core::DataLoadingConfig* data_config_;
  int architecture_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2ftasks_2eproto;
};
// -------------------------------------------------------------------

class IOStrategy final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.IOStrategy) */ {
 public:
  IOStrategy();
  virtual ~IOStrategy();

  IOStrategy(const IOStrategy& from);

  inline IOStrategy& operator=(const IOStrategy& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IOStrategy(IOStrategy&& from) noexcept
    : IOStrategy() {
    *this = ::std::move(from);
  }

  inline IOStrategy& operator=(IOStrategy&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const IOStrategy& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IOStrategy* internal_default_instance() {
    return reinterpret_cast<const IOStrategy*>(
               &_IOStrategy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(IOStrategy* other);
  friend void swap(IOStrategy& a, IOStrategy& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IOStrategy* New() const final {
    return CreateMaybeMessage<IOStrategy>(nullptr);
  }

  IOStrategy* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IOStrategy>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const IOStrategy& from);
  void MergeFrom(const IOStrategy& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IOStrategy* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef IOStrategy_DownloadMode DownloadMode;
  static const DownloadMode DOWNLOAD_EAGER =
    IOStrategy_DownloadMode_DOWNLOAD_EAGER;
  static const DownloadMode DOWNLOAD_STREAM =
    IOStrategy_DownloadMode_DOWNLOAD_STREAM;
  static const DownloadMode DO_NOT_DOWNLOAD =
    IOStrategy_DownloadMode_DO_NOT_DOWNLOAD;
  static inline bool DownloadMode_IsValid(int value) {
    return IOStrategy_DownloadMode_IsValid(value);
  }
  static const DownloadMode DownloadMode_MIN =
    IOStrategy_DownloadMode_DownloadMode_MIN;
  static const DownloadMode DownloadMode_MAX =
    IOStrategy_DownloadMode_DownloadMode_MAX;
  static const int DownloadMode_ARRAYSIZE =
    IOStrategy_DownloadMode_DownloadMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DownloadMode_descriptor() {
    return IOStrategy_DownloadMode_descriptor();
  }
  static inline const ::std::string& DownloadMode_Name(DownloadMode value) {
    return IOStrategy_DownloadMode_Name(value);
  }
  static inline bool DownloadMode_Parse(const ::std::string& name,
      DownloadMode* value) {
    return IOStrategy_DownloadMode_Parse(name, value);
  }

  typedef IOStrategy_UploadMode UploadMode;
  static const UploadMode UPLOAD_ON_EXIT =
    IOStrategy_UploadMode_UPLOAD_ON_EXIT;
  static const UploadMode UPLOAD_EAGER =
    IOStrategy_UploadMode_UPLOAD_EAGER;
  static const UploadMode DO_NOT_UPLOAD =
    IOStrategy_UploadMode_DO_NOT_UPLOAD;
  static inline bool UploadMode_IsValid(int value) {
    return IOStrategy_UploadMode_IsValid(value);
  }
  static const UploadMode UploadMode_MIN =
    IOStrategy_UploadMode_UploadMode_MIN;
  static const UploadMode UploadMode_MAX =
    IOStrategy_UploadMode_UploadMode_MAX;
  static const int UploadMode_ARRAYSIZE =
    IOStrategy_UploadMode_UploadMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  UploadMode_descriptor() {
    return IOStrategy_UploadMode_descriptor();
  }
  static inline const ::std::string& UploadMode_Name(UploadMode value) {
    return IOStrategy_UploadMode_Name(value);
  }
  static inline bool UploadMode_Parse(const ::std::string& name,
      UploadMode* value) {
    return IOStrategy_UploadMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .flyteidl.core.IOStrategy.DownloadMode download_mode = 1;
  void clear_download_mode();
  static const int kDownloadModeFieldNumber = 1;
  ::flyteidl::core::IOStrategy_DownloadMode download_mode() const;
  void set_download_mode(::flyteidl::core::IOStrategy_DownloadMode value);

  // .flyteidl.core.IOStrategy.UploadMode upload_mode = 2;
  void clear_upload_mode();
  static const int kUploadModeFieldNumber = 2;
  ::flyteidl::core::IOStrategy_UploadMode upload_mode() const;
  void set_upload_mode(::flyteidl::core::IOStrategy_UploadMode value);

  // @@protoc_insertion_point(class_scope:flyteidl.core.IOStrategy)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int download_mode_;
  int upload_mode_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2ftasks_2eproto;
};
// -------------------------------------------------------------------

class DataLoadingConfig final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.DataLoadingConfig) */ {
 public:
  DataLoadingConfig();
  virtual ~DataLoadingConfig();

  DataLoadingConfig(const DataLoadingConfig& from);

  inline DataLoadingConfig& operator=(const DataLoadingConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DataLoadingConfig(DataLoadingConfig&& from) noexcept
    : DataLoadingConfig() {
    *this = ::std::move(from);
  }

  inline DataLoadingConfig& operator=(DataLoadingConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const DataLoadingConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DataLoadingConfig* internal_default_instance() {
    return reinterpret_cast<const DataLoadingConfig*>(
               &_DataLoadingConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(DataLoadingConfig* other);
  friend void swap(DataLoadingConfig& a, DataLoadingConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DataLoadingConfig* New() const final {
    return CreateMaybeMessage<DataLoadingConfig>(nullptr);
  }

  DataLoadingConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DataLoadingConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DataLoadingConfig& from);
  void MergeFrom(const DataLoadingConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataLoadingConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DataLoadingConfig_LiteralMapFormat LiteralMapFormat;
  static const LiteralMapFormat JSON =
    DataLoadingConfig_LiteralMapFormat_JSON;
  static const LiteralMapFormat YAML =
    DataLoadingConfig_LiteralMapFormat_YAML;
  static const LiteralMapFormat PROTO =
    DataLoadingConfig_LiteralMapFormat_PROTO;
  static inline bool LiteralMapFormat_IsValid(int value) {
    return DataLoadingConfig_LiteralMapFormat_IsValid(value);
  }
  static const LiteralMapFormat LiteralMapFormat_MIN =
    DataLoadingConfig_LiteralMapFormat_LiteralMapFormat_MIN;
  static const LiteralMapFormat LiteralMapFormat_MAX =
    DataLoadingConfig_LiteralMapFormat_LiteralMapFormat_MAX;
  static const int LiteralMapFormat_ARRAYSIZE =
    DataLoadingConfig_LiteralMapFormat_LiteralMapFormat_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LiteralMapFormat_descriptor() {
    return DataLoadingConfig_LiteralMapFormat_descriptor();
  }
  static inline const ::std::string& LiteralMapFormat_Name(LiteralMapFormat value) {
    return DataLoadingConfig_LiteralMapFormat_Name(value);
  }
  static inline bool LiteralMapFormat_Parse(const ::std::string& name,
      LiteralMapFormat* value) {
    return DataLoadingConfig_LiteralMapFormat_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string input_path = 2;
  void clear_input_path();
  static const int kInputPathFieldNumber = 2;
  const ::std::string& input_path() const;
  void set_input_path(const ::std::string& value);
  #if LANG_CXX11
  void set_input_path(::std::string&& value);
  #endif
  void set_input_path(const char* value);
  void set_input_path(const char* value, size_t size);
  ::std::string* mutable_input_path();
  ::std::string* release_input_path();
  void set_allocated_input_path(::std::string* input_path);

  // string output_path = 3;
  void clear_output_path();
  static const int kOutputPathFieldNumber = 3;
  const ::std::string& output_path() const;
  void set_output_path(const ::std::string& value);
  #if LANG_CXX11
  void set_output_path(::std::string&& value);
  #endif
  void set_output_path(const char* value);
  void set_output_path(const char* value, size_t size);
  ::std::string* mutable_output_path();
  ::std::string* release_output_path();
  void set_allocated_output_path(::std::string* output_path);

  // .flyteidl.core.IOStrategy io_strategy = 5;
  bool has_io_strategy() const;
  void clear_io_strategy();
  static const int kIoStrategyFieldNumber = 5;
  const ::flyteidl::core::IOStrategy& io_strategy() const;
  ::flyteidl::core::IOStrategy* release_io_strategy();
  ::flyteidl::core::IOStrategy* mutable_io_strategy();
  void set_allocated_io_strategy(::flyteidl::core::IOStrategy* io_strategy);

  // bool enabled = 1;
  void clear_enabled();
  static const int kEnabledFieldNumber = 1;
  bool enabled() const;
  void set_enabled(bool value);

  // .flyteidl.core.DataLoadingConfig.LiteralMapFormat format = 4;
  void clear_format();
  static const int kFormatFieldNumber = 4;
  ::flyteidl::core::DataLoadingConfig_LiteralMapFormat format() const;
  void set_format(::flyteidl::core::DataLoadingConfig_LiteralMapFormat value);

  // @@protoc_insertion_point(class_scope:flyteidl.core.DataLoadingConfig)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr input_path_;
  ::google::protobuf::internal::ArenaStringPtr output_path_;
  ::flyteidl::core::IOStrategy* io_strategy_;
  bool enabled_;
  int format_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2ftasks_2eproto;
};
// -------------------------------------------------------------------

class K8sPod final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.K8sPod) */ {
 public:
  K8sPod();
  virtual ~K8sPod();

  K8sPod(const K8sPod& from);

  inline K8sPod& operator=(const K8sPod& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  K8sPod(K8sPod&& from) noexcept
    : K8sPod() {
    *this = ::std::move(from);
  }

  inline K8sPod& operator=(K8sPod&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const K8sPod& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const K8sPod* internal_default_instance() {
    return reinterpret_cast<const K8sPod*>(
               &_K8sPod_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(K8sPod* other);
  friend void swap(K8sPod& a, K8sPod& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline K8sPod* New() const final {
    return CreateMaybeMessage<K8sPod>(nullptr);
  }

  K8sPod* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<K8sPod>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const K8sPod& from);
  void MergeFrom(const K8sPod& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(K8sPod* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .flyteidl.core.K8sObjectMetadata metadata = 1;
  bool has_metadata() const;
  void clear_metadata();
  static const int kMetadataFieldNumber = 1;
  const ::flyteidl::core::K8sObjectMetadata& metadata() const;
  ::flyteidl::core::K8sObjectMetadata* release_metadata();
  ::flyteidl::core::K8sObjectMetadata* mutable_metadata();
  void set_allocated_metadata(::flyteidl::core::K8sObjectMetadata* metadata);

  // .google.protobuf.Struct pod_spec = 2;
  bool has_pod_spec() const;
  void clear_pod_spec();
  static const int kPodSpecFieldNumber = 2;
  const ::google::protobuf::Struct& pod_spec() const;
  ::google::protobuf::Struct* release_pod_spec();
  ::google::protobuf::Struct* mutable_pod_spec();
  void set_allocated_pod_spec(::google::protobuf::Struct* pod_spec);

  // .flyteidl.core.DataLoadingConfig data_config = 3;
  bool has_data_config() const;
  void clear_data_config();
  static const int kDataConfigFieldNumber = 3;
  const ::flyteidl::core::DataLoadingConfig& data_config() const;
  ::flyteidl::core::DataLoadingConfig* release_data_config();
  ::flyteidl::core::DataLoadingConfig* mutable_data_config();
  void set_allocated_data_config(::flyteidl::core::DataLoadingConfig* data_config);

  // @@protoc_insertion_point(class_scope:flyteidl.core.K8sPod)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::flyteidl::core::K8sObjectMetadata* metadata_;
  ::google::protobuf::Struct* pod_spec_;
  ::flyteidl::core::DataLoadingConfig* data_config_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2ftasks_2eproto;
};
// -------------------------------------------------------------------

class K8sObjectMetadata_LabelsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<K8sObjectMetadata_LabelsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
static bool _ParseMap(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  typedef ::google::protobuf::internal::MapEntry<K8sObjectMetadata_LabelsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  K8sObjectMetadata_LabelsEntry_DoNotUse();
  K8sObjectMetadata_LabelsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const K8sObjectMetadata_LabelsEntry_DoNotUse& other);
  static const K8sObjectMetadata_LabelsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const K8sObjectMetadata_LabelsEntry_DoNotUse*>(&_K8sObjectMetadata_LabelsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class K8sObjectMetadata_AnnotationsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<K8sObjectMetadata_AnnotationsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
static bool _ParseMap(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  typedef ::google::protobuf::internal::MapEntry<K8sObjectMetadata_AnnotationsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  K8sObjectMetadata_AnnotationsEntry_DoNotUse();
  K8sObjectMetadata_AnnotationsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const K8sObjectMetadata_AnnotationsEntry_DoNotUse& other);
  static const K8sObjectMetadata_AnnotationsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const K8sObjectMetadata_AnnotationsEntry_DoNotUse*>(&_K8sObjectMetadata_AnnotationsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class K8sObjectMetadata final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.K8sObjectMetadata) */ {
 public:
  K8sObjectMetadata();
  virtual ~K8sObjectMetadata();

  K8sObjectMetadata(const K8sObjectMetadata& from);

  inline K8sObjectMetadata& operator=(const K8sObjectMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  K8sObjectMetadata(K8sObjectMetadata&& from) noexcept
    : K8sObjectMetadata() {
    *this = ::std::move(from);
  }

  inline K8sObjectMetadata& operator=(K8sObjectMetadata&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const K8sObjectMetadata& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const K8sObjectMetadata* internal_default_instance() {
    return reinterpret_cast<const K8sObjectMetadata*>(
               &_K8sObjectMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(K8sObjectMetadata* other);
  friend void swap(K8sObjectMetadata& a, K8sObjectMetadata& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline K8sObjectMetadata* New() const final {
    return CreateMaybeMessage<K8sObjectMetadata>(nullptr);
  }

  K8sObjectMetadata* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<K8sObjectMetadata>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const K8sObjectMetadata& from);
  void MergeFrom(const K8sObjectMetadata& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(K8sObjectMetadata* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, string> labels = 1;
  int labels_size() const;
  void clear_labels();
  static const int kLabelsFieldNumber = 1;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      labels() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_labels();

  // map<string, string> annotations = 2;
  int annotations_size() const;
  void clear_annotations();
  static const int kAnnotationsFieldNumber = 2;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      annotations() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_annotations();

  // @@protoc_insertion_point(class_scope:flyteidl.core.K8sObjectMetadata)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      K8sObjectMetadata_LabelsEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > labels_;
  ::google::protobuf::internal::MapField<
      K8sObjectMetadata_AnnotationsEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > annotations_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2ftasks_2eproto;
};
// -------------------------------------------------------------------

class Sql final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.Sql) */ {
 public:
  Sql();
  virtual ~Sql();

  Sql(const Sql& from);

  inline Sql& operator=(const Sql& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Sql(Sql&& from) noexcept
    : Sql() {
    *this = ::std::move(from);
  }

  inline Sql& operator=(Sql&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Sql& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Sql* internal_default_instance() {
    return reinterpret_cast<const Sql*>(
               &_Sql_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(Sql* other);
  friend void swap(Sql& a, Sql& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Sql* New() const final {
    return CreateMaybeMessage<Sql>(nullptr);
  }

  Sql* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Sql>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Sql& from);
  void MergeFrom(const Sql& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Sql* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Sql_Dialect Dialect;
  static const Dialect UNDEFINED =
    Sql_Dialect_UNDEFINED;
  static const Dialect ANSI =
    Sql_Dialect_ANSI;
  static const Dialect HIVE =
    Sql_Dialect_HIVE;
  static const Dialect OTHER =
    Sql_Dialect_OTHER;
  static inline bool Dialect_IsValid(int value) {
    return Sql_Dialect_IsValid(value);
  }
  static const Dialect Dialect_MIN =
    Sql_Dialect_Dialect_MIN;
  static const Dialect Dialect_MAX =
    Sql_Dialect_Dialect_MAX;
  static const int Dialect_ARRAYSIZE =
    Sql_Dialect_Dialect_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Dialect_descriptor() {
    return Sql_Dialect_descriptor();
  }
  static inline const ::std::string& Dialect_Name(Dialect value) {
    return Sql_Dialect_Name(value);
  }
  static inline bool Dialect_Parse(const ::std::string& name,
      Dialect* value) {
    return Sql_Dialect_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string statement = 1;
  void clear_statement();
  static const int kStatementFieldNumber = 1;
  const ::std::string& statement() const;
  void set_statement(const ::std::string& value);
  #if LANG_CXX11
  void set_statement(::std::string&& value);
  #endif
  void set_statement(const char* value);
  void set_statement(const char* value, size_t size);
  ::std::string* mutable_statement();
  ::std::string* release_statement();
  void set_allocated_statement(::std::string* statement);

  // .flyteidl.core.Sql.Dialect dialect = 2;
  void clear_dialect();
  static const int kDialectFieldNumber = 2;
  ::flyteidl::core::Sql_Dialect dialect() const;
  void set_dialect(::flyteidl::core::Sql_Dialect value);

  // @@protoc_insertion_point(class_scope:flyteidl.core.Sql)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr statement_;
  int dialect_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2ftasks_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Resources_ResourceEntry

// .flyteidl.core.Resources.ResourceName name = 1;
inline void Resources_ResourceEntry::clear_name() {
  name_ = 0;
}
inline ::flyteidl::core::Resources_ResourceName Resources_ResourceEntry::name() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Resources.ResourceEntry.name)
  return static_cast< ::flyteidl::core::Resources_ResourceName >(name_);
}
inline void Resources_ResourceEntry::set_name(::flyteidl::core::Resources_ResourceName value) {
  
  name_ = value;
  // @@protoc_insertion_point(field_set:flyteidl.core.Resources.ResourceEntry.name)
}

// string value = 2;
inline void Resources_ResourceEntry::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Resources_ResourceEntry::value() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Resources.ResourceEntry.value)
  return value_.GetNoArena();
}
inline void Resources_ResourceEntry::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.Resources.ResourceEntry.value)
}
#if LANG_CXX11
inline void Resources_ResourceEntry::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.Resources.ResourceEntry.value)
}
#endif
inline void Resources_ResourceEntry::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.Resources.ResourceEntry.value)
}
inline void Resources_ResourceEntry::set_value(const char* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.Resources.ResourceEntry.value)
}
inline ::std::string* Resources_ResourceEntry::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Resources.ResourceEntry.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Resources_ResourceEntry::release_value() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Resources.ResourceEntry.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Resources_ResourceEntry::set_allocated_value(::std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.Resources.ResourceEntry.value)
}

// -------------------------------------------------------------------

// Resources

// repeated .flyteidl.core.Resources.ResourceEntry requests = 1;
inline int Resources::requests_size() const {
  return requests_.size();
}
inline void Resources::clear_requests() {
  requests_.Clear();
}
inline ::flyteidl::core::Resources_ResourceEntry* Resources::mutable_requests(int index) {
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Resources.requests)
  return requests_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::flyteidl::core::Resources_ResourceEntry >*
Resources::mutable_requests() {
  // @@protoc_insertion_point(field_mutable_list:flyteidl.core.Resources.requests)
  return &requests_;
}
inline const ::flyteidl::core::Resources_ResourceEntry& Resources::requests(int index) const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Resources.requests)
  return requests_.Get(index);
}
inline ::flyteidl::core::Resources_ResourceEntry* Resources::add_requests() {
  // @@protoc_insertion_point(field_add:flyteidl.core.Resources.requests)
  return requests_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::flyteidl::core::Resources_ResourceEntry >&
Resources::requests() const {
  // @@protoc_insertion_point(field_list:flyteidl.core.Resources.requests)
  return requests_;
}

// repeated .flyteidl.core.Resources.ResourceEntry limits = 2;
inline int Resources::limits_size() const {
  return limits_.size();
}
inline void Resources::clear_limits() {
  limits_.Clear();
}
inline ::flyteidl::core::Resources_ResourceEntry* Resources::mutable_limits(int index) {
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Resources.limits)
  return limits_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::flyteidl::core::Resources_ResourceEntry >*
Resources::mutable_limits() {
  // @@protoc_insertion_point(field_mutable_list:flyteidl.core.Resources.limits)
  return &limits_;
}
inline const ::flyteidl::core::Resources_ResourceEntry& Resources::limits(int index) const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Resources.limits)
  return limits_.Get(index);
}
inline ::flyteidl::core::Resources_ResourceEntry* Resources::add_limits() {
  // @@protoc_insertion_point(field_add:flyteidl.core.Resources.limits)
  return limits_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::flyteidl::core::Resources_ResourceEntry >&
Resources::limits() const {
  // @@protoc_insertion_point(field_list:flyteidl.core.Resources.limits)
  return limits_;
}

// -------------------------------------------------------------------

// RuntimeMetadata

// .flyteidl.core.RuntimeMetadata.RuntimeType type = 1;
inline void RuntimeMetadata::clear_type() {
  type_ = 0;
}
inline ::flyteidl::core::RuntimeMetadata_RuntimeType RuntimeMetadata::type() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.RuntimeMetadata.type)
  return static_cast< ::flyteidl::core::RuntimeMetadata_RuntimeType >(type_);
}
inline void RuntimeMetadata::set_type(::flyteidl::core::RuntimeMetadata_RuntimeType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:flyteidl.core.RuntimeMetadata.type)
}

// string version = 2;
inline void RuntimeMetadata::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RuntimeMetadata::version() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.RuntimeMetadata.version)
  return version_.GetNoArena();
}
inline void RuntimeMetadata::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.RuntimeMetadata.version)
}
#if LANG_CXX11
inline void RuntimeMetadata::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.RuntimeMetadata.version)
}
#endif
inline void RuntimeMetadata::set_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.RuntimeMetadata.version)
}
inline void RuntimeMetadata::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.RuntimeMetadata.version)
}
inline ::std::string* RuntimeMetadata::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.RuntimeMetadata.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RuntimeMetadata::release_version() {
  // @@protoc_insertion_point(field_release:flyteidl.core.RuntimeMetadata.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RuntimeMetadata::set_allocated_version(::std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.RuntimeMetadata.version)
}

// string flavor = 3;
inline void RuntimeMetadata::clear_flavor() {
  flavor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RuntimeMetadata::flavor() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.RuntimeMetadata.flavor)
  return flavor_.GetNoArena();
}
inline void RuntimeMetadata::set_flavor(const ::std::string& value) {
  
  flavor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.RuntimeMetadata.flavor)
}
#if LANG_CXX11
inline void RuntimeMetadata::set_flavor(::std::string&& value) {
  
  flavor_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.RuntimeMetadata.flavor)
}
#endif
inline void RuntimeMetadata::set_flavor(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  flavor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.RuntimeMetadata.flavor)
}
inline void RuntimeMetadata::set_flavor(const char* value, size_t size) {
  
  flavor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.RuntimeMetadata.flavor)
}
inline ::std::string* RuntimeMetadata::mutable_flavor() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.RuntimeMetadata.flavor)
  return flavor_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RuntimeMetadata::release_flavor() {
  // @@protoc_insertion_point(field_release:flyteidl.core.RuntimeMetadata.flavor)
  
  return flavor_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RuntimeMetadata::set_allocated_flavor(::std::string* flavor) {
  if (flavor != nullptr) {
    
  } else {
    
  }
  flavor_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), flavor);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.RuntimeMetadata.flavor)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TaskMetadata

// bool discoverable = 1;
inline void TaskMetadata::clear_discoverable() {
  discoverable_ = false;
}
inline bool TaskMetadata::discoverable() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.TaskMetadata.discoverable)
  return discoverable_;
}
inline void TaskMetadata::set_discoverable(bool value) {
  
  discoverable_ = value;
  // @@protoc_insertion_point(field_set:flyteidl.core.TaskMetadata.discoverable)
}

// .flyteidl.core.RuntimeMetadata runtime = 2;
inline bool TaskMetadata::has_runtime() const {
  return this != internal_default_instance() && runtime_ != nullptr;
}
inline void TaskMetadata::clear_runtime() {
  if (GetArenaNoVirtual() == nullptr && runtime_ != nullptr) {
    delete runtime_;
  }
  runtime_ = nullptr;
}
inline const ::flyteidl::core::RuntimeMetadata& TaskMetadata::runtime() const {
  const ::flyteidl::core::RuntimeMetadata* p = runtime_;
  // @@protoc_insertion_point(field_get:flyteidl.core.TaskMetadata.runtime)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::RuntimeMetadata*>(
      &::flyteidl::core::_RuntimeMetadata_default_instance_);
}
inline ::flyteidl::core::RuntimeMetadata* TaskMetadata::release_runtime() {
  // @@protoc_insertion_point(field_release:flyteidl.core.TaskMetadata.runtime)
  
  ::flyteidl::core::RuntimeMetadata* temp = runtime_;
  runtime_ = nullptr;
  return temp;
}
inline ::flyteidl::core::RuntimeMetadata* TaskMetadata::mutable_runtime() {
  
  if (runtime_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::RuntimeMetadata>(GetArenaNoVirtual());
    runtime_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.TaskMetadata.runtime)
  return runtime_;
}
inline void TaskMetadata::set_allocated_runtime(::flyteidl::core::RuntimeMetadata* runtime) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete runtime_;
  }
  if (runtime) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      runtime = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, runtime, submessage_arena);
    }
    
  } else {
    
  }
  runtime_ = runtime;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.TaskMetadata.runtime)
}

// .google.protobuf.Duration timeout = 4;
inline bool TaskMetadata::has_timeout() const {
  return this != internal_default_instance() && timeout_ != nullptr;
}
inline const ::google::protobuf::Duration& TaskMetadata::timeout() const {
  const ::google::protobuf::Duration* p = timeout_;
  // @@protoc_insertion_point(field_get:flyteidl.core.TaskMetadata.timeout)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::Duration*>(
      &::google::protobuf::_Duration_default_instance_);
}
inline ::google::protobuf::Duration* TaskMetadata::release_timeout() {
  // @@protoc_insertion_point(field_release:flyteidl.core.TaskMetadata.timeout)
  
  ::google::protobuf::Duration* temp = timeout_;
  timeout_ = nullptr;
  return temp;
}
inline ::google::protobuf::Duration* TaskMetadata::mutable_timeout() {
  
  if (timeout_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Duration>(GetArenaNoVirtual());
    timeout_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.TaskMetadata.timeout)
  return timeout_;
}
inline void TaskMetadata::set_allocated_timeout(::google::protobuf::Duration* timeout) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(timeout_);
  }
  if (timeout) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(timeout)->GetArena();
    if (message_arena != submessage_arena) {
      timeout = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, timeout, submessage_arena);
    }
    
  } else {
    
  }
  timeout_ = timeout;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.TaskMetadata.timeout)
}

// .flyteidl.core.RetryStrategy retries = 5;
inline bool TaskMetadata::has_retries() const {
  return this != internal_default_instance() && retries_ != nullptr;
}
inline const ::flyteidl::core::RetryStrategy& TaskMetadata::retries() const {
  const ::flyteidl::core::RetryStrategy* p = retries_;
  // @@protoc_insertion_point(field_get:flyteidl.core.TaskMetadata.retries)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::RetryStrategy*>(
      &::flyteidl::core::_RetryStrategy_default_instance_);
}
inline ::flyteidl::core::RetryStrategy* TaskMetadata::release_retries() {
  // @@protoc_insertion_point(field_release:flyteidl.core.TaskMetadata.retries)
  
  ::flyteidl::core::RetryStrategy* temp = retries_;
  retries_ = nullptr;
  return temp;
}
inline ::flyteidl::core::RetryStrategy* TaskMetadata::mutable_retries() {
  
  if (retries_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::RetryStrategy>(GetArenaNoVirtual());
    retries_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.TaskMetadata.retries)
  return retries_;
}
inline void TaskMetadata::set_allocated_retries(::flyteidl::core::RetryStrategy* retries) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(retries_);
  }
  if (retries) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      retries = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, retries, submessage_arena);
    }
    
  } else {
    
  }
  retries_ = retries;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.TaskMetadata.retries)
}

// string discovery_version = 6;
inline void TaskMetadata::clear_discovery_version() {
  discovery_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TaskMetadata::discovery_version() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.TaskMetadata.discovery_version)
  return discovery_version_.GetNoArena();
}
inline void TaskMetadata::set_discovery_version(const ::std::string& value) {
  
  discovery_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.TaskMetadata.discovery_version)
}
#if LANG_CXX11
inline void TaskMetadata::set_discovery_version(::std::string&& value) {
  
  discovery_version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.TaskMetadata.discovery_version)
}
#endif
inline void TaskMetadata::set_discovery_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  discovery_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.TaskMetadata.discovery_version)
}
inline void TaskMetadata::set_discovery_version(const char* value, size_t size) {
  
  discovery_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.TaskMetadata.discovery_version)
}
inline ::std::string* TaskMetadata::mutable_discovery_version() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.TaskMetadata.discovery_version)
  return discovery_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TaskMetadata::release_discovery_version() {
  // @@protoc_insertion_point(field_release:flyteidl.core.TaskMetadata.discovery_version)
  
  return discovery_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TaskMetadata::set_allocated_discovery_version(::std::string* discovery_version) {
  if (discovery_version != nullptr) {
    
  } else {
    
  }
  discovery_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), discovery_version);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.TaskMetadata.discovery_version)
}

// string deprecated_error_message = 7;
inline void TaskMetadata::clear_deprecated_error_message() {
  deprecated_error_message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TaskMetadata::deprecated_error_message() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.TaskMetadata.deprecated_error_message)
  return deprecated_error_message_.GetNoArena();
}
inline void TaskMetadata::set_deprecated_error_message(const ::std::string& value) {
  
  deprecated_error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.TaskMetadata.deprecated_error_message)
}
#if LANG_CXX11
inline void TaskMetadata::set_deprecated_error_message(::std::string&& value) {
  
  deprecated_error_message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.TaskMetadata.deprecated_error_message)
}
#endif
inline void TaskMetadata::set_deprecated_error_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  deprecated_error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.TaskMetadata.deprecated_error_message)
}
inline void TaskMetadata::set_deprecated_error_message(const char* value, size_t size) {
  
  deprecated_error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.TaskMetadata.deprecated_error_message)
}
inline ::std::string* TaskMetadata::mutable_deprecated_error_message() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.TaskMetadata.deprecated_error_message)
  return deprecated_error_message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TaskMetadata::release_deprecated_error_message() {
  // @@protoc_insertion_point(field_release:flyteidl.core.TaskMetadata.deprecated_error_message)
  
  return deprecated_error_message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TaskMetadata::set_allocated_deprecated_error_message(::std::string* deprecated_error_message) {
  if (deprecated_error_message != nullptr) {
    
  } else {
    
  }
  deprecated_error_message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), deprecated_error_message);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.TaskMetadata.deprecated_error_message)
}

// bool interruptible = 8;
inline bool TaskMetadata::has_interruptible() const {
  return interruptible_value_case() == kInterruptible;
}
inline void TaskMetadata::set_has_interruptible() {
  _oneof_case_[0] = kInterruptible;
}
inline void TaskMetadata::clear_interruptible() {
  if (has_interruptible()) {
    interruptible_value_.interruptible_ = false;
    clear_has_interruptible_value();
  }
}
inline bool TaskMetadata::interruptible() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.TaskMetadata.interruptible)
  if (has_interruptible()) {
    return interruptible_value_.interruptible_;
  }
  return false;
}
inline void TaskMetadata::set_interruptible(bool value) {
  if (!has_interruptible()) {
    clear_interruptible_value();
    set_has_interruptible();
  }
  interruptible_value_.interruptible_ = value;
  // @@protoc_insertion_point(field_set:flyteidl.core.TaskMetadata.interruptible)
}

// bool cache_serializable = 9;
inline void TaskMetadata::clear_cache_serializable() {
  cache_serializable_ = false;
}
inline bool TaskMetadata::cache_serializable() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.TaskMetadata.cache_serializable)
  return cache_serializable_;
}
inline void TaskMetadata::set_cache_serializable(bool value) {
  
  cache_serializable_ = value;
  // @@protoc_insertion_point(field_set:flyteidl.core.TaskMetadata.cache_serializable)
}

// bool generates_deck = 10;
inline void TaskMetadata::clear_generates_deck() {
  generates_deck_ = false;
}
inline bool TaskMetadata::generates_deck() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.TaskMetadata.generates_deck)
  return generates_deck_;
}
inline void TaskMetadata::set_generates_deck(bool value) {
  
  generates_deck_ = value;
  // @@protoc_insertion_point(field_set:flyteidl.core.TaskMetadata.generates_deck)
}

// map<string, string> tags = 11;
inline int TaskMetadata::tags_size() const {
  return tags_.size();
}
inline void TaskMetadata::clear_tags() {
  tags_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
TaskMetadata::tags() const {
  // @@protoc_insertion_point(field_map:flyteidl.core.TaskMetadata.tags)
  return tags_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
TaskMetadata::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_map:flyteidl.core.TaskMetadata.tags)
  return tags_.MutableMap();
}

// string pod_template_name = 12;
inline void TaskMetadata::clear_pod_template_name() {
  pod_template_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TaskMetadata::pod_template_name() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.TaskMetadata.pod_template_name)
  return pod_template_name_.GetNoArena();
}
inline void TaskMetadata::set_pod_template_name(const ::std::string& value) {
  
  pod_template_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.TaskMetadata.pod_template_name)
}
#if LANG_CXX11
inline void TaskMetadata::set_pod_template_name(::std::string&& value) {
  
  pod_template_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.TaskMetadata.pod_template_name)
}
#endif
inline void TaskMetadata::set_pod_template_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  pod_template_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.TaskMetadata.pod_template_name)
}
inline void TaskMetadata::set_pod_template_name(const char* value, size_t size) {
  
  pod_template_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.TaskMetadata.pod_template_name)
}
inline ::std::string* TaskMetadata::mutable_pod_template_name() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.TaskMetadata.pod_template_name)
  return pod_template_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TaskMetadata::release_pod_template_name() {
  // @@protoc_insertion_point(field_release:flyteidl.core.TaskMetadata.pod_template_name)
  
  return pod_template_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TaskMetadata::set_allocated_pod_template_name(::std::string* pod_template_name) {
  if (pod_template_name != nullptr) {
    
  } else {
    
  }
  pod_template_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pod_template_name);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.TaskMetadata.pod_template_name)
}

inline bool TaskMetadata::has_interruptible_value() const {
  return interruptible_value_case() != INTERRUPTIBLE_VALUE_NOT_SET;
}
inline void TaskMetadata::clear_has_interruptible_value() {
  _oneof_case_[0] = INTERRUPTIBLE_VALUE_NOT_SET;
}
inline TaskMetadata::InterruptibleValueCase TaskMetadata::interruptible_value_case() const {
  return TaskMetadata::InterruptibleValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TaskTemplate

// .flyteidl.core.Identifier id = 1;
inline bool TaskTemplate::has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline const ::flyteidl::core::Identifier& TaskTemplate::id() const {
  const ::flyteidl::core::Identifier* p = id_;
  // @@protoc_insertion_point(field_get:flyteidl.core.TaskTemplate.id)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::Identifier*>(
      &::flyteidl::core::_Identifier_default_instance_);
}
inline ::flyteidl::core::Identifier* TaskTemplate::release_id() {
  // @@protoc_insertion_point(field_release:flyteidl.core.TaskTemplate.id)
  
  ::flyteidl::core::Identifier* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::flyteidl::core::Identifier* TaskTemplate::mutable_id() {
  
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::Identifier>(GetArenaNoVirtual());
    id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.TaskTemplate.id)
  return id_;
}
inline void TaskTemplate::set_allocated_id(::flyteidl::core::Identifier* id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(id_);
  }
  if (id) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.TaskTemplate.id)
}

// string type = 2;
inline void TaskTemplate::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TaskTemplate::type() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.TaskTemplate.type)
  return type_.GetNoArena();
}
inline void TaskTemplate::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.TaskTemplate.type)
}
#if LANG_CXX11
inline void TaskTemplate::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.TaskTemplate.type)
}
#endif
inline void TaskTemplate::set_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.TaskTemplate.type)
}
inline void TaskTemplate::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.TaskTemplate.type)
}
inline ::std::string* TaskTemplate::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.TaskTemplate.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TaskTemplate::release_type() {
  // @@protoc_insertion_point(field_release:flyteidl.core.TaskTemplate.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TaskTemplate::set_allocated_type(::std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.TaskTemplate.type)
}

// .flyteidl.core.TaskMetadata metadata = 3;
inline bool TaskTemplate::has_metadata() const {
  return this != internal_default_instance() && metadata_ != nullptr;
}
inline void TaskTemplate::clear_metadata() {
  if (GetArenaNoVirtual() == nullptr && metadata_ != nullptr) {
    delete metadata_;
  }
  metadata_ = nullptr;
}
inline const ::flyteidl::core::TaskMetadata& TaskTemplate::metadata() const {
  const ::flyteidl::core::TaskMetadata* p = metadata_;
  // @@protoc_insertion_point(field_get:flyteidl.core.TaskTemplate.metadata)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::TaskMetadata*>(
      &::flyteidl::core::_TaskMetadata_default_instance_);
}
inline ::flyteidl::core::TaskMetadata* TaskTemplate::release_metadata() {
  // @@protoc_insertion_point(field_release:flyteidl.core.TaskTemplate.metadata)
  
  ::flyteidl::core::TaskMetadata* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::flyteidl::core::TaskMetadata* TaskTemplate::mutable_metadata() {
  
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::TaskMetadata>(GetArenaNoVirtual());
    metadata_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.TaskTemplate.metadata)
  return metadata_;
}
inline void TaskTemplate::set_allocated_metadata(::flyteidl::core::TaskMetadata* metadata) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete metadata_;
  }
  if (metadata) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      metadata = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.TaskTemplate.metadata)
}

// .flyteidl.core.TypedInterface interface = 4;
inline bool TaskTemplate::has_interface() const {
  return this != internal_default_instance() && interface_ != nullptr;
}
inline const ::flyteidl::core::TypedInterface& TaskTemplate::interface() const {
  const ::flyteidl::core::TypedInterface* p = interface_;
  // @@protoc_insertion_point(field_get:flyteidl.core.TaskTemplate.interface)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::TypedInterface*>(
      &::flyteidl::core::_TypedInterface_default_instance_);
}
inline ::flyteidl::core::TypedInterface* TaskTemplate::release_interface() {
  // @@protoc_insertion_point(field_release:flyteidl.core.TaskTemplate.interface)
  
  ::flyteidl::core::TypedInterface* temp = interface_;
  interface_ = nullptr;
  return temp;
}
inline ::flyteidl::core::TypedInterface* TaskTemplate::mutable_interface() {
  
  if (interface_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::TypedInterface>(GetArenaNoVirtual());
    interface_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.TaskTemplate.interface)
  return interface_;
}
inline void TaskTemplate::set_allocated_interface(::flyteidl::core::TypedInterface* interface) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(interface_);
  }
  if (interface) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      interface = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, interface, submessage_arena);
    }
    
  } else {
    
  }
  interface_ = interface;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.TaskTemplate.interface)
}

// .google.protobuf.Struct custom = 5;
inline bool TaskTemplate::has_custom() const {
  return this != internal_default_instance() && custom_ != nullptr;
}
inline const ::google::protobuf::Struct& TaskTemplate::custom() const {
  const ::google::protobuf::Struct* p = custom_;
  // @@protoc_insertion_point(field_get:flyteidl.core.TaskTemplate.custom)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::Struct*>(
      &::google::protobuf::_Struct_default_instance_);
}
inline ::google::protobuf::Struct* TaskTemplate::release_custom() {
  // @@protoc_insertion_point(field_release:flyteidl.core.TaskTemplate.custom)
  
  ::google::protobuf::Struct* temp = custom_;
  custom_ = nullptr;
  return temp;
}
inline ::google::protobuf::Struct* TaskTemplate::mutable_custom() {
  
  if (custom_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Struct>(GetArenaNoVirtual());
    custom_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.TaskTemplate.custom)
  return custom_;
}
inline void TaskTemplate::set_allocated_custom(::google::protobuf::Struct* custom) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(custom_);
  }
  if (custom) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(custom)->GetArena();
    if (message_arena != submessage_arena) {
      custom = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, custom, submessage_arena);
    }
    
  } else {
    
  }
  custom_ = custom;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.TaskTemplate.custom)
}

// .flyteidl.core.Container container = 6;
inline bool TaskTemplate::has_container() const {
  return target_case() == kContainer;
}
inline void TaskTemplate::set_has_container() {
  _oneof_case_[0] = kContainer;
}
inline void TaskTemplate::clear_container() {
  if (has_container()) {
    delete target_.container_;
    clear_has_target();
  }
}
inline ::flyteidl::core::Container* TaskTemplate::release_container() {
  // @@protoc_insertion_point(field_release:flyteidl.core.TaskTemplate.container)
  if (has_container()) {
    clear_has_target();
      ::flyteidl::core::Container* temp = target_.container_;
    target_.container_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::core::Container& TaskTemplate::container() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.TaskTemplate.container)
  return has_container()
      ? *target_.container_
      : *reinterpret_cast< ::flyteidl::core::Container*>(&::flyteidl::core::_Container_default_instance_);
}
inline ::flyteidl::core::Container* TaskTemplate::mutable_container() {
  if (!has_container()) {
    clear_target();
    set_has_container();
    target_.container_ = CreateMaybeMessage< ::flyteidl::core::Container >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.TaskTemplate.container)
  return target_.container_;
}

// .flyteidl.core.K8sPod k8s_pod = 17;
inline bool TaskTemplate::has_k8s_pod() const {
  return target_case() == kK8SPod;
}
inline void TaskTemplate::set_has_k8s_pod() {
  _oneof_case_[0] = kK8SPod;
}
inline void TaskTemplate::clear_k8s_pod() {
  if (has_k8s_pod()) {
    delete target_.k8s_pod_;
    clear_has_target();
  }
}
inline ::flyteidl::core::K8sPod* TaskTemplate::release_k8s_pod() {
  // @@protoc_insertion_point(field_release:flyteidl.core.TaskTemplate.k8s_pod)
  if (has_k8s_pod()) {
    clear_has_target();
      ::flyteidl::core::K8sPod* temp = target_.k8s_pod_;
    target_.k8s_pod_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::core::K8sPod& TaskTemplate::k8s_pod() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.TaskTemplate.k8s_pod)
  return has_k8s_pod()
      ? *target_.k8s_pod_
      : *reinterpret_cast< ::flyteidl::core::K8sPod*>(&::flyteidl::core::_K8sPod_default_instance_);
}
inline ::flyteidl::core::K8sPod* TaskTemplate::mutable_k8s_pod() {
  if (!has_k8s_pod()) {
    clear_target();
    set_has_k8s_pod();
    target_.k8s_pod_ = CreateMaybeMessage< ::flyteidl::core::K8sPod >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.TaskTemplate.k8s_pod)
  return target_.k8s_pod_;
}

// .flyteidl.core.Sql sql = 18;
inline bool TaskTemplate::has_sql() const {
  return target_case() == kSql;
}
inline void TaskTemplate::set_has_sql() {
  _oneof_case_[0] = kSql;
}
inline void TaskTemplate::clear_sql() {
  if (has_sql()) {
    delete target_.sql_;
    clear_has_target();
  }
}
inline ::flyteidl::core::Sql* TaskTemplate::release_sql() {
  // @@protoc_insertion_point(field_release:flyteidl.core.TaskTemplate.sql)
  if (has_sql()) {
    clear_has_target();
      ::flyteidl::core::Sql* temp = target_.sql_;
    target_.sql_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::core::Sql& TaskTemplate::sql() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.TaskTemplate.sql)
  return has_sql()
      ? *target_.sql_
      : *reinterpret_cast< ::flyteidl::core::Sql*>(&::flyteidl::core::_Sql_default_instance_);
}
inline ::flyteidl::core::Sql* TaskTemplate::mutable_sql() {
  if (!has_sql()) {
    clear_target();
    set_has_sql();
    target_.sql_ = CreateMaybeMessage< ::flyteidl::core::Sql >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.TaskTemplate.sql)
  return target_.sql_;
}

// int32 task_type_version = 7;
inline void TaskTemplate::clear_task_type_version() {
  task_type_version_ = 0;
}
inline ::google::protobuf::int32 TaskTemplate::task_type_version() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.TaskTemplate.task_type_version)
  return task_type_version_;
}
inline void TaskTemplate::set_task_type_version(::google::protobuf::int32 value) {
  
  task_type_version_ = value;
  // @@protoc_insertion_point(field_set:flyteidl.core.TaskTemplate.task_type_version)
}

// .flyteidl.core.SecurityContext security_context = 8;
inline bool TaskTemplate::has_security_context() const {
  return this != internal_default_instance() && security_context_ != nullptr;
}
inline const ::flyteidl::core::SecurityContext& TaskTemplate::security_context() const {
  const ::flyteidl::core::SecurityContext* p = security_context_;
  // @@protoc_insertion_point(field_get:flyteidl.core.TaskTemplate.security_context)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::SecurityContext*>(
      &::flyteidl::core::_SecurityContext_default_instance_);
}
inline ::flyteidl::core::SecurityContext* TaskTemplate::release_security_context() {
  // @@protoc_insertion_point(field_release:flyteidl.core.TaskTemplate.security_context)
  
  ::flyteidl::core::SecurityContext* temp = security_context_;
  security_context_ = nullptr;
  return temp;
}
inline ::flyteidl::core::SecurityContext* TaskTemplate::mutable_security_context() {
  
  if (security_context_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::SecurityContext>(GetArenaNoVirtual());
    security_context_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.TaskTemplate.security_context)
  return security_context_;
}
inline void TaskTemplate::set_allocated_security_context(::flyteidl::core::SecurityContext* security_context) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(security_context_);
  }
  if (security_context) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      security_context = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, security_context, submessage_arena);
    }
    
  } else {
    
  }
  security_context_ = security_context;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.TaskTemplate.security_context)
}

// map<string, string> config = 16;
inline int TaskTemplate::config_size() const {
  return config_.size();
}
inline void TaskTemplate::clear_config() {
  config_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
TaskTemplate::config() const {
  // @@protoc_insertion_point(field_map:flyteidl.core.TaskTemplate.config)
  return config_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
TaskTemplate::mutable_config() {
  // @@protoc_insertion_point(field_mutable_map:flyteidl.core.TaskTemplate.config)
  return config_.MutableMap();
}

inline bool TaskTemplate::has_target() const {
  return target_case() != TARGET_NOT_SET;
}
inline void TaskTemplate::clear_has_target() {
  _oneof_case_[0] = TARGET_NOT_SET;
}
inline TaskTemplate::TargetCase TaskTemplate::target_case() const {
  return TaskTemplate::TargetCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ContainerPort

// uint32 container_port = 1;
inline void ContainerPort::clear_container_port() {
  container_port_ = 0u;
}
inline ::google::protobuf::uint32 ContainerPort::container_port() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.ContainerPort.container_port)
  return container_port_;
}
inline void ContainerPort::set_container_port(::google::protobuf::uint32 value) {
  
  container_port_ = value;
  // @@protoc_insertion_point(field_set:flyteidl.core.ContainerPort.container_port)
}

// -------------------------------------------------------------------

// Container

// string image = 1;
inline void Container::clear_image() {
  image_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Container::image() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Container.image)
  return image_.GetNoArena();
}
inline void Container::set_image(const ::std::string& value) {
  
  image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.Container.image)
}
#if LANG_CXX11
inline void Container::set_image(::std::string&& value) {
  
  image_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.Container.image)
}
#endif
inline void Container::set_image(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.Container.image)
}
inline void Container::set_image(const char* value, size_t size) {
  
  image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.Container.image)
}
inline ::std::string* Container::mutable_image() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Container.image)
  return image_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Container::release_image() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Container.image)
  
  return image_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Container::set_allocated_image(::std::string* image) {
  if (image != nullptr) {
    
  } else {
    
  }
  image_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), image);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.Container.image)
}

// repeated string command = 2;
inline int Container::command_size() const {
  return command_.size();
}
inline void Container::clear_command() {
  command_.Clear();
}
inline const ::std::string& Container::command(int index) const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Container.command)
  return command_.Get(index);
}
inline ::std::string* Container::mutable_command(int index) {
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Container.command)
  return command_.Mutable(index);
}
inline void Container::set_command(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:flyteidl.core.Container.command)
  command_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Container::set_command(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:flyteidl.core.Container.command)
  command_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Container::set_command(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  command_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:flyteidl.core.Container.command)
}
inline void Container::set_command(int index, const char* value, size_t size) {
  command_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.Container.command)
}
inline ::std::string* Container::add_command() {
  // @@protoc_insertion_point(field_add_mutable:flyteidl.core.Container.command)
  return command_.Add();
}
inline void Container::add_command(const ::std::string& value) {
  command_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:flyteidl.core.Container.command)
}
#if LANG_CXX11
inline void Container::add_command(::std::string&& value) {
  command_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:flyteidl.core.Container.command)
}
#endif
inline void Container::add_command(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  command_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:flyteidl.core.Container.command)
}
inline void Container::add_command(const char* value, size_t size) {
  command_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:flyteidl.core.Container.command)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
Container::command() const {
  // @@protoc_insertion_point(field_list:flyteidl.core.Container.command)
  return command_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
Container::mutable_command() {
  // @@protoc_insertion_point(field_mutable_list:flyteidl.core.Container.command)
  return &command_;
}

// repeated string args = 3;
inline int Container::args_size() const {
  return args_.size();
}
inline void Container::clear_args() {
  args_.Clear();
}
inline const ::std::string& Container::args(int index) const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Container.args)
  return args_.Get(index);
}
inline ::std::string* Container::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Container.args)
  return args_.Mutable(index);
}
inline void Container::set_args(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:flyteidl.core.Container.args)
  args_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Container::set_args(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:flyteidl.core.Container.args)
  args_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Container::set_args(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  args_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:flyteidl.core.Container.args)
}
inline void Container::set_args(int index, const char* value, size_t size) {
  args_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.Container.args)
}
inline ::std::string* Container::add_args() {
  // @@protoc_insertion_point(field_add_mutable:flyteidl.core.Container.args)
  return args_.Add();
}
inline void Container::add_args(const ::std::string& value) {
  args_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:flyteidl.core.Container.args)
}
#if LANG_CXX11
inline void Container::add_args(::std::string&& value) {
  args_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:flyteidl.core.Container.args)
}
#endif
inline void Container::add_args(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  args_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:flyteidl.core.Container.args)
}
inline void Container::add_args(const char* value, size_t size) {
  args_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:flyteidl.core.Container.args)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
Container::args() const {
  // @@protoc_insertion_point(field_list:flyteidl.core.Container.args)
  return args_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
Container::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:flyteidl.core.Container.args)
  return &args_;
}

// .flyteidl.core.Resources resources = 4;
inline bool Container::has_resources() const {
  return this != internal_default_instance() && resources_ != nullptr;
}
inline void Container::clear_resources() {
  if (GetArenaNoVirtual() == nullptr && resources_ != nullptr) {
    delete resources_;
  }
  resources_ = nullptr;
}
inline const ::flyteidl::core::Resources& Container::resources() const {
  const ::flyteidl::core::Resources* p = resources_;
  // @@protoc_insertion_point(field_get:flyteidl.core.Container.resources)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::Resources*>(
      &::flyteidl::core::_Resources_default_instance_);
}
inline ::flyteidl::core::Resources* Container::release_resources() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Container.resources)
  
  ::flyteidl::core::Resources* temp = resources_;
  resources_ = nullptr;
  return temp;
}
inline ::flyteidl::core::Resources* Container::mutable_resources() {
  
  if (resources_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::Resources>(GetArenaNoVirtual());
    resources_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Container.resources)
  return resources_;
}
inline void Container::set_allocated_resources(::flyteidl::core::Resources* resources) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete resources_;
  }
  if (resources) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      resources = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, resources, submessage_arena);
    }
    
  } else {
    
  }
  resources_ = resources;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.Container.resources)
}

// repeated .flyteidl.core.KeyValuePair env = 5;
inline int Container::env_size() const {
  return env_.size();
}
inline ::flyteidl::core::KeyValuePair* Container::mutable_env(int index) {
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Container.env)
  return env_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::flyteidl::core::KeyValuePair >*
Container::mutable_env() {
  // @@protoc_insertion_point(field_mutable_list:flyteidl.core.Container.env)
  return &env_;
}
inline const ::flyteidl::core::KeyValuePair& Container::env(int index) const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Container.env)
  return env_.Get(index);
}
inline ::flyteidl::core::KeyValuePair* Container::add_env() {
  // @@protoc_insertion_point(field_add:flyteidl.core.Container.env)
  return env_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::flyteidl::core::KeyValuePair >&
Container::env() const {
  // @@protoc_insertion_point(field_list:flyteidl.core.Container.env)
  return env_;
}

// repeated .flyteidl.core.KeyValuePair config = 6 [deprecated = true];
inline int Container::config_size() const {
  return config_.size();
}
inline ::flyteidl::core::KeyValuePair* Container::mutable_config(int index) {
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Container.config)
  return config_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::flyteidl::core::KeyValuePair >*
Container::mutable_config() {
  // @@protoc_insertion_point(field_mutable_list:flyteidl.core.Container.config)
  return &config_;
}
inline const ::flyteidl::core::KeyValuePair& Container::config(int index) const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Container.config)
  return config_.Get(index);
}
inline ::flyteidl::core::KeyValuePair* Container::add_config() {
  // @@protoc_insertion_point(field_add:flyteidl.core.Container.config)
  return config_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::flyteidl::core::KeyValuePair >&
Container::config() const {
  // @@protoc_insertion_point(field_list:flyteidl.core.Container.config)
  return config_;
}

// repeated .flyteidl.core.ContainerPort ports = 7;
inline int Container::ports_size() const {
  return ports_.size();
}
inline void Container::clear_ports() {
  ports_.Clear();
}
inline ::flyteidl::core::ContainerPort* Container::mutable_ports(int index) {
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Container.ports)
  return ports_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::flyteidl::core::ContainerPort >*
Container::mutable_ports() {
  // @@protoc_insertion_point(field_mutable_list:flyteidl.core.Container.ports)
  return &ports_;
}
inline const ::flyteidl::core::ContainerPort& Container::ports(int index) const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Container.ports)
  return ports_.Get(index);
}
inline ::flyteidl::core::ContainerPort* Container::add_ports() {
  // @@protoc_insertion_point(field_add:flyteidl.core.Container.ports)
  return ports_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::flyteidl::core::ContainerPort >&
Container::ports() const {
  // @@protoc_insertion_point(field_list:flyteidl.core.Container.ports)
  return ports_;
}

// .flyteidl.core.DataLoadingConfig data_config = 9;
inline bool Container::has_data_config() const {
  return this != internal_default_instance() && data_config_ != nullptr;
}
inline void Container::clear_data_config() {
  if (GetArenaNoVirtual() == nullptr && data_config_ != nullptr) {
    delete data_config_;
  }
  data_config_ = nullptr;
}
inline const ::flyteidl::core::DataLoadingConfig& Container::data_config() const {
  const ::flyteidl::core::DataLoadingConfig* p = data_config_;
  // @@protoc_insertion_point(field_get:flyteidl.core.Container.data_config)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::DataLoadingConfig*>(
      &::flyteidl::core::_DataLoadingConfig_default_instance_);
}
inline ::flyteidl::core::DataLoadingConfig* Container::release_data_config() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Container.data_config)
  
  ::flyteidl::core::DataLoadingConfig* temp = data_config_;
  data_config_ = nullptr;
  return temp;
}
inline ::flyteidl::core::DataLoadingConfig* Container::mutable_data_config() {
  
  if (data_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::DataLoadingConfig>(GetArenaNoVirtual());
    data_config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Container.data_config)
  return data_config_;
}
inline void Container::set_allocated_data_config(::flyteidl::core::DataLoadingConfig* data_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete data_config_;
  }
  if (data_config) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      data_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, data_config, submessage_arena);
    }
    
  } else {
    
  }
  data_config_ = data_config;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.Container.data_config)
}

// .flyteidl.core.Container.Architecture architecture = 10;
inline void Container::clear_architecture() {
  architecture_ = 0;
}
inline ::flyteidl::core::Container_Architecture Container::architecture() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Container.architecture)
  return static_cast< ::flyteidl::core::Container_Architecture >(architecture_);
}
inline void Container::set_architecture(::flyteidl::core::Container_Architecture value) {
  
  architecture_ = value;
  // @@protoc_insertion_point(field_set:flyteidl.core.Container.architecture)
}

// -------------------------------------------------------------------

// IOStrategy

// .flyteidl.core.IOStrategy.DownloadMode download_mode = 1;
inline void IOStrategy::clear_download_mode() {
  download_mode_ = 0;
}
inline ::flyteidl::core::IOStrategy_DownloadMode IOStrategy::download_mode() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.IOStrategy.download_mode)
  return static_cast< ::flyteidl::core::IOStrategy_DownloadMode >(download_mode_);
}
inline void IOStrategy::set_download_mode(::flyteidl::core::IOStrategy_DownloadMode value) {
  
  download_mode_ = value;
  // @@protoc_insertion_point(field_set:flyteidl.core.IOStrategy.download_mode)
}

// .flyteidl.core.IOStrategy.UploadMode upload_mode = 2;
inline void IOStrategy::clear_upload_mode() {
  upload_mode_ = 0;
}
inline ::flyteidl::core::IOStrategy_UploadMode IOStrategy::upload_mode() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.IOStrategy.upload_mode)
  return static_cast< ::flyteidl::core::IOStrategy_UploadMode >(upload_mode_);
}
inline void IOStrategy::set_upload_mode(::flyteidl::core::IOStrategy_UploadMode value) {
  
  upload_mode_ = value;
  // @@protoc_insertion_point(field_set:flyteidl.core.IOStrategy.upload_mode)
}

// -------------------------------------------------------------------

// DataLoadingConfig

// bool enabled = 1;
inline void DataLoadingConfig::clear_enabled() {
  enabled_ = false;
}
inline bool DataLoadingConfig::enabled() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.DataLoadingConfig.enabled)
  return enabled_;
}
inline void DataLoadingConfig::set_enabled(bool value) {
  
  enabled_ = value;
  // @@protoc_insertion_point(field_set:flyteidl.core.DataLoadingConfig.enabled)
}

// string input_path = 2;
inline void DataLoadingConfig::clear_input_path() {
  input_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DataLoadingConfig::input_path() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.DataLoadingConfig.input_path)
  return input_path_.GetNoArena();
}
inline void DataLoadingConfig::set_input_path(const ::std::string& value) {
  
  input_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.DataLoadingConfig.input_path)
}
#if LANG_CXX11
inline void DataLoadingConfig::set_input_path(::std::string&& value) {
  
  input_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.DataLoadingConfig.input_path)
}
#endif
inline void DataLoadingConfig::set_input_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  input_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.DataLoadingConfig.input_path)
}
inline void DataLoadingConfig::set_input_path(const char* value, size_t size) {
  
  input_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.DataLoadingConfig.input_path)
}
inline ::std::string* DataLoadingConfig::mutable_input_path() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.DataLoadingConfig.input_path)
  return input_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DataLoadingConfig::release_input_path() {
  // @@protoc_insertion_point(field_release:flyteidl.core.DataLoadingConfig.input_path)
  
  return input_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DataLoadingConfig::set_allocated_input_path(::std::string* input_path) {
  if (input_path != nullptr) {
    
  } else {
    
  }
  input_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), input_path);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.DataLoadingConfig.input_path)
}

// string output_path = 3;
inline void DataLoadingConfig::clear_output_path() {
  output_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DataLoadingConfig::output_path() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.DataLoadingConfig.output_path)
  return output_path_.GetNoArena();
}
inline void DataLoadingConfig::set_output_path(const ::std::string& value) {
  
  output_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.DataLoadingConfig.output_path)
}
#if LANG_CXX11
inline void DataLoadingConfig::set_output_path(::std::string&& value) {
  
  output_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.DataLoadingConfig.output_path)
}
#endif
inline void DataLoadingConfig::set_output_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  output_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.DataLoadingConfig.output_path)
}
inline void DataLoadingConfig::set_output_path(const char* value, size_t size) {
  
  output_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.DataLoadingConfig.output_path)
}
inline ::std::string* DataLoadingConfig::mutable_output_path() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.DataLoadingConfig.output_path)
  return output_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DataLoadingConfig::release_output_path() {
  // @@protoc_insertion_point(field_release:flyteidl.core.DataLoadingConfig.output_path)
  
  return output_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DataLoadingConfig::set_allocated_output_path(::std::string* output_path) {
  if (output_path != nullptr) {
    
  } else {
    
  }
  output_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), output_path);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.DataLoadingConfig.output_path)
}

// .flyteidl.core.DataLoadingConfig.LiteralMapFormat format = 4;
inline void DataLoadingConfig::clear_format() {
  format_ = 0;
}
inline ::flyteidl::core::DataLoadingConfig_LiteralMapFormat DataLoadingConfig::format() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.DataLoadingConfig.format)
  return static_cast< ::flyteidl::core::DataLoadingConfig_LiteralMapFormat >(format_);
}
inline void DataLoadingConfig::set_format(::flyteidl::core::DataLoadingConfig_LiteralMapFormat value) {
  
  format_ = value;
  // @@protoc_insertion_point(field_set:flyteidl.core.DataLoadingConfig.format)
}

// .flyteidl.core.IOStrategy io_strategy = 5;
inline bool DataLoadingConfig::has_io_strategy() const {
  return this != internal_default_instance() && io_strategy_ != nullptr;
}
inline void DataLoadingConfig::clear_io_strategy() {
  if (GetArenaNoVirtual() == nullptr && io_strategy_ != nullptr) {
    delete io_strategy_;
  }
  io_strategy_ = nullptr;
}
inline const ::flyteidl::core::IOStrategy& DataLoadingConfig::io_strategy() const {
  const ::flyteidl::core::IOStrategy* p = io_strategy_;
  // @@protoc_insertion_point(field_get:flyteidl.core.DataLoadingConfig.io_strategy)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::IOStrategy*>(
      &::flyteidl::core::_IOStrategy_default_instance_);
}
inline ::flyteidl::core::IOStrategy* DataLoadingConfig::release_io_strategy() {
  // @@protoc_insertion_point(field_release:flyteidl.core.DataLoadingConfig.io_strategy)
  
  ::flyteidl::core::IOStrategy* temp = io_strategy_;
  io_strategy_ = nullptr;
  return temp;
}
inline ::flyteidl::core::IOStrategy* DataLoadingConfig::mutable_io_strategy() {
  
  if (io_strategy_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::IOStrategy>(GetArenaNoVirtual());
    io_strategy_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.DataLoadingConfig.io_strategy)
  return io_strategy_;
}
inline void DataLoadingConfig::set_allocated_io_strategy(::flyteidl::core::IOStrategy* io_strategy) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete io_strategy_;
  }
  if (io_strategy) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      io_strategy = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, io_strategy, submessage_arena);
    }
    
  } else {
    
  }
  io_strategy_ = io_strategy;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.DataLoadingConfig.io_strategy)
}

// -------------------------------------------------------------------

// K8sPod

// .flyteidl.core.K8sObjectMetadata metadata = 1;
inline bool K8sPod::has_metadata() const {
  return this != internal_default_instance() && metadata_ != nullptr;
}
inline void K8sPod::clear_metadata() {
  if (GetArenaNoVirtual() == nullptr && metadata_ != nullptr) {
    delete metadata_;
  }
  metadata_ = nullptr;
}
inline const ::flyteidl::core::K8sObjectMetadata& K8sPod::metadata() const {
  const ::flyteidl::core::K8sObjectMetadata* p = metadata_;
  // @@protoc_insertion_point(field_get:flyteidl.core.K8sPod.metadata)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::K8sObjectMetadata*>(
      &::flyteidl::core::_K8sObjectMetadata_default_instance_);
}
inline ::flyteidl::core::K8sObjectMetadata* K8sPod::release_metadata() {
  // @@protoc_insertion_point(field_release:flyteidl.core.K8sPod.metadata)
  
  ::flyteidl::core::K8sObjectMetadata* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::flyteidl::core::K8sObjectMetadata* K8sPod::mutable_metadata() {
  
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::K8sObjectMetadata>(GetArenaNoVirtual());
    metadata_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.K8sPod.metadata)
  return metadata_;
}
inline void K8sPod::set_allocated_metadata(::flyteidl::core::K8sObjectMetadata* metadata) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete metadata_;
  }
  if (metadata) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      metadata = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.K8sPod.metadata)
}

// .google.protobuf.Struct pod_spec = 2;
inline bool K8sPod::has_pod_spec() const {
  return this != internal_default_instance() && pod_spec_ != nullptr;
}
inline const ::google::protobuf::Struct& K8sPod::pod_spec() const {
  const ::google::protobuf::Struct* p = pod_spec_;
  // @@protoc_insertion_point(field_get:flyteidl.core.K8sPod.pod_spec)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::Struct*>(
      &::google::protobuf::_Struct_default_instance_);
}
inline ::google::protobuf::Struct* K8sPod::release_pod_spec() {
  // @@protoc_insertion_point(field_release:flyteidl.core.K8sPod.pod_spec)
  
  ::google::protobuf::Struct* temp = pod_spec_;
  pod_spec_ = nullptr;
  return temp;
}
inline ::google::protobuf::Struct* K8sPod::mutable_pod_spec() {
  
  if (pod_spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Struct>(GetArenaNoVirtual());
    pod_spec_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.K8sPod.pod_spec)
  return pod_spec_;
}
inline void K8sPod::set_allocated_pod_spec(::google::protobuf::Struct* pod_spec) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(pod_spec_);
  }
  if (pod_spec) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(pod_spec)->GetArena();
    if (message_arena != submessage_arena) {
      pod_spec = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pod_spec, submessage_arena);
    }
    
  } else {
    
  }
  pod_spec_ = pod_spec;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.K8sPod.pod_spec)
}

// .flyteidl.core.DataLoadingConfig data_config = 3;
inline bool K8sPod::has_data_config() const {
  return this != internal_default_instance() && data_config_ != nullptr;
}
inline void K8sPod::clear_data_config() {
  if (GetArenaNoVirtual() == nullptr && data_config_ != nullptr) {
    delete data_config_;
  }
  data_config_ = nullptr;
}
inline const ::flyteidl::core::DataLoadingConfig& K8sPod::data_config() const {
  const ::flyteidl::core::DataLoadingConfig* p = data_config_;
  // @@protoc_insertion_point(field_get:flyteidl.core.K8sPod.data_config)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::DataLoadingConfig*>(
      &::flyteidl::core::_DataLoadingConfig_default_instance_);
}
inline ::flyteidl::core::DataLoadingConfig* K8sPod::release_data_config() {
  // @@protoc_insertion_point(field_release:flyteidl.core.K8sPod.data_config)
  
  ::flyteidl::core::DataLoadingConfig* temp = data_config_;
  data_config_ = nullptr;
  return temp;
}
inline ::flyteidl::core::DataLoadingConfig* K8sPod::mutable_data_config() {
  
  if (data_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::DataLoadingConfig>(GetArenaNoVirtual());
    data_config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.K8sPod.data_config)
  return data_config_;
}
inline void K8sPod::set_allocated_data_config(::flyteidl::core::DataLoadingConfig* data_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete data_config_;
  }
  if (data_config) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      data_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, data_config, submessage_arena);
    }
    
  } else {
    
  }
  data_config_ = data_config;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.K8sPod.data_config)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// K8sObjectMetadata

// map<string, string> labels = 1;
inline int K8sObjectMetadata::labels_size() const {
  return labels_.size();
}
inline void K8sObjectMetadata::clear_labels() {
  labels_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
K8sObjectMetadata::labels() const {
  // @@protoc_insertion_point(field_map:flyteidl.core.K8sObjectMetadata.labels)
  return labels_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
K8sObjectMetadata::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_map:flyteidl.core.K8sObjectMetadata.labels)
  return labels_.MutableMap();
}

// map<string, string> annotations = 2;
inline int K8sObjectMetadata::annotations_size() const {
  return annotations_.size();
}
inline void K8sObjectMetadata::clear_annotations() {
  annotations_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
K8sObjectMetadata::annotations() const {
  // @@protoc_insertion_point(field_map:flyteidl.core.K8sObjectMetadata.annotations)
  return annotations_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
K8sObjectMetadata::mutable_annotations() {
  // @@protoc_insertion_point(field_mutable_map:flyteidl.core.K8sObjectMetadata.annotations)
  return annotations_.MutableMap();
}

// -------------------------------------------------------------------

// Sql

// string statement = 1;
inline void Sql::clear_statement() {
  statement_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Sql::statement() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Sql.statement)
  return statement_.GetNoArena();
}
inline void Sql::set_statement(const ::std::string& value) {
  
  statement_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.Sql.statement)
}
#if LANG_CXX11
inline void Sql::set_statement(::std::string&& value) {
  
  statement_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.Sql.statement)
}
#endif
inline void Sql::set_statement(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  statement_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.Sql.statement)
}
inline void Sql::set_statement(const char* value, size_t size) {
  
  statement_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.Sql.statement)
}
inline ::std::string* Sql::mutable_statement() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Sql.statement)
  return statement_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Sql::release_statement() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Sql.statement)
  
  return statement_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Sql::set_allocated_statement(::std::string* statement) {
  if (statement != nullptr) {
    
  } else {
    
  }
  statement_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), statement);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.Sql.statement)
}

// .flyteidl.core.Sql.Dialect dialect = 2;
inline void Sql::clear_dialect() {
  dialect_ = 0;
}
inline ::flyteidl::core::Sql_Dialect Sql::dialect() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Sql.dialect)
  return static_cast< ::flyteidl::core::Sql_Dialect >(dialect_);
}
inline void Sql::set_dialect(::flyteidl::core::Sql_Dialect value) {
  
  dialect_ = value;
  // @@protoc_insertion_point(field_set:flyteidl.core.Sql.dialect)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace core
}  // namespace flyteidl

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::flyteidl::core::Resources_ResourceName> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::flyteidl::core::Resources_ResourceName>() {
  return ::flyteidl::core::Resources_ResourceName_descriptor();
}
template <> struct is_proto_enum< ::flyteidl::core::RuntimeMetadata_RuntimeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::flyteidl::core::RuntimeMetadata_RuntimeType>() {
  return ::flyteidl::core::RuntimeMetadata_RuntimeType_descriptor();
}
template <> struct is_proto_enum< ::flyteidl::core::Container_Architecture> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::flyteidl::core::Container_Architecture>() {
  return ::flyteidl::core::Container_Architecture_descriptor();
}
template <> struct is_proto_enum< ::flyteidl::core::IOStrategy_DownloadMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::flyteidl::core::IOStrategy_DownloadMode>() {
  return ::flyteidl::core::IOStrategy_DownloadMode_descriptor();
}
template <> struct is_proto_enum< ::flyteidl::core::IOStrategy_UploadMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::flyteidl::core::IOStrategy_UploadMode>() {
  return ::flyteidl::core::IOStrategy_UploadMode_descriptor();
}
template <> struct is_proto_enum< ::flyteidl::core::DataLoadingConfig_LiteralMapFormat> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::flyteidl::core::DataLoadingConfig_LiteralMapFormat>() {
  return ::flyteidl::core::DataLoadingConfig_LiteralMapFormat_descriptor();
}
template <> struct is_proto_enum< ::flyteidl::core::Sql_Dialect> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::flyteidl::core::Sql_Dialect>() {
  return ::flyteidl::core::Sql_Dialect_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_flyteidl_2fcore_2ftasks_2eproto
