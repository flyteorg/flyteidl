// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: flyteidl/core/literals.proto

#ifndef PROTOBUF_INCLUDED_flyteidl_2fcore_2fliterals_2eproto
#define PROTOBUF_INCLUDED_flyteidl_2fcore_2fliterals_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
#include <google/protobuf/duration.pb.h>
#include <google/protobuf/struct.pb.h>
#include "flyteidl/core/types.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_flyteidl_2fcore_2fliterals_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_flyteidl_2fcore_2fliterals_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[25]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_flyteidl_2fcore_2fliterals_2eproto();
namespace flyteidl {
namespace core {
class Binary;
class BinaryDefaultTypeInternal;
extern BinaryDefaultTypeInternal _Binary_default_instance_;
class Binding;
class BindingDefaultTypeInternal;
extern BindingDefaultTypeInternal _Binding_default_instance_;
class BindingData;
class BindingDataDefaultTypeInternal;
extern BindingDataDefaultTypeInternal _BindingData_default_instance_;
class BindingDataCollection;
class BindingDataCollectionDefaultTypeInternal;
extern BindingDataCollectionDefaultTypeInternal _BindingDataCollection_default_instance_;
class BindingDataMap;
class BindingDataMapDefaultTypeInternal;
extern BindingDataMapDefaultTypeInternal _BindingDataMap_default_instance_;
class BindingDataMap_BindingsEntry_DoNotUse;
class BindingDataMap_BindingsEntry_DoNotUseDefaultTypeInternal;
extern BindingDataMap_BindingsEntry_DoNotUseDefaultTypeInternal _BindingDataMap_BindingsEntry_DoNotUse_default_instance_;
class Blob;
class BlobDefaultTypeInternal;
extern BlobDefaultTypeInternal _Blob_default_instance_;
class BlobMetadata;
class BlobMetadataDefaultTypeInternal;
extern BlobMetadataDefaultTypeInternal _BlobMetadata_default_instance_;
class BoolVector;
class BoolVectorDefaultTypeInternal;
extern BoolVectorDefaultTypeInternal _BoolVector_default_instance_;
class DoubleVector;
class DoubleVectorDefaultTypeInternal;
extern DoubleVectorDefaultTypeInternal _DoubleVector_default_instance_;
class FloatVector;
class FloatVectorDefaultTypeInternal;
extern FloatVectorDefaultTypeInternal _FloatVector_default_instance_;
class Int32Vector;
class Int32VectorDefaultTypeInternal;
extern Int32VectorDefaultTypeInternal _Int32Vector_default_instance_;
class Int64Vector;
class Int64VectorDefaultTypeInternal;
extern Int64VectorDefaultTypeInternal _Int64Vector_default_instance_;
class KeyValuePair;
class KeyValuePairDefaultTypeInternal;
extern KeyValuePairDefaultTypeInternal _KeyValuePair_default_instance_;
class Literal;
class LiteralDefaultTypeInternal;
extern LiteralDefaultTypeInternal _Literal_default_instance_;
class LiteralCollection;
class LiteralCollectionDefaultTypeInternal;
extern LiteralCollectionDefaultTypeInternal _LiteralCollection_default_instance_;
class LiteralMap;
class LiteralMapDefaultTypeInternal;
extern LiteralMapDefaultTypeInternal _LiteralMap_default_instance_;
class LiteralMap_LiteralsEntry_DoNotUse;
class LiteralMap_LiteralsEntry_DoNotUseDefaultTypeInternal;
extern LiteralMap_LiteralsEntry_DoNotUseDefaultTypeInternal _LiteralMap_LiteralsEntry_DoNotUse_default_instance_;
class Offloaded;
class OffloadedDefaultTypeInternal;
extern OffloadedDefaultTypeInternal _Offloaded_default_instance_;
class Primitive;
class PrimitiveDefaultTypeInternal;
extern PrimitiveDefaultTypeInternal _Primitive_default_instance_;
class RetryStrategy;
class RetryStrategyDefaultTypeInternal;
extern RetryStrategyDefaultTypeInternal _RetryStrategy_default_instance_;
class Scalar;
class ScalarDefaultTypeInternal;
extern ScalarDefaultTypeInternal _Scalar_default_instance_;
class Schema;
class SchemaDefaultTypeInternal;
extern SchemaDefaultTypeInternal _Schema_default_instance_;
class StringVector;
class StringVectorDefaultTypeInternal;
extern StringVectorDefaultTypeInternal _StringVector_default_instance_;
class Void;
class VoidDefaultTypeInternal;
extern VoidDefaultTypeInternal _Void_default_instance_;
}  // namespace core
}  // namespace flyteidl
namespace google {
namespace protobuf {
template<> ::flyteidl::core::Binary* Arena::CreateMaybeMessage<::flyteidl::core::Binary>(Arena*);
template<> ::flyteidl::core::Binding* Arena::CreateMaybeMessage<::flyteidl::core::Binding>(Arena*);
template<> ::flyteidl::core::BindingData* Arena::CreateMaybeMessage<::flyteidl::core::BindingData>(Arena*);
template<> ::flyteidl::core::BindingDataCollection* Arena::CreateMaybeMessage<::flyteidl::core::BindingDataCollection>(Arena*);
template<> ::flyteidl::core::BindingDataMap* Arena::CreateMaybeMessage<::flyteidl::core::BindingDataMap>(Arena*);
template<> ::flyteidl::core::BindingDataMap_BindingsEntry_DoNotUse* Arena::CreateMaybeMessage<::flyteidl::core::BindingDataMap_BindingsEntry_DoNotUse>(Arena*);
template<> ::flyteidl::core::Blob* Arena::CreateMaybeMessage<::flyteidl::core::Blob>(Arena*);
template<> ::flyteidl::core::BlobMetadata* Arena::CreateMaybeMessage<::flyteidl::core::BlobMetadata>(Arena*);
template<> ::flyteidl::core::BoolVector* Arena::CreateMaybeMessage<::flyteidl::core::BoolVector>(Arena*);
template<> ::flyteidl::core::DoubleVector* Arena::CreateMaybeMessage<::flyteidl::core::DoubleVector>(Arena*);
template<> ::flyteidl::core::FloatVector* Arena::CreateMaybeMessage<::flyteidl::core::FloatVector>(Arena*);
template<> ::flyteidl::core::Int32Vector* Arena::CreateMaybeMessage<::flyteidl::core::Int32Vector>(Arena*);
template<> ::flyteidl::core::Int64Vector* Arena::CreateMaybeMessage<::flyteidl::core::Int64Vector>(Arena*);
template<> ::flyteidl::core::KeyValuePair* Arena::CreateMaybeMessage<::flyteidl::core::KeyValuePair>(Arena*);
template<> ::flyteidl::core::Literal* Arena::CreateMaybeMessage<::flyteidl::core::Literal>(Arena*);
template<> ::flyteidl::core::LiteralCollection* Arena::CreateMaybeMessage<::flyteidl::core::LiteralCollection>(Arena*);
template<> ::flyteidl::core::LiteralMap* Arena::CreateMaybeMessage<::flyteidl::core::LiteralMap>(Arena*);
template<> ::flyteidl::core::LiteralMap_LiteralsEntry_DoNotUse* Arena::CreateMaybeMessage<::flyteidl::core::LiteralMap_LiteralsEntry_DoNotUse>(Arena*);
template<> ::flyteidl::core::Offloaded* Arena::CreateMaybeMessage<::flyteidl::core::Offloaded>(Arena*);
template<> ::flyteidl::core::Primitive* Arena::CreateMaybeMessage<::flyteidl::core::Primitive>(Arena*);
template<> ::flyteidl::core::RetryStrategy* Arena::CreateMaybeMessage<::flyteidl::core::RetryStrategy>(Arena*);
template<> ::flyteidl::core::Scalar* Arena::CreateMaybeMessage<::flyteidl::core::Scalar>(Arena*);
template<> ::flyteidl::core::Schema* Arena::CreateMaybeMessage<::flyteidl::core::Schema>(Arena*);
template<> ::flyteidl::core::StringVector* Arena::CreateMaybeMessage<::flyteidl::core::StringVector>(Arena*);
template<> ::flyteidl::core::Void* Arena::CreateMaybeMessage<::flyteidl::core::Void>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace flyteidl {
namespace core {

// ===================================================================

class Primitive final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.Primitive) */ {
 public:
  Primitive();
  virtual ~Primitive();

  Primitive(const Primitive& from);

  inline Primitive& operator=(const Primitive& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Primitive(Primitive&& from) noexcept
    : Primitive() {
    *this = ::std::move(from);
  }

  inline Primitive& operator=(Primitive&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Primitive& default_instance();

  enum ValueCase {
    kInteger = 1,
    kFloatValue = 2,
    kStringValue = 3,
    kBoolean = 4,
    kDatetime = 5,
    kDuration = 6,
    VALUE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Primitive* internal_default_instance() {
    return reinterpret_cast<const Primitive*>(
               &_Primitive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Primitive* other);
  friend void swap(Primitive& a, Primitive& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Primitive* New() const final {
    return CreateMaybeMessage<Primitive>(nullptr);
  }

  Primitive* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Primitive>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Primitive& from);
  void MergeFrom(const Primitive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Primitive* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 integer = 1;
  private:
  bool has_integer() const;
  public:
  void clear_integer();
  static const int kIntegerFieldNumber = 1;
  ::google::protobuf::int64 integer() const;
  void set_integer(::google::protobuf::int64 value);

  // double float_value = 2;
  private:
  bool has_float_value() const;
  public:
  void clear_float_value();
  static const int kFloatValueFieldNumber = 2;
  double float_value() const;
  void set_float_value(double value);

  // string string_value = 3;
  private:
  bool has_string_value() const;
  public:
  void clear_string_value();
  static const int kStringValueFieldNumber = 3;
  const ::std::string& string_value() const;
  void set_string_value(const ::std::string& value);
  #if LANG_CXX11
  void set_string_value(::std::string&& value);
  #endif
  void set_string_value(const char* value);
  void set_string_value(const char* value, size_t size);
  ::std::string* mutable_string_value();
  ::std::string* release_string_value();
  void set_allocated_string_value(::std::string* string_value);

  // bool boolean = 4;
  private:
  bool has_boolean() const;
  public:
  void clear_boolean();
  static const int kBooleanFieldNumber = 4;
  bool boolean() const;
  void set_boolean(bool value);

  // .google.protobuf.Timestamp datetime = 5;
  bool has_datetime() const;
  void clear_datetime();
  static const int kDatetimeFieldNumber = 5;
  const ::google::protobuf::Timestamp& datetime() const;
  ::google::protobuf::Timestamp* release_datetime();
  ::google::protobuf::Timestamp* mutable_datetime();
  void set_allocated_datetime(::google::protobuf::Timestamp* datetime);

  // .google.protobuf.Duration duration = 6;
  bool has_duration() const;
  void clear_duration();
  static const int kDurationFieldNumber = 6;
  const ::google::protobuf::Duration& duration() const;
  ::google::protobuf::Duration* release_duration();
  ::google::protobuf::Duration* mutable_duration();
  void set_allocated_duration(::google::protobuf::Duration* duration);

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:flyteidl.core.Primitive)
 private:
  class HasBitSetters;
  void set_has_integer();
  void set_has_float_value();
  void set_has_string_value();
  void set_has_boolean();
  void set_has_datetime();
  void set_has_duration();

  inline bool has_value() const;
  inline void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union ValueUnion {
    ValueUnion() {}
    ::google::protobuf::int64 integer_;
    double float_value_;
    ::google::protobuf::internal::ArenaStringPtr string_value_;
    bool boolean_;
    ::google::protobuf::Timestamp* datetime_;
    ::google::protobuf::Duration* duration_;
  } value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_flyteidl_2fcore_2fliterals_2eproto;
};
// -------------------------------------------------------------------

class Void final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.Void) */ {
 public:
  Void();
  virtual ~Void();

  Void(const Void& from);

  inline Void& operator=(const Void& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Void(Void&& from) noexcept
    : Void() {
    *this = ::std::move(from);
  }

  inline Void& operator=(Void&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Void& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Void* internal_default_instance() {
    return reinterpret_cast<const Void*>(
               &_Void_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Void* other);
  friend void swap(Void& a, Void& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Void* New() const final {
    return CreateMaybeMessage<Void>(nullptr);
  }

  Void* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Void>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Void& from);
  void MergeFrom(const Void& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Void* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:flyteidl.core.Void)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2fliterals_2eproto;
};
// -------------------------------------------------------------------

class Blob final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.Blob) */ {
 public:
  Blob();
  virtual ~Blob();

  Blob(const Blob& from);

  inline Blob& operator=(const Blob& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Blob(Blob&& from) noexcept
    : Blob() {
    *this = ::std::move(from);
  }

  inline Blob& operator=(Blob&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Blob& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Blob* internal_default_instance() {
    return reinterpret_cast<const Blob*>(
               &_Blob_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Blob* other);
  friend void swap(Blob& a, Blob& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Blob* New() const final {
    return CreateMaybeMessage<Blob>(nullptr);
  }

  Blob* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Blob>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Blob& from);
  void MergeFrom(const Blob& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Blob* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string uri = 3;
  void clear_uri();
  static const int kUriFieldNumber = 3;
  const ::std::string& uri() const;
  void set_uri(const ::std::string& value);
  #if LANG_CXX11
  void set_uri(::std::string&& value);
  #endif
  void set_uri(const char* value);
  void set_uri(const char* value, size_t size);
  ::std::string* mutable_uri();
  ::std::string* release_uri();
  void set_allocated_uri(::std::string* uri);

  // .flyteidl.core.BlobMetadata metadata = 1;
  bool has_metadata() const;
  void clear_metadata();
  static const int kMetadataFieldNumber = 1;
  const ::flyteidl::core::BlobMetadata& metadata() const;
  ::flyteidl::core::BlobMetadata* release_metadata();
  ::flyteidl::core::BlobMetadata* mutable_metadata();
  void set_allocated_metadata(::flyteidl::core::BlobMetadata* metadata);

  // @@protoc_insertion_point(class_scope:flyteidl.core.Blob)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr uri_;
  ::flyteidl::core::BlobMetadata* metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2fliterals_2eproto;
};
// -------------------------------------------------------------------

class BlobMetadata final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.BlobMetadata) */ {
 public:
  BlobMetadata();
  virtual ~BlobMetadata();

  BlobMetadata(const BlobMetadata& from);

  inline BlobMetadata& operator=(const BlobMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BlobMetadata(BlobMetadata&& from) noexcept
    : BlobMetadata() {
    *this = ::std::move(from);
  }

  inline BlobMetadata& operator=(BlobMetadata&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const BlobMetadata& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BlobMetadata* internal_default_instance() {
    return reinterpret_cast<const BlobMetadata*>(
               &_BlobMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(BlobMetadata* other);
  friend void swap(BlobMetadata& a, BlobMetadata& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BlobMetadata* New() const final {
    return CreateMaybeMessage<BlobMetadata>(nullptr);
  }

  BlobMetadata* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BlobMetadata>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BlobMetadata& from);
  void MergeFrom(const BlobMetadata& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlobMetadata* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .flyteidl.core.BlobType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  const ::flyteidl::core::BlobType& type() const;
  ::flyteidl::core::BlobType* release_type();
  ::flyteidl::core::BlobType* mutable_type();
  void set_allocated_type(::flyteidl::core::BlobType* type);

  // @@protoc_insertion_point(class_scope:flyteidl.core.BlobMetadata)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::flyteidl::core::BlobType* type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2fliterals_2eproto;
};
// -------------------------------------------------------------------

class Binary final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.Binary) */ {
 public:
  Binary();
  virtual ~Binary();

  Binary(const Binary& from);

  inline Binary& operator=(const Binary& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Binary(Binary&& from) noexcept
    : Binary() {
    *this = ::std::move(from);
  }

  inline Binary& operator=(Binary&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Binary& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Binary* internal_default_instance() {
    return reinterpret_cast<const Binary*>(
               &_Binary_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Binary* other);
  friend void swap(Binary& a, Binary& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Binary* New() const final {
    return CreateMaybeMessage<Binary>(nullptr);
  }

  Binary* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Binary>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Binary& from);
  void MergeFrom(const Binary& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Binary* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // string tag = 2;
  void clear_tag();
  static const int kTagFieldNumber = 2;
  const ::std::string& tag() const;
  void set_tag(const ::std::string& value);
  #if LANG_CXX11
  void set_tag(::std::string&& value);
  #endif
  void set_tag(const char* value);
  void set_tag(const char* value, size_t size);
  ::std::string* mutable_tag();
  ::std::string* release_tag();
  void set_allocated_tag(::std::string* tag);

  // @@protoc_insertion_point(class_scope:flyteidl.core.Binary)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::google::protobuf::internal::ArenaStringPtr tag_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2fliterals_2eproto;
};
// -------------------------------------------------------------------

class Schema final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.Schema) */ {
 public:
  Schema();
  virtual ~Schema();

  Schema(const Schema& from);

  inline Schema& operator=(const Schema& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Schema(Schema&& from) noexcept
    : Schema() {
    *this = ::std::move(from);
  }

  inline Schema& operator=(Schema&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Schema& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Schema* internal_default_instance() {
    return reinterpret_cast<const Schema*>(
               &_Schema_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Schema* other);
  friend void swap(Schema& a, Schema& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Schema* New() const final {
    return CreateMaybeMessage<Schema>(nullptr);
  }

  Schema* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Schema>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Schema& from);
  void MergeFrom(const Schema& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Schema* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string uri = 1;
  void clear_uri();
  static const int kUriFieldNumber = 1;
  const ::std::string& uri() const;
  void set_uri(const ::std::string& value);
  #if LANG_CXX11
  void set_uri(::std::string&& value);
  #endif
  void set_uri(const char* value);
  void set_uri(const char* value, size_t size);
  ::std::string* mutable_uri();
  ::std::string* release_uri();
  void set_allocated_uri(::std::string* uri);

  // .flyteidl.core.SchemaType type = 3;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  const ::flyteidl::core::SchemaType& type() const;
  ::flyteidl::core::SchemaType* release_type();
  ::flyteidl::core::SchemaType* mutable_type();
  void set_allocated_type(::flyteidl::core::SchemaType* type);

  // @@protoc_insertion_point(class_scope:flyteidl.core.Schema)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr uri_;
  ::flyteidl::core::SchemaType* type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2fliterals_2eproto;
};
// -------------------------------------------------------------------

class Scalar final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.Scalar) */ {
 public:
  Scalar();
  virtual ~Scalar();

  Scalar(const Scalar& from);

  inline Scalar& operator=(const Scalar& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Scalar(Scalar&& from) noexcept
    : Scalar() {
    *this = ::std::move(from);
  }

  inline Scalar& operator=(Scalar&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Scalar& default_instance();

  enum ValueCase {
    kPrimitive = 1,
    kBlob = 2,
    kBinary = 3,
    kSchema = 4,
    kNoneType = 5,
    kError = 6,
    kGeneric = 7,
    VALUE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Scalar* internal_default_instance() {
    return reinterpret_cast<const Scalar*>(
               &_Scalar_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Scalar* other);
  friend void swap(Scalar& a, Scalar& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Scalar* New() const final {
    return CreateMaybeMessage<Scalar>(nullptr);
  }

  Scalar* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Scalar>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Scalar& from);
  void MergeFrom(const Scalar& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Scalar* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .flyteidl.core.Primitive primitive = 1;
  bool has_primitive() const;
  void clear_primitive();
  static const int kPrimitiveFieldNumber = 1;
  const ::flyteidl::core::Primitive& primitive() const;
  ::flyteidl::core::Primitive* release_primitive();
  ::flyteidl::core::Primitive* mutable_primitive();
  void set_allocated_primitive(::flyteidl::core::Primitive* primitive);

  // .flyteidl.core.Blob blob = 2;
  bool has_blob() const;
  void clear_blob();
  static const int kBlobFieldNumber = 2;
  const ::flyteidl::core::Blob& blob() const;
  ::flyteidl::core::Blob* release_blob();
  ::flyteidl::core::Blob* mutable_blob();
  void set_allocated_blob(::flyteidl::core::Blob* blob);

  // .flyteidl.core.Binary binary = 3;
  bool has_binary() const;
  void clear_binary();
  static const int kBinaryFieldNumber = 3;
  const ::flyteidl::core::Binary& binary() const;
  ::flyteidl::core::Binary* release_binary();
  ::flyteidl::core::Binary* mutable_binary();
  void set_allocated_binary(::flyteidl::core::Binary* binary);

  // .flyteidl.core.Schema schema = 4;
  bool has_schema() const;
  void clear_schema();
  static const int kSchemaFieldNumber = 4;
  const ::flyteidl::core::Schema& schema() const;
  ::flyteidl::core::Schema* release_schema();
  ::flyteidl::core::Schema* mutable_schema();
  void set_allocated_schema(::flyteidl::core::Schema* schema);

  // .flyteidl.core.Void none_type = 5;
  bool has_none_type() const;
  void clear_none_type();
  static const int kNoneTypeFieldNumber = 5;
  const ::flyteidl::core::Void& none_type() const;
  ::flyteidl::core::Void* release_none_type();
  ::flyteidl::core::Void* mutable_none_type();
  void set_allocated_none_type(::flyteidl::core::Void* none_type);

  // .flyteidl.core.Error error = 6;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 6;
  const ::flyteidl::core::Error& error() const;
  ::flyteidl::core::Error* release_error();
  ::flyteidl::core::Error* mutable_error();
  void set_allocated_error(::flyteidl::core::Error* error);

  // .google.protobuf.Struct generic = 7;
  bool has_generic() const;
  void clear_generic();
  static const int kGenericFieldNumber = 7;
  const ::google::protobuf::Struct& generic() const;
  ::google::protobuf::Struct* release_generic();
  ::google::protobuf::Struct* mutable_generic();
  void set_allocated_generic(::google::protobuf::Struct* generic);

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:flyteidl.core.Scalar)
 private:
  class HasBitSetters;
  void set_has_primitive();
  void set_has_blob();
  void set_has_binary();
  void set_has_schema();
  void set_has_none_type();
  void set_has_error();
  void set_has_generic();

  inline bool has_value() const;
  inline void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union ValueUnion {
    ValueUnion() {}
    ::flyteidl::core::Primitive* primitive_;
    ::flyteidl::core::Blob* blob_;
    ::flyteidl::core::Binary* binary_;
    ::flyteidl::core::Schema* schema_;
    ::flyteidl::core::Void* none_type_;
    ::flyteidl::core::Error* error_;
    ::google::protobuf::Struct* generic_;
  } value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_flyteidl_2fcore_2fliterals_2eproto;
};
// -------------------------------------------------------------------

class Literal final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.Literal) */ {
 public:
  Literal();
  virtual ~Literal();

  Literal(const Literal& from);

  inline Literal& operator=(const Literal& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Literal(Literal&& from) noexcept
    : Literal() {
    *this = ::std::move(from);
  }

  inline Literal& operator=(Literal&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Literal& default_instance();

  enum ValueCase {
    kScalar = 1,
    kCollection = 2,
    kMap = 3,
    kInt32Vector = 4,
    kIntVector = 5,
    kFloatVector = 6,
    kDoubleVector = 7,
    kBoolVector = 8,
    kStrVector = 9,
    VALUE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Literal* internal_default_instance() {
    return reinterpret_cast<const Literal*>(
               &_Literal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(Literal* other);
  friend void swap(Literal& a, Literal& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Literal* New() const final {
    return CreateMaybeMessage<Literal>(nullptr);
  }

  Literal* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Literal>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Literal& from);
  void MergeFrom(const Literal& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Literal* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .flyteidl.core.Scalar scalar = 1;
  bool has_scalar() const;
  void clear_scalar();
  static const int kScalarFieldNumber = 1;
  const ::flyteidl::core::Scalar& scalar() const;
  ::flyteidl::core::Scalar* release_scalar();
  ::flyteidl::core::Scalar* mutable_scalar();
  void set_allocated_scalar(::flyteidl::core::Scalar* scalar);

  // .flyteidl.core.LiteralCollection collection = 2;
  bool has_collection() const;
  void clear_collection();
  static const int kCollectionFieldNumber = 2;
  const ::flyteidl::core::LiteralCollection& collection() const;
  ::flyteidl::core::LiteralCollection* release_collection();
  ::flyteidl::core::LiteralCollection* mutable_collection();
  void set_allocated_collection(::flyteidl::core::LiteralCollection* collection);

  // .flyteidl.core.LiteralMap map = 3;
  bool has_map() const;
  void clear_map();
  static const int kMapFieldNumber = 3;
  const ::flyteidl::core::LiteralMap& map() const;
  ::flyteidl::core::LiteralMap* release_map();
  ::flyteidl::core::LiteralMap* mutable_map();
  void set_allocated_map(::flyteidl::core::LiteralMap* map);

  // .flyteidl.core.Int32Vector int32_vector = 4;
  bool has_int32_vector() const;
  void clear_int32_vector();
  static const int kInt32VectorFieldNumber = 4;
  const ::flyteidl::core::Int32Vector& int32_vector() const;
  ::flyteidl::core::Int32Vector* release_int32_vector();
  ::flyteidl::core::Int32Vector* mutable_int32_vector();
  void set_allocated_int32_vector(::flyteidl::core::Int32Vector* int32_vector);

  // .flyteidl.core.Int64Vector int_vector = 5;
  bool has_int_vector() const;
  void clear_int_vector();
  static const int kIntVectorFieldNumber = 5;
  const ::flyteidl::core::Int64Vector& int_vector() const;
  ::flyteidl::core::Int64Vector* release_int_vector();
  ::flyteidl::core::Int64Vector* mutable_int_vector();
  void set_allocated_int_vector(::flyteidl::core::Int64Vector* int_vector);

  // .flyteidl.core.FloatVector float_vector = 6;
  bool has_float_vector() const;
  void clear_float_vector();
  static const int kFloatVectorFieldNumber = 6;
  const ::flyteidl::core::FloatVector& float_vector() const;
  ::flyteidl::core::FloatVector* release_float_vector();
  ::flyteidl::core::FloatVector* mutable_float_vector();
  void set_allocated_float_vector(::flyteidl::core::FloatVector* float_vector);

  // .flyteidl.core.DoubleVector double_vector = 7;
  bool has_double_vector() const;
  void clear_double_vector();
  static const int kDoubleVectorFieldNumber = 7;
  const ::flyteidl::core::DoubleVector& double_vector() const;
  ::flyteidl::core::DoubleVector* release_double_vector();
  ::flyteidl::core::DoubleVector* mutable_double_vector();
  void set_allocated_double_vector(::flyteidl::core::DoubleVector* double_vector);

  // .flyteidl.core.BoolVector bool_vector = 8;
  bool has_bool_vector() const;
  void clear_bool_vector();
  static const int kBoolVectorFieldNumber = 8;
  const ::flyteidl::core::BoolVector& bool_vector() const;
  ::flyteidl::core::BoolVector* release_bool_vector();
  ::flyteidl::core::BoolVector* mutable_bool_vector();
  void set_allocated_bool_vector(::flyteidl::core::BoolVector* bool_vector);

  // .flyteidl.core.StringVector str_vector = 9;
  bool has_str_vector() const;
  void clear_str_vector();
  static const int kStrVectorFieldNumber = 9;
  const ::flyteidl::core::StringVector& str_vector() const;
  ::flyteidl::core::StringVector* release_str_vector();
  ::flyteidl::core::StringVector* mutable_str_vector();
  void set_allocated_str_vector(::flyteidl::core::StringVector* str_vector);

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:flyteidl.core.Literal)
 private:
  class HasBitSetters;
  void set_has_scalar();
  void set_has_collection();
  void set_has_map();
  void set_has_int32_vector();
  void set_has_int_vector();
  void set_has_float_vector();
  void set_has_double_vector();
  void set_has_bool_vector();
  void set_has_str_vector();

  inline bool has_value() const;
  inline void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union ValueUnion {
    ValueUnion() {}
    ::flyteidl::core::Scalar* scalar_;
    ::flyteidl::core::LiteralCollection* collection_;
    ::flyteidl::core::LiteralMap* map_;
    ::flyteidl::core::Int32Vector* int32_vector_;
    ::flyteidl::core::Int64Vector* int_vector_;
    ::flyteidl::core::FloatVector* float_vector_;
    ::flyteidl::core::DoubleVector* double_vector_;
    ::flyteidl::core::BoolVector* bool_vector_;
    ::flyteidl::core::StringVector* str_vector_;
  } value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_flyteidl_2fcore_2fliterals_2eproto;
};
// -------------------------------------------------------------------

class Offloaded final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.Offloaded) */ {
 public:
  Offloaded();
  virtual ~Offloaded();

  Offloaded(const Offloaded& from);

  inline Offloaded& operator=(const Offloaded& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Offloaded(Offloaded&& from) noexcept
    : Offloaded() {
    *this = ::std::move(from);
  }

  inline Offloaded& operator=(Offloaded&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Offloaded& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Offloaded* internal_default_instance() {
    return reinterpret_cast<const Offloaded*>(
               &_Offloaded_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(Offloaded* other);
  friend void swap(Offloaded& a, Offloaded& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Offloaded* New() const final {
    return CreateMaybeMessage<Offloaded>(nullptr);
  }

  Offloaded* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Offloaded>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Offloaded& from);
  void MergeFrom(const Offloaded& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Offloaded* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string uri = 1;
  void clear_uri();
  static const int kUriFieldNumber = 1;
  const ::std::string& uri() const;
  void set_uri(const ::std::string& value);
  #if LANG_CXX11
  void set_uri(::std::string&& value);
  #endif
  void set_uri(const char* value);
  void set_uri(const char* value, size_t size);
  ::std::string* mutable_uri();
  ::std::string* release_uri();
  void set_allocated_uri(::std::string* uri);

  // string format = 2;
  void clear_format();
  static const int kFormatFieldNumber = 2;
  const ::std::string& format() const;
  void set_format(const ::std::string& value);
  #if LANG_CXX11
  void set_format(::std::string&& value);
  #endif
  void set_format(const char* value);
  void set_format(const char* value, size_t size);
  ::std::string* mutable_format();
  ::std::string* release_format();
  void set_allocated_format(::std::string* format);

  // @@protoc_insertion_point(class_scope:flyteidl.core.Offloaded)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr uri_;
  ::google::protobuf::internal::ArenaStringPtr format_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2fliterals_2eproto;
};
// -------------------------------------------------------------------

class StringVector final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.StringVector) */ {
 public:
  StringVector();
  virtual ~StringVector();

  StringVector(const StringVector& from);

  inline StringVector& operator=(const StringVector& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StringVector(StringVector&& from) noexcept
    : StringVector() {
    *this = ::std::move(from);
  }

  inline StringVector& operator=(StringVector&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const StringVector& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StringVector* internal_default_instance() {
    return reinterpret_cast<const StringVector*>(
               &_StringVector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(StringVector* other);
  friend void swap(StringVector& a, StringVector& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StringVector* New() const final {
    return CreateMaybeMessage<StringVector>(nullptr);
  }

  StringVector* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StringVector>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StringVector& from);
  void MergeFrom(const StringVector& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StringVector* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string values = 1;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 1;
  const ::std::string& values(int index) const;
  ::std::string* mutable_values(int index);
  void set_values(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_values(int index, ::std::string&& value);
  #endif
  void set_values(int index, const char* value);
  void set_values(int index, const char* value, size_t size);
  ::std::string* add_values();
  void add_values(const ::std::string& value);
  #if LANG_CXX11
  void add_values(::std::string&& value);
  #endif
  void add_values(const char* value);
  void add_values(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& values() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_values();

  // .flyteidl.core.Offloaded offloaded = 2;
  bool has_offloaded() const;
  void clear_offloaded();
  static const int kOffloadedFieldNumber = 2;
  const ::flyteidl::core::Offloaded& offloaded() const;
  ::flyteidl::core::Offloaded* release_offloaded();
  ::flyteidl::core::Offloaded* mutable_offloaded();
  void set_allocated_offloaded(::flyteidl::core::Offloaded* offloaded);

  // @@protoc_insertion_point(class_scope:flyteidl.core.StringVector)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField<::std::string> values_;
  ::flyteidl::core::Offloaded* offloaded_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2fliterals_2eproto;
};
// -------------------------------------------------------------------

class Int32Vector final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.Int32Vector) */ {
 public:
  Int32Vector();
  virtual ~Int32Vector();

  Int32Vector(const Int32Vector& from);

  inline Int32Vector& operator=(const Int32Vector& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Int32Vector(Int32Vector&& from) noexcept
    : Int32Vector() {
    *this = ::std::move(from);
  }

  inline Int32Vector& operator=(Int32Vector&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Int32Vector& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Int32Vector* internal_default_instance() {
    return reinterpret_cast<const Int32Vector*>(
               &_Int32Vector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(Int32Vector* other);
  friend void swap(Int32Vector& a, Int32Vector& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Int32Vector* New() const final {
    return CreateMaybeMessage<Int32Vector>(nullptr);
  }

  Int32Vector* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Int32Vector>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Int32Vector& from);
  void MergeFrom(const Int32Vector& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Int32Vector* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 values = 1;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 1;
  ::google::protobuf::int32 values(int index) const;
  void set_values(int index, ::google::protobuf::int32 value);
  void add_values(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      values() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_values();

  // .flyteidl.core.Offloaded offloaded = 2;
  bool has_offloaded() const;
  void clear_offloaded();
  static const int kOffloadedFieldNumber = 2;
  const ::flyteidl::core::Offloaded& offloaded() const;
  ::flyteidl::core::Offloaded* release_offloaded();
  ::flyteidl::core::Offloaded* mutable_offloaded();
  void set_allocated_offloaded(::flyteidl::core::Offloaded* offloaded);

  // @@protoc_insertion_point(class_scope:flyteidl.core.Int32Vector)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > values_;
  mutable std::atomic<int> _values_cached_byte_size_;
  ::flyteidl::core::Offloaded* offloaded_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2fliterals_2eproto;
};
// -------------------------------------------------------------------

class Int64Vector final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.Int64Vector) */ {
 public:
  Int64Vector();
  virtual ~Int64Vector();

  Int64Vector(const Int64Vector& from);

  inline Int64Vector& operator=(const Int64Vector& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Int64Vector(Int64Vector&& from) noexcept
    : Int64Vector() {
    *this = ::std::move(from);
  }

  inline Int64Vector& operator=(Int64Vector&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Int64Vector& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Int64Vector* internal_default_instance() {
    return reinterpret_cast<const Int64Vector*>(
               &_Int64Vector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(Int64Vector* other);
  friend void swap(Int64Vector& a, Int64Vector& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Int64Vector* New() const final {
    return CreateMaybeMessage<Int64Vector>(nullptr);
  }

  Int64Vector* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Int64Vector>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Int64Vector& from);
  void MergeFrom(const Int64Vector& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Int64Vector* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int64 values = 1;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 1;
  ::google::protobuf::int64 values(int index) const;
  void set_values(int index, ::google::protobuf::int64 value);
  void add_values(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      values() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_values();

  // .flyteidl.core.Offloaded offloaded = 2;
  bool has_offloaded() const;
  void clear_offloaded();
  static const int kOffloadedFieldNumber = 2;
  const ::flyteidl::core::Offloaded& offloaded() const;
  ::flyteidl::core::Offloaded* release_offloaded();
  ::flyteidl::core::Offloaded* mutable_offloaded();
  void set_allocated_offloaded(::flyteidl::core::Offloaded* offloaded);

  // @@protoc_insertion_point(class_scope:flyteidl.core.Int64Vector)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > values_;
  mutable std::atomic<int> _values_cached_byte_size_;
  ::flyteidl::core::Offloaded* offloaded_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2fliterals_2eproto;
};
// -------------------------------------------------------------------

class FloatVector final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.FloatVector) */ {
 public:
  FloatVector();
  virtual ~FloatVector();

  FloatVector(const FloatVector& from);

  inline FloatVector& operator=(const FloatVector& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FloatVector(FloatVector&& from) noexcept
    : FloatVector() {
    *this = ::std::move(from);
  }

  inline FloatVector& operator=(FloatVector&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const FloatVector& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FloatVector* internal_default_instance() {
    return reinterpret_cast<const FloatVector*>(
               &_FloatVector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(FloatVector* other);
  friend void swap(FloatVector& a, FloatVector& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FloatVector* New() const final {
    return CreateMaybeMessage<FloatVector>(nullptr);
  }

  FloatVector* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FloatVector>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FloatVector& from);
  void MergeFrom(const FloatVector& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FloatVector* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float values = 1;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 1;
  float values(int index) const;
  void set_values(int index, float value);
  void add_values(float value);
  const ::google::protobuf::RepeatedField< float >&
      values() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_values();

  // .flyteidl.core.Offloaded offloaded = 2;
  bool has_offloaded() const;
  void clear_offloaded();
  static const int kOffloadedFieldNumber = 2;
  const ::flyteidl::core::Offloaded& offloaded() const;
  ::flyteidl::core::Offloaded* release_offloaded();
  ::flyteidl::core::Offloaded* mutable_offloaded();
  void set_allocated_offloaded(::flyteidl::core::Offloaded* offloaded);

  // @@protoc_insertion_point(class_scope:flyteidl.core.FloatVector)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< float > values_;
  mutable std::atomic<int> _values_cached_byte_size_;
  ::flyteidl::core::Offloaded* offloaded_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2fliterals_2eproto;
};
// -------------------------------------------------------------------

class DoubleVector final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.DoubleVector) */ {
 public:
  DoubleVector();
  virtual ~DoubleVector();

  DoubleVector(const DoubleVector& from);

  inline DoubleVector& operator=(const DoubleVector& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DoubleVector(DoubleVector&& from) noexcept
    : DoubleVector() {
    *this = ::std::move(from);
  }

  inline DoubleVector& operator=(DoubleVector&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const DoubleVector& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DoubleVector* internal_default_instance() {
    return reinterpret_cast<const DoubleVector*>(
               &_DoubleVector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(DoubleVector* other);
  friend void swap(DoubleVector& a, DoubleVector& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DoubleVector* New() const final {
    return CreateMaybeMessage<DoubleVector>(nullptr);
  }

  DoubleVector* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DoubleVector>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DoubleVector& from);
  void MergeFrom(const DoubleVector& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DoubleVector* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double values = 1;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 1;
  double values(int index) const;
  void set_values(int index, double value);
  void add_values(double value);
  const ::google::protobuf::RepeatedField< double >&
      values() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_values();

  // .flyteidl.core.Offloaded offloaded = 2;
  bool has_offloaded() const;
  void clear_offloaded();
  static const int kOffloadedFieldNumber = 2;
  const ::flyteidl::core::Offloaded& offloaded() const;
  ::flyteidl::core::Offloaded* release_offloaded();
  ::flyteidl::core::Offloaded* mutable_offloaded();
  void set_allocated_offloaded(::flyteidl::core::Offloaded* offloaded);

  // @@protoc_insertion_point(class_scope:flyteidl.core.DoubleVector)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< double > values_;
  mutable std::atomic<int> _values_cached_byte_size_;
  ::flyteidl::core::Offloaded* offloaded_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2fliterals_2eproto;
};
// -------------------------------------------------------------------

class BoolVector final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.BoolVector) */ {
 public:
  BoolVector();
  virtual ~BoolVector();

  BoolVector(const BoolVector& from);

  inline BoolVector& operator=(const BoolVector& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BoolVector(BoolVector&& from) noexcept
    : BoolVector() {
    *this = ::std::move(from);
  }

  inline BoolVector& operator=(BoolVector&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const BoolVector& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BoolVector* internal_default_instance() {
    return reinterpret_cast<const BoolVector*>(
               &_BoolVector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(BoolVector* other);
  friend void swap(BoolVector& a, BoolVector& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BoolVector* New() const final {
    return CreateMaybeMessage<BoolVector>(nullptr);
  }

  BoolVector* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BoolVector>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BoolVector& from);
  void MergeFrom(const BoolVector& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BoolVector* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bool values = 1;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 1;
  bool values(int index) const;
  void set_values(int index, bool value);
  void add_values(bool value);
  const ::google::protobuf::RepeatedField< bool >&
      values() const;
  ::google::protobuf::RepeatedField< bool >*
      mutable_values();

  // .flyteidl.core.Offloaded offloaded = 2;
  bool has_offloaded() const;
  void clear_offloaded();
  static const int kOffloadedFieldNumber = 2;
  const ::flyteidl::core::Offloaded& offloaded() const;
  ::flyteidl::core::Offloaded* release_offloaded();
  ::flyteidl::core::Offloaded* mutable_offloaded();
  void set_allocated_offloaded(::flyteidl::core::Offloaded* offloaded);

  // @@protoc_insertion_point(class_scope:flyteidl.core.BoolVector)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< bool > values_;
  mutable std::atomic<int> _values_cached_byte_size_;
  ::flyteidl::core::Offloaded* offloaded_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2fliterals_2eproto;
};
// -------------------------------------------------------------------

class LiteralCollection final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.LiteralCollection) */ {
 public:
  LiteralCollection();
  virtual ~LiteralCollection();

  LiteralCollection(const LiteralCollection& from);

  inline LiteralCollection& operator=(const LiteralCollection& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LiteralCollection(LiteralCollection&& from) noexcept
    : LiteralCollection() {
    *this = ::std::move(from);
  }

  inline LiteralCollection& operator=(LiteralCollection&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const LiteralCollection& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LiteralCollection* internal_default_instance() {
    return reinterpret_cast<const LiteralCollection*>(
               &_LiteralCollection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(LiteralCollection* other);
  friend void swap(LiteralCollection& a, LiteralCollection& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LiteralCollection* New() const final {
    return CreateMaybeMessage<LiteralCollection>(nullptr);
  }

  LiteralCollection* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LiteralCollection>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LiteralCollection& from);
  void MergeFrom(const LiteralCollection& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LiteralCollection* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .flyteidl.core.Literal literals = 1;
  int literals_size() const;
  void clear_literals();
  static const int kLiteralsFieldNumber = 1;
  ::flyteidl::core::Literal* mutable_literals(int index);
  ::google::protobuf::RepeatedPtrField< ::flyteidl::core::Literal >*
      mutable_literals();
  const ::flyteidl::core::Literal& literals(int index) const;
  ::flyteidl::core::Literal* add_literals();
  const ::google::protobuf::RepeatedPtrField< ::flyteidl::core::Literal >&
      literals() const;

  // @@protoc_insertion_point(class_scope:flyteidl.core.LiteralCollection)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::flyteidl::core::Literal > literals_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2fliterals_2eproto;
};
// -------------------------------------------------------------------

class LiteralMap_LiteralsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<LiteralMap_LiteralsEntry_DoNotUse, 
    ::std::string, ::flyteidl::core::Literal,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
static bool _ParseMap(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  typedef ::google::protobuf::internal::MapEntry<LiteralMap_LiteralsEntry_DoNotUse, 
    ::std::string, ::flyteidl::core::Literal,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  LiteralMap_LiteralsEntry_DoNotUse();
  LiteralMap_LiteralsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const LiteralMap_LiteralsEntry_DoNotUse& other);
  static const LiteralMap_LiteralsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const LiteralMap_LiteralsEntry_DoNotUse*>(&_LiteralMap_LiteralsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class LiteralMap final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.LiteralMap) */ {
 public:
  LiteralMap();
  virtual ~LiteralMap();

  LiteralMap(const LiteralMap& from);

  inline LiteralMap& operator=(const LiteralMap& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LiteralMap(LiteralMap&& from) noexcept
    : LiteralMap() {
    *this = ::std::move(from);
  }

  inline LiteralMap& operator=(LiteralMap&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const LiteralMap& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LiteralMap* internal_default_instance() {
    return reinterpret_cast<const LiteralMap*>(
               &_LiteralMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(LiteralMap* other);
  friend void swap(LiteralMap& a, LiteralMap& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LiteralMap* New() const final {
    return CreateMaybeMessage<LiteralMap>(nullptr);
  }

  LiteralMap* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LiteralMap>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LiteralMap& from);
  void MergeFrom(const LiteralMap& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LiteralMap* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, .flyteidl.core.Literal> literals = 1;
  int literals_size() const;
  void clear_literals();
  static const int kLiteralsFieldNumber = 1;
  const ::google::protobuf::Map< ::std::string, ::flyteidl::core::Literal >&
      literals() const;
  ::google::protobuf::Map< ::std::string, ::flyteidl::core::Literal >*
      mutable_literals();

  // @@protoc_insertion_point(class_scope:flyteidl.core.LiteralMap)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      LiteralMap_LiteralsEntry_DoNotUse,
      ::std::string, ::flyteidl::core::Literal,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > literals_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2fliterals_2eproto;
};
// -------------------------------------------------------------------

class BindingDataCollection final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.BindingDataCollection) */ {
 public:
  BindingDataCollection();
  virtual ~BindingDataCollection();

  BindingDataCollection(const BindingDataCollection& from);

  inline BindingDataCollection& operator=(const BindingDataCollection& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BindingDataCollection(BindingDataCollection&& from) noexcept
    : BindingDataCollection() {
    *this = ::std::move(from);
  }

  inline BindingDataCollection& operator=(BindingDataCollection&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const BindingDataCollection& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BindingDataCollection* internal_default_instance() {
    return reinterpret_cast<const BindingDataCollection*>(
               &_BindingDataCollection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(BindingDataCollection* other);
  friend void swap(BindingDataCollection& a, BindingDataCollection& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BindingDataCollection* New() const final {
    return CreateMaybeMessage<BindingDataCollection>(nullptr);
  }

  BindingDataCollection* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BindingDataCollection>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BindingDataCollection& from);
  void MergeFrom(const BindingDataCollection& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BindingDataCollection* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .flyteidl.core.BindingData bindings = 1;
  int bindings_size() const;
  void clear_bindings();
  static const int kBindingsFieldNumber = 1;
  ::flyteidl::core::BindingData* mutable_bindings(int index);
  ::google::protobuf::RepeatedPtrField< ::flyteidl::core::BindingData >*
      mutable_bindings();
  const ::flyteidl::core::BindingData& bindings(int index) const;
  ::flyteidl::core::BindingData* add_bindings();
  const ::google::protobuf::RepeatedPtrField< ::flyteidl::core::BindingData >&
      bindings() const;

  // @@protoc_insertion_point(class_scope:flyteidl.core.BindingDataCollection)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::flyteidl::core::BindingData > bindings_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2fliterals_2eproto;
};
// -------------------------------------------------------------------

class BindingDataMap_BindingsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<BindingDataMap_BindingsEntry_DoNotUse, 
    ::std::string, ::flyteidl::core::BindingData,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
static bool _ParseMap(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  typedef ::google::protobuf::internal::MapEntry<BindingDataMap_BindingsEntry_DoNotUse, 
    ::std::string, ::flyteidl::core::BindingData,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  BindingDataMap_BindingsEntry_DoNotUse();
  BindingDataMap_BindingsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const BindingDataMap_BindingsEntry_DoNotUse& other);
  static const BindingDataMap_BindingsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const BindingDataMap_BindingsEntry_DoNotUse*>(&_BindingDataMap_BindingsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class BindingDataMap final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.BindingDataMap) */ {
 public:
  BindingDataMap();
  virtual ~BindingDataMap();

  BindingDataMap(const BindingDataMap& from);

  inline BindingDataMap& operator=(const BindingDataMap& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BindingDataMap(BindingDataMap&& from) noexcept
    : BindingDataMap() {
    *this = ::std::move(from);
  }

  inline BindingDataMap& operator=(BindingDataMap&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const BindingDataMap& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BindingDataMap* internal_default_instance() {
    return reinterpret_cast<const BindingDataMap*>(
               &_BindingDataMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(BindingDataMap* other);
  friend void swap(BindingDataMap& a, BindingDataMap& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BindingDataMap* New() const final {
    return CreateMaybeMessage<BindingDataMap>(nullptr);
  }

  BindingDataMap* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BindingDataMap>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BindingDataMap& from);
  void MergeFrom(const BindingDataMap& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BindingDataMap* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, .flyteidl.core.BindingData> bindings = 1;
  int bindings_size() const;
  void clear_bindings();
  static const int kBindingsFieldNumber = 1;
  const ::google::protobuf::Map< ::std::string, ::flyteidl::core::BindingData >&
      bindings() const;
  ::google::protobuf::Map< ::std::string, ::flyteidl::core::BindingData >*
      mutable_bindings();

  // @@protoc_insertion_point(class_scope:flyteidl.core.BindingDataMap)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      BindingDataMap_BindingsEntry_DoNotUse,
      ::std::string, ::flyteidl::core::BindingData,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > bindings_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2fliterals_2eproto;
};
// -------------------------------------------------------------------

class BindingData final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.BindingData) */ {
 public:
  BindingData();
  virtual ~BindingData();

  BindingData(const BindingData& from);

  inline BindingData& operator=(const BindingData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BindingData(BindingData&& from) noexcept
    : BindingData() {
    *this = ::std::move(from);
  }

  inline BindingData& operator=(BindingData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const BindingData& default_instance();

  enum ValueCase {
    kScalar = 1,
    kCollection = 2,
    kPromise = 3,
    kMap = 4,
    VALUE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BindingData* internal_default_instance() {
    return reinterpret_cast<const BindingData*>(
               &_BindingData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(BindingData* other);
  friend void swap(BindingData& a, BindingData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BindingData* New() const final {
    return CreateMaybeMessage<BindingData>(nullptr);
  }

  BindingData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BindingData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BindingData& from);
  void MergeFrom(const BindingData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BindingData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .flyteidl.core.Scalar scalar = 1;
  bool has_scalar() const;
  void clear_scalar();
  static const int kScalarFieldNumber = 1;
  const ::flyteidl::core::Scalar& scalar() const;
  ::flyteidl::core::Scalar* release_scalar();
  ::flyteidl::core::Scalar* mutable_scalar();
  void set_allocated_scalar(::flyteidl::core::Scalar* scalar);

  // .flyteidl.core.BindingDataCollection collection = 2;
  bool has_collection() const;
  void clear_collection();
  static const int kCollectionFieldNumber = 2;
  const ::flyteidl::core::BindingDataCollection& collection() const;
  ::flyteidl::core::BindingDataCollection* release_collection();
  ::flyteidl::core::BindingDataCollection* mutable_collection();
  void set_allocated_collection(::flyteidl::core::BindingDataCollection* collection);

  // .flyteidl.core.OutputReference promise = 3;
  bool has_promise() const;
  void clear_promise();
  static const int kPromiseFieldNumber = 3;
  const ::flyteidl::core::OutputReference& promise() const;
  ::flyteidl::core::OutputReference* release_promise();
  ::flyteidl::core::OutputReference* mutable_promise();
  void set_allocated_promise(::flyteidl::core::OutputReference* promise);

  // .flyteidl.core.BindingDataMap map = 4;
  bool has_map() const;
  void clear_map();
  static const int kMapFieldNumber = 4;
  const ::flyteidl::core::BindingDataMap& map() const;
  ::flyteidl::core::BindingDataMap* release_map();
  ::flyteidl::core::BindingDataMap* mutable_map();
  void set_allocated_map(::flyteidl::core::BindingDataMap* map);

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:flyteidl.core.BindingData)
 private:
  class HasBitSetters;
  void set_has_scalar();
  void set_has_collection();
  void set_has_promise();
  void set_has_map();

  inline bool has_value() const;
  inline void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union ValueUnion {
    ValueUnion() {}
    ::flyteidl::core::Scalar* scalar_;
    ::flyteidl::core::BindingDataCollection* collection_;
    ::flyteidl::core::OutputReference* promise_;
    ::flyteidl::core::BindingDataMap* map_;
  } value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_flyteidl_2fcore_2fliterals_2eproto;
};
// -------------------------------------------------------------------

class Binding final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.Binding) */ {
 public:
  Binding();
  virtual ~Binding();

  Binding(const Binding& from);

  inline Binding& operator=(const Binding& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Binding(Binding&& from) noexcept
    : Binding() {
    *this = ::std::move(from);
  }

  inline Binding& operator=(Binding&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Binding& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Binding* internal_default_instance() {
    return reinterpret_cast<const Binding*>(
               &_Binding_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(Binding* other);
  friend void swap(Binding& a, Binding& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Binding* New() const final {
    return CreateMaybeMessage<Binding>(nullptr);
  }

  Binding* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Binding>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Binding& from);
  void MergeFrom(const Binding& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Binding* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string var = 1;
  void clear_var();
  static const int kVarFieldNumber = 1;
  const ::std::string& var() const;
  void set_var(const ::std::string& value);
  #if LANG_CXX11
  void set_var(::std::string&& value);
  #endif
  void set_var(const char* value);
  void set_var(const char* value, size_t size);
  ::std::string* mutable_var();
  ::std::string* release_var();
  void set_allocated_var(::std::string* var);

  // .flyteidl.core.BindingData binding = 2;
  bool has_binding() const;
  void clear_binding();
  static const int kBindingFieldNumber = 2;
  const ::flyteidl::core::BindingData& binding() const;
  ::flyteidl::core::BindingData* release_binding();
  ::flyteidl::core::BindingData* mutable_binding();
  void set_allocated_binding(::flyteidl::core::BindingData* binding);

  // @@protoc_insertion_point(class_scope:flyteidl.core.Binding)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr var_;
  ::flyteidl::core::BindingData* binding_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2fliterals_2eproto;
};
// -------------------------------------------------------------------

class KeyValuePair final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.KeyValuePair) */ {
 public:
  KeyValuePair();
  virtual ~KeyValuePair();

  KeyValuePair(const KeyValuePair& from);

  inline KeyValuePair& operator=(const KeyValuePair& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KeyValuePair(KeyValuePair&& from) noexcept
    : KeyValuePair() {
    *this = ::std::move(from);
  }

  inline KeyValuePair& operator=(KeyValuePair&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const KeyValuePair& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KeyValuePair* internal_default_instance() {
    return reinterpret_cast<const KeyValuePair*>(
               &_KeyValuePair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(KeyValuePair* other);
  friend void swap(KeyValuePair& a, KeyValuePair& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KeyValuePair* New() const final {
    return CreateMaybeMessage<KeyValuePair>(nullptr);
  }

  KeyValuePair* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<KeyValuePair>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const KeyValuePair& from);
  void MergeFrom(const KeyValuePair& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyValuePair* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // string value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:flyteidl.core.KeyValuePair)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2fliterals_2eproto;
};
// -------------------------------------------------------------------

class RetryStrategy final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.RetryStrategy) */ {
 public:
  RetryStrategy();
  virtual ~RetryStrategy();

  RetryStrategy(const RetryStrategy& from);

  inline RetryStrategy& operator=(const RetryStrategy& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RetryStrategy(RetryStrategy&& from) noexcept
    : RetryStrategy() {
    *this = ::std::move(from);
  }

  inline RetryStrategy& operator=(RetryStrategy&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RetryStrategy& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RetryStrategy* internal_default_instance() {
    return reinterpret_cast<const RetryStrategy*>(
               &_RetryStrategy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(RetryStrategy* other);
  friend void swap(RetryStrategy& a, RetryStrategy& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RetryStrategy* New() const final {
    return CreateMaybeMessage<RetryStrategy>(nullptr);
  }

  RetryStrategy* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RetryStrategy>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RetryStrategy& from);
  void MergeFrom(const RetryStrategy& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RetryStrategy* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 retries = 5;
  void clear_retries();
  static const int kRetriesFieldNumber = 5;
  ::google::protobuf::uint32 retries() const;
  void set_retries(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:flyteidl.core.RetryStrategy)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 retries_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2fliterals_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Primitive

// int64 integer = 1;
inline bool Primitive::has_integer() const {
  return value_case() == kInteger;
}
inline void Primitive::set_has_integer() {
  _oneof_case_[0] = kInteger;
}
inline void Primitive::clear_integer() {
  if (has_integer()) {
    value_.integer_ = PROTOBUF_LONGLONG(0);
    clear_has_value();
  }
}
inline ::google::protobuf::int64 Primitive::integer() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Primitive.integer)
  if (has_integer()) {
    return value_.integer_;
  }
  return PROTOBUF_LONGLONG(0);
}
inline void Primitive::set_integer(::google::protobuf::int64 value) {
  if (!has_integer()) {
    clear_value();
    set_has_integer();
  }
  value_.integer_ = value;
  // @@protoc_insertion_point(field_set:flyteidl.core.Primitive.integer)
}

// double float_value = 2;
inline bool Primitive::has_float_value() const {
  return value_case() == kFloatValue;
}
inline void Primitive::set_has_float_value() {
  _oneof_case_[0] = kFloatValue;
}
inline void Primitive::clear_float_value() {
  if (has_float_value()) {
    value_.float_value_ = 0;
    clear_has_value();
  }
}
inline double Primitive::float_value() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Primitive.float_value)
  if (has_float_value()) {
    return value_.float_value_;
  }
  return 0;
}
inline void Primitive::set_float_value(double value) {
  if (!has_float_value()) {
    clear_value();
    set_has_float_value();
  }
  value_.float_value_ = value;
  // @@protoc_insertion_point(field_set:flyteidl.core.Primitive.float_value)
}

// string string_value = 3;
inline bool Primitive::has_string_value() const {
  return value_case() == kStringValue;
}
inline void Primitive::set_has_string_value() {
  _oneof_case_[0] = kStringValue;
}
inline void Primitive::clear_string_value() {
  if (has_string_value()) {
    value_.string_value_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_value();
  }
}
inline const ::std::string& Primitive::string_value() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Primitive.string_value)
  if (has_string_value()) {
    return value_.string_value_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void Primitive::set_string_value(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:flyteidl.core.Primitive.string_value)
  if (!has_string_value()) {
    clear_value();
    set_has_string_value();
    value_.string_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.string_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.Primitive.string_value)
}
#if LANG_CXX11
inline void Primitive::set_string_value(::std::string&& value) {
  // @@protoc_insertion_point(field_set:flyteidl.core.Primitive.string_value)
  if (!has_string_value()) {
    clear_value();
    set_has_string_value();
    value_.string_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.string_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.Primitive.string_value)
}
#endif
inline void Primitive::set_string_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!has_string_value()) {
    clear_value();
    set_has_string_value();
    value_.string_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.string_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.Primitive.string_value)
}
inline void Primitive::set_string_value(const char* value, size_t size) {
  if (!has_string_value()) {
    clear_value();
    set_has_string_value();
    value_.string_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.string_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.Primitive.string_value)
}
inline ::std::string* Primitive::mutable_string_value() {
  if (!has_string_value()) {
    clear_value();
    set_has_string_value();
    value_.string_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Primitive.string_value)
  return value_.string_value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Primitive::release_string_value() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Primitive.string_value)
  if (has_string_value()) {
    clear_has_value();
    return value_.string_value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return nullptr;
  }
}
inline void Primitive::set_allocated_string_value(::std::string* string_value) {
  if (has_value()) {
    clear_value();
  }
  if (string_value != nullptr) {
    set_has_string_value();
    value_.string_value_.UnsafeSetDefault(string_value);
  }
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.Primitive.string_value)
}

// bool boolean = 4;
inline bool Primitive::has_boolean() const {
  return value_case() == kBoolean;
}
inline void Primitive::set_has_boolean() {
  _oneof_case_[0] = kBoolean;
}
inline void Primitive::clear_boolean() {
  if (has_boolean()) {
    value_.boolean_ = false;
    clear_has_value();
  }
}
inline bool Primitive::boolean() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Primitive.boolean)
  if (has_boolean()) {
    return value_.boolean_;
  }
  return false;
}
inline void Primitive::set_boolean(bool value) {
  if (!has_boolean()) {
    clear_value();
    set_has_boolean();
  }
  value_.boolean_ = value;
  // @@protoc_insertion_point(field_set:flyteidl.core.Primitive.boolean)
}

// .google.protobuf.Timestamp datetime = 5;
inline bool Primitive::has_datetime() const {
  return value_case() == kDatetime;
}
inline void Primitive::set_has_datetime() {
  _oneof_case_[0] = kDatetime;
}
inline ::google::protobuf::Timestamp* Primitive::release_datetime() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Primitive.datetime)
  if (has_datetime()) {
    clear_has_value();
      ::google::protobuf::Timestamp* temp = value_.datetime_;
    value_.datetime_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::protobuf::Timestamp& Primitive::datetime() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Primitive.datetime)
  return has_datetime()
      ? *value_.datetime_
      : *reinterpret_cast< ::google::protobuf::Timestamp*>(&::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* Primitive::mutable_datetime() {
  if (!has_datetime()) {
    clear_value();
    set_has_datetime();
    value_.datetime_ = CreateMaybeMessage< ::google::protobuf::Timestamp >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Primitive.datetime)
  return value_.datetime_;
}

// .google.protobuf.Duration duration = 6;
inline bool Primitive::has_duration() const {
  return value_case() == kDuration;
}
inline void Primitive::set_has_duration() {
  _oneof_case_[0] = kDuration;
}
inline ::google::protobuf::Duration* Primitive::release_duration() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Primitive.duration)
  if (has_duration()) {
    clear_has_value();
      ::google::protobuf::Duration* temp = value_.duration_;
    value_.duration_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::protobuf::Duration& Primitive::duration() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Primitive.duration)
  return has_duration()
      ? *value_.duration_
      : *reinterpret_cast< ::google::protobuf::Duration*>(&::google::protobuf::_Duration_default_instance_);
}
inline ::google::protobuf::Duration* Primitive::mutable_duration() {
  if (!has_duration()) {
    clear_value();
    set_has_duration();
    value_.duration_ = CreateMaybeMessage< ::google::protobuf::Duration >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Primitive.duration)
  return value_.duration_;
}

inline bool Primitive::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void Primitive::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline Primitive::ValueCase Primitive::value_case() const {
  return Primitive::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Void

// -------------------------------------------------------------------

// Blob

// .flyteidl.core.BlobMetadata metadata = 1;
inline bool Blob::has_metadata() const {
  return this != internal_default_instance() && metadata_ != nullptr;
}
inline void Blob::clear_metadata() {
  if (GetArenaNoVirtual() == nullptr && metadata_ != nullptr) {
    delete metadata_;
  }
  metadata_ = nullptr;
}
inline const ::flyteidl::core::BlobMetadata& Blob::metadata() const {
  const ::flyteidl::core::BlobMetadata* p = metadata_;
  // @@protoc_insertion_point(field_get:flyteidl.core.Blob.metadata)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::BlobMetadata*>(
      &::flyteidl::core::_BlobMetadata_default_instance_);
}
inline ::flyteidl::core::BlobMetadata* Blob::release_metadata() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Blob.metadata)
  
  ::flyteidl::core::BlobMetadata* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::flyteidl::core::BlobMetadata* Blob::mutable_metadata() {
  
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::BlobMetadata>(GetArenaNoVirtual());
    metadata_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Blob.metadata)
  return metadata_;
}
inline void Blob::set_allocated_metadata(::flyteidl::core::BlobMetadata* metadata) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete metadata_;
  }
  if (metadata) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      metadata = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.Blob.metadata)
}

// string uri = 3;
inline void Blob::clear_uri() {
  uri_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Blob::uri() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Blob.uri)
  return uri_.GetNoArena();
}
inline void Blob::set_uri(const ::std::string& value) {
  
  uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.Blob.uri)
}
#if LANG_CXX11
inline void Blob::set_uri(::std::string&& value) {
  
  uri_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.Blob.uri)
}
#endif
inline void Blob::set_uri(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.Blob.uri)
}
inline void Blob::set_uri(const char* value, size_t size) {
  
  uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.Blob.uri)
}
inline ::std::string* Blob::mutable_uri() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Blob.uri)
  return uri_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Blob::release_uri() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Blob.uri)
  
  return uri_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Blob::set_allocated_uri(::std::string* uri) {
  if (uri != nullptr) {
    
  } else {
    
  }
  uri_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uri);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.Blob.uri)
}

// -------------------------------------------------------------------

// BlobMetadata

// .flyteidl.core.BlobType type = 1;
inline bool BlobMetadata::has_type() const {
  return this != internal_default_instance() && type_ != nullptr;
}
inline const ::flyteidl::core::BlobType& BlobMetadata::type() const {
  const ::flyteidl::core::BlobType* p = type_;
  // @@protoc_insertion_point(field_get:flyteidl.core.BlobMetadata.type)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::BlobType*>(
      &::flyteidl::core::_BlobType_default_instance_);
}
inline ::flyteidl::core::BlobType* BlobMetadata::release_type() {
  // @@protoc_insertion_point(field_release:flyteidl.core.BlobMetadata.type)
  
  ::flyteidl::core::BlobType* temp = type_;
  type_ = nullptr;
  return temp;
}
inline ::flyteidl::core::BlobType* BlobMetadata::mutable_type() {
  
  if (type_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::BlobType>(GetArenaNoVirtual());
    type_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.BlobMetadata.type)
  return type_;
}
inline void BlobMetadata::set_allocated_type(::flyteidl::core::BlobType* type) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(type_);
  }
  if (type) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      type = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, type, submessage_arena);
    }
    
  } else {
    
  }
  type_ = type;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.BlobMetadata.type)
}

// -------------------------------------------------------------------

// Binary

// bytes value = 1;
inline void Binary::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Binary::value() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Binary.value)
  return value_.GetNoArena();
}
inline void Binary::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.Binary.value)
}
#if LANG_CXX11
inline void Binary::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.Binary.value)
}
#endif
inline void Binary::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.Binary.value)
}
inline void Binary::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.Binary.value)
}
inline ::std::string* Binary::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Binary.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Binary::release_value() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Binary.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Binary::set_allocated_value(::std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.Binary.value)
}

// string tag = 2;
inline void Binary::clear_tag() {
  tag_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Binary::tag() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Binary.tag)
  return tag_.GetNoArena();
}
inline void Binary::set_tag(const ::std::string& value) {
  
  tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.Binary.tag)
}
#if LANG_CXX11
inline void Binary::set_tag(::std::string&& value) {
  
  tag_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.Binary.tag)
}
#endif
inline void Binary::set_tag(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.Binary.tag)
}
inline void Binary::set_tag(const char* value, size_t size) {
  
  tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.Binary.tag)
}
inline ::std::string* Binary::mutable_tag() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Binary.tag)
  return tag_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Binary::release_tag() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Binary.tag)
  
  return tag_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Binary::set_allocated_tag(::std::string* tag) {
  if (tag != nullptr) {
    
  } else {
    
  }
  tag_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tag);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.Binary.tag)
}

// -------------------------------------------------------------------

// Schema

// string uri = 1;
inline void Schema::clear_uri() {
  uri_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Schema::uri() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Schema.uri)
  return uri_.GetNoArena();
}
inline void Schema::set_uri(const ::std::string& value) {
  
  uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.Schema.uri)
}
#if LANG_CXX11
inline void Schema::set_uri(::std::string&& value) {
  
  uri_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.Schema.uri)
}
#endif
inline void Schema::set_uri(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.Schema.uri)
}
inline void Schema::set_uri(const char* value, size_t size) {
  
  uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.Schema.uri)
}
inline ::std::string* Schema::mutable_uri() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Schema.uri)
  return uri_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Schema::release_uri() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Schema.uri)
  
  return uri_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Schema::set_allocated_uri(::std::string* uri) {
  if (uri != nullptr) {
    
  } else {
    
  }
  uri_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uri);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.Schema.uri)
}

// .flyteidl.core.SchemaType type = 3;
inline bool Schema::has_type() const {
  return this != internal_default_instance() && type_ != nullptr;
}
inline const ::flyteidl::core::SchemaType& Schema::type() const {
  const ::flyteidl::core::SchemaType* p = type_;
  // @@protoc_insertion_point(field_get:flyteidl.core.Schema.type)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::SchemaType*>(
      &::flyteidl::core::_SchemaType_default_instance_);
}
inline ::flyteidl::core::SchemaType* Schema::release_type() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Schema.type)
  
  ::flyteidl::core::SchemaType* temp = type_;
  type_ = nullptr;
  return temp;
}
inline ::flyteidl::core::SchemaType* Schema::mutable_type() {
  
  if (type_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::SchemaType>(GetArenaNoVirtual());
    type_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Schema.type)
  return type_;
}
inline void Schema::set_allocated_type(::flyteidl::core::SchemaType* type) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(type_);
  }
  if (type) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      type = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, type, submessage_arena);
    }
    
  } else {
    
  }
  type_ = type;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.Schema.type)
}

// -------------------------------------------------------------------

// Scalar

// .flyteidl.core.Primitive primitive = 1;
inline bool Scalar::has_primitive() const {
  return value_case() == kPrimitive;
}
inline void Scalar::set_has_primitive() {
  _oneof_case_[0] = kPrimitive;
}
inline void Scalar::clear_primitive() {
  if (has_primitive()) {
    delete value_.primitive_;
    clear_has_value();
  }
}
inline ::flyteidl::core::Primitive* Scalar::release_primitive() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Scalar.primitive)
  if (has_primitive()) {
    clear_has_value();
      ::flyteidl::core::Primitive* temp = value_.primitive_;
    value_.primitive_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::core::Primitive& Scalar::primitive() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Scalar.primitive)
  return has_primitive()
      ? *value_.primitive_
      : *reinterpret_cast< ::flyteidl::core::Primitive*>(&::flyteidl::core::_Primitive_default_instance_);
}
inline ::flyteidl::core::Primitive* Scalar::mutable_primitive() {
  if (!has_primitive()) {
    clear_value();
    set_has_primitive();
    value_.primitive_ = CreateMaybeMessage< ::flyteidl::core::Primitive >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Scalar.primitive)
  return value_.primitive_;
}

// .flyteidl.core.Blob blob = 2;
inline bool Scalar::has_blob() const {
  return value_case() == kBlob;
}
inline void Scalar::set_has_blob() {
  _oneof_case_[0] = kBlob;
}
inline void Scalar::clear_blob() {
  if (has_blob()) {
    delete value_.blob_;
    clear_has_value();
  }
}
inline ::flyteidl::core::Blob* Scalar::release_blob() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Scalar.blob)
  if (has_blob()) {
    clear_has_value();
      ::flyteidl::core::Blob* temp = value_.blob_;
    value_.blob_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::core::Blob& Scalar::blob() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Scalar.blob)
  return has_blob()
      ? *value_.blob_
      : *reinterpret_cast< ::flyteidl::core::Blob*>(&::flyteidl::core::_Blob_default_instance_);
}
inline ::flyteidl::core::Blob* Scalar::mutable_blob() {
  if (!has_blob()) {
    clear_value();
    set_has_blob();
    value_.blob_ = CreateMaybeMessage< ::flyteidl::core::Blob >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Scalar.blob)
  return value_.blob_;
}

// .flyteidl.core.Binary binary = 3;
inline bool Scalar::has_binary() const {
  return value_case() == kBinary;
}
inline void Scalar::set_has_binary() {
  _oneof_case_[0] = kBinary;
}
inline void Scalar::clear_binary() {
  if (has_binary()) {
    delete value_.binary_;
    clear_has_value();
  }
}
inline ::flyteidl::core::Binary* Scalar::release_binary() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Scalar.binary)
  if (has_binary()) {
    clear_has_value();
      ::flyteidl::core::Binary* temp = value_.binary_;
    value_.binary_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::core::Binary& Scalar::binary() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Scalar.binary)
  return has_binary()
      ? *value_.binary_
      : *reinterpret_cast< ::flyteidl::core::Binary*>(&::flyteidl::core::_Binary_default_instance_);
}
inline ::flyteidl::core::Binary* Scalar::mutable_binary() {
  if (!has_binary()) {
    clear_value();
    set_has_binary();
    value_.binary_ = CreateMaybeMessage< ::flyteidl::core::Binary >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Scalar.binary)
  return value_.binary_;
}

// .flyteidl.core.Schema schema = 4;
inline bool Scalar::has_schema() const {
  return value_case() == kSchema;
}
inline void Scalar::set_has_schema() {
  _oneof_case_[0] = kSchema;
}
inline void Scalar::clear_schema() {
  if (has_schema()) {
    delete value_.schema_;
    clear_has_value();
  }
}
inline ::flyteidl::core::Schema* Scalar::release_schema() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Scalar.schema)
  if (has_schema()) {
    clear_has_value();
      ::flyteidl::core::Schema* temp = value_.schema_;
    value_.schema_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::core::Schema& Scalar::schema() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Scalar.schema)
  return has_schema()
      ? *value_.schema_
      : *reinterpret_cast< ::flyteidl::core::Schema*>(&::flyteidl::core::_Schema_default_instance_);
}
inline ::flyteidl::core::Schema* Scalar::mutable_schema() {
  if (!has_schema()) {
    clear_value();
    set_has_schema();
    value_.schema_ = CreateMaybeMessage< ::flyteidl::core::Schema >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Scalar.schema)
  return value_.schema_;
}

// .flyteidl.core.Void none_type = 5;
inline bool Scalar::has_none_type() const {
  return value_case() == kNoneType;
}
inline void Scalar::set_has_none_type() {
  _oneof_case_[0] = kNoneType;
}
inline void Scalar::clear_none_type() {
  if (has_none_type()) {
    delete value_.none_type_;
    clear_has_value();
  }
}
inline ::flyteidl::core::Void* Scalar::release_none_type() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Scalar.none_type)
  if (has_none_type()) {
    clear_has_value();
      ::flyteidl::core::Void* temp = value_.none_type_;
    value_.none_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::core::Void& Scalar::none_type() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Scalar.none_type)
  return has_none_type()
      ? *value_.none_type_
      : *reinterpret_cast< ::flyteidl::core::Void*>(&::flyteidl::core::_Void_default_instance_);
}
inline ::flyteidl::core::Void* Scalar::mutable_none_type() {
  if (!has_none_type()) {
    clear_value();
    set_has_none_type();
    value_.none_type_ = CreateMaybeMessage< ::flyteidl::core::Void >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Scalar.none_type)
  return value_.none_type_;
}

// .flyteidl.core.Error error = 6;
inline bool Scalar::has_error() const {
  return value_case() == kError;
}
inline void Scalar::set_has_error() {
  _oneof_case_[0] = kError;
}
inline ::flyteidl::core::Error* Scalar::release_error() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Scalar.error)
  if (has_error()) {
    clear_has_value();
      ::flyteidl::core::Error* temp = value_.error_;
    value_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::core::Error& Scalar::error() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Scalar.error)
  return has_error()
      ? *value_.error_
      : *reinterpret_cast< ::flyteidl::core::Error*>(&::flyteidl::core::_Error_default_instance_);
}
inline ::flyteidl::core::Error* Scalar::mutable_error() {
  if (!has_error()) {
    clear_value();
    set_has_error();
    value_.error_ = CreateMaybeMessage< ::flyteidl::core::Error >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Scalar.error)
  return value_.error_;
}

// .google.protobuf.Struct generic = 7;
inline bool Scalar::has_generic() const {
  return value_case() == kGeneric;
}
inline void Scalar::set_has_generic() {
  _oneof_case_[0] = kGeneric;
}
inline ::google::protobuf::Struct* Scalar::release_generic() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Scalar.generic)
  if (has_generic()) {
    clear_has_value();
      ::google::protobuf::Struct* temp = value_.generic_;
    value_.generic_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::protobuf::Struct& Scalar::generic() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Scalar.generic)
  return has_generic()
      ? *value_.generic_
      : *reinterpret_cast< ::google::protobuf::Struct*>(&::google::protobuf::_Struct_default_instance_);
}
inline ::google::protobuf::Struct* Scalar::mutable_generic() {
  if (!has_generic()) {
    clear_value();
    set_has_generic();
    value_.generic_ = CreateMaybeMessage< ::google::protobuf::Struct >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Scalar.generic)
  return value_.generic_;
}

inline bool Scalar::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void Scalar::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline Scalar::ValueCase Scalar::value_case() const {
  return Scalar::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Literal

// .flyteidl.core.Scalar scalar = 1;
inline bool Literal::has_scalar() const {
  return value_case() == kScalar;
}
inline void Literal::set_has_scalar() {
  _oneof_case_[0] = kScalar;
}
inline void Literal::clear_scalar() {
  if (has_scalar()) {
    delete value_.scalar_;
    clear_has_value();
  }
}
inline ::flyteidl::core::Scalar* Literal::release_scalar() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Literal.scalar)
  if (has_scalar()) {
    clear_has_value();
      ::flyteidl::core::Scalar* temp = value_.scalar_;
    value_.scalar_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::core::Scalar& Literal::scalar() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Literal.scalar)
  return has_scalar()
      ? *value_.scalar_
      : *reinterpret_cast< ::flyteidl::core::Scalar*>(&::flyteidl::core::_Scalar_default_instance_);
}
inline ::flyteidl::core::Scalar* Literal::mutable_scalar() {
  if (!has_scalar()) {
    clear_value();
    set_has_scalar();
    value_.scalar_ = CreateMaybeMessage< ::flyteidl::core::Scalar >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Literal.scalar)
  return value_.scalar_;
}

// .flyteidl.core.LiteralCollection collection = 2;
inline bool Literal::has_collection() const {
  return value_case() == kCollection;
}
inline void Literal::set_has_collection() {
  _oneof_case_[0] = kCollection;
}
inline void Literal::clear_collection() {
  if (has_collection()) {
    delete value_.collection_;
    clear_has_value();
  }
}
inline ::flyteidl::core::LiteralCollection* Literal::release_collection() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Literal.collection)
  if (has_collection()) {
    clear_has_value();
      ::flyteidl::core::LiteralCollection* temp = value_.collection_;
    value_.collection_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::core::LiteralCollection& Literal::collection() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Literal.collection)
  return has_collection()
      ? *value_.collection_
      : *reinterpret_cast< ::flyteidl::core::LiteralCollection*>(&::flyteidl::core::_LiteralCollection_default_instance_);
}
inline ::flyteidl::core::LiteralCollection* Literal::mutable_collection() {
  if (!has_collection()) {
    clear_value();
    set_has_collection();
    value_.collection_ = CreateMaybeMessage< ::flyteidl::core::LiteralCollection >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Literal.collection)
  return value_.collection_;
}

// .flyteidl.core.LiteralMap map = 3;
inline bool Literal::has_map() const {
  return value_case() == kMap;
}
inline void Literal::set_has_map() {
  _oneof_case_[0] = kMap;
}
inline void Literal::clear_map() {
  if (has_map()) {
    delete value_.map_;
    clear_has_value();
  }
}
inline ::flyteidl::core::LiteralMap* Literal::release_map() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Literal.map)
  if (has_map()) {
    clear_has_value();
      ::flyteidl::core::LiteralMap* temp = value_.map_;
    value_.map_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::core::LiteralMap& Literal::map() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Literal.map)
  return has_map()
      ? *value_.map_
      : *reinterpret_cast< ::flyteidl::core::LiteralMap*>(&::flyteidl::core::_LiteralMap_default_instance_);
}
inline ::flyteidl::core::LiteralMap* Literal::mutable_map() {
  if (!has_map()) {
    clear_value();
    set_has_map();
    value_.map_ = CreateMaybeMessage< ::flyteidl::core::LiteralMap >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Literal.map)
  return value_.map_;
}

// .flyteidl.core.Int32Vector int32_vector = 4;
inline bool Literal::has_int32_vector() const {
  return value_case() == kInt32Vector;
}
inline void Literal::set_has_int32_vector() {
  _oneof_case_[0] = kInt32Vector;
}
inline void Literal::clear_int32_vector() {
  if (has_int32_vector()) {
    delete value_.int32_vector_;
    clear_has_value();
  }
}
inline ::flyteidl::core::Int32Vector* Literal::release_int32_vector() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Literal.int32_vector)
  if (has_int32_vector()) {
    clear_has_value();
      ::flyteidl::core::Int32Vector* temp = value_.int32_vector_;
    value_.int32_vector_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::core::Int32Vector& Literal::int32_vector() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Literal.int32_vector)
  return has_int32_vector()
      ? *value_.int32_vector_
      : *reinterpret_cast< ::flyteidl::core::Int32Vector*>(&::flyteidl::core::_Int32Vector_default_instance_);
}
inline ::flyteidl::core::Int32Vector* Literal::mutable_int32_vector() {
  if (!has_int32_vector()) {
    clear_value();
    set_has_int32_vector();
    value_.int32_vector_ = CreateMaybeMessage< ::flyteidl::core::Int32Vector >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Literal.int32_vector)
  return value_.int32_vector_;
}

// .flyteidl.core.Int64Vector int_vector = 5;
inline bool Literal::has_int_vector() const {
  return value_case() == kIntVector;
}
inline void Literal::set_has_int_vector() {
  _oneof_case_[0] = kIntVector;
}
inline void Literal::clear_int_vector() {
  if (has_int_vector()) {
    delete value_.int_vector_;
    clear_has_value();
  }
}
inline ::flyteidl::core::Int64Vector* Literal::release_int_vector() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Literal.int_vector)
  if (has_int_vector()) {
    clear_has_value();
      ::flyteidl::core::Int64Vector* temp = value_.int_vector_;
    value_.int_vector_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::core::Int64Vector& Literal::int_vector() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Literal.int_vector)
  return has_int_vector()
      ? *value_.int_vector_
      : *reinterpret_cast< ::flyteidl::core::Int64Vector*>(&::flyteidl::core::_Int64Vector_default_instance_);
}
inline ::flyteidl::core::Int64Vector* Literal::mutable_int_vector() {
  if (!has_int_vector()) {
    clear_value();
    set_has_int_vector();
    value_.int_vector_ = CreateMaybeMessage< ::flyteidl::core::Int64Vector >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Literal.int_vector)
  return value_.int_vector_;
}

// .flyteidl.core.FloatVector float_vector = 6;
inline bool Literal::has_float_vector() const {
  return value_case() == kFloatVector;
}
inline void Literal::set_has_float_vector() {
  _oneof_case_[0] = kFloatVector;
}
inline void Literal::clear_float_vector() {
  if (has_float_vector()) {
    delete value_.float_vector_;
    clear_has_value();
  }
}
inline ::flyteidl::core::FloatVector* Literal::release_float_vector() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Literal.float_vector)
  if (has_float_vector()) {
    clear_has_value();
      ::flyteidl::core::FloatVector* temp = value_.float_vector_;
    value_.float_vector_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::core::FloatVector& Literal::float_vector() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Literal.float_vector)
  return has_float_vector()
      ? *value_.float_vector_
      : *reinterpret_cast< ::flyteidl::core::FloatVector*>(&::flyteidl::core::_FloatVector_default_instance_);
}
inline ::flyteidl::core::FloatVector* Literal::mutable_float_vector() {
  if (!has_float_vector()) {
    clear_value();
    set_has_float_vector();
    value_.float_vector_ = CreateMaybeMessage< ::flyteidl::core::FloatVector >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Literal.float_vector)
  return value_.float_vector_;
}

// .flyteidl.core.DoubleVector double_vector = 7;
inline bool Literal::has_double_vector() const {
  return value_case() == kDoubleVector;
}
inline void Literal::set_has_double_vector() {
  _oneof_case_[0] = kDoubleVector;
}
inline void Literal::clear_double_vector() {
  if (has_double_vector()) {
    delete value_.double_vector_;
    clear_has_value();
  }
}
inline ::flyteidl::core::DoubleVector* Literal::release_double_vector() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Literal.double_vector)
  if (has_double_vector()) {
    clear_has_value();
      ::flyteidl::core::DoubleVector* temp = value_.double_vector_;
    value_.double_vector_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::core::DoubleVector& Literal::double_vector() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Literal.double_vector)
  return has_double_vector()
      ? *value_.double_vector_
      : *reinterpret_cast< ::flyteidl::core::DoubleVector*>(&::flyteidl::core::_DoubleVector_default_instance_);
}
inline ::flyteidl::core::DoubleVector* Literal::mutable_double_vector() {
  if (!has_double_vector()) {
    clear_value();
    set_has_double_vector();
    value_.double_vector_ = CreateMaybeMessage< ::flyteidl::core::DoubleVector >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Literal.double_vector)
  return value_.double_vector_;
}

// .flyteidl.core.BoolVector bool_vector = 8;
inline bool Literal::has_bool_vector() const {
  return value_case() == kBoolVector;
}
inline void Literal::set_has_bool_vector() {
  _oneof_case_[0] = kBoolVector;
}
inline void Literal::clear_bool_vector() {
  if (has_bool_vector()) {
    delete value_.bool_vector_;
    clear_has_value();
  }
}
inline ::flyteidl::core::BoolVector* Literal::release_bool_vector() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Literal.bool_vector)
  if (has_bool_vector()) {
    clear_has_value();
      ::flyteidl::core::BoolVector* temp = value_.bool_vector_;
    value_.bool_vector_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::core::BoolVector& Literal::bool_vector() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Literal.bool_vector)
  return has_bool_vector()
      ? *value_.bool_vector_
      : *reinterpret_cast< ::flyteidl::core::BoolVector*>(&::flyteidl::core::_BoolVector_default_instance_);
}
inline ::flyteidl::core::BoolVector* Literal::mutable_bool_vector() {
  if (!has_bool_vector()) {
    clear_value();
    set_has_bool_vector();
    value_.bool_vector_ = CreateMaybeMessage< ::flyteidl::core::BoolVector >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Literal.bool_vector)
  return value_.bool_vector_;
}

// .flyteidl.core.StringVector str_vector = 9;
inline bool Literal::has_str_vector() const {
  return value_case() == kStrVector;
}
inline void Literal::set_has_str_vector() {
  _oneof_case_[0] = kStrVector;
}
inline void Literal::clear_str_vector() {
  if (has_str_vector()) {
    delete value_.str_vector_;
    clear_has_value();
  }
}
inline ::flyteidl::core::StringVector* Literal::release_str_vector() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Literal.str_vector)
  if (has_str_vector()) {
    clear_has_value();
      ::flyteidl::core::StringVector* temp = value_.str_vector_;
    value_.str_vector_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::core::StringVector& Literal::str_vector() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Literal.str_vector)
  return has_str_vector()
      ? *value_.str_vector_
      : *reinterpret_cast< ::flyteidl::core::StringVector*>(&::flyteidl::core::_StringVector_default_instance_);
}
inline ::flyteidl::core::StringVector* Literal::mutable_str_vector() {
  if (!has_str_vector()) {
    clear_value();
    set_has_str_vector();
    value_.str_vector_ = CreateMaybeMessage< ::flyteidl::core::StringVector >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Literal.str_vector)
  return value_.str_vector_;
}

inline bool Literal::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void Literal::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline Literal::ValueCase Literal::value_case() const {
  return Literal::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Offloaded

// string uri = 1;
inline void Offloaded::clear_uri() {
  uri_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Offloaded::uri() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Offloaded.uri)
  return uri_.GetNoArena();
}
inline void Offloaded::set_uri(const ::std::string& value) {
  
  uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.Offloaded.uri)
}
#if LANG_CXX11
inline void Offloaded::set_uri(::std::string&& value) {
  
  uri_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.Offloaded.uri)
}
#endif
inline void Offloaded::set_uri(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.Offloaded.uri)
}
inline void Offloaded::set_uri(const char* value, size_t size) {
  
  uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.Offloaded.uri)
}
inline ::std::string* Offloaded::mutable_uri() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Offloaded.uri)
  return uri_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Offloaded::release_uri() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Offloaded.uri)
  
  return uri_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Offloaded::set_allocated_uri(::std::string* uri) {
  if (uri != nullptr) {
    
  } else {
    
  }
  uri_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uri);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.Offloaded.uri)
}

// string format = 2;
inline void Offloaded::clear_format() {
  format_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Offloaded::format() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Offloaded.format)
  return format_.GetNoArena();
}
inline void Offloaded::set_format(const ::std::string& value) {
  
  format_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.Offloaded.format)
}
#if LANG_CXX11
inline void Offloaded::set_format(::std::string&& value) {
  
  format_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.Offloaded.format)
}
#endif
inline void Offloaded::set_format(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  format_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.Offloaded.format)
}
inline void Offloaded::set_format(const char* value, size_t size) {
  
  format_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.Offloaded.format)
}
inline ::std::string* Offloaded::mutable_format() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Offloaded.format)
  return format_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Offloaded::release_format() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Offloaded.format)
  
  return format_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Offloaded::set_allocated_format(::std::string* format) {
  if (format != nullptr) {
    
  } else {
    
  }
  format_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), format);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.Offloaded.format)
}

// -------------------------------------------------------------------

// StringVector

// repeated string values = 1;
inline int StringVector::values_size() const {
  return values_.size();
}
inline void StringVector::clear_values() {
  values_.Clear();
}
inline const ::std::string& StringVector::values(int index) const {
  // @@protoc_insertion_point(field_get:flyteidl.core.StringVector.values)
  return values_.Get(index);
}
inline ::std::string* StringVector::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:flyteidl.core.StringVector.values)
  return values_.Mutable(index);
}
inline void StringVector::set_values(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:flyteidl.core.StringVector.values)
  values_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void StringVector::set_values(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:flyteidl.core.StringVector.values)
  values_.Mutable(index)->assign(std::move(value));
}
#endif
inline void StringVector::set_values(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:flyteidl.core.StringVector.values)
}
inline void StringVector::set_values(int index, const char* value, size_t size) {
  values_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.StringVector.values)
}
inline ::std::string* StringVector::add_values() {
  // @@protoc_insertion_point(field_add_mutable:flyteidl.core.StringVector.values)
  return values_.Add();
}
inline void StringVector::add_values(const ::std::string& value) {
  values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:flyteidl.core.StringVector.values)
}
#if LANG_CXX11
inline void StringVector::add_values(::std::string&& value) {
  values_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:flyteidl.core.StringVector.values)
}
#endif
inline void StringVector::add_values(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:flyteidl.core.StringVector.values)
}
inline void StringVector::add_values(const char* value, size_t size) {
  values_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:flyteidl.core.StringVector.values)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
StringVector::values() const {
  // @@protoc_insertion_point(field_list:flyteidl.core.StringVector.values)
  return values_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
StringVector::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:flyteidl.core.StringVector.values)
  return &values_;
}

// .flyteidl.core.Offloaded offloaded = 2;
inline bool StringVector::has_offloaded() const {
  return this != internal_default_instance() && offloaded_ != nullptr;
}
inline void StringVector::clear_offloaded() {
  if (GetArenaNoVirtual() == nullptr && offloaded_ != nullptr) {
    delete offloaded_;
  }
  offloaded_ = nullptr;
}
inline const ::flyteidl::core::Offloaded& StringVector::offloaded() const {
  const ::flyteidl::core::Offloaded* p = offloaded_;
  // @@protoc_insertion_point(field_get:flyteidl.core.StringVector.offloaded)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::Offloaded*>(
      &::flyteidl::core::_Offloaded_default_instance_);
}
inline ::flyteidl::core::Offloaded* StringVector::release_offloaded() {
  // @@protoc_insertion_point(field_release:flyteidl.core.StringVector.offloaded)
  
  ::flyteidl::core::Offloaded* temp = offloaded_;
  offloaded_ = nullptr;
  return temp;
}
inline ::flyteidl::core::Offloaded* StringVector::mutable_offloaded() {
  
  if (offloaded_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::Offloaded>(GetArenaNoVirtual());
    offloaded_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.StringVector.offloaded)
  return offloaded_;
}
inline void StringVector::set_allocated_offloaded(::flyteidl::core::Offloaded* offloaded) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete offloaded_;
  }
  if (offloaded) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      offloaded = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, offloaded, submessage_arena);
    }
    
  } else {
    
  }
  offloaded_ = offloaded;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.StringVector.offloaded)
}

// -------------------------------------------------------------------

// Int32Vector

// repeated int32 values = 1;
inline int Int32Vector::values_size() const {
  return values_.size();
}
inline void Int32Vector::clear_values() {
  values_.Clear();
}
inline ::google::protobuf::int32 Int32Vector::values(int index) const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Int32Vector.values)
  return values_.Get(index);
}
inline void Int32Vector::set_values(int index, ::google::protobuf::int32 value) {
  values_.Set(index, value);
  // @@protoc_insertion_point(field_set:flyteidl.core.Int32Vector.values)
}
inline void Int32Vector::add_values(::google::protobuf::int32 value) {
  values_.Add(value);
  // @@protoc_insertion_point(field_add:flyteidl.core.Int32Vector.values)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Int32Vector::values() const {
  // @@protoc_insertion_point(field_list:flyteidl.core.Int32Vector.values)
  return values_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Int32Vector::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:flyteidl.core.Int32Vector.values)
  return &values_;
}

// .flyteidl.core.Offloaded offloaded = 2;
inline bool Int32Vector::has_offloaded() const {
  return this != internal_default_instance() && offloaded_ != nullptr;
}
inline void Int32Vector::clear_offloaded() {
  if (GetArenaNoVirtual() == nullptr && offloaded_ != nullptr) {
    delete offloaded_;
  }
  offloaded_ = nullptr;
}
inline const ::flyteidl::core::Offloaded& Int32Vector::offloaded() const {
  const ::flyteidl::core::Offloaded* p = offloaded_;
  // @@protoc_insertion_point(field_get:flyteidl.core.Int32Vector.offloaded)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::Offloaded*>(
      &::flyteidl::core::_Offloaded_default_instance_);
}
inline ::flyteidl::core::Offloaded* Int32Vector::release_offloaded() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Int32Vector.offloaded)
  
  ::flyteidl::core::Offloaded* temp = offloaded_;
  offloaded_ = nullptr;
  return temp;
}
inline ::flyteidl::core::Offloaded* Int32Vector::mutable_offloaded() {
  
  if (offloaded_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::Offloaded>(GetArenaNoVirtual());
    offloaded_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Int32Vector.offloaded)
  return offloaded_;
}
inline void Int32Vector::set_allocated_offloaded(::flyteidl::core::Offloaded* offloaded) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete offloaded_;
  }
  if (offloaded) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      offloaded = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, offloaded, submessage_arena);
    }
    
  } else {
    
  }
  offloaded_ = offloaded;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.Int32Vector.offloaded)
}

// -------------------------------------------------------------------

// Int64Vector

// repeated int64 values = 1;
inline int Int64Vector::values_size() const {
  return values_.size();
}
inline void Int64Vector::clear_values() {
  values_.Clear();
}
inline ::google::protobuf::int64 Int64Vector::values(int index) const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Int64Vector.values)
  return values_.Get(index);
}
inline void Int64Vector::set_values(int index, ::google::protobuf::int64 value) {
  values_.Set(index, value);
  // @@protoc_insertion_point(field_set:flyteidl.core.Int64Vector.values)
}
inline void Int64Vector::add_values(::google::protobuf::int64 value) {
  values_.Add(value);
  // @@protoc_insertion_point(field_add:flyteidl.core.Int64Vector.values)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
Int64Vector::values() const {
  // @@protoc_insertion_point(field_list:flyteidl.core.Int64Vector.values)
  return values_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
Int64Vector::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:flyteidl.core.Int64Vector.values)
  return &values_;
}

// .flyteidl.core.Offloaded offloaded = 2;
inline bool Int64Vector::has_offloaded() const {
  return this != internal_default_instance() && offloaded_ != nullptr;
}
inline void Int64Vector::clear_offloaded() {
  if (GetArenaNoVirtual() == nullptr && offloaded_ != nullptr) {
    delete offloaded_;
  }
  offloaded_ = nullptr;
}
inline const ::flyteidl::core::Offloaded& Int64Vector::offloaded() const {
  const ::flyteidl::core::Offloaded* p = offloaded_;
  // @@protoc_insertion_point(field_get:flyteidl.core.Int64Vector.offloaded)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::Offloaded*>(
      &::flyteidl::core::_Offloaded_default_instance_);
}
inline ::flyteidl::core::Offloaded* Int64Vector::release_offloaded() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Int64Vector.offloaded)
  
  ::flyteidl::core::Offloaded* temp = offloaded_;
  offloaded_ = nullptr;
  return temp;
}
inline ::flyteidl::core::Offloaded* Int64Vector::mutable_offloaded() {
  
  if (offloaded_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::Offloaded>(GetArenaNoVirtual());
    offloaded_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Int64Vector.offloaded)
  return offloaded_;
}
inline void Int64Vector::set_allocated_offloaded(::flyteidl::core::Offloaded* offloaded) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete offloaded_;
  }
  if (offloaded) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      offloaded = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, offloaded, submessage_arena);
    }
    
  } else {
    
  }
  offloaded_ = offloaded;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.Int64Vector.offloaded)
}

// -------------------------------------------------------------------

// FloatVector

// repeated float values = 1;
inline int FloatVector::values_size() const {
  return values_.size();
}
inline void FloatVector::clear_values() {
  values_.Clear();
}
inline float FloatVector::values(int index) const {
  // @@protoc_insertion_point(field_get:flyteidl.core.FloatVector.values)
  return values_.Get(index);
}
inline void FloatVector::set_values(int index, float value) {
  values_.Set(index, value);
  // @@protoc_insertion_point(field_set:flyteidl.core.FloatVector.values)
}
inline void FloatVector::add_values(float value) {
  values_.Add(value);
  // @@protoc_insertion_point(field_add:flyteidl.core.FloatVector.values)
}
inline const ::google::protobuf::RepeatedField< float >&
FloatVector::values() const {
  // @@protoc_insertion_point(field_list:flyteidl.core.FloatVector.values)
  return values_;
}
inline ::google::protobuf::RepeatedField< float >*
FloatVector::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:flyteidl.core.FloatVector.values)
  return &values_;
}

// .flyteidl.core.Offloaded offloaded = 2;
inline bool FloatVector::has_offloaded() const {
  return this != internal_default_instance() && offloaded_ != nullptr;
}
inline void FloatVector::clear_offloaded() {
  if (GetArenaNoVirtual() == nullptr && offloaded_ != nullptr) {
    delete offloaded_;
  }
  offloaded_ = nullptr;
}
inline const ::flyteidl::core::Offloaded& FloatVector::offloaded() const {
  const ::flyteidl::core::Offloaded* p = offloaded_;
  // @@protoc_insertion_point(field_get:flyteidl.core.FloatVector.offloaded)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::Offloaded*>(
      &::flyteidl::core::_Offloaded_default_instance_);
}
inline ::flyteidl::core::Offloaded* FloatVector::release_offloaded() {
  // @@protoc_insertion_point(field_release:flyteidl.core.FloatVector.offloaded)
  
  ::flyteidl::core::Offloaded* temp = offloaded_;
  offloaded_ = nullptr;
  return temp;
}
inline ::flyteidl::core::Offloaded* FloatVector::mutable_offloaded() {
  
  if (offloaded_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::Offloaded>(GetArenaNoVirtual());
    offloaded_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.FloatVector.offloaded)
  return offloaded_;
}
inline void FloatVector::set_allocated_offloaded(::flyteidl::core::Offloaded* offloaded) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete offloaded_;
  }
  if (offloaded) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      offloaded = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, offloaded, submessage_arena);
    }
    
  } else {
    
  }
  offloaded_ = offloaded;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.FloatVector.offloaded)
}

// -------------------------------------------------------------------

// DoubleVector

// repeated double values = 1;
inline int DoubleVector::values_size() const {
  return values_.size();
}
inline void DoubleVector::clear_values() {
  values_.Clear();
}
inline double DoubleVector::values(int index) const {
  // @@protoc_insertion_point(field_get:flyteidl.core.DoubleVector.values)
  return values_.Get(index);
}
inline void DoubleVector::set_values(int index, double value) {
  values_.Set(index, value);
  // @@protoc_insertion_point(field_set:flyteidl.core.DoubleVector.values)
}
inline void DoubleVector::add_values(double value) {
  values_.Add(value);
  // @@protoc_insertion_point(field_add:flyteidl.core.DoubleVector.values)
}
inline const ::google::protobuf::RepeatedField< double >&
DoubleVector::values() const {
  // @@protoc_insertion_point(field_list:flyteidl.core.DoubleVector.values)
  return values_;
}
inline ::google::protobuf::RepeatedField< double >*
DoubleVector::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:flyteidl.core.DoubleVector.values)
  return &values_;
}

// .flyteidl.core.Offloaded offloaded = 2;
inline bool DoubleVector::has_offloaded() const {
  return this != internal_default_instance() && offloaded_ != nullptr;
}
inline void DoubleVector::clear_offloaded() {
  if (GetArenaNoVirtual() == nullptr && offloaded_ != nullptr) {
    delete offloaded_;
  }
  offloaded_ = nullptr;
}
inline const ::flyteidl::core::Offloaded& DoubleVector::offloaded() const {
  const ::flyteidl::core::Offloaded* p = offloaded_;
  // @@protoc_insertion_point(field_get:flyteidl.core.DoubleVector.offloaded)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::Offloaded*>(
      &::flyteidl::core::_Offloaded_default_instance_);
}
inline ::flyteidl::core::Offloaded* DoubleVector::release_offloaded() {
  // @@protoc_insertion_point(field_release:flyteidl.core.DoubleVector.offloaded)
  
  ::flyteidl::core::Offloaded* temp = offloaded_;
  offloaded_ = nullptr;
  return temp;
}
inline ::flyteidl::core::Offloaded* DoubleVector::mutable_offloaded() {
  
  if (offloaded_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::Offloaded>(GetArenaNoVirtual());
    offloaded_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.DoubleVector.offloaded)
  return offloaded_;
}
inline void DoubleVector::set_allocated_offloaded(::flyteidl::core::Offloaded* offloaded) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete offloaded_;
  }
  if (offloaded) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      offloaded = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, offloaded, submessage_arena);
    }
    
  } else {
    
  }
  offloaded_ = offloaded;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.DoubleVector.offloaded)
}

// -------------------------------------------------------------------

// BoolVector

// repeated bool values = 1;
inline int BoolVector::values_size() const {
  return values_.size();
}
inline void BoolVector::clear_values() {
  values_.Clear();
}
inline bool BoolVector::values(int index) const {
  // @@protoc_insertion_point(field_get:flyteidl.core.BoolVector.values)
  return values_.Get(index);
}
inline void BoolVector::set_values(int index, bool value) {
  values_.Set(index, value);
  // @@protoc_insertion_point(field_set:flyteidl.core.BoolVector.values)
}
inline void BoolVector::add_values(bool value) {
  values_.Add(value);
  // @@protoc_insertion_point(field_add:flyteidl.core.BoolVector.values)
}
inline const ::google::protobuf::RepeatedField< bool >&
BoolVector::values() const {
  // @@protoc_insertion_point(field_list:flyteidl.core.BoolVector.values)
  return values_;
}
inline ::google::protobuf::RepeatedField< bool >*
BoolVector::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:flyteidl.core.BoolVector.values)
  return &values_;
}

// .flyteidl.core.Offloaded offloaded = 2;
inline bool BoolVector::has_offloaded() const {
  return this != internal_default_instance() && offloaded_ != nullptr;
}
inline void BoolVector::clear_offloaded() {
  if (GetArenaNoVirtual() == nullptr && offloaded_ != nullptr) {
    delete offloaded_;
  }
  offloaded_ = nullptr;
}
inline const ::flyteidl::core::Offloaded& BoolVector::offloaded() const {
  const ::flyteidl::core::Offloaded* p = offloaded_;
  // @@protoc_insertion_point(field_get:flyteidl.core.BoolVector.offloaded)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::Offloaded*>(
      &::flyteidl::core::_Offloaded_default_instance_);
}
inline ::flyteidl::core::Offloaded* BoolVector::release_offloaded() {
  // @@protoc_insertion_point(field_release:flyteidl.core.BoolVector.offloaded)
  
  ::flyteidl::core::Offloaded* temp = offloaded_;
  offloaded_ = nullptr;
  return temp;
}
inline ::flyteidl::core::Offloaded* BoolVector::mutable_offloaded() {
  
  if (offloaded_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::Offloaded>(GetArenaNoVirtual());
    offloaded_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.BoolVector.offloaded)
  return offloaded_;
}
inline void BoolVector::set_allocated_offloaded(::flyteidl::core::Offloaded* offloaded) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete offloaded_;
  }
  if (offloaded) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      offloaded = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, offloaded, submessage_arena);
    }
    
  } else {
    
  }
  offloaded_ = offloaded;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.BoolVector.offloaded)
}

// -------------------------------------------------------------------

// LiteralCollection

// repeated .flyteidl.core.Literal literals = 1;
inline int LiteralCollection::literals_size() const {
  return literals_.size();
}
inline void LiteralCollection::clear_literals() {
  literals_.Clear();
}
inline ::flyteidl::core::Literal* LiteralCollection::mutable_literals(int index) {
  // @@protoc_insertion_point(field_mutable:flyteidl.core.LiteralCollection.literals)
  return literals_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::flyteidl::core::Literal >*
LiteralCollection::mutable_literals() {
  // @@protoc_insertion_point(field_mutable_list:flyteidl.core.LiteralCollection.literals)
  return &literals_;
}
inline const ::flyteidl::core::Literal& LiteralCollection::literals(int index) const {
  // @@protoc_insertion_point(field_get:flyteidl.core.LiteralCollection.literals)
  return literals_.Get(index);
}
inline ::flyteidl::core::Literal* LiteralCollection::add_literals() {
  // @@protoc_insertion_point(field_add:flyteidl.core.LiteralCollection.literals)
  return literals_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::flyteidl::core::Literal >&
LiteralCollection::literals() const {
  // @@protoc_insertion_point(field_list:flyteidl.core.LiteralCollection.literals)
  return literals_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// LiteralMap

// map<string, .flyteidl.core.Literal> literals = 1;
inline int LiteralMap::literals_size() const {
  return literals_.size();
}
inline void LiteralMap::clear_literals() {
  literals_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::flyteidl::core::Literal >&
LiteralMap::literals() const {
  // @@protoc_insertion_point(field_map:flyteidl.core.LiteralMap.literals)
  return literals_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::flyteidl::core::Literal >*
LiteralMap::mutable_literals() {
  // @@protoc_insertion_point(field_mutable_map:flyteidl.core.LiteralMap.literals)
  return literals_.MutableMap();
}

// -------------------------------------------------------------------

// BindingDataCollection

// repeated .flyteidl.core.BindingData bindings = 1;
inline int BindingDataCollection::bindings_size() const {
  return bindings_.size();
}
inline void BindingDataCollection::clear_bindings() {
  bindings_.Clear();
}
inline ::flyteidl::core::BindingData* BindingDataCollection::mutable_bindings(int index) {
  // @@protoc_insertion_point(field_mutable:flyteidl.core.BindingDataCollection.bindings)
  return bindings_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::flyteidl::core::BindingData >*
BindingDataCollection::mutable_bindings() {
  // @@protoc_insertion_point(field_mutable_list:flyteidl.core.BindingDataCollection.bindings)
  return &bindings_;
}
inline const ::flyteidl::core::BindingData& BindingDataCollection::bindings(int index) const {
  // @@protoc_insertion_point(field_get:flyteidl.core.BindingDataCollection.bindings)
  return bindings_.Get(index);
}
inline ::flyteidl::core::BindingData* BindingDataCollection::add_bindings() {
  // @@protoc_insertion_point(field_add:flyteidl.core.BindingDataCollection.bindings)
  return bindings_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::flyteidl::core::BindingData >&
BindingDataCollection::bindings() const {
  // @@protoc_insertion_point(field_list:flyteidl.core.BindingDataCollection.bindings)
  return bindings_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// BindingDataMap

// map<string, .flyteidl.core.BindingData> bindings = 1;
inline int BindingDataMap::bindings_size() const {
  return bindings_.size();
}
inline void BindingDataMap::clear_bindings() {
  bindings_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::flyteidl::core::BindingData >&
BindingDataMap::bindings() const {
  // @@protoc_insertion_point(field_map:flyteidl.core.BindingDataMap.bindings)
  return bindings_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::flyteidl::core::BindingData >*
BindingDataMap::mutable_bindings() {
  // @@protoc_insertion_point(field_mutable_map:flyteidl.core.BindingDataMap.bindings)
  return bindings_.MutableMap();
}

// -------------------------------------------------------------------

// BindingData

// .flyteidl.core.Scalar scalar = 1;
inline bool BindingData::has_scalar() const {
  return value_case() == kScalar;
}
inline void BindingData::set_has_scalar() {
  _oneof_case_[0] = kScalar;
}
inline void BindingData::clear_scalar() {
  if (has_scalar()) {
    delete value_.scalar_;
    clear_has_value();
  }
}
inline ::flyteidl::core::Scalar* BindingData::release_scalar() {
  // @@protoc_insertion_point(field_release:flyteidl.core.BindingData.scalar)
  if (has_scalar()) {
    clear_has_value();
      ::flyteidl::core::Scalar* temp = value_.scalar_;
    value_.scalar_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::core::Scalar& BindingData::scalar() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.BindingData.scalar)
  return has_scalar()
      ? *value_.scalar_
      : *reinterpret_cast< ::flyteidl::core::Scalar*>(&::flyteidl::core::_Scalar_default_instance_);
}
inline ::flyteidl::core::Scalar* BindingData::mutable_scalar() {
  if (!has_scalar()) {
    clear_value();
    set_has_scalar();
    value_.scalar_ = CreateMaybeMessage< ::flyteidl::core::Scalar >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.BindingData.scalar)
  return value_.scalar_;
}

// .flyteidl.core.BindingDataCollection collection = 2;
inline bool BindingData::has_collection() const {
  return value_case() == kCollection;
}
inline void BindingData::set_has_collection() {
  _oneof_case_[0] = kCollection;
}
inline void BindingData::clear_collection() {
  if (has_collection()) {
    delete value_.collection_;
    clear_has_value();
  }
}
inline ::flyteidl::core::BindingDataCollection* BindingData::release_collection() {
  // @@protoc_insertion_point(field_release:flyteidl.core.BindingData.collection)
  if (has_collection()) {
    clear_has_value();
      ::flyteidl::core::BindingDataCollection* temp = value_.collection_;
    value_.collection_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::core::BindingDataCollection& BindingData::collection() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.BindingData.collection)
  return has_collection()
      ? *value_.collection_
      : *reinterpret_cast< ::flyteidl::core::BindingDataCollection*>(&::flyteidl::core::_BindingDataCollection_default_instance_);
}
inline ::flyteidl::core::BindingDataCollection* BindingData::mutable_collection() {
  if (!has_collection()) {
    clear_value();
    set_has_collection();
    value_.collection_ = CreateMaybeMessage< ::flyteidl::core::BindingDataCollection >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.BindingData.collection)
  return value_.collection_;
}

// .flyteidl.core.OutputReference promise = 3;
inline bool BindingData::has_promise() const {
  return value_case() == kPromise;
}
inline void BindingData::set_has_promise() {
  _oneof_case_[0] = kPromise;
}
inline ::flyteidl::core::OutputReference* BindingData::release_promise() {
  // @@protoc_insertion_point(field_release:flyteidl.core.BindingData.promise)
  if (has_promise()) {
    clear_has_value();
      ::flyteidl::core::OutputReference* temp = value_.promise_;
    value_.promise_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::core::OutputReference& BindingData::promise() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.BindingData.promise)
  return has_promise()
      ? *value_.promise_
      : *reinterpret_cast< ::flyteidl::core::OutputReference*>(&::flyteidl::core::_OutputReference_default_instance_);
}
inline ::flyteidl::core::OutputReference* BindingData::mutable_promise() {
  if (!has_promise()) {
    clear_value();
    set_has_promise();
    value_.promise_ = CreateMaybeMessage< ::flyteidl::core::OutputReference >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.BindingData.promise)
  return value_.promise_;
}

// .flyteidl.core.BindingDataMap map = 4;
inline bool BindingData::has_map() const {
  return value_case() == kMap;
}
inline void BindingData::set_has_map() {
  _oneof_case_[0] = kMap;
}
inline void BindingData::clear_map() {
  if (has_map()) {
    delete value_.map_;
    clear_has_value();
  }
}
inline ::flyteidl::core::BindingDataMap* BindingData::release_map() {
  // @@protoc_insertion_point(field_release:flyteidl.core.BindingData.map)
  if (has_map()) {
    clear_has_value();
      ::flyteidl::core::BindingDataMap* temp = value_.map_;
    value_.map_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::core::BindingDataMap& BindingData::map() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.BindingData.map)
  return has_map()
      ? *value_.map_
      : *reinterpret_cast< ::flyteidl::core::BindingDataMap*>(&::flyteidl::core::_BindingDataMap_default_instance_);
}
inline ::flyteidl::core::BindingDataMap* BindingData::mutable_map() {
  if (!has_map()) {
    clear_value();
    set_has_map();
    value_.map_ = CreateMaybeMessage< ::flyteidl::core::BindingDataMap >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.BindingData.map)
  return value_.map_;
}

inline bool BindingData::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void BindingData::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline BindingData::ValueCase BindingData::value_case() const {
  return BindingData::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Binding

// string var = 1;
inline void Binding::clear_var() {
  var_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Binding::var() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Binding.var)
  return var_.GetNoArena();
}
inline void Binding::set_var(const ::std::string& value) {
  
  var_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.Binding.var)
}
#if LANG_CXX11
inline void Binding::set_var(::std::string&& value) {
  
  var_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.Binding.var)
}
#endif
inline void Binding::set_var(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  var_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.Binding.var)
}
inline void Binding::set_var(const char* value, size_t size) {
  
  var_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.Binding.var)
}
inline ::std::string* Binding::mutable_var() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Binding.var)
  return var_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Binding::release_var() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Binding.var)
  
  return var_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Binding::set_allocated_var(::std::string* var) {
  if (var != nullptr) {
    
  } else {
    
  }
  var_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), var);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.Binding.var)
}

// .flyteidl.core.BindingData binding = 2;
inline bool Binding::has_binding() const {
  return this != internal_default_instance() && binding_ != nullptr;
}
inline void Binding::clear_binding() {
  if (GetArenaNoVirtual() == nullptr && binding_ != nullptr) {
    delete binding_;
  }
  binding_ = nullptr;
}
inline const ::flyteidl::core::BindingData& Binding::binding() const {
  const ::flyteidl::core::BindingData* p = binding_;
  // @@protoc_insertion_point(field_get:flyteidl.core.Binding.binding)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::BindingData*>(
      &::flyteidl::core::_BindingData_default_instance_);
}
inline ::flyteidl::core::BindingData* Binding::release_binding() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Binding.binding)
  
  ::flyteidl::core::BindingData* temp = binding_;
  binding_ = nullptr;
  return temp;
}
inline ::flyteidl::core::BindingData* Binding::mutable_binding() {
  
  if (binding_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::BindingData>(GetArenaNoVirtual());
    binding_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Binding.binding)
  return binding_;
}
inline void Binding::set_allocated_binding(::flyteidl::core::BindingData* binding) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete binding_;
  }
  if (binding) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      binding = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, binding, submessage_arena);
    }
    
  } else {
    
  }
  binding_ = binding;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.Binding.binding)
}

// -------------------------------------------------------------------

// KeyValuePair

// string key = 1;
inline void KeyValuePair::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KeyValuePair::key() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.KeyValuePair.key)
  return key_.GetNoArena();
}
inline void KeyValuePair::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.KeyValuePair.key)
}
#if LANG_CXX11
inline void KeyValuePair::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.KeyValuePair.key)
}
#endif
inline void KeyValuePair::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.KeyValuePair.key)
}
inline void KeyValuePair::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.KeyValuePair.key)
}
inline ::std::string* KeyValuePair::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.KeyValuePair.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KeyValuePair::release_key() {
  // @@protoc_insertion_point(field_release:flyteidl.core.KeyValuePair.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyValuePair::set_allocated_key(::std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.KeyValuePair.key)
}

// string value = 2;
inline void KeyValuePair::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KeyValuePair::value() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.KeyValuePair.value)
  return value_.GetNoArena();
}
inline void KeyValuePair::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.KeyValuePair.value)
}
#if LANG_CXX11
inline void KeyValuePair::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.KeyValuePair.value)
}
#endif
inline void KeyValuePair::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.KeyValuePair.value)
}
inline void KeyValuePair::set_value(const char* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.KeyValuePair.value)
}
inline ::std::string* KeyValuePair::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.KeyValuePair.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KeyValuePair::release_value() {
  // @@protoc_insertion_point(field_release:flyteidl.core.KeyValuePair.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyValuePair::set_allocated_value(::std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.KeyValuePair.value)
}

// -------------------------------------------------------------------

// RetryStrategy

// uint32 retries = 5;
inline void RetryStrategy::clear_retries() {
  retries_ = 0u;
}
inline ::google::protobuf::uint32 RetryStrategy::retries() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.RetryStrategy.retries)
  return retries_;
}
inline void RetryStrategy::set_retries(::google::protobuf::uint32 value) {
  
  retries_ = value;
  // @@protoc_insertion_point(field_set:flyteidl.core.RetryStrategy.retries)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace core
}  // namespace flyteidl

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_flyteidl_2fcore_2fliterals_2eproto
