// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: flyteidl/core/tasks.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_flyteidl_2fcore_2ftasks_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_flyteidl_2fcore_2ftasks_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "flyteidl/core/identifier.pb.h"
#include "flyteidl/core/interface.pb.h"
#include "flyteidl/core/literals.pb.h"
#include "flyteidl/core/security.pb.h"
#include <google/protobuf/duration.pb.h>
#include <google/protobuf/struct.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_flyteidl_2fcore_2ftasks_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_flyteidl_2fcore_2ftasks_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[15]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_flyteidl_2fcore_2ftasks_2eproto;
namespace flyteidl {
namespace core {
class Container;
struct ContainerDefaultTypeInternal;
extern ContainerDefaultTypeInternal _Container_default_instance_;
class ContainerPort;
struct ContainerPortDefaultTypeInternal;
extern ContainerPortDefaultTypeInternal _ContainerPort_default_instance_;
class DataLoadingConfig;
struct DataLoadingConfigDefaultTypeInternal;
extern DataLoadingConfigDefaultTypeInternal _DataLoadingConfig_default_instance_;
class IOStrategy;
struct IOStrategyDefaultTypeInternal;
extern IOStrategyDefaultTypeInternal _IOStrategy_default_instance_;
class K8sObjectMetadata;
struct K8sObjectMetadataDefaultTypeInternal;
extern K8sObjectMetadataDefaultTypeInternal _K8sObjectMetadata_default_instance_;
class K8sObjectMetadata_AnnotationsEntry_DoNotUse;
struct K8sObjectMetadata_AnnotationsEntry_DoNotUseDefaultTypeInternal;
extern K8sObjectMetadata_AnnotationsEntry_DoNotUseDefaultTypeInternal _K8sObjectMetadata_AnnotationsEntry_DoNotUse_default_instance_;
class K8sObjectMetadata_LabelsEntry_DoNotUse;
struct K8sObjectMetadata_LabelsEntry_DoNotUseDefaultTypeInternal;
extern K8sObjectMetadata_LabelsEntry_DoNotUseDefaultTypeInternal _K8sObjectMetadata_LabelsEntry_DoNotUse_default_instance_;
class K8sPod;
struct K8sPodDefaultTypeInternal;
extern K8sPodDefaultTypeInternal _K8sPod_default_instance_;
class Resources;
struct ResourcesDefaultTypeInternal;
extern ResourcesDefaultTypeInternal _Resources_default_instance_;
class Resources_ResourceEntry;
struct Resources_ResourceEntryDefaultTypeInternal;
extern Resources_ResourceEntryDefaultTypeInternal _Resources_ResourceEntry_default_instance_;
class RuntimeMetadata;
struct RuntimeMetadataDefaultTypeInternal;
extern RuntimeMetadataDefaultTypeInternal _RuntimeMetadata_default_instance_;
class Sql;
struct SqlDefaultTypeInternal;
extern SqlDefaultTypeInternal _Sql_default_instance_;
class TaskMetadata;
struct TaskMetadataDefaultTypeInternal;
extern TaskMetadataDefaultTypeInternal _TaskMetadata_default_instance_;
class TaskTemplate;
struct TaskTemplateDefaultTypeInternal;
extern TaskTemplateDefaultTypeInternal _TaskTemplate_default_instance_;
class TaskTemplate_ConfigEntry_DoNotUse;
struct TaskTemplate_ConfigEntry_DoNotUseDefaultTypeInternal;
extern TaskTemplate_ConfigEntry_DoNotUseDefaultTypeInternal _TaskTemplate_ConfigEntry_DoNotUse_default_instance_;
}  // namespace core
}  // namespace flyteidl
PROTOBUF_NAMESPACE_OPEN
template<> ::flyteidl::core::Container* Arena::CreateMaybeMessage<::flyteidl::core::Container>(Arena*);
template<> ::flyteidl::core::ContainerPort* Arena::CreateMaybeMessage<::flyteidl::core::ContainerPort>(Arena*);
template<> ::flyteidl::core::DataLoadingConfig* Arena::CreateMaybeMessage<::flyteidl::core::DataLoadingConfig>(Arena*);
template<> ::flyteidl::core::IOStrategy* Arena::CreateMaybeMessage<::flyteidl::core::IOStrategy>(Arena*);
template<> ::flyteidl::core::K8sObjectMetadata* Arena::CreateMaybeMessage<::flyteidl::core::K8sObjectMetadata>(Arena*);
template<> ::flyteidl::core::K8sObjectMetadata_AnnotationsEntry_DoNotUse* Arena::CreateMaybeMessage<::flyteidl::core::K8sObjectMetadata_AnnotationsEntry_DoNotUse>(Arena*);
template<> ::flyteidl::core::K8sObjectMetadata_LabelsEntry_DoNotUse* Arena::CreateMaybeMessage<::flyteidl::core::K8sObjectMetadata_LabelsEntry_DoNotUse>(Arena*);
template<> ::flyteidl::core::K8sPod* Arena::CreateMaybeMessage<::flyteidl::core::K8sPod>(Arena*);
template<> ::flyteidl::core::Resources* Arena::CreateMaybeMessage<::flyteidl::core::Resources>(Arena*);
template<> ::flyteidl::core::Resources_ResourceEntry* Arena::CreateMaybeMessage<::flyteidl::core::Resources_ResourceEntry>(Arena*);
template<> ::flyteidl::core::RuntimeMetadata* Arena::CreateMaybeMessage<::flyteidl::core::RuntimeMetadata>(Arena*);
template<> ::flyteidl::core::Sql* Arena::CreateMaybeMessage<::flyteidl::core::Sql>(Arena*);
template<> ::flyteidl::core::TaskMetadata* Arena::CreateMaybeMessage<::flyteidl::core::TaskMetadata>(Arena*);
template<> ::flyteidl::core::TaskTemplate* Arena::CreateMaybeMessage<::flyteidl::core::TaskTemplate>(Arena*);
template<> ::flyteidl::core::TaskTemplate_ConfigEntry_DoNotUse* Arena::CreateMaybeMessage<::flyteidl::core::TaskTemplate_ConfigEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace flyteidl {
namespace core {

enum Resources_ResourceName : int {
  Resources_ResourceName_UNKNOWN = 0,
  Resources_ResourceName_CPU = 1,
  Resources_ResourceName_GPU = 2,
  Resources_ResourceName_MEMORY = 3,
  Resources_ResourceName_STORAGE = 4,
  Resources_ResourceName_EPHEMERAL_STORAGE = 5,
  Resources_ResourceName_Resources_ResourceName_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Resources_ResourceName_Resources_ResourceName_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Resources_ResourceName_IsValid(int value);
constexpr Resources_ResourceName Resources_ResourceName_ResourceName_MIN = Resources_ResourceName_UNKNOWN;
constexpr Resources_ResourceName Resources_ResourceName_ResourceName_MAX = Resources_ResourceName_EPHEMERAL_STORAGE;
constexpr int Resources_ResourceName_ResourceName_ARRAYSIZE = Resources_ResourceName_ResourceName_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Resources_ResourceName_descriptor();
template<typename T>
inline const std::string& Resources_ResourceName_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Resources_ResourceName>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Resources_ResourceName_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Resources_ResourceName_descriptor(), enum_t_value);
}
inline bool Resources_ResourceName_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Resources_ResourceName* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Resources_ResourceName>(
    Resources_ResourceName_descriptor(), name, value);
}
enum RuntimeMetadata_RuntimeType : int {
  RuntimeMetadata_RuntimeType_OTHER = 0,
  RuntimeMetadata_RuntimeType_FLYTE_SDK = 1,
  RuntimeMetadata_RuntimeType_RuntimeMetadata_RuntimeType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RuntimeMetadata_RuntimeType_RuntimeMetadata_RuntimeType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RuntimeMetadata_RuntimeType_IsValid(int value);
constexpr RuntimeMetadata_RuntimeType RuntimeMetadata_RuntimeType_RuntimeType_MIN = RuntimeMetadata_RuntimeType_OTHER;
constexpr RuntimeMetadata_RuntimeType RuntimeMetadata_RuntimeType_RuntimeType_MAX = RuntimeMetadata_RuntimeType_FLYTE_SDK;
constexpr int RuntimeMetadata_RuntimeType_RuntimeType_ARRAYSIZE = RuntimeMetadata_RuntimeType_RuntimeType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RuntimeMetadata_RuntimeType_descriptor();
template<typename T>
inline const std::string& RuntimeMetadata_RuntimeType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RuntimeMetadata_RuntimeType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RuntimeMetadata_RuntimeType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RuntimeMetadata_RuntimeType_descriptor(), enum_t_value);
}
inline bool RuntimeMetadata_RuntimeType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RuntimeMetadata_RuntimeType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RuntimeMetadata_RuntimeType>(
    RuntimeMetadata_RuntimeType_descriptor(), name, value);
}
enum Container_Architecture : int {
  Container_Architecture_UNKNOWN = 0,
  Container_Architecture_AMD64 = 1,
  Container_Architecture_ARM64 = 2,
  Container_Architecture_ARM_V6 = 3,
  Container_Architecture_ARM_V7 = 4,
  Container_Architecture_Container_Architecture_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Container_Architecture_Container_Architecture_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Container_Architecture_IsValid(int value);
constexpr Container_Architecture Container_Architecture_Architecture_MIN = Container_Architecture_UNKNOWN;
constexpr Container_Architecture Container_Architecture_Architecture_MAX = Container_Architecture_ARM_V7;
constexpr int Container_Architecture_Architecture_ARRAYSIZE = Container_Architecture_Architecture_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Container_Architecture_descriptor();
template<typename T>
inline const std::string& Container_Architecture_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Container_Architecture>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Container_Architecture_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Container_Architecture_descriptor(), enum_t_value);
}
inline bool Container_Architecture_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Container_Architecture* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Container_Architecture>(
    Container_Architecture_descriptor(), name, value);
}
enum IOStrategy_DownloadMode : int {
  IOStrategy_DownloadMode_DOWNLOAD_EAGER = 0,
  IOStrategy_DownloadMode_DOWNLOAD_STREAM = 1,
  IOStrategy_DownloadMode_DO_NOT_DOWNLOAD = 2,
  IOStrategy_DownloadMode_IOStrategy_DownloadMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  IOStrategy_DownloadMode_IOStrategy_DownloadMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool IOStrategy_DownloadMode_IsValid(int value);
constexpr IOStrategy_DownloadMode IOStrategy_DownloadMode_DownloadMode_MIN = IOStrategy_DownloadMode_DOWNLOAD_EAGER;
constexpr IOStrategy_DownloadMode IOStrategy_DownloadMode_DownloadMode_MAX = IOStrategy_DownloadMode_DO_NOT_DOWNLOAD;
constexpr int IOStrategy_DownloadMode_DownloadMode_ARRAYSIZE = IOStrategy_DownloadMode_DownloadMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* IOStrategy_DownloadMode_descriptor();
template<typename T>
inline const std::string& IOStrategy_DownloadMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, IOStrategy_DownloadMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function IOStrategy_DownloadMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    IOStrategy_DownloadMode_descriptor(), enum_t_value);
}
inline bool IOStrategy_DownloadMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, IOStrategy_DownloadMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<IOStrategy_DownloadMode>(
    IOStrategy_DownloadMode_descriptor(), name, value);
}
enum IOStrategy_UploadMode : int {
  IOStrategy_UploadMode_UPLOAD_ON_EXIT = 0,
  IOStrategy_UploadMode_UPLOAD_EAGER = 1,
  IOStrategy_UploadMode_DO_NOT_UPLOAD = 2,
  IOStrategy_UploadMode_IOStrategy_UploadMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  IOStrategy_UploadMode_IOStrategy_UploadMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool IOStrategy_UploadMode_IsValid(int value);
constexpr IOStrategy_UploadMode IOStrategy_UploadMode_UploadMode_MIN = IOStrategy_UploadMode_UPLOAD_ON_EXIT;
constexpr IOStrategy_UploadMode IOStrategy_UploadMode_UploadMode_MAX = IOStrategy_UploadMode_DO_NOT_UPLOAD;
constexpr int IOStrategy_UploadMode_UploadMode_ARRAYSIZE = IOStrategy_UploadMode_UploadMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* IOStrategy_UploadMode_descriptor();
template<typename T>
inline const std::string& IOStrategy_UploadMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, IOStrategy_UploadMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function IOStrategy_UploadMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    IOStrategy_UploadMode_descriptor(), enum_t_value);
}
inline bool IOStrategy_UploadMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, IOStrategy_UploadMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<IOStrategy_UploadMode>(
    IOStrategy_UploadMode_descriptor(), name, value);
}
enum DataLoadingConfig_LiteralMapFormat : int {
  DataLoadingConfig_LiteralMapFormat_JSON = 0,
  DataLoadingConfig_LiteralMapFormat_YAML = 1,
  DataLoadingConfig_LiteralMapFormat_PROTO = 2,
  DataLoadingConfig_LiteralMapFormat_DataLoadingConfig_LiteralMapFormat_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DataLoadingConfig_LiteralMapFormat_DataLoadingConfig_LiteralMapFormat_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DataLoadingConfig_LiteralMapFormat_IsValid(int value);
constexpr DataLoadingConfig_LiteralMapFormat DataLoadingConfig_LiteralMapFormat_LiteralMapFormat_MIN = DataLoadingConfig_LiteralMapFormat_JSON;
constexpr DataLoadingConfig_LiteralMapFormat DataLoadingConfig_LiteralMapFormat_LiteralMapFormat_MAX = DataLoadingConfig_LiteralMapFormat_PROTO;
constexpr int DataLoadingConfig_LiteralMapFormat_LiteralMapFormat_ARRAYSIZE = DataLoadingConfig_LiteralMapFormat_LiteralMapFormat_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DataLoadingConfig_LiteralMapFormat_descriptor();
template<typename T>
inline const std::string& DataLoadingConfig_LiteralMapFormat_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DataLoadingConfig_LiteralMapFormat>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DataLoadingConfig_LiteralMapFormat_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DataLoadingConfig_LiteralMapFormat_descriptor(), enum_t_value);
}
inline bool DataLoadingConfig_LiteralMapFormat_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DataLoadingConfig_LiteralMapFormat* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DataLoadingConfig_LiteralMapFormat>(
    DataLoadingConfig_LiteralMapFormat_descriptor(), name, value);
}
enum Sql_Dialect : int {
  Sql_Dialect_UNDEFINED = 0,
  Sql_Dialect_ANSI = 1,
  Sql_Dialect_HIVE = 2,
  Sql_Dialect_OTHER = 3,
  Sql_Dialect_Sql_Dialect_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Sql_Dialect_Sql_Dialect_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Sql_Dialect_IsValid(int value);
constexpr Sql_Dialect Sql_Dialect_Dialect_MIN = Sql_Dialect_UNDEFINED;
constexpr Sql_Dialect Sql_Dialect_Dialect_MAX = Sql_Dialect_OTHER;
constexpr int Sql_Dialect_Dialect_ARRAYSIZE = Sql_Dialect_Dialect_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Sql_Dialect_descriptor();
template<typename T>
inline const std::string& Sql_Dialect_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Sql_Dialect>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Sql_Dialect_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Sql_Dialect_descriptor(), enum_t_value);
}
inline bool Sql_Dialect_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Sql_Dialect* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Sql_Dialect>(
    Sql_Dialect_descriptor(), name, value);
}
// ===================================================================

class Resources_ResourceEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.Resources.ResourceEntry) */ {
 public:
  inline Resources_ResourceEntry() : Resources_ResourceEntry(nullptr) {}
  ~Resources_ResourceEntry() override;
  explicit constexpr Resources_ResourceEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Resources_ResourceEntry(const Resources_ResourceEntry& from);
  Resources_ResourceEntry(Resources_ResourceEntry&& from) noexcept
    : Resources_ResourceEntry() {
    *this = ::std::move(from);
  }

  inline Resources_ResourceEntry& operator=(const Resources_ResourceEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline Resources_ResourceEntry& operator=(Resources_ResourceEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Resources_ResourceEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const Resources_ResourceEntry* internal_default_instance() {
    return reinterpret_cast<const Resources_ResourceEntry*>(
               &_Resources_ResourceEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Resources_ResourceEntry& a, Resources_ResourceEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(Resources_ResourceEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Resources_ResourceEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Resources_ResourceEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Resources_ResourceEntry>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Resources_ResourceEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.core.Resources.ResourceEntry";
  }
  protected:
  explicit Resources_ResourceEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 2,
    kNameFieldNumber = 1,
  };
  // string value = 2 [json_name = "value"];
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // .flyteidl.core.Resources.ResourceName name = 1 [json_name = "name"];
  void clear_name();
  ::flyteidl::core::Resources_ResourceName name() const;
  void set_name(::flyteidl::core::Resources_ResourceName value);
  private:
  ::flyteidl::core::Resources_ResourceName _internal_name() const;
  void _internal_set_name(::flyteidl::core::Resources_ResourceName value);
  public:

  // @@protoc_insertion_point(class_scope:flyteidl.core.Resources.ResourceEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  int name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2ftasks_2eproto;
};
// -------------------------------------------------------------------

class Resources final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.Resources) */ {
 public:
  inline Resources() : Resources(nullptr) {}
  ~Resources() override;
  explicit constexpr Resources(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Resources(const Resources& from);
  Resources(Resources&& from) noexcept
    : Resources() {
    *this = ::std::move(from);
  }

  inline Resources& operator=(const Resources& from) {
    CopyFrom(from);
    return *this;
  }
  inline Resources& operator=(Resources&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Resources& default_instance() {
    return *internal_default_instance();
  }
  static inline const Resources* internal_default_instance() {
    return reinterpret_cast<const Resources*>(
               &_Resources_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Resources& a, Resources& b) {
    a.Swap(&b);
  }
  inline void Swap(Resources* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Resources* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Resources* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Resources>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Resources* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.core.Resources";
  }
  protected:
  explicit Resources(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Resources_ResourceEntry ResourceEntry;

  typedef Resources_ResourceName ResourceName;
  static constexpr ResourceName UNKNOWN =
    Resources_ResourceName_UNKNOWN;
  static constexpr ResourceName CPU =
    Resources_ResourceName_CPU;
  static constexpr ResourceName GPU =
    Resources_ResourceName_GPU;
  static constexpr ResourceName MEMORY =
    Resources_ResourceName_MEMORY;
  static constexpr ResourceName STORAGE =
    Resources_ResourceName_STORAGE;
  static constexpr ResourceName EPHEMERAL_STORAGE =
    Resources_ResourceName_EPHEMERAL_STORAGE;
  static inline bool ResourceName_IsValid(int value) {
    return Resources_ResourceName_IsValid(value);
  }
  static constexpr ResourceName ResourceName_MIN =
    Resources_ResourceName_ResourceName_MIN;
  static constexpr ResourceName ResourceName_MAX =
    Resources_ResourceName_ResourceName_MAX;
  static constexpr int ResourceName_ARRAYSIZE =
    Resources_ResourceName_ResourceName_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ResourceName_descriptor() {
    return Resources_ResourceName_descriptor();
  }
  template<typename T>
  static inline const std::string& ResourceName_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ResourceName>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ResourceName_Name.");
    return Resources_ResourceName_Name(enum_t_value);
  }
  static inline bool ResourceName_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ResourceName* value) {
    return Resources_ResourceName_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRequestsFieldNumber = 1,
    kLimitsFieldNumber = 2,
  };
  // repeated .flyteidl.core.Resources.ResourceEntry requests = 1 [json_name = "requests"];
  int requests_size() const;
  private:
  int _internal_requests_size() const;
  public:
  void clear_requests();
  ::flyteidl::core::Resources_ResourceEntry* mutable_requests(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::core::Resources_ResourceEntry >*
      mutable_requests();
  private:
  const ::flyteidl::core::Resources_ResourceEntry& _internal_requests(int index) const;
  ::flyteidl::core::Resources_ResourceEntry* _internal_add_requests();
  public:
  const ::flyteidl::core::Resources_ResourceEntry& requests(int index) const;
  ::flyteidl::core::Resources_ResourceEntry* add_requests();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::core::Resources_ResourceEntry >&
      requests() const;

  // repeated .flyteidl.core.Resources.ResourceEntry limits = 2 [json_name = "limits"];
  int limits_size() const;
  private:
  int _internal_limits_size() const;
  public:
  void clear_limits();
  ::flyteidl::core::Resources_ResourceEntry* mutable_limits(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::core::Resources_ResourceEntry >*
      mutable_limits();
  private:
  const ::flyteidl::core::Resources_ResourceEntry& _internal_limits(int index) const;
  ::flyteidl::core::Resources_ResourceEntry* _internal_add_limits();
  public:
  const ::flyteidl::core::Resources_ResourceEntry& limits(int index) const;
  ::flyteidl::core::Resources_ResourceEntry* add_limits();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::core::Resources_ResourceEntry >&
      limits() const;

  // @@protoc_insertion_point(class_scope:flyteidl.core.Resources)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::core::Resources_ResourceEntry > requests_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::core::Resources_ResourceEntry > limits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2ftasks_2eproto;
};
// -------------------------------------------------------------------

class RuntimeMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.RuntimeMetadata) */ {
 public:
  inline RuntimeMetadata() : RuntimeMetadata(nullptr) {}
  ~RuntimeMetadata() override;
  explicit constexpr RuntimeMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RuntimeMetadata(const RuntimeMetadata& from);
  RuntimeMetadata(RuntimeMetadata&& from) noexcept
    : RuntimeMetadata() {
    *this = ::std::move(from);
  }

  inline RuntimeMetadata& operator=(const RuntimeMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline RuntimeMetadata& operator=(RuntimeMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RuntimeMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const RuntimeMetadata* internal_default_instance() {
    return reinterpret_cast<const RuntimeMetadata*>(
               &_RuntimeMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RuntimeMetadata& a, RuntimeMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(RuntimeMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RuntimeMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RuntimeMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RuntimeMetadata>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RuntimeMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.core.RuntimeMetadata";
  }
  protected:
  explicit RuntimeMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RuntimeMetadata_RuntimeType RuntimeType;
  static constexpr RuntimeType OTHER =
    RuntimeMetadata_RuntimeType_OTHER;
  static constexpr RuntimeType FLYTE_SDK =
    RuntimeMetadata_RuntimeType_FLYTE_SDK;
  static inline bool RuntimeType_IsValid(int value) {
    return RuntimeMetadata_RuntimeType_IsValid(value);
  }
  static constexpr RuntimeType RuntimeType_MIN =
    RuntimeMetadata_RuntimeType_RuntimeType_MIN;
  static constexpr RuntimeType RuntimeType_MAX =
    RuntimeMetadata_RuntimeType_RuntimeType_MAX;
  static constexpr int RuntimeType_ARRAYSIZE =
    RuntimeMetadata_RuntimeType_RuntimeType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  RuntimeType_descriptor() {
    return RuntimeMetadata_RuntimeType_descriptor();
  }
  template<typename T>
  static inline const std::string& RuntimeType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RuntimeType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RuntimeType_Name.");
    return RuntimeMetadata_RuntimeType_Name(enum_t_value);
  }
  static inline bool RuntimeType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      RuntimeType* value) {
    return RuntimeMetadata_RuntimeType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 2,
    kFlavorFieldNumber = 3,
    kTypeFieldNumber = 1,
  };
  // string version = 2 [json_name = "version"];
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string flavor = 3 [json_name = "flavor"];
  void clear_flavor();
  const std::string& flavor() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_flavor(ArgT0&& arg0, ArgT... args);
  std::string* mutable_flavor();
  PROTOBUF_NODISCARD std::string* release_flavor();
  void set_allocated_flavor(std::string* flavor);
  private:
  const std::string& _internal_flavor() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_flavor(const std::string& value);
  std::string* _internal_mutable_flavor();
  public:

  // .flyteidl.core.RuntimeMetadata.RuntimeType type = 1 [json_name = "type"];
  void clear_type();
  ::flyteidl::core::RuntimeMetadata_RuntimeType type() const;
  void set_type(::flyteidl::core::RuntimeMetadata_RuntimeType value);
  private:
  ::flyteidl::core::RuntimeMetadata_RuntimeType _internal_type() const;
  void _internal_set_type(::flyteidl::core::RuntimeMetadata_RuntimeType value);
  public:

  // @@protoc_insertion_point(class_scope:flyteidl.core.RuntimeMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr flavor_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2ftasks_2eproto;
};
// -------------------------------------------------------------------

class TaskMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.TaskMetadata) */ {
 public:
  inline TaskMetadata() : TaskMetadata(nullptr) {}
  ~TaskMetadata() override;
  explicit constexpr TaskMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TaskMetadata(const TaskMetadata& from);
  TaskMetadata(TaskMetadata&& from) noexcept
    : TaskMetadata() {
    *this = ::std::move(from);
  }

  inline TaskMetadata& operator=(const TaskMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskMetadata& operator=(TaskMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskMetadata& default_instance() {
    return *internal_default_instance();
  }
  enum InterruptibleValueCase {
    kInterruptible = 8,
    INTERRUPTIBLE_VALUE_NOT_SET = 0,
  };

  static inline const TaskMetadata* internal_default_instance() {
    return reinterpret_cast<const TaskMetadata*>(
               &_TaskMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(TaskMetadata& a, TaskMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TaskMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TaskMetadata>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.core.TaskMetadata";
  }
  protected:
  explicit TaskMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDiscoveryVersionFieldNumber = 6,
    kDeprecatedErrorMessageFieldNumber = 7,
    kRuntimeFieldNumber = 2,
    kTimeoutFieldNumber = 4,
    kRetriesFieldNumber = 5,
    kDiscoverableFieldNumber = 1,
    kCacheSerializableFieldNumber = 9,
    kInterruptibleFieldNumber = 8,
  };
  // string discovery_version = 6 [json_name = "discoveryVersion"];
  void clear_discovery_version();
  const std::string& discovery_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_discovery_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_discovery_version();
  PROTOBUF_NODISCARD std::string* release_discovery_version();
  void set_allocated_discovery_version(std::string* discovery_version);
  private:
  const std::string& _internal_discovery_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_discovery_version(const std::string& value);
  std::string* _internal_mutable_discovery_version();
  public:

  // string deprecated_error_message = 7 [json_name = "deprecatedErrorMessage"];
  void clear_deprecated_error_message();
  const std::string& deprecated_error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_deprecated_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_deprecated_error_message();
  PROTOBUF_NODISCARD std::string* release_deprecated_error_message();
  void set_allocated_deprecated_error_message(std::string* deprecated_error_message);
  private:
  const std::string& _internal_deprecated_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_deprecated_error_message(const std::string& value);
  std::string* _internal_mutable_deprecated_error_message();
  public:

  // .flyteidl.core.RuntimeMetadata runtime = 2 [json_name = "runtime"];
  bool has_runtime() const;
  private:
  bool _internal_has_runtime() const;
  public:
  void clear_runtime();
  const ::flyteidl::core::RuntimeMetadata& runtime() const;
  PROTOBUF_NODISCARD ::flyteidl::core::RuntimeMetadata* release_runtime();
  ::flyteidl::core::RuntimeMetadata* mutable_runtime();
  void set_allocated_runtime(::flyteidl::core::RuntimeMetadata* runtime);
  private:
  const ::flyteidl::core::RuntimeMetadata& _internal_runtime() const;
  ::flyteidl::core::RuntimeMetadata* _internal_mutable_runtime();
  public:
  void unsafe_arena_set_allocated_runtime(
      ::flyteidl::core::RuntimeMetadata* runtime);
  ::flyteidl::core::RuntimeMetadata* unsafe_arena_release_runtime();

  // .google.protobuf.Duration timeout = 4 [json_name = "timeout"];
  bool has_timeout() const;
  private:
  bool _internal_has_timeout() const;
  public:
  void clear_timeout();
  const ::PROTOBUF_NAMESPACE_ID::Duration& timeout() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_timeout();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_timeout();
  void set_allocated_timeout(::PROTOBUF_NAMESPACE_ID::Duration* timeout);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_timeout() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_timeout();
  public:
  void unsafe_arena_set_allocated_timeout(
      ::PROTOBUF_NAMESPACE_ID::Duration* timeout);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_timeout();

  // .flyteidl.core.RetryStrategy retries = 5 [json_name = "retries"];
  bool has_retries() const;
  private:
  bool _internal_has_retries() const;
  public:
  void clear_retries();
  const ::flyteidl::core::RetryStrategy& retries() const;
  PROTOBUF_NODISCARD ::flyteidl::core::RetryStrategy* release_retries();
  ::flyteidl::core::RetryStrategy* mutable_retries();
  void set_allocated_retries(::flyteidl::core::RetryStrategy* retries);
  private:
  const ::flyteidl::core::RetryStrategy& _internal_retries() const;
  ::flyteidl::core::RetryStrategy* _internal_mutable_retries();
  public:
  void unsafe_arena_set_allocated_retries(
      ::flyteidl::core::RetryStrategy* retries);
  ::flyteidl::core::RetryStrategy* unsafe_arena_release_retries();

  // bool discoverable = 1 [json_name = "discoverable"];
  void clear_discoverable();
  bool discoverable() const;
  void set_discoverable(bool value);
  private:
  bool _internal_discoverable() const;
  void _internal_set_discoverable(bool value);
  public:

  // bool cache_serializable = 9 [json_name = "cacheSerializable"];
  void clear_cache_serializable();
  bool cache_serializable() const;
  void set_cache_serializable(bool value);
  private:
  bool _internal_cache_serializable() const;
  void _internal_set_cache_serializable(bool value);
  public:

  // bool interruptible = 8 [json_name = "interruptible"];
  bool has_interruptible() const;
  private:
  bool _internal_has_interruptible() const;
  public:
  void clear_interruptible();
  bool interruptible() const;
  void set_interruptible(bool value);
  private:
  bool _internal_interruptible() const;
  void _internal_set_interruptible(bool value);
  public:

  void clear_interruptible_value();
  InterruptibleValueCase interruptible_value_case() const;
  // @@protoc_insertion_point(class_scope:flyteidl.core.TaskMetadata)
 private:
  class _Internal;
  void set_has_interruptible();

  inline bool has_interruptible_value() const;
  inline void clear_has_interruptible_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr discovery_version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr deprecated_error_message_;
  ::flyteidl::core::RuntimeMetadata* runtime_;
  ::PROTOBUF_NAMESPACE_ID::Duration* timeout_;
  ::flyteidl::core::RetryStrategy* retries_;
  bool discoverable_;
  bool cache_serializable_;
  union InterruptibleValueUnion {
    constexpr InterruptibleValueUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    bool interruptible_;
  } interruptible_value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_flyteidl_2fcore_2ftasks_2eproto;
};
// -------------------------------------------------------------------

class TaskTemplate_ConfigEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TaskTemplate_ConfigEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TaskTemplate_ConfigEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  TaskTemplate_ConfigEntry_DoNotUse();
  explicit constexpr TaskTemplate_ConfigEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit TaskTemplate_ConfigEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const TaskTemplate_ConfigEntry_DoNotUse& other);
  static const TaskTemplate_ConfigEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TaskTemplate_ConfigEntry_DoNotUse*>(&_TaskTemplate_ConfigEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "flyteidl.core.TaskTemplate.ConfigEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "flyteidl.core.TaskTemplate.ConfigEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class TaskTemplate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.TaskTemplate) */ {
 public:
  inline TaskTemplate() : TaskTemplate(nullptr) {}
  ~TaskTemplate() override;
  explicit constexpr TaskTemplate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TaskTemplate(const TaskTemplate& from);
  TaskTemplate(TaskTemplate&& from) noexcept
    : TaskTemplate() {
    *this = ::std::move(from);
  }

  inline TaskTemplate& operator=(const TaskTemplate& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskTemplate& operator=(TaskTemplate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskTemplate& default_instance() {
    return *internal_default_instance();
  }
  enum TargetCase {
    kContainer = 6,
    kK8SPod = 17,
    kSql = 18,
    TARGET_NOT_SET = 0,
  };

  static inline const TaskTemplate* internal_default_instance() {
    return reinterpret_cast<const TaskTemplate*>(
               &_TaskTemplate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(TaskTemplate& a, TaskTemplate& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskTemplate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskTemplate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TaskTemplate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TaskTemplate>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskTemplate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.core.TaskTemplate";
  }
  protected:
  explicit TaskTemplate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kConfigFieldNumber = 16,
    kTypeFieldNumber = 2,
    kIdFieldNumber = 1,
    kMetadataFieldNumber = 3,
    kInterfaceFieldNumber = 4,
    kCustomFieldNumber = 5,
    kSecurityContextFieldNumber = 8,
    kTaskTypeVersionFieldNumber = 7,
    kContainerFieldNumber = 6,
    kK8SPodFieldNumber = 17,
    kSqlFieldNumber = 18,
  };
  // map<string, string> config = 16 [json_name = "config"];
  int config_size() const;
  private:
  int _internal_config_size() const;
  public:
  void clear_config();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_config() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_config();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      config() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_config();

  // string type = 2 [json_name = "type"];
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // .flyteidl.core.Identifier id = 1 [json_name = "id"];
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::flyteidl::core::Identifier& id() const;
  PROTOBUF_NODISCARD ::flyteidl::core::Identifier* release_id();
  ::flyteidl::core::Identifier* mutable_id();
  void set_allocated_id(::flyteidl::core::Identifier* id);
  private:
  const ::flyteidl::core::Identifier& _internal_id() const;
  ::flyteidl::core::Identifier* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::flyteidl::core::Identifier* id);
  ::flyteidl::core::Identifier* unsafe_arena_release_id();

  // .flyteidl.core.TaskMetadata metadata = 3 [json_name = "metadata"];
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::flyteidl::core::TaskMetadata& metadata() const;
  PROTOBUF_NODISCARD ::flyteidl::core::TaskMetadata* release_metadata();
  ::flyteidl::core::TaskMetadata* mutable_metadata();
  void set_allocated_metadata(::flyteidl::core::TaskMetadata* metadata);
  private:
  const ::flyteidl::core::TaskMetadata& _internal_metadata() const;
  ::flyteidl::core::TaskMetadata* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::flyteidl::core::TaskMetadata* metadata);
  ::flyteidl::core::TaskMetadata* unsafe_arena_release_metadata();

  // .flyteidl.core.TypedInterface interface = 4 [json_name = "interface"];
  bool has_interface() const;
  private:
  bool _internal_has_interface() const;
  public:
  void clear_interface();
  const ::flyteidl::core::TypedInterface& interface() const;
  PROTOBUF_NODISCARD ::flyteidl::core::TypedInterface* release_interface();
  ::flyteidl::core::TypedInterface* mutable_interface();
  void set_allocated_interface(::flyteidl::core::TypedInterface* interface);
  private:
  const ::flyteidl::core::TypedInterface& _internal_interface() const;
  ::flyteidl::core::TypedInterface* _internal_mutable_interface();
  public:
  void unsafe_arena_set_allocated_interface(
      ::flyteidl::core::TypedInterface* interface);
  ::flyteidl::core::TypedInterface* unsafe_arena_release_interface();

  // .google.protobuf.Struct custom = 5 [json_name = "custom"];
  bool has_custom() const;
  private:
  bool _internal_has_custom() const;
  public:
  void clear_custom();
  const ::PROTOBUF_NAMESPACE_ID::Struct& custom() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_custom();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_custom();
  void set_allocated_custom(::PROTOBUF_NAMESPACE_ID::Struct* custom);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_custom() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_custom();
  public:
  void unsafe_arena_set_allocated_custom(
      ::PROTOBUF_NAMESPACE_ID::Struct* custom);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_custom();

  // .flyteidl.core.SecurityContext security_context = 8 [json_name = "securityContext"];
  bool has_security_context() const;
  private:
  bool _internal_has_security_context() const;
  public:
  void clear_security_context();
  const ::flyteidl::core::SecurityContext& security_context() const;
  PROTOBUF_NODISCARD ::flyteidl::core::SecurityContext* release_security_context();
  ::flyteidl::core::SecurityContext* mutable_security_context();
  void set_allocated_security_context(::flyteidl::core::SecurityContext* security_context);
  private:
  const ::flyteidl::core::SecurityContext& _internal_security_context() const;
  ::flyteidl::core::SecurityContext* _internal_mutable_security_context();
  public:
  void unsafe_arena_set_allocated_security_context(
      ::flyteidl::core::SecurityContext* security_context);
  ::flyteidl::core::SecurityContext* unsafe_arena_release_security_context();

  // int32 task_type_version = 7 [json_name = "taskTypeVersion"];
  void clear_task_type_version();
  int32_t task_type_version() const;
  void set_task_type_version(int32_t value);
  private:
  int32_t _internal_task_type_version() const;
  void _internal_set_task_type_version(int32_t value);
  public:

  // .flyteidl.core.Container container = 6 [json_name = "container"];
  bool has_container() const;
  private:
  bool _internal_has_container() const;
  public:
  void clear_container();
  const ::flyteidl::core::Container& container() const;
  PROTOBUF_NODISCARD ::flyteidl::core::Container* release_container();
  ::flyteidl::core::Container* mutable_container();
  void set_allocated_container(::flyteidl::core::Container* container);
  private:
  const ::flyteidl::core::Container& _internal_container() const;
  ::flyteidl::core::Container* _internal_mutable_container();
  public:
  void unsafe_arena_set_allocated_container(
      ::flyteidl::core::Container* container);
  ::flyteidl::core::Container* unsafe_arena_release_container();

  // .flyteidl.core.K8sPod k8s_pod = 17 [json_name = "k8sPod"];
  bool has_k8s_pod() const;
  private:
  bool _internal_has_k8s_pod() const;
  public:
  void clear_k8s_pod();
  const ::flyteidl::core::K8sPod& k8s_pod() const;
  PROTOBUF_NODISCARD ::flyteidl::core::K8sPod* release_k8s_pod();
  ::flyteidl::core::K8sPod* mutable_k8s_pod();
  void set_allocated_k8s_pod(::flyteidl::core::K8sPod* k8s_pod);
  private:
  const ::flyteidl::core::K8sPod& _internal_k8s_pod() const;
  ::flyteidl::core::K8sPod* _internal_mutable_k8s_pod();
  public:
  void unsafe_arena_set_allocated_k8s_pod(
      ::flyteidl::core::K8sPod* k8s_pod);
  ::flyteidl::core::K8sPod* unsafe_arena_release_k8s_pod();

  // .flyteidl.core.Sql sql = 18 [json_name = "sql"];
  bool has_sql() const;
  private:
  bool _internal_has_sql() const;
  public:
  void clear_sql();
  const ::flyteidl::core::Sql& sql() const;
  PROTOBUF_NODISCARD ::flyteidl::core::Sql* release_sql();
  ::flyteidl::core::Sql* mutable_sql();
  void set_allocated_sql(::flyteidl::core::Sql* sql);
  private:
  const ::flyteidl::core::Sql& _internal_sql() const;
  ::flyteidl::core::Sql* _internal_mutable_sql();
  public:
  void unsafe_arena_set_allocated_sql(
      ::flyteidl::core::Sql* sql);
  ::flyteidl::core::Sql* unsafe_arena_release_sql();

  void clear_target();
  TargetCase target_case() const;
  // @@protoc_insertion_point(class_scope:flyteidl.core.TaskTemplate)
 private:
  class _Internal;
  void set_has_container();
  void set_has_k8s_pod();
  void set_has_sql();

  inline bool has_target() const;
  inline void clear_has_target();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      TaskTemplate_ConfigEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> config_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  ::flyteidl::core::Identifier* id_;
  ::flyteidl::core::TaskMetadata* metadata_;
  ::flyteidl::core::TypedInterface* interface_;
  ::PROTOBUF_NAMESPACE_ID::Struct* custom_;
  ::flyteidl::core::SecurityContext* security_context_;
  int32_t task_type_version_;
  union TargetUnion {
    constexpr TargetUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::flyteidl::core::Container* container_;
    ::flyteidl::core::K8sPod* k8s_pod_;
    ::flyteidl::core::Sql* sql_;
  } target_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_flyteidl_2fcore_2ftasks_2eproto;
};
// -------------------------------------------------------------------

class ContainerPort final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.ContainerPort) */ {
 public:
  inline ContainerPort() : ContainerPort(nullptr) {}
  ~ContainerPort() override;
  explicit constexpr ContainerPort(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContainerPort(const ContainerPort& from);
  ContainerPort(ContainerPort&& from) noexcept
    : ContainerPort() {
    *this = ::std::move(from);
  }

  inline ContainerPort& operator=(const ContainerPort& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContainerPort& operator=(ContainerPort&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContainerPort& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContainerPort* internal_default_instance() {
    return reinterpret_cast<const ContainerPort*>(
               &_ContainerPort_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ContainerPort& a, ContainerPort& b) {
    a.Swap(&b);
  }
  inline void Swap(ContainerPort* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContainerPort* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContainerPort* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContainerPort>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContainerPort* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.core.ContainerPort";
  }
  protected:
  explicit ContainerPort(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContainerPortFieldNumber = 1,
  };
  // uint32 container_port = 1 [json_name = "containerPort"];
  void clear_container_port();
  uint32_t container_port() const;
  void set_container_port(uint32_t value);
  private:
  uint32_t _internal_container_port() const;
  void _internal_set_container_port(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:flyteidl.core.ContainerPort)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t container_port_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2ftasks_2eproto;
};
// -------------------------------------------------------------------

class Container final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.Container) */ {
 public:
  inline Container() : Container(nullptr) {}
  ~Container() override;
  explicit constexpr Container(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Container(const Container& from);
  Container(Container&& from) noexcept
    : Container() {
    *this = ::std::move(from);
  }

  inline Container& operator=(const Container& from) {
    CopyFrom(from);
    return *this;
  }
  inline Container& operator=(Container&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Container& default_instance() {
    return *internal_default_instance();
  }
  static inline const Container* internal_default_instance() {
    return reinterpret_cast<const Container*>(
               &_Container_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Container& a, Container& b) {
    a.Swap(&b);
  }
  inline void Swap(Container* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Container* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Container* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Container>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Container* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.core.Container";
  }
  protected:
  explicit Container(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Container_Architecture Architecture;
  static constexpr Architecture UNKNOWN =
    Container_Architecture_UNKNOWN;
  static constexpr Architecture AMD64 =
    Container_Architecture_AMD64;
  static constexpr Architecture ARM64 =
    Container_Architecture_ARM64;
  static constexpr Architecture ARM_V6 =
    Container_Architecture_ARM_V6;
  static constexpr Architecture ARM_V7 =
    Container_Architecture_ARM_V7;
  static inline bool Architecture_IsValid(int value) {
    return Container_Architecture_IsValid(value);
  }
  static constexpr Architecture Architecture_MIN =
    Container_Architecture_Architecture_MIN;
  static constexpr Architecture Architecture_MAX =
    Container_Architecture_Architecture_MAX;
  static constexpr int Architecture_ARRAYSIZE =
    Container_Architecture_Architecture_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Architecture_descriptor() {
    return Container_Architecture_descriptor();
  }
  template<typename T>
  static inline const std::string& Architecture_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Architecture>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Architecture_Name.");
    return Container_Architecture_Name(enum_t_value);
  }
  static inline bool Architecture_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Architecture* value) {
    return Container_Architecture_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCommandFieldNumber = 2,
    kArgsFieldNumber = 3,
    kEnvFieldNumber = 5,
    kConfigFieldNumber = 6,
    kPortsFieldNumber = 7,
    kImageFieldNumber = 1,
    kResourcesFieldNumber = 4,
    kDataConfigFieldNumber = 9,
    kArchitectureFieldNumber = 10,
  };
  // repeated string command = 2 [json_name = "command"];
  int command_size() const;
  private:
  int _internal_command_size() const;
  public:
  void clear_command();
  const std::string& command(int index) const;
  std::string* mutable_command(int index);
  void set_command(int index, const std::string& value);
  void set_command(int index, std::string&& value);
  void set_command(int index, const char* value);
  void set_command(int index, const char* value, size_t size);
  std::string* add_command();
  void add_command(const std::string& value);
  void add_command(std::string&& value);
  void add_command(const char* value);
  void add_command(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& command() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_command();
  private:
  const std::string& _internal_command(int index) const;
  std::string* _internal_add_command();
  public:

  // repeated string args = 3 [json_name = "args"];
  int args_size() const;
  private:
  int _internal_args_size() const;
  public:
  void clear_args();
  const std::string& args(int index) const;
  std::string* mutable_args(int index);
  void set_args(int index, const std::string& value);
  void set_args(int index, std::string&& value);
  void set_args(int index, const char* value);
  void set_args(int index, const char* value, size_t size);
  std::string* add_args();
  void add_args(const std::string& value);
  void add_args(std::string&& value);
  void add_args(const char* value);
  void add_args(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& args() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_args();
  private:
  const std::string& _internal_args(int index) const;
  std::string* _internal_add_args();
  public:

  // repeated .flyteidl.core.KeyValuePair env = 5 [json_name = "env"];
  int env_size() const;
  private:
  int _internal_env_size() const;
  public:
  void clear_env();
  ::flyteidl::core::KeyValuePair* mutable_env(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::core::KeyValuePair >*
      mutable_env();
  private:
  const ::flyteidl::core::KeyValuePair& _internal_env(int index) const;
  ::flyteidl::core::KeyValuePair* _internal_add_env();
  public:
  const ::flyteidl::core::KeyValuePair& env(int index) const;
  ::flyteidl::core::KeyValuePair* add_env();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::core::KeyValuePair >&
      env() const;

  // repeated .flyteidl.core.KeyValuePair config = 6 [json_name = "config", deprecated = true];
  PROTOBUF_DEPRECATED int config_size() const;
  private:
  int _internal_config_size() const;
  public:
  PROTOBUF_DEPRECATED void clear_config();
  PROTOBUF_DEPRECATED ::flyteidl::core::KeyValuePair* mutable_config(int index);
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::core::KeyValuePair >*
      mutable_config();
  private:
  const ::flyteidl::core::KeyValuePair& _internal_config(int index) const;
  ::flyteidl::core::KeyValuePair* _internal_add_config();
  public:
  PROTOBUF_DEPRECATED const ::flyteidl::core::KeyValuePair& config(int index) const;
  PROTOBUF_DEPRECATED ::flyteidl::core::KeyValuePair* add_config();
  PROTOBUF_DEPRECATED const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::core::KeyValuePair >&
      config() const;

  // repeated .flyteidl.core.ContainerPort ports = 7 [json_name = "ports"];
  int ports_size() const;
  private:
  int _internal_ports_size() const;
  public:
  void clear_ports();
  ::flyteidl::core::ContainerPort* mutable_ports(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::core::ContainerPort >*
      mutable_ports();
  private:
  const ::flyteidl::core::ContainerPort& _internal_ports(int index) const;
  ::flyteidl::core::ContainerPort* _internal_add_ports();
  public:
  const ::flyteidl::core::ContainerPort& ports(int index) const;
  ::flyteidl::core::ContainerPort* add_ports();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::core::ContainerPort >&
      ports() const;

  // string image = 1 [json_name = "image"];
  void clear_image();
  const std::string& image() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_image(ArgT0&& arg0, ArgT... args);
  std::string* mutable_image();
  PROTOBUF_NODISCARD std::string* release_image();
  void set_allocated_image(std::string* image);
  private:
  const std::string& _internal_image() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_image(const std::string& value);
  std::string* _internal_mutable_image();
  public:

  // .flyteidl.core.Resources resources = 4 [json_name = "resources"];
  bool has_resources() const;
  private:
  bool _internal_has_resources() const;
  public:
  void clear_resources();
  const ::flyteidl::core::Resources& resources() const;
  PROTOBUF_NODISCARD ::flyteidl::core::Resources* release_resources();
  ::flyteidl::core::Resources* mutable_resources();
  void set_allocated_resources(::flyteidl::core::Resources* resources);
  private:
  const ::flyteidl::core::Resources& _internal_resources() const;
  ::flyteidl::core::Resources* _internal_mutable_resources();
  public:
  void unsafe_arena_set_allocated_resources(
      ::flyteidl::core::Resources* resources);
  ::flyteidl::core::Resources* unsafe_arena_release_resources();

  // .flyteidl.core.DataLoadingConfig data_config = 9 [json_name = "dataConfig"];
  bool has_data_config() const;
  private:
  bool _internal_has_data_config() const;
  public:
  void clear_data_config();
  const ::flyteidl::core::DataLoadingConfig& data_config() const;
  PROTOBUF_NODISCARD ::flyteidl::core::DataLoadingConfig* release_data_config();
  ::flyteidl::core::DataLoadingConfig* mutable_data_config();
  void set_allocated_data_config(::flyteidl::core::DataLoadingConfig* data_config);
  private:
  const ::flyteidl::core::DataLoadingConfig& _internal_data_config() const;
  ::flyteidl::core::DataLoadingConfig* _internal_mutable_data_config();
  public:
  void unsafe_arena_set_allocated_data_config(
      ::flyteidl::core::DataLoadingConfig* data_config);
  ::flyteidl::core::DataLoadingConfig* unsafe_arena_release_data_config();

  // .flyteidl.core.Container.Architecture architecture = 10 [json_name = "architecture"];
  void clear_architecture();
  ::flyteidl::core::Container_Architecture architecture() const;
  void set_architecture(::flyteidl::core::Container_Architecture value);
  private:
  ::flyteidl::core::Container_Architecture _internal_architecture() const;
  void _internal_set_architecture(::flyteidl::core::Container_Architecture value);
  public:

  // @@protoc_insertion_point(class_scope:flyteidl.core.Container)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> command_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> args_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::core::KeyValuePair > env_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::core::KeyValuePair > config_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::core::ContainerPort > ports_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr image_;
  ::flyteidl::core::Resources* resources_;
  ::flyteidl::core::DataLoadingConfig* data_config_;
  int architecture_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2ftasks_2eproto;
};
// -------------------------------------------------------------------

class IOStrategy final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.IOStrategy) */ {
 public:
  inline IOStrategy() : IOStrategy(nullptr) {}
  ~IOStrategy() override;
  explicit constexpr IOStrategy(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IOStrategy(const IOStrategy& from);
  IOStrategy(IOStrategy&& from) noexcept
    : IOStrategy() {
    *this = ::std::move(from);
  }

  inline IOStrategy& operator=(const IOStrategy& from) {
    CopyFrom(from);
    return *this;
  }
  inline IOStrategy& operator=(IOStrategy&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IOStrategy& default_instance() {
    return *internal_default_instance();
  }
  static inline const IOStrategy* internal_default_instance() {
    return reinterpret_cast<const IOStrategy*>(
               &_IOStrategy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(IOStrategy& a, IOStrategy& b) {
    a.Swap(&b);
  }
  inline void Swap(IOStrategy* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IOStrategy* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IOStrategy* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IOStrategy>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IOStrategy* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.core.IOStrategy";
  }
  protected:
  explicit IOStrategy(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef IOStrategy_DownloadMode DownloadMode;
  static constexpr DownloadMode DOWNLOAD_EAGER =
    IOStrategy_DownloadMode_DOWNLOAD_EAGER;
  static constexpr DownloadMode DOWNLOAD_STREAM =
    IOStrategy_DownloadMode_DOWNLOAD_STREAM;
  static constexpr DownloadMode DO_NOT_DOWNLOAD =
    IOStrategy_DownloadMode_DO_NOT_DOWNLOAD;
  static inline bool DownloadMode_IsValid(int value) {
    return IOStrategy_DownloadMode_IsValid(value);
  }
  static constexpr DownloadMode DownloadMode_MIN =
    IOStrategy_DownloadMode_DownloadMode_MIN;
  static constexpr DownloadMode DownloadMode_MAX =
    IOStrategy_DownloadMode_DownloadMode_MAX;
  static constexpr int DownloadMode_ARRAYSIZE =
    IOStrategy_DownloadMode_DownloadMode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  DownloadMode_descriptor() {
    return IOStrategy_DownloadMode_descriptor();
  }
  template<typename T>
  static inline const std::string& DownloadMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, DownloadMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function DownloadMode_Name.");
    return IOStrategy_DownloadMode_Name(enum_t_value);
  }
  static inline bool DownloadMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      DownloadMode* value) {
    return IOStrategy_DownloadMode_Parse(name, value);
  }

  typedef IOStrategy_UploadMode UploadMode;
  static constexpr UploadMode UPLOAD_ON_EXIT =
    IOStrategy_UploadMode_UPLOAD_ON_EXIT;
  static constexpr UploadMode UPLOAD_EAGER =
    IOStrategy_UploadMode_UPLOAD_EAGER;
  static constexpr UploadMode DO_NOT_UPLOAD =
    IOStrategy_UploadMode_DO_NOT_UPLOAD;
  static inline bool UploadMode_IsValid(int value) {
    return IOStrategy_UploadMode_IsValid(value);
  }
  static constexpr UploadMode UploadMode_MIN =
    IOStrategy_UploadMode_UploadMode_MIN;
  static constexpr UploadMode UploadMode_MAX =
    IOStrategy_UploadMode_UploadMode_MAX;
  static constexpr int UploadMode_ARRAYSIZE =
    IOStrategy_UploadMode_UploadMode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  UploadMode_descriptor() {
    return IOStrategy_UploadMode_descriptor();
  }
  template<typename T>
  static inline const std::string& UploadMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, UploadMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function UploadMode_Name.");
    return IOStrategy_UploadMode_Name(enum_t_value);
  }
  static inline bool UploadMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      UploadMode* value) {
    return IOStrategy_UploadMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDownloadModeFieldNumber = 1,
    kUploadModeFieldNumber = 2,
  };
  // .flyteidl.core.IOStrategy.DownloadMode download_mode = 1 [json_name = "downloadMode"];
  void clear_download_mode();
  ::flyteidl::core::IOStrategy_DownloadMode download_mode() const;
  void set_download_mode(::flyteidl::core::IOStrategy_DownloadMode value);
  private:
  ::flyteidl::core::IOStrategy_DownloadMode _internal_download_mode() const;
  void _internal_set_download_mode(::flyteidl::core::IOStrategy_DownloadMode value);
  public:

  // .flyteidl.core.IOStrategy.UploadMode upload_mode = 2 [json_name = "uploadMode"];
  void clear_upload_mode();
  ::flyteidl::core::IOStrategy_UploadMode upload_mode() const;
  void set_upload_mode(::flyteidl::core::IOStrategy_UploadMode value);
  private:
  ::flyteidl::core::IOStrategy_UploadMode _internal_upload_mode() const;
  void _internal_set_upload_mode(::flyteidl::core::IOStrategy_UploadMode value);
  public:

  // @@protoc_insertion_point(class_scope:flyteidl.core.IOStrategy)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int download_mode_;
  int upload_mode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2ftasks_2eproto;
};
// -------------------------------------------------------------------

class DataLoadingConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.DataLoadingConfig) */ {
 public:
  inline DataLoadingConfig() : DataLoadingConfig(nullptr) {}
  ~DataLoadingConfig() override;
  explicit constexpr DataLoadingConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataLoadingConfig(const DataLoadingConfig& from);
  DataLoadingConfig(DataLoadingConfig&& from) noexcept
    : DataLoadingConfig() {
    *this = ::std::move(from);
  }

  inline DataLoadingConfig& operator=(const DataLoadingConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataLoadingConfig& operator=(DataLoadingConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataLoadingConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataLoadingConfig* internal_default_instance() {
    return reinterpret_cast<const DataLoadingConfig*>(
               &_DataLoadingConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(DataLoadingConfig& a, DataLoadingConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(DataLoadingConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataLoadingConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataLoadingConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataLoadingConfig>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataLoadingConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.core.DataLoadingConfig";
  }
  protected:
  explicit DataLoadingConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DataLoadingConfig_LiteralMapFormat LiteralMapFormat;
  static constexpr LiteralMapFormat JSON =
    DataLoadingConfig_LiteralMapFormat_JSON;
  static constexpr LiteralMapFormat YAML =
    DataLoadingConfig_LiteralMapFormat_YAML;
  static constexpr LiteralMapFormat PROTO =
    DataLoadingConfig_LiteralMapFormat_PROTO;
  static inline bool LiteralMapFormat_IsValid(int value) {
    return DataLoadingConfig_LiteralMapFormat_IsValid(value);
  }
  static constexpr LiteralMapFormat LiteralMapFormat_MIN =
    DataLoadingConfig_LiteralMapFormat_LiteralMapFormat_MIN;
  static constexpr LiteralMapFormat LiteralMapFormat_MAX =
    DataLoadingConfig_LiteralMapFormat_LiteralMapFormat_MAX;
  static constexpr int LiteralMapFormat_ARRAYSIZE =
    DataLoadingConfig_LiteralMapFormat_LiteralMapFormat_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  LiteralMapFormat_descriptor() {
    return DataLoadingConfig_LiteralMapFormat_descriptor();
  }
  template<typename T>
  static inline const std::string& LiteralMapFormat_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LiteralMapFormat>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LiteralMapFormat_Name.");
    return DataLoadingConfig_LiteralMapFormat_Name(enum_t_value);
  }
  static inline bool LiteralMapFormat_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      LiteralMapFormat* value) {
    return DataLoadingConfig_LiteralMapFormat_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kInputPathFieldNumber = 2,
    kOutputPathFieldNumber = 3,
    kIoStrategyFieldNumber = 5,
    kEnabledFieldNumber = 1,
    kFormatFieldNumber = 4,
  };
  // string input_path = 2 [json_name = "inputPath"];
  void clear_input_path();
  const std::string& input_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_input_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_input_path();
  PROTOBUF_NODISCARD std::string* release_input_path();
  void set_allocated_input_path(std::string* input_path);
  private:
  const std::string& _internal_input_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_input_path(const std::string& value);
  std::string* _internal_mutable_input_path();
  public:

  // string output_path = 3 [json_name = "outputPath"];
  void clear_output_path();
  const std::string& output_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_output_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_output_path();
  PROTOBUF_NODISCARD std::string* release_output_path();
  void set_allocated_output_path(std::string* output_path);
  private:
  const std::string& _internal_output_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_output_path(const std::string& value);
  std::string* _internal_mutable_output_path();
  public:

  // .flyteidl.core.IOStrategy io_strategy = 5 [json_name = "ioStrategy"];
  bool has_io_strategy() const;
  private:
  bool _internal_has_io_strategy() const;
  public:
  void clear_io_strategy();
  const ::flyteidl::core::IOStrategy& io_strategy() const;
  PROTOBUF_NODISCARD ::flyteidl::core::IOStrategy* release_io_strategy();
  ::flyteidl::core::IOStrategy* mutable_io_strategy();
  void set_allocated_io_strategy(::flyteidl::core::IOStrategy* io_strategy);
  private:
  const ::flyteidl::core::IOStrategy& _internal_io_strategy() const;
  ::flyteidl::core::IOStrategy* _internal_mutable_io_strategy();
  public:
  void unsafe_arena_set_allocated_io_strategy(
      ::flyteidl::core::IOStrategy* io_strategy);
  ::flyteidl::core::IOStrategy* unsafe_arena_release_io_strategy();

  // bool enabled = 1 [json_name = "enabled"];
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // .flyteidl.core.DataLoadingConfig.LiteralMapFormat format = 4 [json_name = "format"];
  void clear_format();
  ::flyteidl::core::DataLoadingConfig_LiteralMapFormat format() const;
  void set_format(::flyteidl::core::DataLoadingConfig_LiteralMapFormat value);
  private:
  ::flyteidl::core::DataLoadingConfig_LiteralMapFormat _internal_format() const;
  void _internal_set_format(::flyteidl::core::DataLoadingConfig_LiteralMapFormat value);
  public:

  // @@protoc_insertion_point(class_scope:flyteidl.core.DataLoadingConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr input_path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr output_path_;
  ::flyteidl::core::IOStrategy* io_strategy_;
  bool enabled_;
  int format_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2ftasks_2eproto;
};
// -------------------------------------------------------------------

class K8sPod final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.K8sPod) */ {
 public:
  inline K8sPod() : K8sPod(nullptr) {}
  ~K8sPod() override;
  explicit constexpr K8sPod(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  K8sPod(const K8sPod& from);
  K8sPod(K8sPod&& from) noexcept
    : K8sPod() {
    *this = ::std::move(from);
  }

  inline K8sPod& operator=(const K8sPod& from) {
    CopyFrom(from);
    return *this;
  }
  inline K8sPod& operator=(K8sPod&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const K8sPod& default_instance() {
    return *internal_default_instance();
  }
  static inline const K8sPod* internal_default_instance() {
    return reinterpret_cast<const K8sPod*>(
               &_K8sPod_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(K8sPod& a, K8sPod& b) {
    a.Swap(&b);
  }
  inline void Swap(K8sPod* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(K8sPod* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  K8sPod* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<K8sPod>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(K8sPod* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.core.K8sPod";
  }
  protected:
  explicit K8sPod(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 1,
    kPodSpecFieldNumber = 2,
  };
  // .flyteidl.core.K8sObjectMetadata metadata = 1 [json_name = "metadata"];
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::flyteidl::core::K8sObjectMetadata& metadata() const;
  PROTOBUF_NODISCARD ::flyteidl::core::K8sObjectMetadata* release_metadata();
  ::flyteidl::core::K8sObjectMetadata* mutable_metadata();
  void set_allocated_metadata(::flyteidl::core::K8sObjectMetadata* metadata);
  private:
  const ::flyteidl::core::K8sObjectMetadata& _internal_metadata() const;
  ::flyteidl::core::K8sObjectMetadata* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::flyteidl::core::K8sObjectMetadata* metadata);
  ::flyteidl::core::K8sObjectMetadata* unsafe_arena_release_metadata();

  // .google.protobuf.Struct pod_spec = 2 [json_name = "podSpec"];
  bool has_pod_spec() const;
  private:
  bool _internal_has_pod_spec() const;
  public:
  void clear_pod_spec();
  const ::PROTOBUF_NAMESPACE_ID::Struct& pod_spec() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_pod_spec();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_pod_spec();
  void set_allocated_pod_spec(::PROTOBUF_NAMESPACE_ID::Struct* pod_spec);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_pod_spec() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_pod_spec();
  public:
  void unsafe_arena_set_allocated_pod_spec(
      ::PROTOBUF_NAMESPACE_ID::Struct* pod_spec);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_pod_spec();

  // @@protoc_insertion_point(class_scope:flyteidl.core.K8sPod)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::flyteidl::core::K8sObjectMetadata* metadata_;
  ::PROTOBUF_NAMESPACE_ID::Struct* pod_spec_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2ftasks_2eproto;
};
// -------------------------------------------------------------------

class K8sObjectMetadata_LabelsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<K8sObjectMetadata_LabelsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<K8sObjectMetadata_LabelsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  K8sObjectMetadata_LabelsEntry_DoNotUse();
  explicit constexpr K8sObjectMetadata_LabelsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit K8sObjectMetadata_LabelsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const K8sObjectMetadata_LabelsEntry_DoNotUse& other);
  static const K8sObjectMetadata_LabelsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const K8sObjectMetadata_LabelsEntry_DoNotUse*>(&_K8sObjectMetadata_LabelsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "flyteidl.core.K8sObjectMetadata.LabelsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "flyteidl.core.K8sObjectMetadata.LabelsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class K8sObjectMetadata_AnnotationsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<K8sObjectMetadata_AnnotationsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<K8sObjectMetadata_AnnotationsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  K8sObjectMetadata_AnnotationsEntry_DoNotUse();
  explicit constexpr K8sObjectMetadata_AnnotationsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit K8sObjectMetadata_AnnotationsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const K8sObjectMetadata_AnnotationsEntry_DoNotUse& other);
  static const K8sObjectMetadata_AnnotationsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const K8sObjectMetadata_AnnotationsEntry_DoNotUse*>(&_K8sObjectMetadata_AnnotationsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "flyteidl.core.K8sObjectMetadata.AnnotationsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "flyteidl.core.K8sObjectMetadata.AnnotationsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class K8sObjectMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.K8sObjectMetadata) */ {
 public:
  inline K8sObjectMetadata() : K8sObjectMetadata(nullptr) {}
  ~K8sObjectMetadata() override;
  explicit constexpr K8sObjectMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  K8sObjectMetadata(const K8sObjectMetadata& from);
  K8sObjectMetadata(K8sObjectMetadata&& from) noexcept
    : K8sObjectMetadata() {
    *this = ::std::move(from);
  }

  inline K8sObjectMetadata& operator=(const K8sObjectMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline K8sObjectMetadata& operator=(K8sObjectMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const K8sObjectMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const K8sObjectMetadata* internal_default_instance() {
    return reinterpret_cast<const K8sObjectMetadata*>(
               &_K8sObjectMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(K8sObjectMetadata& a, K8sObjectMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(K8sObjectMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(K8sObjectMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  K8sObjectMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<K8sObjectMetadata>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(K8sObjectMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.core.K8sObjectMetadata";
  }
  protected:
  explicit K8sObjectMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kLabelsFieldNumber = 1,
    kAnnotationsFieldNumber = 2,
  };
  // map<string, string> labels = 1 [json_name = "labels"];
  int labels_size() const;
  private:
  int _internal_labels_size() const;
  public:
  void clear_labels();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_labels() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_labels();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      labels() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_labels();

  // map<string, string> annotations = 2 [json_name = "annotations"];
  int annotations_size() const;
  private:
  int _internal_annotations_size() const;
  public:
  void clear_annotations();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_annotations() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_annotations();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      annotations() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_annotations();

  // @@protoc_insertion_point(class_scope:flyteidl.core.K8sObjectMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      K8sObjectMetadata_LabelsEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> labels_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      K8sObjectMetadata_AnnotationsEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> annotations_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2ftasks_2eproto;
};
// -------------------------------------------------------------------

class Sql final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.Sql) */ {
 public:
  inline Sql() : Sql(nullptr) {}
  ~Sql() override;
  explicit constexpr Sql(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Sql(const Sql& from);
  Sql(Sql&& from) noexcept
    : Sql() {
    *this = ::std::move(from);
  }

  inline Sql& operator=(const Sql& from) {
    CopyFrom(from);
    return *this;
  }
  inline Sql& operator=(Sql&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Sql& default_instance() {
    return *internal_default_instance();
  }
  static inline const Sql* internal_default_instance() {
    return reinterpret_cast<const Sql*>(
               &_Sql_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Sql& a, Sql& b) {
    a.Swap(&b);
  }
  inline void Swap(Sql* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Sql* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Sql* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Sql>(arena);
  }
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Sql* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flyteidl.core.Sql";
  }
  protected:
  explicit Sql(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Sql_Dialect Dialect;
  static constexpr Dialect UNDEFINED =
    Sql_Dialect_UNDEFINED;
  static constexpr Dialect ANSI =
    Sql_Dialect_ANSI;
  static constexpr Dialect HIVE =
    Sql_Dialect_HIVE;
  static constexpr Dialect OTHER =
    Sql_Dialect_OTHER;
  static inline bool Dialect_IsValid(int value) {
    return Sql_Dialect_IsValid(value);
  }
  static constexpr Dialect Dialect_MIN =
    Sql_Dialect_Dialect_MIN;
  static constexpr Dialect Dialect_MAX =
    Sql_Dialect_Dialect_MAX;
  static constexpr int Dialect_ARRAYSIZE =
    Sql_Dialect_Dialect_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Dialect_descriptor() {
    return Sql_Dialect_descriptor();
  }
  template<typename T>
  static inline const std::string& Dialect_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Dialect>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Dialect_Name.");
    return Sql_Dialect_Name(enum_t_value);
  }
  static inline bool Dialect_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Dialect* value) {
    return Sql_Dialect_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStatementFieldNumber = 1,
    kDialectFieldNumber = 2,
  };
  // string statement = 1 [json_name = "statement"];
  void clear_statement();
  const std::string& statement() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_statement(ArgT0&& arg0, ArgT... args);
  std::string* mutable_statement();
  PROTOBUF_NODISCARD std::string* release_statement();
  void set_allocated_statement(std::string* statement);
  private:
  const std::string& _internal_statement() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_statement(const std::string& value);
  std::string* _internal_mutable_statement();
  public:

  // .flyteidl.core.Sql.Dialect dialect = 2 [json_name = "dialect"];
  void clear_dialect();
  ::flyteidl::core::Sql_Dialect dialect() const;
  void set_dialect(::flyteidl::core::Sql_Dialect value);
  private:
  ::flyteidl::core::Sql_Dialect _internal_dialect() const;
  void _internal_set_dialect(::flyteidl::core::Sql_Dialect value);
  public:

  // @@protoc_insertion_point(class_scope:flyteidl.core.Sql)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr statement_;
  int dialect_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2ftasks_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Resources_ResourceEntry

// .flyteidl.core.Resources.ResourceName name = 1 [json_name = "name"];
inline void Resources_ResourceEntry::clear_name() {
  name_ = 0;
}
inline ::flyteidl::core::Resources_ResourceName Resources_ResourceEntry::_internal_name() const {
  return static_cast< ::flyteidl::core::Resources_ResourceName >(name_);
}
inline ::flyteidl::core::Resources_ResourceName Resources_ResourceEntry::name() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Resources.ResourceEntry.name)
  return _internal_name();
}
inline void Resources_ResourceEntry::_internal_set_name(::flyteidl::core::Resources_ResourceName value) {
  
  name_ = value;
}
inline void Resources_ResourceEntry::set_name(::flyteidl::core::Resources_ResourceName value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:flyteidl.core.Resources.ResourceEntry.name)
}

// string value = 2 [json_name = "value"];
inline void Resources_ResourceEntry::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& Resources_ResourceEntry::value() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Resources.ResourceEntry.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Resources_ResourceEntry::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.core.Resources.ResourceEntry.value)
}
inline std::string* Resources_ResourceEntry::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Resources.ResourceEntry.value)
  return _s;
}
inline const std::string& Resources_ResourceEntry::_internal_value() const {
  return value_.Get();
}
inline void Resources_ResourceEntry::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Resources_ResourceEntry::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Resources_ResourceEntry::release_value() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Resources.ResourceEntry.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Resources_ResourceEntry::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (value_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.Resources.ResourceEntry.value)
}

// -------------------------------------------------------------------

// Resources

// repeated .flyteidl.core.Resources.ResourceEntry requests = 1 [json_name = "requests"];
inline int Resources::_internal_requests_size() const {
  return requests_.size();
}
inline int Resources::requests_size() const {
  return _internal_requests_size();
}
inline void Resources::clear_requests() {
  requests_.Clear();
}
inline ::flyteidl::core::Resources_ResourceEntry* Resources::mutable_requests(int index) {
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Resources.requests)
  return requests_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::core::Resources_ResourceEntry >*
Resources::mutable_requests() {
  // @@protoc_insertion_point(field_mutable_list:flyteidl.core.Resources.requests)
  return &requests_;
}
inline const ::flyteidl::core::Resources_ResourceEntry& Resources::_internal_requests(int index) const {
  return requests_.Get(index);
}
inline const ::flyteidl::core::Resources_ResourceEntry& Resources::requests(int index) const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Resources.requests)
  return _internal_requests(index);
}
inline ::flyteidl::core::Resources_ResourceEntry* Resources::_internal_add_requests() {
  return requests_.Add();
}
inline ::flyteidl::core::Resources_ResourceEntry* Resources::add_requests() {
  ::flyteidl::core::Resources_ResourceEntry* _add = _internal_add_requests();
  // @@protoc_insertion_point(field_add:flyteidl.core.Resources.requests)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::core::Resources_ResourceEntry >&
Resources::requests() const {
  // @@protoc_insertion_point(field_list:flyteidl.core.Resources.requests)
  return requests_;
}

// repeated .flyteidl.core.Resources.ResourceEntry limits = 2 [json_name = "limits"];
inline int Resources::_internal_limits_size() const {
  return limits_.size();
}
inline int Resources::limits_size() const {
  return _internal_limits_size();
}
inline void Resources::clear_limits() {
  limits_.Clear();
}
inline ::flyteidl::core::Resources_ResourceEntry* Resources::mutable_limits(int index) {
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Resources.limits)
  return limits_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::core::Resources_ResourceEntry >*
Resources::mutable_limits() {
  // @@protoc_insertion_point(field_mutable_list:flyteidl.core.Resources.limits)
  return &limits_;
}
inline const ::flyteidl::core::Resources_ResourceEntry& Resources::_internal_limits(int index) const {
  return limits_.Get(index);
}
inline const ::flyteidl::core::Resources_ResourceEntry& Resources::limits(int index) const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Resources.limits)
  return _internal_limits(index);
}
inline ::flyteidl::core::Resources_ResourceEntry* Resources::_internal_add_limits() {
  return limits_.Add();
}
inline ::flyteidl::core::Resources_ResourceEntry* Resources::add_limits() {
  ::flyteidl::core::Resources_ResourceEntry* _add = _internal_add_limits();
  // @@protoc_insertion_point(field_add:flyteidl.core.Resources.limits)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::core::Resources_ResourceEntry >&
Resources::limits() const {
  // @@protoc_insertion_point(field_list:flyteidl.core.Resources.limits)
  return limits_;
}

// -------------------------------------------------------------------

// RuntimeMetadata

// .flyteidl.core.RuntimeMetadata.RuntimeType type = 1 [json_name = "type"];
inline void RuntimeMetadata::clear_type() {
  type_ = 0;
}
inline ::flyteidl::core::RuntimeMetadata_RuntimeType RuntimeMetadata::_internal_type() const {
  return static_cast< ::flyteidl::core::RuntimeMetadata_RuntimeType >(type_);
}
inline ::flyteidl::core::RuntimeMetadata_RuntimeType RuntimeMetadata::type() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.RuntimeMetadata.type)
  return _internal_type();
}
inline void RuntimeMetadata::_internal_set_type(::flyteidl::core::RuntimeMetadata_RuntimeType value) {
  
  type_ = value;
}
inline void RuntimeMetadata::set_type(::flyteidl::core::RuntimeMetadata_RuntimeType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:flyteidl.core.RuntimeMetadata.type)
}

// string version = 2 [json_name = "version"];
inline void RuntimeMetadata::clear_version() {
  version_.ClearToEmpty();
}
inline const std::string& RuntimeMetadata::version() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.RuntimeMetadata.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RuntimeMetadata::set_version(ArgT0&& arg0, ArgT... args) {
 
 version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.core.RuntimeMetadata.version)
}
inline std::string* RuntimeMetadata::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.RuntimeMetadata.version)
  return _s;
}
inline const std::string& RuntimeMetadata::_internal_version() const {
  return version_.Get();
}
inline void RuntimeMetadata::_internal_set_version(const std::string& value) {
  
  version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RuntimeMetadata::_internal_mutable_version() {
  
  return version_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RuntimeMetadata::release_version() {
  // @@protoc_insertion_point(field_release:flyteidl.core.RuntimeMetadata.version)
  return version_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RuntimeMetadata::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), version,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (version_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.RuntimeMetadata.version)
}

// string flavor = 3 [json_name = "flavor"];
inline void RuntimeMetadata::clear_flavor() {
  flavor_.ClearToEmpty();
}
inline const std::string& RuntimeMetadata::flavor() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.RuntimeMetadata.flavor)
  return _internal_flavor();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RuntimeMetadata::set_flavor(ArgT0&& arg0, ArgT... args) {
 
 flavor_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.core.RuntimeMetadata.flavor)
}
inline std::string* RuntimeMetadata::mutable_flavor() {
  std::string* _s = _internal_mutable_flavor();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.RuntimeMetadata.flavor)
  return _s;
}
inline const std::string& RuntimeMetadata::_internal_flavor() const {
  return flavor_.Get();
}
inline void RuntimeMetadata::_internal_set_flavor(const std::string& value) {
  
  flavor_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RuntimeMetadata::_internal_mutable_flavor() {
  
  return flavor_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RuntimeMetadata::release_flavor() {
  // @@protoc_insertion_point(field_release:flyteidl.core.RuntimeMetadata.flavor)
  return flavor_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RuntimeMetadata::set_allocated_flavor(std::string* flavor) {
  if (flavor != nullptr) {
    
  } else {
    
  }
  flavor_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), flavor,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (flavor_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    flavor_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.RuntimeMetadata.flavor)
}

// -------------------------------------------------------------------

// TaskMetadata

// bool discoverable = 1 [json_name = "discoverable"];
inline void TaskMetadata::clear_discoverable() {
  discoverable_ = false;
}
inline bool TaskMetadata::_internal_discoverable() const {
  return discoverable_;
}
inline bool TaskMetadata::discoverable() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.TaskMetadata.discoverable)
  return _internal_discoverable();
}
inline void TaskMetadata::_internal_set_discoverable(bool value) {
  
  discoverable_ = value;
}
inline void TaskMetadata::set_discoverable(bool value) {
  _internal_set_discoverable(value);
  // @@protoc_insertion_point(field_set:flyteidl.core.TaskMetadata.discoverable)
}

// .flyteidl.core.RuntimeMetadata runtime = 2 [json_name = "runtime"];
inline bool TaskMetadata::_internal_has_runtime() const {
  return this != internal_default_instance() && runtime_ != nullptr;
}
inline bool TaskMetadata::has_runtime() const {
  return _internal_has_runtime();
}
inline void TaskMetadata::clear_runtime() {
  if (GetArenaForAllocation() == nullptr && runtime_ != nullptr) {
    delete runtime_;
  }
  runtime_ = nullptr;
}
inline const ::flyteidl::core::RuntimeMetadata& TaskMetadata::_internal_runtime() const {
  const ::flyteidl::core::RuntimeMetadata* p = runtime_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::core::RuntimeMetadata&>(
      ::flyteidl::core::_RuntimeMetadata_default_instance_);
}
inline const ::flyteidl::core::RuntimeMetadata& TaskMetadata::runtime() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.TaskMetadata.runtime)
  return _internal_runtime();
}
inline void TaskMetadata::unsafe_arena_set_allocated_runtime(
    ::flyteidl::core::RuntimeMetadata* runtime) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(runtime_);
  }
  runtime_ = runtime;
  if (runtime) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.core.TaskMetadata.runtime)
}
inline ::flyteidl::core::RuntimeMetadata* TaskMetadata::release_runtime() {
  
  ::flyteidl::core::RuntimeMetadata* temp = runtime_;
  runtime_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::core::RuntimeMetadata* TaskMetadata::unsafe_arena_release_runtime() {
  // @@protoc_insertion_point(field_release:flyteidl.core.TaskMetadata.runtime)
  
  ::flyteidl::core::RuntimeMetadata* temp = runtime_;
  runtime_ = nullptr;
  return temp;
}
inline ::flyteidl::core::RuntimeMetadata* TaskMetadata::_internal_mutable_runtime() {
  
  if (runtime_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::RuntimeMetadata>(GetArenaForAllocation());
    runtime_ = p;
  }
  return runtime_;
}
inline ::flyteidl::core::RuntimeMetadata* TaskMetadata::mutable_runtime() {
  ::flyteidl::core::RuntimeMetadata* _msg = _internal_mutable_runtime();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.TaskMetadata.runtime)
  return _msg;
}
inline void TaskMetadata::set_allocated_runtime(::flyteidl::core::RuntimeMetadata* runtime) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete runtime_;
  }
  if (runtime) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::flyteidl::core::RuntimeMetadata>::GetOwningArena(runtime);
    if (message_arena != submessage_arena) {
      runtime = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, runtime, submessage_arena);
    }
    
  } else {
    
  }
  runtime_ = runtime;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.TaskMetadata.runtime)
}

// .google.protobuf.Duration timeout = 4 [json_name = "timeout"];
inline bool TaskMetadata::_internal_has_timeout() const {
  return this != internal_default_instance() && timeout_ != nullptr;
}
inline bool TaskMetadata::has_timeout() const {
  return _internal_has_timeout();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& TaskMetadata::_internal_timeout() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = timeout_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& TaskMetadata::timeout() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.TaskMetadata.timeout)
  return _internal_timeout();
}
inline void TaskMetadata::unsafe_arena_set_allocated_timeout(
    ::PROTOBUF_NAMESPACE_ID::Duration* timeout) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timeout_);
  }
  timeout_ = timeout;
  if (timeout) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.core.TaskMetadata.timeout)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* TaskMetadata::release_timeout() {
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = timeout_;
  timeout_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* TaskMetadata::unsafe_arena_release_timeout() {
  // @@protoc_insertion_point(field_release:flyteidl.core.TaskMetadata.timeout)
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = timeout_;
  timeout_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* TaskMetadata::_internal_mutable_timeout() {
  
  if (timeout_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    timeout_ = p;
  }
  return timeout_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* TaskMetadata::mutable_timeout() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_timeout();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.TaskMetadata.timeout)
  return _msg;
}
inline void TaskMetadata::set_allocated_timeout(::PROTOBUF_NAMESPACE_ID::Duration* timeout) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(timeout_);
  }
  if (timeout) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timeout));
    if (message_arena != submessage_arena) {
      timeout = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timeout, submessage_arena);
    }
    
  } else {
    
  }
  timeout_ = timeout;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.TaskMetadata.timeout)
}

// .flyteidl.core.RetryStrategy retries = 5 [json_name = "retries"];
inline bool TaskMetadata::_internal_has_retries() const {
  return this != internal_default_instance() && retries_ != nullptr;
}
inline bool TaskMetadata::has_retries() const {
  return _internal_has_retries();
}
inline const ::flyteidl::core::RetryStrategy& TaskMetadata::_internal_retries() const {
  const ::flyteidl::core::RetryStrategy* p = retries_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::core::RetryStrategy&>(
      ::flyteidl::core::_RetryStrategy_default_instance_);
}
inline const ::flyteidl::core::RetryStrategy& TaskMetadata::retries() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.TaskMetadata.retries)
  return _internal_retries();
}
inline void TaskMetadata::unsafe_arena_set_allocated_retries(
    ::flyteidl::core::RetryStrategy* retries) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(retries_);
  }
  retries_ = retries;
  if (retries) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.core.TaskMetadata.retries)
}
inline ::flyteidl::core::RetryStrategy* TaskMetadata::release_retries() {
  
  ::flyteidl::core::RetryStrategy* temp = retries_;
  retries_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::core::RetryStrategy* TaskMetadata::unsafe_arena_release_retries() {
  // @@protoc_insertion_point(field_release:flyteidl.core.TaskMetadata.retries)
  
  ::flyteidl::core::RetryStrategy* temp = retries_;
  retries_ = nullptr;
  return temp;
}
inline ::flyteidl::core::RetryStrategy* TaskMetadata::_internal_mutable_retries() {
  
  if (retries_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::RetryStrategy>(GetArenaForAllocation());
    retries_ = p;
  }
  return retries_;
}
inline ::flyteidl::core::RetryStrategy* TaskMetadata::mutable_retries() {
  ::flyteidl::core::RetryStrategy* _msg = _internal_mutable_retries();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.TaskMetadata.retries)
  return _msg;
}
inline void TaskMetadata::set_allocated_retries(::flyteidl::core::RetryStrategy* retries) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(retries_);
  }
  if (retries) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(retries));
    if (message_arena != submessage_arena) {
      retries = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, retries, submessage_arena);
    }
    
  } else {
    
  }
  retries_ = retries;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.TaskMetadata.retries)
}

// string discovery_version = 6 [json_name = "discoveryVersion"];
inline void TaskMetadata::clear_discovery_version() {
  discovery_version_.ClearToEmpty();
}
inline const std::string& TaskMetadata::discovery_version() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.TaskMetadata.discovery_version)
  return _internal_discovery_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TaskMetadata::set_discovery_version(ArgT0&& arg0, ArgT... args) {
 
 discovery_version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.core.TaskMetadata.discovery_version)
}
inline std::string* TaskMetadata::mutable_discovery_version() {
  std::string* _s = _internal_mutable_discovery_version();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.TaskMetadata.discovery_version)
  return _s;
}
inline const std::string& TaskMetadata::_internal_discovery_version() const {
  return discovery_version_.Get();
}
inline void TaskMetadata::_internal_set_discovery_version(const std::string& value) {
  
  discovery_version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TaskMetadata::_internal_mutable_discovery_version() {
  
  return discovery_version_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TaskMetadata::release_discovery_version() {
  // @@protoc_insertion_point(field_release:flyteidl.core.TaskMetadata.discovery_version)
  return discovery_version_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TaskMetadata::set_allocated_discovery_version(std::string* discovery_version) {
  if (discovery_version != nullptr) {
    
  } else {
    
  }
  discovery_version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), discovery_version,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (discovery_version_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    discovery_version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.TaskMetadata.discovery_version)
}

// string deprecated_error_message = 7 [json_name = "deprecatedErrorMessage"];
inline void TaskMetadata::clear_deprecated_error_message() {
  deprecated_error_message_.ClearToEmpty();
}
inline const std::string& TaskMetadata::deprecated_error_message() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.TaskMetadata.deprecated_error_message)
  return _internal_deprecated_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TaskMetadata::set_deprecated_error_message(ArgT0&& arg0, ArgT... args) {
 
 deprecated_error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.core.TaskMetadata.deprecated_error_message)
}
inline std::string* TaskMetadata::mutable_deprecated_error_message() {
  std::string* _s = _internal_mutable_deprecated_error_message();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.TaskMetadata.deprecated_error_message)
  return _s;
}
inline const std::string& TaskMetadata::_internal_deprecated_error_message() const {
  return deprecated_error_message_.Get();
}
inline void TaskMetadata::_internal_set_deprecated_error_message(const std::string& value) {
  
  deprecated_error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TaskMetadata::_internal_mutable_deprecated_error_message() {
  
  return deprecated_error_message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TaskMetadata::release_deprecated_error_message() {
  // @@protoc_insertion_point(field_release:flyteidl.core.TaskMetadata.deprecated_error_message)
  return deprecated_error_message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TaskMetadata::set_allocated_deprecated_error_message(std::string* deprecated_error_message) {
  if (deprecated_error_message != nullptr) {
    
  } else {
    
  }
  deprecated_error_message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), deprecated_error_message,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (deprecated_error_message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    deprecated_error_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.TaskMetadata.deprecated_error_message)
}

// bool interruptible = 8 [json_name = "interruptible"];
inline bool TaskMetadata::_internal_has_interruptible() const {
  return interruptible_value_case() == kInterruptible;
}
inline bool TaskMetadata::has_interruptible() const {
  return _internal_has_interruptible();
}
inline void TaskMetadata::set_has_interruptible() {
  _oneof_case_[0] = kInterruptible;
}
inline void TaskMetadata::clear_interruptible() {
  if (_internal_has_interruptible()) {
    interruptible_value_.interruptible_ = false;
    clear_has_interruptible_value();
  }
}
inline bool TaskMetadata::_internal_interruptible() const {
  if (_internal_has_interruptible()) {
    return interruptible_value_.interruptible_;
  }
  return false;
}
inline void TaskMetadata::_internal_set_interruptible(bool value) {
  if (!_internal_has_interruptible()) {
    clear_interruptible_value();
    set_has_interruptible();
  }
  interruptible_value_.interruptible_ = value;
}
inline bool TaskMetadata::interruptible() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.TaskMetadata.interruptible)
  return _internal_interruptible();
}
inline void TaskMetadata::set_interruptible(bool value) {
  _internal_set_interruptible(value);
  // @@protoc_insertion_point(field_set:flyteidl.core.TaskMetadata.interruptible)
}

// bool cache_serializable = 9 [json_name = "cacheSerializable"];
inline void TaskMetadata::clear_cache_serializable() {
  cache_serializable_ = false;
}
inline bool TaskMetadata::_internal_cache_serializable() const {
  return cache_serializable_;
}
inline bool TaskMetadata::cache_serializable() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.TaskMetadata.cache_serializable)
  return _internal_cache_serializable();
}
inline void TaskMetadata::_internal_set_cache_serializable(bool value) {
  
  cache_serializable_ = value;
}
inline void TaskMetadata::set_cache_serializable(bool value) {
  _internal_set_cache_serializable(value);
  // @@protoc_insertion_point(field_set:flyteidl.core.TaskMetadata.cache_serializable)
}

inline bool TaskMetadata::has_interruptible_value() const {
  return interruptible_value_case() != INTERRUPTIBLE_VALUE_NOT_SET;
}
inline void TaskMetadata::clear_has_interruptible_value() {
  _oneof_case_[0] = INTERRUPTIBLE_VALUE_NOT_SET;
}
inline TaskMetadata::InterruptibleValueCase TaskMetadata::interruptible_value_case() const {
  return TaskMetadata::InterruptibleValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TaskTemplate

// .flyteidl.core.Identifier id = 1 [json_name = "id"];
inline bool TaskTemplate::_internal_has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline bool TaskTemplate::has_id() const {
  return _internal_has_id();
}
inline const ::flyteidl::core::Identifier& TaskTemplate::_internal_id() const {
  const ::flyteidl::core::Identifier* p = id_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::core::Identifier&>(
      ::flyteidl::core::_Identifier_default_instance_);
}
inline const ::flyteidl::core::Identifier& TaskTemplate::id() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.TaskTemplate.id)
  return _internal_id();
}
inline void TaskTemplate::unsafe_arena_set_allocated_id(
    ::flyteidl::core::Identifier* id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.core.TaskTemplate.id)
}
inline ::flyteidl::core::Identifier* TaskTemplate::release_id() {
  
  ::flyteidl::core::Identifier* temp = id_;
  id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::core::Identifier* TaskTemplate::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:flyteidl.core.TaskTemplate.id)
  
  ::flyteidl::core::Identifier* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::flyteidl::core::Identifier* TaskTemplate::_internal_mutable_id() {
  
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::Identifier>(GetArenaForAllocation());
    id_ = p;
  }
  return id_;
}
inline ::flyteidl::core::Identifier* TaskTemplate::mutable_id() {
  ::flyteidl::core::Identifier* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.TaskTemplate.id)
  return _msg;
}
inline void TaskTemplate::set_allocated_id(::flyteidl::core::Identifier* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id));
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.TaskTemplate.id)
}

// string type = 2 [json_name = "type"];
inline void TaskTemplate::clear_type() {
  type_.ClearToEmpty();
}
inline const std::string& TaskTemplate::type() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.TaskTemplate.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TaskTemplate::set_type(ArgT0&& arg0, ArgT... args) {
 
 type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.core.TaskTemplate.type)
}
inline std::string* TaskTemplate::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.TaskTemplate.type)
  return _s;
}
inline const std::string& TaskTemplate::_internal_type() const {
  return type_.Get();
}
inline void TaskTemplate::_internal_set_type(const std::string& value) {
  
  type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TaskTemplate::_internal_mutable_type() {
  
  return type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TaskTemplate::release_type() {
  // @@protoc_insertion_point(field_release:flyteidl.core.TaskTemplate.type)
  return type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TaskTemplate::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.TaskTemplate.type)
}

// .flyteidl.core.TaskMetadata metadata = 3 [json_name = "metadata"];
inline bool TaskTemplate::_internal_has_metadata() const {
  return this != internal_default_instance() && metadata_ != nullptr;
}
inline bool TaskTemplate::has_metadata() const {
  return _internal_has_metadata();
}
inline void TaskTemplate::clear_metadata() {
  if (GetArenaForAllocation() == nullptr && metadata_ != nullptr) {
    delete metadata_;
  }
  metadata_ = nullptr;
}
inline const ::flyteidl::core::TaskMetadata& TaskTemplate::_internal_metadata() const {
  const ::flyteidl::core::TaskMetadata* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::core::TaskMetadata&>(
      ::flyteidl::core::_TaskMetadata_default_instance_);
}
inline const ::flyteidl::core::TaskMetadata& TaskTemplate::metadata() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.TaskTemplate.metadata)
  return _internal_metadata();
}
inline void TaskTemplate::unsafe_arena_set_allocated_metadata(
    ::flyteidl::core::TaskMetadata* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.core.TaskTemplate.metadata)
}
inline ::flyteidl::core::TaskMetadata* TaskTemplate::release_metadata() {
  
  ::flyteidl::core::TaskMetadata* temp = metadata_;
  metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::core::TaskMetadata* TaskTemplate::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:flyteidl.core.TaskTemplate.metadata)
  
  ::flyteidl::core::TaskMetadata* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::flyteidl::core::TaskMetadata* TaskTemplate::_internal_mutable_metadata() {
  
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::TaskMetadata>(GetArenaForAllocation());
    metadata_ = p;
  }
  return metadata_;
}
inline ::flyteidl::core::TaskMetadata* TaskTemplate::mutable_metadata() {
  ::flyteidl::core::TaskMetadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.TaskTemplate.metadata)
  return _msg;
}
inline void TaskTemplate::set_allocated_metadata(::flyteidl::core::TaskMetadata* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete metadata_;
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::flyteidl::core::TaskMetadata>::GetOwningArena(metadata);
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.TaskTemplate.metadata)
}

// .flyteidl.core.TypedInterface interface = 4 [json_name = "interface"];
inline bool TaskTemplate::_internal_has_interface() const {
  return this != internal_default_instance() && interface_ != nullptr;
}
inline bool TaskTemplate::has_interface() const {
  return _internal_has_interface();
}
inline const ::flyteidl::core::TypedInterface& TaskTemplate::_internal_interface() const {
  const ::flyteidl::core::TypedInterface* p = interface_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::core::TypedInterface&>(
      ::flyteidl::core::_TypedInterface_default_instance_);
}
inline const ::flyteidl::core::TypedInterface& TaskTemplate::interface() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.TaskTemplate.interface)
  return _internal_interface();
}
inline void TaskTemplate::unsafe_arena_set_allocated_interface(
    ::flyteidl::core::TypedInterface* interface) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(interface_);
  }
  interface_ = interface;
  if (interface) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.core.TaskTemplate.interface)
}
inline ::flyteidl::core::TypedInterface* TaskTemplate::release_interface() {
  
  ::flyteidl::core::TypedInterface* temp = interface_;
  interface_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::core::TypedInterface* TaskTemplate::unsafe_arena_release_interface() {
  // @@protoc_insertion_point(field_release:flyteidl.core.TaskTemplate.interface)
  
  ::flyteidl::core::TypedInterface* temp = interface_;
  interface_ = nullptr;
  return temp;
}
inline ::flyteidl::core::TypedInterface* TaskTemplate::_internal_mutable_interface() {
  
  if (interface_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::TypedInterface>(GetArenaForAllocation());
    interface_ = p;
  }
  return interface_;
}
inline ::flyteidl::core::TypedInterface* TaskTemplate::mutable_interface() {
  ::flyteidl::core::TypedInterface* _msg = _internal_mutable_interface();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.TaskTemplate.interface)
  return _msg;
}
inline void TaskTemplate::set_allocated_interface(::flyteidl::core::TypedInterface* interface) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(interface_);
  }
  if (interface) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(interface));
    if (message_arena != submessage_arena) {
      interface = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, interface, submessage_arena);
    }
    
  } else {
    
  }
  interface_ = interface;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.TaskTemplate.interface)
}

// .google.protobuf.Struct custom = 5 [json_name = "custom"];
inline bool TaskTemplate::_internal_has_custom() const {
  return this != internal_default_instance() && custom_ != nullptr;
}
inline bool TaskTemplate::has_custom() const {
  return _internal_has_custom();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& TaskTemplate::_internal_custom() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = custom_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& TaskTemplate::custom() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.TaskTemplate.custom)
  return _internal_custom();
}
inline void TaskTemplate::unsafe_arena_set_allocated_custom(
    ::PROTOBUF_NAMESPACE_ID::Struct* custom) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(custom_);
  }
  custom_ = custom;
  if (custom) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.core.TaskTemplate.custom)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* TaskTemplate::release_custom() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = custom_;
  custom_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* TaskTemplate::unsafe_arena_release_custom() {
  // @@protoc_insertion_point(field_release:flyteidl.core.TaskTemplate.custom)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = custom_;
  custom_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* TaskTemplate::_internal_mutable_custom() {
  
  if (custom_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    custom_ = p;
  }
  return custom_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* TaskTemplate::mutable_custom() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_custom();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.TaskTemplate.custom)
  return _msg;
}
inline void TaskTemplate::set_allocated_custom(::PROTOBUF_NAMESPACE_ID::Struct* custom) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(custom_);
  }
  if (custom) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(custom));
    if (message_arena != submessage_arena) {
      custom = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, custom, submessage_arena);
    }
    
  } else {
    
  }
  custom_ = custom;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.TaskTemplate.custom)
}

// .flyteidl.core.Container container = 6 [json_name = "container"];
inline bool TaskTemplate::_internal_has_container() const {
  return target_case() == kContainer;
}
inline bool TaskTemplate::has_container() const {
  return _internal_has_container();
}
inline void TaskTemplate::set_has_container() {
  _oneof_case_[0] = kContainer;
}
inline void TaskTemplate::clear_container() {
  if (_internal_has_container()) {
    if (GetArenaForAllocation() == nullptr) {
      delete target_.container_;
    }
    clear_has_target();
  }
}
inline ::flyteidl::core::Container* TaskTemplate::release_container() {
  // @@protoc_insertion_point(field_release:flyteidl.core.TaskTemplate.container)
  if (_internal_has_container()) {
    clear_has_target();
      ::flyteidl::core::Container* temp = target_.container_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    target_.container_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::core::Container& TaskTemplate::_internal_container() const {
  return _internal_has_container()
      ? *target_.container_
      : reinterpret_cast< ::flyteidl::core::Container&>(::flyteidl::core::_Container_default_instance_);
}
inline const ::flyteidl::core::Container& TaskTemplate::container() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.TaskTemplate.container)
  return _internal_container();
}
inline ::flyteidl::core::Container* TaskTemplate::unsafe_arena_release_container() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flyteidl.core.TaskTemplate.container)
  if (_internal_has_container()) {
    clear_has_target();
    ::flyteidl::core::Container* temp = target_.container_;
    target_.container_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TaskTemplate::unsafe_arena_set_allocated_container(::flyteidl::core::Container* container) {
  clear_target();
  if (container) {
    set_has_container();
    target_.container_ = container;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.core.TaskTemplate.container)
}
inline ::flyteidl::core::Container* TaskTemplate::_internal_mutable_container() {
  if (!_internal_has_container()) {
    clear_target();
    set_has_container();
    target_.container_ = CreateMaybeMessage< ::flyteidl::core::Container >(GetArenaForAllocation());
  }
  return target_.container_;
}
inline ::flyteidl::core::Container* TaskTemplate::mutable_container() {
  ::flyteidl::core::Container* _msg = _internal_mutable_container();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.TaskTemplate.container)
  return _msg;
}

// .flyteidl.core.K8sPod k8s_pod = 17 [json_name = "k8sPod"];
inline bool TaskTemplate::_internal_has_k8s_pod() const {
  return target_case() == kK8SPod;
}
inline bool TaskTemplate::has_k8s_pod() const {
  return _internal_has_k8s_pod();
}
inline void TaskTemplate::set_has_k8s_pod() {
  _oneof_case_[0] = kK8SPod;
}
inline void TaskTemplate::clear_k8s_pod() {
  if (_internal_has_k8s_pod()) {
    if (GetArenaForAllocation() == nullptr) {
      delete target_.k8s_pod_;
    }
    clear_has_target();
  }
}
inline ::flyteidl::core::K8sPod* TaskTemplate::release_k8s_pod() {
  // @@protoc_insertion_point(field_release:flyteidl.core.TaskTemplate.k8s_pod)
  if (_internal_has_k8s_pod()) {
    clear_has_target();
      ::flyteidl::core::K8sPod* temp = target_.k8s_pod_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    target_.k8s_pod_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::core::K8sPod& TaskTemplate::_internal_k8s_pod() const {
  return _internal_has_k8s_pod()
      ? *target_.k8s_pod_
      : reinterpret_cast< ::flyteidl::core::K8sPod&>(::flyteidl::core::_K8sPod_default_instance_);
}
inline const ::flyteidl::core::K8sPod& TaskTemplate::k8s_pod() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.TaskTemplate.k8s_pod)
  return _internal_k8s_pod();
}
inline ::flyteidl::core::K8sPod* TaskTemplate::unsafe_arena_release_k8s_pod() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flyteidl.core.TaskTemplate.k8s_pod)
  if (_internal_has_k8s_pod()) {
    clear_has_target();
    ::flyteidl::core::K8sPod* temp = target_.k8s_pod_;
    target_.k8s_pod_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TaskTemplate::unsafe_arena_set_allocated_k8s_pod(::flyteidl::core::K8sPod* k8s_pod) {
  clear_target();
  if (k8s_pod) {
    set_has_k8s_pod();
    target_.k8s_pod_ = k8s_pod;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.core.TaskTemplate.k8s_pod)
}
inline ::flyteidl::core::K8sPod* TaskTemplate::_internal_mutable_k8s_pod() {
  if (!_internal_has_k8s_pod()) {
    clear_target();
    set_has_k8s_pod();
    target_.k8s_pod_ = CreateMaybeMessage< ::flyteidl::core::K8sPod >(GetArenaForAllocation());
  }
  return target_.k8s_pod_;
}
inline ::flyteidl::core::K8sPod* TaskTemplate::mutable_k8s_pod() {
  ::flyteidl::core::K8sPod* _msg = _internal_mutable_k8s_pod();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.TaskTemplate.k8s_pod)
  return _msg;
}

// .flyteidl.core.Sql sql = 18 [json_name = "sql"];
inline bool TaskTemplate::_internal_has_sql() const {
  return target_case() == kSql;
}
inline bool TaskTemplate::has_sql() const {
  return _internal_has_sql();
}
inline void TaskTemplate::set_has_sql() {
  _oneof_case_[0] = kSql;
}
inline void TaskTemplate::clear_sql() {
  if (_internal_has_sql()) {
    if (GetArenaForAllocation() == nullptr) {
      delete target_.sql_;
    }
    clear_has_target();
  }
}
inline ::flyteidl::core::Sql* TaskTemplate::release_sql() {
  // @@protoc_insertion_point(field_release:flyteidl.core.TaskTemplate.sql)
  if (_internal_has_sql()) {
    clear_has_target();
      ::flyteidl::core::Sql* temp = target_.sql_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    target_.sql_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::core::Sql& TaskTemplate::_internal_sql() const {
  return _internal_has_sql()
      ? *target_.sql_
      : reinterpret_cast< ::flyteidl::core::Sql&>(::flyteidl::core::_Sql_default_instance_);
}
inline const ::flyteidl::core::Sql& TaskTemplate::sql() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.TaskTemplate.sql)
  return _internal_sql();
}
inline ::flyteidl::core::Sql* TaskTemplate::unsafe_arena_release_sql() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flyteidl.core.TaskTemplate.sql)
  if (_internal_has_sql()) {
    clear_has_target();
    ::flyteidl::core::Sql* temp = target_.sql_;
    target_.sql_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TaskTemplate::unsafe_arena_set_allocated_sql(::flyteidl::core::Sql* sql) {
  clear_target();
  if (sql) {
    set_has_sql();
    target_.sql_ = sql;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.core.TaskTemplate.sql)
}
inline ::flyteidl::core::Sql* TaskTemplate::_internal_mutable_sql() {
  if (!_internal_has_sql()) {
    clear_target();
    set_has_sql();
    target_.sql_ = CreateMaybeMessage< ::flyteidl::core::Sql >(GetArenaForAllocation());
  }
  return target_.sql_;
}
inline ::flyteidl::core::Sql* TaskTemplate::mutable_sql() {
  ::flyteidl::core::Sql* _msg = _internal_mutable_sql();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.TaskTemplate.sql)
  return _msg;
}

// int32 task_type_version = 7 [json_name = "taskTypeVersion"];
inline void TaskTemplate::clear_task_type_version() {
  task_type_version_ = 0;
}
inline int32_t TaskTemplate::_internal_task_type_version() const {
  return task_type_version_;
}
inline int32_t TaskTemplate::task_type_version() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.TaskTemplate.task_type_version)
  return _internal_task_type_version();
}
inline void TaskTemplate::_internal_set_task_type_version(int32_t value) {
  
  task_type_version_ = value;
}
inline void TaskTemplate::set_task_type_version(int32_t value) {
  _internal_set_task_type_version(value);
  // @@protoc_insertion_point(field_set:flyteidl.core.TaskTemplate.task_type_version)
}

// .flyteidl.core.SecurityContext security_context = 8 [json_name = "securityContext"];
inline bool TaskTemplate::_internal_has_security_context() const {
  return this != internal_default_instance() && security_context_ != nullptr;
}
inline bool TaskTemplate::has_security_context() const {
  return _internal_has_security_context();
}
inline const ::flyteidl::core::SecurityContext& TaskTemplate::_internal_security_context() const {
  const ::flyteidl::core::SecurityContext* p = security_context_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::core::SecurityContext&>(
      ::flyteidl::core::_SecurityContext_default_instance_);
}
inline const ::flyteidl::core::SecurityContext& TaskTemplate::security_context() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.TaskTemplate.security_context)
  return _internal_security_context();
}
inline void TaskTemplate::unsafe_arena_set_allocated_security_context(
    ::flyteidl::core::SecurityContext* security_context) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(security_context_);
  }
  security_context_ = security_context;
  if (security_context) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.core.TaskTemplate.security_context)
}
inline ::flyteidl::core::SecurityContext* TaskTemplate::release_security_context() {
  
  ::flyteidl::core::SecurityContext* temp = security_context_;
  security_context_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::core::SecurityContext* TaskTemplate::unsafe_arena_release_security_context() {
  // @@protoc_insertion_point(field_release:flyteidl.core.TaskTemplate.security_context)
  
  ::flyteidl::core::SecurityContext* temp = security_context_;
  security_context_ = nullptr;
  return temp;
}
inline ::flyteidl::core::SecurityContext* TaskTemplate::_internal_mutable_security_context() {
  
  if (security_context_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::SecurityContext>(GetArenaForAllocation());
    security_context_ = p;
  }
  return security_context_;
}
inline ::flyteidl::core::SecurityContext* TaskTemplate::mutable_security_context() {
  ::flyteidl::core::SecurityContext* _msg = _internal_mutable_security_context();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.TaskTemplate.security_context)
  return _msg;
}
inline void TaskTemplate::set_allocated_security_context(::flyteidl::core::SecurityContext* security_context) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(security_context_);
  }
  if (security_context) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(security_context));
    if (message_arena != submessage_arena) {
      security_context = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, security_context, submessage_arena);
    }
    
  } else {
    
  }
  security_context_ = security_context;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.TaskTemplate.security_context)
}

// map<string, string> config = 16 [json_name = "config"];
inline int TaskTemplate::_internal_config_size() const {
  return config_.size();
}
inline int TaskTemplate::config_size() const {
  return _internal_config_size();
}
inline void TaskTemplate::clear_config() {
  config_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
TaskTemplate::_internal_config() const {
  return config_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
TaskTemplate::config() const {
  // @@protoc_insertion_point(field_map:flyteidl.core.TaskTemplate.config)
  return _internal_config();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
TaskTemplate::_internal_mutable_config() {
  return config_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
TaskTemplate::mutable_config() {
  // @@protoc_insertion_point(field_mutable_map:flyteidl.core.TaskTemplate.config)
  return _internal_mutable_config();
}

inline bool TaskTemplate::has_target() const {
  return target_case() != TARGET_NOT_SET;
}
inline void TaskTemplate::clear_has_target() {
  _oneof_case_[0] = TARGET_NOT_SET;
}
inline TaskTemplate::TargetCase TaskTemplate::target_case() const {
  return TaskTemplate::TargetCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ContainerPort

// uint32 container_port = 1 [json_name = "containerPort"];
inline void ContainerPort::clear_container_port() {
  container_port_ = 0u;
}
inline uint32_t ContainerPort::_internal_container_port() const {
  return container_port_;
}
inline uint32_t ContainerPort::container_port() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.ContainerPort.container_port)
  return _internal_container_port();
}
inline void ContainerPort::_internal_set_container_port(uint32_t value) {
  
  container_port_ = value;
}
inline void ContainerPort::set_container_port(uint32_t value) {
  _internal_set_container_port(value);
  // @@protoc_insertion_point(field_set:flyteidl.core.ContainerPort.container_port)
}

// -------------------------------------------------------------------

// Container

// string image = 1 [json_name = "image"];
inline void Container::clear_image() {
  image_.ClearToEmpty();
}
inline const std::string& Container::image() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Container.image)
  return _internal_image();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Container::set_image(ArgT0&& arg0, ArgT... args) {
 
 image_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.core.Container.image)
}
inline std::string* Container::mutable_image() {
  std::string* _s = _internal_mutable_image();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Container.image)
  return _s;
}
inline const std::string& Container::_internal_image() const {
  return image_.Get();
}
inline void Container::_internal_set_image(const std::string& value) {
  
  image_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Container::_internal_mutable_image() {
  
  return image_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Container::release_image() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Container.image)
  return image_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Container::set_allocated_image(std::string* image) {
  if (image != nullptr) {
    
  } else {
    
  }
  image_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), image,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (image_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    image_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.Container.image)
}

// repeated string command = 2 [json_name = "command"];
inline int Container::_internal_command_size() const {
  return command_.size();
}
inline int Container::command_size() const {
  return _internal_command_size();
}
inline void Container::clear_command() {
  command_.Clear();
}
inline std::string* Container::add_command() {
  std::string* _s = _internal_add_command();
  // @@protoc_insertion_point(field_add_mutable:flyteidl.core.Container.command)
  return _s;
}
inline const std::string& Container::_internal_command(int index) const {
  return command_.Get(index);
}
inline const std::string& Container::command(int index) const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Container.command)
  return _internal_command(index);
}
inline std::string* Container::mutable_command(int index) {
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Container.command)
  return command_.Mutable(index);
}
inline void Container::set_command(int index, const std::string& value) {
  command_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:flyteidl.core.Container.command)
}
inline void Container::set_command(int index, std::string&& value) {
  command_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:flyteidl.core.Container.command)
}
inline void Container::set_command(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  command_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:flyteidl.core.Container.command)
}
inline void Container::set_command(int index, const char* value, size_t size) {
  command_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.Container.command)
}
inline std::string* Container::_internal_add_command() {
  return command_.Add();
}
inline void Container::add_command(const std::string& value) {
  command_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:flyteidl.core.Container.command)
}
inline void Container::add_command(std::string&& value) {
  command_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:flyteidl.core.Container.command)
}
inline void Container::add_command(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  command_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:flyteidl.core.Container.command)
}
inline void Container::add_command(const char* value, size_t size) {
  command_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:flyteidl.core.Container.command)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Container::command() const {
  // @@protoc_insertion_point(field_list:flyteidl.core.Container.command)
  return command_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Container::mutable_command() {
  // @@protoc_insertion_point(field_mutable_list:flyteidl.core.Container.command)
  return &command_;
}

// repeated string args = 3 [json_name = "args"];
inline int Container::_internal_args_size() const {
  return args_.size();
}
inline int Container::args_size() const {
  return _internal_args_size();
}
inline void Container::clear_args() {
  args_.Clear();
}
inline std::string* Container::add_args() {
  std::string* _s = _internal_add_args();
  // @@protoc_insertion_point(field_add_mutable:flyteidl.core.Container.args)
  return _s;
}
inline const std::string& Container::_internal_args(int index) const {
  return args_.Get(index);
}
inline const std::string& Container::args(int index) const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Container.args)
  return _internal_args(index);
}
inline std::string* Container::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Container.args)
  return args_.Mutable(index);
}
inline void Container::set_args(int index, const std::string& value) {
  args_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:flyteidl.core.Container.args)
}
inline void Container::set_args(int index, std::string&& value) {
  args_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:flyteidl.core.Container.args)
}
inline void Container::set_args(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  args_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:flyteidl.core.Container.args)
}
inline void Container::set_args(int index, const char* value, size_t size) {
  args_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.Container.args)
}
inline std::string* Container::_internal_add_args() {
  return args_.Add();
}
inline void Container::add_args(const std::string& value) {
  args_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:flyteidl.core.Container.args)
}
inline void Container::add_args(std::string&& value) {
  args_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:flyteidl.core.Container.args)
}
inline void Container::add_args(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  args_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:flyteidl.core.Container.args)
}
inline void Container::add_args(const char* value, size_t size) {
  args_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:flyteidl.core.Container.args)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Container::args() const {
  // @@protoc_insertion_point(field_list:flyteidl.core.Container.args)
  return args_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Container::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:flyteidl.core.Container.args)
  return &args_;
}

// .flyteidl.core.Resources resources = 4 [json_name = "resources"];
inline bool Container::_internal_has_resources() const {
  return this != internal_default_instance() && resources_ != nullptr;
}
inline bool Container::has_resources() const {
  return _internal_has_resources();
}
inline void Container::clear_resources() {
  if (GetArenaForAllocation() == nullptr && resources_ != nullptr) {
    delete resources_;
  }
  resources_ = nullptr;
}
inline const ::flyteidl::core::Resources& Container::_internal_resources() const {
  const ::flyteidl::core::Resources* p = resources_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::core::Resources&>(
      ::flyteidl::core::_Resources_default_instance_);
}
inline const ::flyteidl::core::Resources& Container::resources() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Container.resources)
  return _internal_resources();
}
inline void Container::unsafe_arena_set_allocated_resources(
    ::flyteidl::core::Resources* resources) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(resources_);
  }
  resources_ = resources;
  if (resources) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.core.Container.resources)
}
inline ::flyteidl::core::Resources* Container::release_resources() {
  
  ::flyteidl::core::Resources* temp = resources_;
  resources_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::core::Resources* Container::unsafe_arena_release_resources() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Container.resources)
  
  ::flyteidl::core::Resources* temp = resources_;
  resources_ = nullptr;
  return temp;
}
inline ::flyteidl::core::Resources* Container::_internal_mutable_resources() {
  
  if (resources_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::Resources>(GetArenaForAllocation());
    resources_ = p;
  }
  return resources_;
}
inline ::flyteidl::core::Resources* Container::mutable_resources() {
  ::flyteidl::core::Resources* _msg = _internal_mutable_resources();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Container.resources)
  return _msg;
}
inline void Container::set_allocated_resources(::flyteidl::core::Resources* resources) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete resources_;
  }
  if (resources) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::flyteidl::core::Resources>::GetOwningArena(resources);
    if (message_arena != submessage_arena) {
      resources = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, resources, submessage_arena);
    }
    
  } else {
    
  }
  resources_ = resources;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.Container.resources)
}

// repeated .flyteidl.core.KeyValuePair env = 5 [json_name = "env"];
inline int Container::_internal_env_size() const {
  return env_.size();
}
inline int Container::env_size() const {
  return _internal_env_size();
}
inline ::flyteidl::core::KeyValuePair* Container::mutable_env(int index) {
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Container.env)
  return env_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::core::KeyValuePair >*
Container::mutable_env() {
  // @@protoc_insertion_point(field_mutable_list:flyteidl.core.Container.env)
  return &env_;
}
inline const ::flyteidl::core::KeyValuePair& Container::_internal_env(int index) const {
  return env_.Get(index);
}
inline const ::flyteidl::core::KeyValuePair& Container::env(int index) const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Container.env)
  return _internal_env(index);
}
inline ::flyteidl::core::KeyValuePair* Container::_internal_add_env() {
  return env_.Add();
}
inline ::flyteidl::core::KeyValuePair* Container::add_env() {
  ::flyteidl::core::KeyValuePair* _add = _internal_add_env();
  // @@protoc_insertion_point(field_add:flyteidl.core.Container.env)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::core::KeyValuePair >&
Container::env() const {
  // @@protoc_insertion_point(field_list:flyteidl.core.Container.env)
  return env_;
}

// repeated .flyteidl.core.KeyValuePair config = 6 [json_name = "config", deprecated = true];
inline int Container::_internal_config_size() const {
  return config_.size();
}
inline int Container::config_size() const {
  return _internal_config_size();
}
inline ::flyteidl::core::KeyValuePair* Container::mutable_config(int index) {
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Container.config)
  return config_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::core::KeyValuePair >*
Container::mutable_config() {
  // @@protoc_insertion_point(field_mutable_list:flyteidl.core.Container.config)
  return &config_;
}
inline const ::flyteidl::core::KeyValuePair& Container::_internal_config(int index) const {
  return config_.Get(index);
}
inline const ::flyteidl::core::KeyValuePair& Container::config(int index) const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Container.config)
  return _internal_config(index);
}
inline ::flyteidl::core::KeyValuePair* Container::_internal_add_config() {
  return config_.Add();
}
inline ::flyteidl::core::KeyValuePair* Container::add_config() {
  ::flyteidl::core::KeyValuePair* _add = _internal_add_config();
  // @@protoc_insertion_point(field_add:flyteidl.core.Container.config)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::core::KeyValuePair >&
Container::config() const {
  // @@protoc_insertion_point(field_list:flyteidl.core.Container.config)
  return config_;
}

// repeated .flyteidl.core.ContainerPort ports = 7 [json_name = "ports"];
inline int Container::_internal_ports_size() const {
  return ports_.size();
}
inline int Container::ports_size() const {
  return _internal_ports_size();
}
inline void Container::clear_ports() {
  ports_.Clear();
}
inline ::flyteidl::core::ContainerPort* Container::mutable_ports(int index) {
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Container.ports)
  return ports_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::core::ContainerPort >*
Container::mutable_ports() {
  // @@protoc_insertion_point(field_mutable_list:flyteidl.core.Container.ports)
  return &ports_;
}
inline const ::flyteidl::core::ContainerPort& Container::_internal_ports(int index) const {
  return ports_.Get(index);
}
inline const ::flyteidl::core::ContainerPort& Container::ports(int index) const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Container.ports)
  return _internal_ports(index);
}
inline ::flyteidl::core::ContainerPort* Container::_internal_add_ports() {
  return ports_.Add();
}
inline ::flyteidl::core::ContainerPort* Container::add_ports() {
  ::flyteidl::core::ContainerPort* _add = _internal_add_ports();
  // @@protoc_insertion_point(field_add:flyteidl.core.Container.ports)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flyteidl::core::ContainerPort >&
Container::ports() const {
  // @@protoc_insertion_point(field_list:flyteidl.core.Container.ports)
  return ports_;
}

// .flyteidl.core.DataLoadingConfig data_config = 9 [json_name = "dataConfig"];
inline bool Container::_internal_has_data_config() const {
  return this != internal_default_instance() && data_config_ != nullptr;
}
inline bool Container::has_data_config() const {
  return _internal_has_data_config();
}
inline void Container::clear_data_config() {
  if (GetArenaForAllocation() == nullptr && data_config_ != nullptr) {
    delete data_config_;
  }
  data_config_ = nullptr;
}
inline const ::flyteidl::core::DataLoadingConfig& Container::_internal_data_config() const {
  const ::flyteidl::core::DataLoadingConfig* p = data_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::core::DataLoadingConfig&>(
      ::flyteidl::core::_DataLoadingConfig_default_instance_);
}
inline const ::flyteidl::core::DataLoadingConfig& Container::data_config() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Container.data_config)
  return _internal_data_config();
}
inline void Container::unsafe_arena_set_allocated_data_config(
    ::flyteidl::core::DataLoadingConfig* data_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_config_);
  }
  data_config_ = data_config;
  if (data_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.core.Container.data_config)
}
inline ::flyteidl::core::DataLoadingConfig* Container::release_data_config() {
  
  ::flyteidl::core::DataLoadingConfig* temp = data_config_;
  data_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::core::DataLoadingConfig* Container::unsafe_arena_release_data_config() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Container.data_config)
  
  ::flyteidl::core::DataLoadingConfig* temp = data_config_;
  data_config_ = nullptr;
  return temp;
}
inline ::flyteidl::core::DataLoadingConfig* Container::_internal_mutable_data_config() {
  
  if (data_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::DataLoadingConfig>(GetArenaForAllocation());
    data_config_ = p;
  }
  return data_config_;
}
inline ::flyteidl::core::DataLoadingConfig* Container::mutable_data_config() {
  ::flyteidl::core::DataLoadingConfig* _msg = _internal_mutable_data_config();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Container.data_config)
  return _msg;
}
inline void Container::set_allocated_data_config(::flyteidl::core::DataLoadingConfig* data_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete data_config_;
  }
  if (data_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::flyteidl::core::DataLoadingConfig>::GetOwningArena(data_config);
    if (message_arena != submessage_arena) {
      data_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data_config, submessage_arena);
    }
    
  } else {
    
  }
  data_config_ = data_config;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.Container.data_config)
}

// .flyteidl.core.Container.Architecture architecture = 10 [json_name = "architecture"];
inline void Container::clear_architecture() {
  architecture_ = 0;
}
inline ::flyteidl::core::Container_Architecture Container::_internal_architecture() const {
  return static_cast< ::flyteidl::core::Container_Architecture >(architecture_);
}
inline ::flyteidl::core::Container_Architecture Container::architecture() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Container.architecture)
  return _internal_architecture();
}
inline void Container::_internal_set_architecture(::flyteidl::core::Container_Architecture value) {
  
  architecture_ = value;
}
inline void Container::set_architecture(::flyteidl::core::Container_Architecture value) {
  _internal_set_architecture(value);
  // @@protoc_insertion_point(field_set:flyteidl.core.Container.architecture)
}

// -------------------------------------------------------------------

// IOStrategy

// .flyteidl.core.IOStrategy.DownloadMode download_mode = 1 [json_name = "downloadMode"];
inline void IOStrategy::clear_download_mode() {
  download_mode_ = 0;
}
inline ::flyteidl::core::IOStrategy_DownloadMode IOStrategy::_internal_download_mode() const {
  return static_cast< ::flyteidl::core::IOStrategy_DownloadMode >(download_mode_);
}
inline ::flyteidl::core::IOStrategy_DownloadMode IOStrategy::download_mode() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.IOStrategy.download_mode)
  return _internal_download_mode();
}
inline void IOStrategy::_internal_set_download_mode(::flyteidl::core::IOStrategy_DownloadMode value) {
  
  download_mode_ = value;
}
inline void IOStrategy::set_download_mode(::flyteidl::core::IOStrategy_DownloadMode value) {
  _internal_set_download_mode(value);
  // @@protoc_insertion_point(field_set:flyteidl.core.IOStrategy.download_mode)
}

// .flyteidl.core.IOStrategy.UploadMode upload_mode = 2 [json_name = "uploadMode"];
inline void IOStrategy::clear_upload_mode() {
  upload_mode_ = 0;
}
inline ::flyteidl::core::IOStrategy_UploadMode IOStrategy::_internal_upload_mode() const {
  return static_cast< ::flyteidl::core::IOStrategy_UploadMode >(upload_mode_);
}
inline ::flyteidl::core::IOStrategy_UploadMode IOStrategy::upload_mode() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.IOStrategy.upload_mode)
  return _internal_upload_mode();
}
inline void IOStrategy::_internal_set_upload_mode(::flyteidl::core::IOStrategy_UploadMode value) {
  
  upload_mode_ = value;
}
inline void IOStrategy::set_upload_mode(::flyteidl::core::IOStrategy_UploadMode value) {
  _internal_set_upload_mode(value);
  // @@protoc_insertion_point(field_set:flyteidl.core.IOStrategy.upload_mode)
}

// -------------------------------------------------------------------

// DataLoadingConfig

// bool enabled = 1 [json_name = "enabled"];
inline void DataLoadingConfig::clear_enabled() {
  enabled_ = false;
}
inline bool DataLoadingConfig::_internal_enabled() const {
  return enabled_;
}
inline bool DataLoadingConfig::enabled() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.DataLoadingConfig.enabled)
  return _internal_enabled();
}
inline void DataLoadingConfig::_internal_set_enabled(bool value) {
  
  enabled_ = value;
}
inline void DataLoadingConfig::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:flyteidl.core.DataLoadingConfig.enabled)
}

// string input_path = 2 [json_name = "inputPath"];
inline void DataLoadingConfig::clear_input_path() {
  input_path_.ClearToEmpty();
}
inline const std::string& DataLoadingConfig::input_path() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.DataLoadingConfig.input_path)
  return _internal_input_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataLoadingConfig::set_input_path(ArgT0&& arg0, ArgT... args) {
 
 input_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.core.DataLoadingConfig.input_path)
}
inline std::string* DataLoadingConfig::mutable_input_path() {
  std::string* _s = _internal_mutable_input_path();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.DataLoadingConfig.input_path)
  return _s;
}
inline const std::string& DataLoadingConfig::_internal_input_path() const {
  return input_path_.Get();
}
inline void DataLoadingConfig::_internal_set_input_path(const std::string& value) {
  
  input_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DataLoadingConfig::_internal_mutable_input_path() {
  
  return input_path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DataLoadingConfig::release_input_path() {
  // @@protoc_insertion_point(field_release:flyteidl.core.DataLoadingConfig.input_path)
  return input_path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DataLoadingConfig::set_allocated_input_path(std::string* input_path) {
  if (input_path != nullptr) {
    
  } else {
    
  }
  input_path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), input_path,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (input_path_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    input_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.DataLoadingConfig.input_path)
}

// string output_path = 3 [json_name = "outputPath"];
inline void DataLoadingConfig::clear_output_path() {
  output_path_.ClearToEmpty();
}
inline const std::string& DataLoadingConfig::output_path() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.DataLoadingConfig.output_path)
  return _internal_output_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataLoadingConfig::set_output_path(ArgT0&& arg0, ArgT... args) {
 
 output_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.core.DataLoadingConfig.output_path)
}
inline std::string* DataLoadingConfig::mutable_output_path() {
  std::string* _s = _internal_mutable_output_path();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.DataLoadingConfig.output_path)
  return _s;
}
inline const std::string& DataLoadingConfig::_internal_output_path() const {
  return output_path_.Get();
}
inline void DataLoadingConfig::_internal_set_output_path(const std::string& value) {
  
  output_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DataLoadingConfig::_internal_mutable_output_path() {
  
  return output_path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DataLoadingConfig::release_output_path() {
  // @@protoc_insertion_point(field_release:flyteidl.core.DataLoadingConfig.output_path)
  return output_path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DataLoadingConfig::set_allocated_output_path(std::string* output_path) {
  if (output_path != nullptr) {
    
  } else {
    
  }
  output_path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), output_path,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (output_path_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    output_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.DataLoadingConfig.output_path)
}

// .flyteidl.core.DataLoadingConfig.LiteralMapFormat format = 4 [json_name = "format"];
inline void DataLoadingConfig::clear_format() {
  format_ = 0;
}
inline ::flyteidl::core::DataLoadingConfig_LiteralMapFormat DataLoadingConfig::_internal_format() const {
  return static_cast< ::flyteidl::core::DataLoadingConfig_LiteralMapFormat >(format_);
}
inline ::flyteidl::core::DataLoadingConfig_LiteralMapFormat DataLoadingConfig::format() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.DataLoadingConfig.format)
  return _internal_format();
}
inline void DataLoadingConfig::_internal_set_format(::flyteidl::core::DataLoadingConfig_LiteralMapFormat value) {
  
  format_ = value;
}
inline void DataLoadingConfig::set_format(::flyteidl::core::DataLoadingConfig_LiteralMapFormat value) {
  _internal_set_format(value);
  // @@protoc_insertion_point(field_set:flyteidl.core.DataLoadingConfig.format)
}

// .flyteidl.core.IOStrategy io_strategy = 5 [json_name = "ioStrategy"];
inline bool DataLoadingConfig::_internal_has_io_strategy() const {
  return this != internal_default_instance() && io_strategy_ != nullptr;
}
inline bool DataLoadingConfig::has_io_strategy() const {
  return _internal_has_io_strategy();
}
inline void DataLoadingConfig::clear_io_strategy() {
  if (GetArenaForAllocation() == nullptr && io_strategy_ != nullptr) {
    delete io_strategy_;
  }
  io_strategy_ = nullptr;
}
inline const ::flyteidl::core::IOStrategy& DataLoadingConfig::_internal_io_strategy() const {
  const ::flyteidl::core::IOStrategy* p = io_strategy_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::core::IOStrategy&>(
      ::flyteidl::core::_IOStrategy_default_instance_);
}
inline const ::flyteidl::core::IOStrategy& DataLoadingConfig::io_strategy() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.DataLoadingConfig.io_strategy)
  return _internal_io_strategy();
}
inline void DataLoadingConfig::unsafe_arena_set_allocated_io_strategy(
    ::flyteidl::core::IOStrategy* io_strategy) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(io_strategy_);
  }
  io_strategy_ = io_strategy;
  if (io_strategy) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.core.DataLoadingConfig.io_strategy)
}
inline ::flyteidl::core::IOStrategy* DataLoadingConfig::release_io_strategy() {
  
  ::flyteidl::core::IOStrategy* temp = io_strategy_;
  io_strategy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::core::IOStrategy* DataLoadingConfig::unsafe_arena_release_io_strategy() {
  // @@protoc_insertion_point(field_release:flyteidl.core.DataLoadingConfig.io_strategy)
  
  ::flyteidl::core::IOStrategy* temp = io_strategy_;
  io_strategy_ = nullptr;
  return temp;
}
inline ::flyteidl::core::IOStrategy* DataLoadingConfig::_internal_mutable_io_strategy() {
  
  if (io_strategy_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::IOStrategy>(GetArenaForAllocation());
    io_strategy_ = p;
  }
  return io_strategy_;
}
inline ::flyteidl::core::IOStrategy* DataLoadingConfig::mutable_io_strategy() {
  ::flyteidl::core::IOStrategy* _msg = _internal_mutable_io_strategy();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.DataLoadingConfig.io_strategy)
  return _msg;
}
inline void DataLoadingConfig::set_allocated_io_strategy(::flyteidl::core::IOStrategy* io_strategy) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete io_strategy_;
  }
  if (io_strategy) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::flyteidl::core::IOStrategy>::GetOwningArena(io_strategy);
    if (message_arena != submessage_arena) {
      io_strategy = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, io_strategy, submessage_arena);
    }
    
  } else {
    
  }
  io_strategy_ = io_strategy;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.DataLoadingConfig.io_strategy)
}

// -------------------------------------------------------------------

// K8sPod

// .flyteidl.core.K8sObjectMetadata metadata = 1 [json_name = "metadata"];
inline bool K8sPod::_internal_has_metadata() const {
  return this != internal_default_instance() && metadata_ != nullptr;
}
inline bool K8sPod::has_metadata() const {
  return _internal_has_metadata();
}
inline void K8sPod::clear_metadata() {
  if (GetArenaForAllocation() == nullptr && metadata_ != nullptr) {
    delete metadata_;
  }
  metadata_ = nullptr;
}
inline const ::flyteidl::core::K8sObjectMetadata& K8sPod::_internal_metadata() const {
  const ::flyteidl::core::K8sObjectMetadata* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::flyteidl::core::K8sObjectMetadata&>(
      ::flyteidl::core::_K8sObjectMetadata_default_instance_);
}
inline const ::flyteidl::core::K8sObjectMetadata& K8sPod::metadata() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.K8sPod.metadata)
  return _internal_metadata();
}
inline void K8sPod::unsafe_arena_set_allocated_metadata(
    ::flyteidl::core::K8sObjectMetadata* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.core.K8sPod.metadata)
}
inline ::flyteidl::core::K8sObjectMetadata* K8sPod::release_metadata() {
  
  ::flyteidl::core::K8sObjectMetadata* temp = metadata_;
  metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flyteidl::core::K8sObjectMetadata* K8sPod::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:flyteidl.core.K8sPod.metadata)
  
  ::flyteidl::core::K8sObjectMetadata* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::flyteidl::core::K8sObjectMetadata* K8sPod::_internal_mutable_metadata() {
  
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::K8sObjectMetadata>(GetArenaForAllocation());
    metadata_ = p;
  }
  return metadata_;
}
inline ::flyteidl::core::K8sObjectMetadata* K8sPod::mutable_metadata() {
  ::flyteidl::core::K8sObjectMetadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.K8sPod.metadata)
  return _msg;
}
inline void K8sPod::set_allocated_metadata(::flyteidl::core::K8sObjectMetadata* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete metadata_;
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::flyteidl::core::K8sObjectMetadata>::GetOwningArena(metadata);
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.K8sPod.metadata)
}

// .google.protobuf.Struct pod_spec = 2 [json_name = "podSpec"];
inline bool K8sPod::_internal_has_pod_spec() const {
  return this != internal_default_instance() && pod_spec_ != nullptr;
}
inline bool K8sPod::has_pod_spec() const {
  return _internal_has_pod_spec();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& K8sPod::_internal_pod_spec() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = pod_spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& K8sPod::pod_spec() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.K8sPod.pod_spec)
  return _internal_pod_spec();
}
inline void K8sPod::unsafe_arena_set_allocated_pod_spec(
    ::PROTOBUF_NAMESPACE_ID::Struct* pod_spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pod_spec_);
  }
  pod_spec_ = pod_spec;
  if (pod_spec) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flyteidl.core.K8sPod.pod_spec)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* K8sPod::release_pod_spec() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = pod_spec_;
  pod_spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* K8sPod::unsafe_arena_release_pod_spec() {
  // @@protoc_insertion_point(field_release:flyteidl.core.K8sPod.pod_spec)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = pod_spec_;
  pod_spec_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* K8sPod::_internal_mutable_pod_spec() {
  
  if (pod_spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    pod_spec_ = p;
  }
  return pod_spec_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* K8sPod::mutable_pod_spec() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_pod_spec();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.K8sPod.pod_spec)
  return _msg;
}
inline void K8sPod::set_allocated_pod_spec(::PROTOBUF_NAMESPACE_ID::Struct* pod_spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(pod_spec_);
  }
  if (pod_spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pod_spec));
    if (message_arena != submessage_arena) {
      pod_spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pod_spec, submessage_arena);
    }
    
  } else {
    
  }
  pod_spec_ = pod_spec;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.K8sPod.pod_spec)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// K8sObjectMetadata

// map<string, string> labels = 1 [json_name = "labels"];
inline int K8sObjectMetadata::_internal_labels_size() const {
  return labels_.size();
}
inline int K8sObjectMetadata::labels_size() const {
  return _internal_labels_size();
}
inline void K8sObjectMetadata::clear_labels() {
  labels_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
K8sObjectMetadata::_internal_labels() const {
  return labels_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
K8sObjectMetadata::labels() const {
  // @@protoc_insertion_point(field_map:flyteidl.core.K8sObjectMetadata.labels)
  return _internal_labels();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
K8sObjectMetadata::_internal_mutable_labels() {
  return labels_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
K8sObjectMetadata::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_map:flyteidl.core.K8sObjectMetadata.labels)
  return _internal_mutable_labels();
}

// map<string, string> annotations = 2 [json_name = "annotations"];
inline int K8sObjectMetadata::_internal_annotations_size() const {
  return annotations_.size();
}
inline int K8sObjectMetadata::annotations_size() const {
  return _internal_annotations_size();
}
inline void K8sObjectMetadata::clear_annotations() {
  annotations_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
K8sObjectMetadata::_internal_annotations() const {
  return annotations_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
K8sObjectMetadata::annotations() const {
  // @@protoc_insertion_point(field_map:flyteidl.core.K8sObjectMetadata.annotations)
  return _internal_annotations();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
K8sObjectMetadata::_internal_mutable_annotations() {
  return annotations_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
K8sObjectMetadata::mutable_annotations() {
  // @@protoc_insertion_point(field_mutable_map:flyteidl.core.K8sObjectMetadata.annotations)
  return _internal_mutable_annotations();
}

// -------------------------------------------------------------------

// Sql

// string statement = 1 [json_name = "statement"];
inline void Sql::clear_statement() {
  statement_.ClearToEmpty();
}
inline const std::string& Sql::statement() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Sql.statement)
  return _internal_statement();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Sql::set_statement(ArgT0&& arg0, ArgT... args) {
 
 statement_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flyteidl.core.Sql.statement)
}
inline std::string* Sql::mutable_statement() {
  std::string* _s = _internal_mutable_statement();
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Sql.statement)
  return _s;
}
inline const std::string& Sql::_internal_statement() const {
  return statement_.Get();
}
inline void Sql::_internal_set_statement(const std::string& value) {
  
  statement_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Sql::_internal_mutable_statement() {
  
  return statement_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Sql::release_statement() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Sql.statement)
  return statement_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Sql::set_allocated_statement(std::string* statement) {
  if (statement != nullptr) {
    
  } else {
    
  }
  statement_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), statement,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (statement_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    statement_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.Sql.statement)
}

// .flyteidl.core.Sql.Dialect dialect = 2 [json_name = "dialect"];
inline void Sql::clear_dialect() {
  dialect_ = 0;
}
inline ::flyteidl::core::Sql_Dialect Sql::_internal_dialect() const {
  return static_cast< ::flyteidl::core::Sql_Dialect >(dialect_);
}
inline ::flyteidl::core::Sql_Dialect Sql::dialect() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Sql.dialect)
  return _internal_dialect();
}
inline void Sql::_internal_set_dialect(::flyteidl::core::Sql_Dialect value) {
  
  dialect_ = value;
}
inline void Sql::set_dialect(::flyteidl::core::Sql_Dialect value) {
  _internal_set_dialect(value);
  // @@protoc_insertion_point(field_set:flyteidl.core.Sql.dialect)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace core
}  // namespace flyteidl

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::flyteidl::core::Resources_ResourceName> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::flyteidl::core::Resources_ResourceName>() {
  return ::flyteidl::core::Resources_ResourceName_descriptor();
}
template <> struct is_proto_enum< ::flyteidl::core::RuntimeMetadata_RuntimeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::flyteidl::core::RuntimeMetadata_RuntimeType>() {
  return ::flyteidl::core::RuntimeMetadata_RuntimeType_descriptor();
}
template <> struct is_proto_enum< ::flyteidl::core::Container_Architecture> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::flyteidl::core::Container_Architecture>() {
  return ::flyteidl::core::Container_Architecture_descriptor();
}
template <> struct is_proto_enum< ::flyteidl::core::IOStrategy_DownloadMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::flyteidl::core::IOStrategy_DownloadMode>() {
  return ::flyteidl::core::IOStrategy_DownloadMode_descriptor();
}
template <> struct is_proto_enum< ::flyteidl::core::IOStrategy_UploadMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::flyteidl::core::IOStrategy_UploadMode>() {
  return ::flyteidl::core::IOStrategy_UploadMode_descriptor();
}
template <> struct is_proto_enum< ::flyteidl::core::DataLoadingConfig_LiteralMapFormat> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::flyteidl::core::DataLoadingConfig_LiteralMapFormat>() {
  return ::flyteidl::core::DataLoadingConfig_LiteralMapFormat_descriptor();
}
template <> struct is_proto_enum< ::flyteidl::core::Sql_Dialect> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::flyteidl::core::Sql_Dialect>() {
  return ::flyteidl::core::Sql_Dialect_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_flyteidl_2fcore_2ftasks_2eproto
