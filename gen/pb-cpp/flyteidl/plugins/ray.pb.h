// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: flyteidl/plugins/ray.proto

#ifndef PROTOBUF_INCLUDED_flyteidl_2fplugins_2fray_2eproto
#define PROTOBUF_INCLUDED_flyteidl_2fplugins_2fray_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_flyteidl_2fplugins_2fray_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_flyteidl_2fplugins_2fray_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[6]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_flyteidl_2fplugins_2fray_2eproto();
namespace flyteidl {
namespace plugins {
class HeadGroupSpec;
class HeadGroupSpecDefaultTypeInternal;
extern HeadGroupSpecDefaultTypeInternal _HeadGroupSpec_default_instance_;
class HeadGroupSpec_RayStartParamsEntry_DoNotUse;
class HeadGroupSpec_RayStartParamsEntry_DoNotUseDefaultTypeInternal;
extern HeadGroupSpec_RayStartParamsEntry_DoNotUseDefaultTypeInternal _HeadGroupSpec_RayStartParamsEntry_DoNotUse_default_instance_;
class RayCluster;
class RayClusterDefaultTypeInternal;
extern RayClusterDefaultTypeInternal _RayCluster_default_instance_;
class RayJob;
class RayJobDefaultTypeInternal;
extern RayJobDefaultTypeInternal _RayJob_default_instance_;
class WorkerGroupSpec;
class WorkerGroupSpecDefaultTypeInternal;
extern WorkerGroupSpecDefaultTypeInternal _WorkerGroupSpec_default_instance_;
class WorkerGroupSpec_RayStartParamsEntry_DoNotUse;
class WorkerGroupSpec_RayStartParamsEntry_DoNotUseDefaultTypeInternal;
extern WorkerGroupSpec_RayStartParamsEntry_DoNotUseDefaultTypeInternal _WorkerGroupSpec_RayStartParamsEntry_DoNotUse_default_instance_;
}  // namespace plugins
}  // namespace flyteidl
namespace google {
namespace protobuf {
template<> ::flyteidl::plugins::HeadGroupSpec* Arena::CreateMaybeMessage<::flyteidl::plugins::HeadGroupSpec>(Arena*);
template<> ::flyteidl::plugins::HeadGroupSpec_RayStartParamsEntry_DoNotUse* Arena::CreateMaybeMessage<::flyteidl::plugins::HeadGroupSpec_RayStartParamsEntry_DoNotUse>(Arena*);
template<> ::flyteidl::plugins::RayCluster* Arena::CreateMaybeMessage<::flyteidl::plugins::RayCluster>(Arena*);
template<> ::flyteidl::plugins::RayJob* Arena::CreateMaybeMessage<::flyteidl::plugins::RayJob>(Arena*);
template<> ::flyteidl::plugins::WorkerGroupSpec* Arena::CreateMaybeMessage<::flyteidl::plugins::WorkerGroupSpec>(Arena*);
template<> ::flyteidl::plugins::WorkerGroupSpec_RayStartParamsEntry_DoNotUse* Arena::CreateMaybeMessage<::flyteidl::plugins::WorkerGroupSpec_RayStartParamsEntry_DoNotUse>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace flyteidl {
namespace plugins {

// ===================================================================

class RayJob final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.plugins.RayJob) */ {
 public:
  RayJob();
  virtual ~RayJob();

  RayJob(const RayJob& from);

  inline RayJob& operator=(const RayJob& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RayJob(RayJob&& from) noexcept
    : RayJob() {
    *this = ::std::move(from);
  }

  inline RayJob& operator=(RayJob&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RayJob& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RayJob* internal_default_instance() {
    return reinterpret_cast<const RayJob*>(
               &_RayJob_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(RayJob* other);
  friend void swap(RayJob& a, RayJob& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RayJob* New() const final {
    return CreateMaybeMessage<RayJob>(nullptr);
  }

  RayJob* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RayJob>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RayJob& from);
  void MergeFrom(const RayJob& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RayJob* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string runtime_env = 2;
  void clear_runtime_env();
  static const int kRuntimeEnvFieldNumber = 2;
  const ::std::string& runtime_env() const;
  void set_runtime_env(const ::std::string& value);
  #if LANG_CXX11
  void set_runtime_env(::std::string&& value);
  #endif
  void set_runtime_env(const char* value);
  void set_runtime_env(const char* value, size_t size);
  ::std::string* mutable_runtime_env();
  ::std::string* release_runtime_env();
  void set_allocated_runtime_env(::std::string* runtime_env);

  // .flyteidl.plugins.RayCluster ray_cluster = 1;
  bool has_ray_cluster() const;
  void clear_ray_cluster();
  static const int kRayClusterFieldNumber = 1;
  const ::flyteidl::plugins::RayCluster& ray_cluster() const;
  ::flyteidl::plugins::RayCluster* release_ray_cluster();
  ::flyteidl::plugins::RayCluster* mutable_ray_cluster();
  void set_allocated_ray_cluster(::flyteidl::plugins::RayCluster* ray_cluster);

  // @@protoc_insertion_point(class_scope:flyteidl.plugins.RayJob)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr runtime_env_;
  ::flyteidl::plugins::RayCluster* ray_cluster_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fplugins_2fray_2eproto;
};
// -------------------------------------------------------------------

class RayCluster final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.plugins.RayCluster) */ {
 public:
  RayCluster();
  virtual ~RayCluster();

  RayCluster(const RayCluster& from);

  inline RayCluster& operator=(const RayCluster& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RayCluster(RayCluster&& from) noexcept
    : RayCluster() {
    *this = ::std::move(from);
  }

  inline RayCluster& operator=(RayCluster&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RayCluster& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RayCluster* internal_default_instance() {
    return reinterpret_cast<const RayCluster*>(
               &_RayCluster_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(RayCluster* other);
  friend void swap(RayCluster& a, RayCluster& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RayCluster* New() const final {
    return CreateMaybeMessage<RayCluster>(nullptr);
  }

  RayCluster* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RayCluster>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RayCluster& from);
  void MergeFrom(const RayCluster& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RayCluster* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .flyteidl.plugins.WorkerGroupSpec worker_group_spec = 2;
  int worker_group_spec_size() const;
  void clear_worker_group_spec();
  static const int kWorkerGroupSpecFieldNumber = 2;
  ::flyteidl::plugins::WorkerGroupSpec* mutable_worker_group_spec(int index);
  ::google::protobuf::RepeatedPtrField< ::flyteidl::plugins::WorkerGroupSpec >*
      mutable_worker_group_spec();
  const ::flyteidl::plugins::WorkerGroupSpec& worker_group_spec(int index) const;
  ::flyteidl::plugins::WorkerGroupSpec* add_worker_group_spec();
  const ::google::protobuf::RepeatedPtrField< ::flyteidl::plugins::WorkerGroupSpec >&
      worker_group_spec() const;

  // .flyteidl.plugins.HeadGroupSpec head_group_spec = 1;
  bool has_head_group_spec() const;
  void clear_head_group_spec();
  static const int kHeadGroupSpecFieldNumber = 1;
  const ::flyteidl::plugins::HeadGroupSpec& head_group_spec() const;
  ::flyteidl::plugins::HeadGroupSpec* release_head_group_spec();
  ::flyteidl::plugins::HeadGroupSpec* mutable_head_group_spec();
  void set_allocated_head_group_spec(::flyteidl::plugins::HeadGroupSpec* head_group_spec);

  // @@protoc_insertion_point(class_scope:flyteidl.plugins.RayCluster)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::flyteidl::plugins::WorkerGroupSpec > worker_group_spec_;
  ::flyteidl::plugins::HeadGroupSpec* head_group_spec_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fplugins_2fray_2eproto;
};
// -------------------------------------------------------------------

class HeadGroupSpec_RayStartParamsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<HeadGroupSpec_RayStartParamsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
static bool _ParseMap(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  typedef ::google::protobuf::internal::MapEntry<HeadGroupSpec_RayStartParamsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  HeadGroupSpec_RayStartParamsEntry_DoNotUse();
  HeadGroupSpec_RayStartParamsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const HeadGroupSpec_RayStartParamsEntry_DoNotUse& other);
  static const HeadGroupSpec_RayStartParamsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const HeadGroupSpec_RayStartParamsEntry_DoNotUse*>(&_HeadGroupSpec_RayStartParamsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class HeadGroupSpec final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.plugins.HeadGroupSpec) */ {
 public:
  HeadGroupSpec();
  virtual ~HeadGroupSpec();

  HeadGroupSpec(const HeadGroupSpec& from);

  inline HeadGroupSpec& operator=(const HeadGroupSpec& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HeadGroupSpec(HeadGroupSpec&& from) noexcept
    : HeadGroupSpec() {
    *this = ::std::move(from);
  }

  inline HeadGroupSpec& operator=(HeadGroupSpec&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const HeadGroupSpec& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HeadGroupSpec* internal_default_instance() {
    return reinterpret_cast<const HeadGroupSpec*>(
               &_HeadGroupSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(HeadGroupSpec* other);
  friend void swap(HeadGroupSpec& a, HeadGroupSpec& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HeadGroupSpec* New() const final {
    return CreateMaybeMessage<HeadGroupSpec>(nullptr);
  }

  HeadGroupSpec* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HeadGroupSpec>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HeadGroupSpec& from);
  void MergeFrom(const HeadGroupSpec& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeadGroupSpec* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, string> ray_start_params = 1;
  int ray_start_params_size() const;
  void clear_ray_start_params();
  static const int kRayStartParamsFieldNumber = 1;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      ray_start_params() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_ray_start_params();

  // @@protoc_insertion_point(class_scope:flyteidl.plugins.HeadGroupSpec)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      HeadGroupSpec_RayStartParamsEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > ray_start_params_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fplugins_2fray_2eproto;
};
// -------------------------------------------------------------------

class WorkerGroupSpec_RayStartParamsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<WorkerGroupSpec_RayStartParamsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
static bool _ParseMap(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  typedef ::google::protobuf::internal::MapEntry<WorkerGroupSpec_RayStartParamsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  WorkerGroupSpec_RayStartParamsEntry_DoNotUse();
  WorkerGroupSpec_RayStartParamsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const WorkerGroupSpec_RayStartParamsEntry_DoNotUse& other);
  static const WorkerGroupSpec_RayStartParamsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const WorkerGroupSpec_RayStartParamsEntry_DoNotUse*>(&_WorkerGroupSpec_RayStartParamsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class WorkerGroupSpec final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.plugins.WorkerGroupSpec) */ {
 public:
  WorkerGroupSpec();
  virtual ~WorkerGroupSpec();

  WorkerGroupSpec(const WorkerGroupSpec& from);

  inline WorkerGroupSpec& operator=(const WorkerGroupSpec& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WorkerGroupSpec(WorkerGroupSpec&& from) noexcept
    : WorkerGroupSpec() {
    *this = ::std::move(from);
  }

  inline WorkerGroupSpec& operator=(WorkerGroupSpec&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const WorkerGroupSpec& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WorkerGroupSpec* internal_default_instance() {
    return reinterpret_cast<const WorkerGroupSpec*>(
               &_WorkerGroupSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(WorkerGroupSpec* other);
  friend void swap(WorkerGroupSpec& a, WorkerGroupSpec& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WorkerGroupSpec* New() const final {
    return CreateMaybeMessage<WorkerGroupSpec>(nullptr);
  }

  WorkerGroupSpec* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WorkerGroupSpec>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WorkerGroupSpec& from);
  void MergeFrom(const WorkerGroupSpec& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkerGroupSpec* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, string> ray_start_params = 5;
  int ray_start_params_size() const;
  void clear_ray_start_params();
  static const int kRayStartParamsFieldNumber = 5;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      ray_start_params() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_ray_start_params();

  // string group_name = 1;
  void clear_group_name();
  static const int kGroupNameFieldNumber = 1;
  const ::std::string& group_name() const;
  void set_group_name(const ::std::string& value);
  #if LANG_CXX11
  void set_group_name(::std::string&& value);
  #endif
  void set_group_name(const char* value);
  void set_group_name(const char* value, size_t size);
  ::std::string* mutable_group_name();
  ::std::string* release_group_name();
  void set_allocated_group_name(::std::string* group_name);

  // int32 replicas = 2;
  void clear_replicas();
  static const int kReplicasFieldNumber = 2;
  ::google::protobuf::int32 replicas() const;
  void set_replicas(::google::protobuf::int32 value);

  // int32 min_replicas = 3;
  void clear_min_replicas();
  static const int kMinReplicasFieldNumber = 3;
  ::google::protobuf::int32 min_replicas() const;
  void set_min_replicas(::google::protobuf::int32 value);

  // int32 max_replicas = 4;
  void clear_max_replicas();
  static const int kMaxReplicasFieldNumber = 4;
  ::google::protobuf::int32 max_replicas() const;
  void set_max_replicas(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:flyteidl.plugins.WorkerGroupSpec)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      WorkerGroupSpec_RayStartParamsEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > ray_start_params_;
  ::google::protobuf::internal::ArenaStringPtr group_name_;
  ::google::protobuf::int32 replicas_;
  ::google::protobuf::int32 min_replicas_;
  ::google::protobuf::int32 max_replicas_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fplugins_2fray_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RayJob

// .flyteidl.plugins.RayCluster ray_cluster = 1;
inline bool RayJob::has_ray_cluster() const {
  return this != internal_default_instance() && ray_cluster_ != nullptr;
}
inline void RayJob::clear_ray_cluster() {
  if (GetArenaNoVirtual() == nullptr && ray_cluster_ != nullptr) {
    delete ray_cluster_;
  }
  ray_cluster_ = nullptr;
}
inline const ::flyteidl::plugins::RayCluster& RayJob::ray_cluster() const {
  const ::flyteidl::plugins::RayCluster* p = ray_cluster_;
  // @@protoc_insertion_point(field_get:flyteidl.plugins.RayJob.ray_cluster)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::plugins::RayCluster*>(
      &::flyteidl::plugins::_RayCluster_default_instance_);
}
inline ::flyteidl::plugins::RayCluster* RayJob::release_ray_cluster() {
  // @@protoc_insertion_point(field_release:flyteidl.plugins.RayJob.ray_cluster)
  
  ::flyteidl::plugins::RayCluster* temp = ray_cluster_;
  ray_cluster_ = nullptr;
  return temp;
}
inline ::flyteidl::plugins::RayCluster* RayJob::mutable_ray_cluster() {
  
  if (ray_cluster_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::plugins::RayCluster>(GetArenaNoVirtual());
    ray_cluster_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.plugins.RayJob.ray_cluster)
  return ray_cluster_;
}
inline void RayJob::set_allocated_ray_cluster(::flyteidl::plugins::RayCluster* ray_cluster) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete ray_cluster_;
  }
  if (ray_cluster) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ray_cluster = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ray_cluster, submessage_arena);
    }
    
  } else {
    
  }
  ray_cluster_ = ray_cluster;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.plugins.RayJob.ray_cluster)
}

// string runtime_env = 2;
inline void RayJob::clear_runtime_env() {
  runtime_env_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RayJob::runtime_env() const {
  // @@protoc_insertion_point(field_get:flyteidl.plugins.RayJob.runtime_env)
  return runtime_env_.GetNoArena();
}
inline void RayJob::set_runtime_env(const ::std::string& value) {
  
  runtime_env_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.plugins.RayJob.runtime_env)
}
#if LANG_CXX11
inline void RayJob::set_runtime_env(::std::string&& value) {
  
  runtime_env_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.plugins.RayJob.runtime_env)
}
#endif
inline void RayJob::set_runtime_env(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  runtime_env_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.plugins.RayJob.runtime_env)
}
inline void RayJob::set_runtime_env(const char* value, size_t size) {
  
  runtime_env_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.plugins.RayJob.runtime_env)
}
inline ::std::string* RayJob::mutable_runtime_env() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.plugins.RayJob.runtime_env)
  return runtime_env_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RayJob::release_runtime_env() {
  // @@protoc_insertion_point(field_release:flyteidl.plugins.RayJob.runtime_env)
  
  return runtime_env_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RayJob::set_allocated_runtime_env(::std::string* runtime_env) {
  if (runtime_env != nullptr) {
    
  } else {
    
  }
  runtime_env_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), runtime_env);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.plugins.RayJob.runtime_env)
}

// -------------------------------------------------------------------

// RayCluster

// .flyteidl.plugins.HeadGroupSpec head_group_spec = 1;
inline bool RayCluster::has_head_group_spec() const {
  return this != internal_default_instance() && head_group_spec_ != nullptr;
}
inline void RayCluster::clear_head_group_spec() {
  if (GetArenaNoVirtual() == nullptr && head_group_spec_ != nullptr) {
    delete head_group_spec_;
  }
  head_group_spec_ = nullptr;
}
inline const ::flyteidl::plugins::HeadGroupSpec& RayCluster::head_group_spec() const {
  const ::flyteidl::plugins::HeadGroupSpec* p = head_group_spec_;
  // @@protoc_insertion_point(field_get:flyteidl.plugins.RayCluster.head_group_spec)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::plugins::HeadGroupSpec*>(
      &::flyteidl::plugins::_HeadGroupSpec_default_instance_);
}
inline ::flyteidl::plugins::HeadGroupSpec* RayCluster::release_head_group_spec() {
  // @@protoc_insertion_point(field_release:flyteidl.plugins.RayCluster.head_group_spec)
  
  ::flyteidl::plugins::HeadGroupSpec* temp = head_group_spec_;
  head_group_spec_ = nullptr;
  return temp;
}
inline ::flyteidl::plugins::HeadGroupSpec* RayCluster::mutable_head_group_spec() {
  
  if (head_group_spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::plugins::HeadGroupSpec>(GetArenaNoVirtual());
    head_group_spec_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.plugins.RayCluster.head_group_spec)
  return head_group_spec_;
}
inline void RayCluster::set_allocated_head_group_spec(::flyteidl::plugins::HeadGroupSpec* head_group_spec) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete head_group_spec_;
  }
  if (head_group_spec) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      head_group_spec = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, head_group_spec, submessage_arena);
    }
    
  } else {
    
  }
  head_group_spec_ = head_group_spec;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.plugins.RayCluster.head_group_spec)
}

// repeated .flyteidl.plugins.WorkerGroupSpec worker_group_spec = 2;
inline int RayCluster::worker_group_spec_size() const {
  return worker_group_spec_.size();
}
inline void RayCluster::clear_worker_group_spec() {
  worker_group_spec_.Clear();
}
inline ::flyteidl::plugins::WorkerGroupSpec* RayCluster::mutable_worker_group_spec(int index) {
  // @@protoc_insertion_point(field_mutable:flyteidl.plugins.RayCluster.worker_group_spec)
  return worker_group_spec_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::flyteidl::plugins::WorkerGroupSpec >*
RayCluster::mutable_worker_group_spec() {
  // @@protoc_insertion_point(field_mutable_list:flyteidl.plugins.RayCluster.worker_group_spec)
  return &worker_group_spec_;
}
inline const ::flyteidl::plugins::WorkerGroupSpec& RayCluster::worker_group_spec(int index) const {
  // @@protoc_insertion_point(field_get:flyteidl.plugins.RayCluster.worker_group_spec)
  return worker_group_spec_.Get(index);
}
inline ::flyteidl::plugins::WorkerGroupSpec* RayCluster::add_worker_group_spec() {
  // @@protoc_insertion_point(field_add:flyteidl.plugins.RayCluster.worker_group_spec)
  return worker_group_spec_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::flyteidl::plugins::WorkerGroupSpec >&
RayCluster::worker_group_spec() const {
  // @@protoc_insertion_point(field_list:flyteidl.plugins.RayCluster.worker_group_spec)
  return worker_group_spec_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// HeadGroupSpec

// map<string, string> ray_start_params = 1;
inline int HeadGroupSpec::ray_start_params_size() const {
  return ray_start_params_.size();
}
inline void HeadGroupSpec::clear_ray_start_params() {
  ray_start_params_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
HeadGroupSpec::ray_start_params() const {
  // @@protoc_insertion_point(field_map:flyteidl.plugins.HeadGroupSpec.ray_start_params)
  return ray_start_params_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
HeadGroupSpec::mutable_ray_start_params() {
  // @@protoc_insertion_point(field_mutable_map:flyteidl.plugins.HeadGroupSpec.ray_start_params)
  return ray_start_params_.MutableMap();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// WorkerGroupSpec

// string group_name = 1;
inline void WorkerGroupSpec::clear_group_name() {
  group_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WorkerGroupSpec::group_name() const {
  // @@protoc_insertion_point(field_get:flyteidl.plugins.WorkerGroupSpec.group_name)
  return group_name_.GetNoArena();
}
inline void WorkerGroupSpec::set_group_name(const ::std::string& value) {
  
  group_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.plugins.WorkerGroupSpec.group_name)
}
#if LANG_CXX11
inline void WorkerGroupSpec::set_group_name(::std::string&& value) {
  
  group_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.plugins.WorkerGroupSpec.group_name)
}
#endif
inline void WorkerGroupSpec::set_group_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  group_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.plugins.WorkerGroupSpec.group_name)
}
inline void WorkerGroupSpec::set_group_name(const char* value, size_t size) {
  
  group_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.plugins.WorkerGroupSpec.group_name)
}
inline ::std::string* WorkerGroupSpec::mutable_group_name() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.plugins.WorkerGroupSpec.group_name)
  return group_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WorkerGroupSpec::release_group_name() {
  // @@protoc_insertion_point(field_release:flyteidl.plugins.WorkerGroupSpec.group_name)
  
  return group_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WorkerGroupSpec::set_allocated_group_name(::std::string* group_name) {
  if (group_name != nullptr) {
    
  } else {
    
  }
  group_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), group_name);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.plugins.WorkerGroupSpec.group_name)
}

// int32 replicas = 2;
inline void WorkerGroupSpec::clear_replicas() {
  replicas_ = 0;
}
inline ::google::protobuf::int32 WorkerGroupSpec::replicas() const {
  // @@protoc_insertion_point(field_get:flyteidl.plugins.WorkerGroupSpec.replicas)
  return replicas_;
}
inline void WorkerGroupSpec::set_replicas(::google::protobuf::int32 value) {
  
  replicas_ = value;
  // @@protoc_insertion_point(field_set:flyteidl.plugins.WorkerGroupSpec.replicas)
}

// int32 min_replicas = 3;
inline void WorkerGroupSpec::clear_min_replicas() {
  min_replicas_ = 0;
}
inline ::google::protobuf::int32 WorkerGroupSpec::min_replicas() const {
  // @@protoc_insertion_point(field_get:flyteidl.plugins.WorkerGroupSpec.min_replicas)
  return min_replicas_;
}
inline void WorkerGroupSpec::set_min_replicas(::google::protobuf::int32 value) {
  
  min_replicas_ = value;
  // @@protoc_insertion_point(field_set:flyteidl.plugins.WorkerGroupSpec.min_replicas)
}

// int32 max_replicas = 4;
inline void WorkerGroupSpec::clear_max_replicas() {
  max_replicas_ = 0;
}
inline ::google::protobuf::int32 WorkerGroupSpec::max_replicas() const {
  // @@protoc_insertion_point(field_get:flyteidl.plugins.WorkerGroupSpec.max_replicas)
  return max_replicas_;
}
inline void WorkerGroupSpec::set_max_replicas(::google::protobuf::int32 value) {
  
  max_replicas_ = value;
  // @@protoc_insertion_point(field_set:flyteidl.plugins.WorkerGroupSpec.max_replicas)
}

// map<string, string> ray_start_params = 5;
inline int WorkerGroupSpec::ray_start_params_size() const {
  return ray_start_params_.size();
}
inline void WorkerGroupSpec::clear_ray_start_params() {
  ray_start_params_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
WorkerGroupSpec::ray_start_params() const {
  // @@protoc_insertion_point(field_map:flyteidl.plugins.WorkerGroupSpec.ray_start_params)
  return ray_start_params_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
WorkerGroupSpec::mutable_ray_start_params() {
  // @@protoc_insertion_point(field_mutable_map:flyteidl.plugins.WorkerGroupSpec.ray_start_params)
  return ray_start_params_.MutableMap();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace plugins
}  // namespace flyteidl

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_flyteidl_2fplugins_2fray_2eproto
